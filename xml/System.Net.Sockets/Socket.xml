<?xml version="1.0" encoding="utf-8"?>
<xliff xmlns="urn:oasis:names:tc:xliff:document:1.2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" version="1.2" xsi:schemaLocation="urn:oasis:names:tc:xliff:document:1.2 xliff-core-1.2-transitional.xsd">
  <file datatype="xml" original="Socket.xml" source-language="en-US" target-language="de-DE">
    <header>
      <tool tool-id="mdxliff" tool-name="mdxliff" tool-version="1.0-81070f4" tool-company="Microsoft" />
      <xliffext:skl_file_name xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1e344e59-9d8e-481b-978a-09f2e01be86cb34938e927f531ff1ab3b495e670e7f3a8bb0398.skl</xliffext:skl_file_name>
      <xliffext:version xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">1.2</xliffext:version>
      <xliffext:ms.openlocfilehash xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">b34938e927f531ff1ab3b495e670e7f3a8bb0398</xliffext:ms.openlocfilehash>
      <xliffext:ms.sourcegitcommit xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">f9e3295b6cc303a611a73a84c4b27f9da792ad0d</xliffext:ms.sourcegitcommit>
      <xliffext:ms.lasthandoff xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">04/26/2018</xliffext:ms.lasthandoff>
      <xliffext:moniker_ids xmlns:xliffext="urn:microsoft:content:schema:xliffextensions">netcore-1.0,netcore-1.1,netcore-2.0,netcore-2.1,netframework-4.5.1,netframework-4.5.2,netframework-4.5,netframework-4.6.1,netframework-4.6.2,netframework-4.6,netframework-4.7.1,netframework-4.7.2,netframework-4.7,netstandard-1.3,netstandard-1.4,netstandard-1.6,netstandard-2.0,xamarinandroid-7.1,xamarinios-10.8,xamarinmac-3.0</xliffext:moniker_ids>
    </header>
    <body>
      <group id="content" extype="content">
        <trans-unit id="101" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Implements the Berkeley sockets interface.</source>
          <target state="translated">Implementiert die Berkeley-Sockets-Schnittstelle.</target>       </trans-unit>
        <trans-unit id="102" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class provides a rich set of methods and properties for network communications.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse bietet einen umfangreichen Satz von Methoden und Eigenschaften für die Netzwerkkommunikation.</target>       </trans-unit>
        <trans-unit id="103" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> enumeration.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse ermöglicht sowohl synchrone und asynchrone Datenübertragung mithilfe der Protokolle für die Kommunikation in der <ph id="ph2">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="104" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class follows the .NET Framework naming pattern for asynchronous methods.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse folgt das Benennungsmuster von .NET Framework für asynchrone Methoden.</target>       </trans-unit>
        <trans-unit id="105" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>For example, the synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method corresponds to the asynchronous <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods.</source>
          <target state="translated">Angenommen, die synchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode entspricht, auf den asynchronen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> und <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="106" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</source>
          <target state="translated">Wenn Ihre Anwendung während der Ausführung nur einen Thread erfordert, verwenden Sie die folgenden Methoden, die für den synchronen Betriebsmodus entworfen werden.</target>       </trans-unit>
        <trans-unit id="107" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, kann der Server für Verbindungen mit dem Lauschen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="108" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method processes any incoming connection requests and returns a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to communicate data with the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode Prozesse eingehende Verbindung anfordert, und gibt eine <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , dass Sie verwenden können, um Daten mit dem Remotehost kommunizieren.</target>       </trans-unit>
        <trans-unit id="109" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Verwenden Sie diesen zurückgegebenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zum Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="110" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method prior to calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method if you want to specify the local IP address and port number.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode vor dem Aufruf der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> Methode, wenn Sie die lokale IP-Adresse und Port-Nummer angeben möchten.</target>       </trans-unit>
        <trans-unit id="111" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use a port number of zero if you want the underlying service provider to assign a free port for you.</source>
          <target state="translated">Verwenden Sie die Portnummer 0 (null), wenn Sie den zugrunde liegenden Dienstanbieter einen freien Anschluss zuweisen möchten.</target>       </trans-unit>
        <trans-unit id="112" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you want to connect to a listening host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie einen überwachenden Host eine Verbindung herstellen möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="113" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To communicate data, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Um Daten zu kommunizieren, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="114" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht zum Lauschen auf Verbindungen an.</target>       </trans-unit>
        <trans-unit id="115" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method to accept any incoming datagrams.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode, um eingehende Datagramme zu akzeptieren.</target>       </trans-unit>
        <trans-unit id="116" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method to send datagrams to a remote host.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode, um Datagramme mit einem Remotehost senden.</target>       </trans-unit>
        <trans-unit id="117" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</source>
          <target state="translated">Verwenden Sie zum Verarbeiten der Kommunikation mit separaten Threads während der Ausführung der folgenden Methoden, die für den asynchronen Vorgang Modus vorgesehen sind.</target>       </trans-unit>
        <trans-unit id="118" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connection-oriented protocol such as TCP, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> methods to connect with a listening host.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, verwenden Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methoden für die Verbindung mit einem überwachenden Host.</target>       </trans-unit>
        <trans-unit id="119" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> methods to communicate data asynchronously.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> und <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methoden, um Daten asynchron kommunizieren.</target>       </trans-unit>
        <trans-unit id="120" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Incoming connection requests can be processed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</source>
          <target state="translated">Eingehende verbindungsanforderungen mit verarbeitet <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="121" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are using a connectionless protocol such as UDP, you can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> to send datagrams, and <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> and <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> to receive datagrams.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, können Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> Datagramme senden und <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> und <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> um Datagramme zu empfangen.</target>       </trans-unit>
        <trans-unit id="122" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</source>
          <target state="translated">Wenn Sie mehrere asynchrone Vorgänge für ein Socket ausführen, sie nicht unbedingt in der Reihenfolge abgeschlossen in denen sie gestartet wurden.</target>       </trans-unit>
        <trans-unit id="123" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>When you are finished sending and receiving data, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht mehr benötigen, senden und Empfangen von Daten sind, verwenden Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> Methode zum Deaktivieren der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="124" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to release all resources associated with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode, um alle zugeordneten Ressourcen freizugeben. der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="125" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class allows you to configure your <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Klasse ermöglicht es Ihnen so konfigurieren Sie Ihre <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> mithilfe der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="126" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Retrieve these settings using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Rufen Sie diese Einstellungen über die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="127" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>If you are writing a relatively simple application and do not require maximum performance, consider using <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</source>
          <target state="translated">Wenn Sie eine relativ einfache Anwendung schreiben und nicht die maximale Leistung benötigen, erwägen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.TcpListener&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.UdpClient&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="128" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>These classes provide a simpler and more user-friendly interface to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> communications.</source>
          <target state="translated">Diese Klassen bieten eine einfachere und benutzerfreundlichere Oberfläche für <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Kommunikation.</target>       </trans-unit>
        <trans-unit id="129" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>The following code example shows how the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can be used to send data to an HTTP server and receive the response.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht wie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse kann verwendet werden, um Daten an einem HTTP-Server senden und Empfangen der Antwort.</target>       </trans-unit>
        <trans-unit id="130" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>This example blocks until the entire page is received.</source>
          <target state="translated">In diesem Beispiel wird blockiert, bis die gesamte Seite empfangen wird.</target>       </trans-unit>
        <trans-unit id="131" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>To establish an outgoing connection or accept an incoming request.</source>
          <target state="translated">Um eine ausgehende Verbindung herzustellen, oder übernehmen Sie eine eingehende Anforderung.</target>       </trans-unit>
        <trans-unit id="132" translate="yes" xml:space="preserve" extradata="MT" uid="T:System.Net.Sockets.Socket">
          <source>Instances of this class are thread safe.</source>
          <target state="translated">Instanzen dieser Klasse sind threadsicher.</target>       </trans-unit>
        <trans-unit id="133" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="134" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>The socket information returned by <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Die von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph> zurückgegebenen Socketinformationen.</target>       </trans-unit>
        <trans-unit id="135" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified value returned from <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse mit dem angegebenen Wert, der von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /&gt;</ph> zurückgegeben wird.</target>       </trans-unit>
        <trans-unit id="136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>s with the same underlying socket.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>mit den gleichen zugrunde liegenden Socket.</target>       </trans-unit>
        <trans-unit id="137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Dieses Vorgehen wird dringend abgeraten.</target>       </trans-unit>
        <trans-unit id="138" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="139" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="140" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified socket type and protocol.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse unter Verwendung der angegebenen Sockettyps und Protokolls.</target>       </trans-unit>
        <trans-unit id="141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`socketType`</ph> parameter specifies the type of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class and the <ph id="ph3">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">`socketType`</ph> Parameter gibt den Typ des der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse und die <ph id="ph3">`protocolType`</ph> Parameter gibt an, die vom verwendeten Protokolls <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The two parameters are not independent.</source>
          <target state="translated">Die beiden Parameter sind nicht voneinander unabhängig.</target>       </trans-unit>
        <trans-unit id="143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Häufig die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Typ ist implizit in das Protokoll.</target>       </trans-unit>
        <trans-unit id="144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn die Kombination von <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Typ und im Protokoll geben Ergebnisse in eine ungültige <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, löst der Konstruktor eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn dieses Konstruktors löst eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of  <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> and <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">Die Kombination von <ph id="ph1">&lt;paramref name="socketType" /&gt;</ph> und <ph id="ph2">&lt;paramref name="protocolType" /&gt;</ph> führt zu einem ungültigen Socket.</target>       </trans-unit>
        <trans-unit id="150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Initializes a new instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class using the specified address family, socket type and protocol.</source>
          <target state="translated">Initialisiert eine neue Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse unter Verwendung der angegebenen Adressfamilie sowie des angegebenen Sockettyps und Protokolls.</target>       </trans-unit>
        <trans-unit id="154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The <ph id="ph1">`addressFamily`</ph> parameter specifies the addressing scheme that the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class uses, the <ph id="ph3">`socketType`</ph> parameter specifies the type of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class, and the <ph id="ph5">`protocolType`</ph> parameter specifies the protocol used by <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">`addressFamily`</ph> Parameter gibt an, die Adressierung, die Schemas der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Klasse verwendet, die <ph id="ph3">`socketType`</ph> Parameter gibt den Typ des der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Klasse, und die <ph id="ph5">`protocolType`</ph> Parameter gibt an, die vom verwendeten Protokolls <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The three parameters are not independent.</source>
          <target state="translated">Die drei Parameter sind nicht voneinander unabhängig.</target>       </trans-unit>
        <trans-unit id="156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>Some address families restrict which protocols can be used with them, and often the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type is implicit in the protocol.</source>
          <target state="translated">Einige Adressfamilien einschränken, welche Protokolle verwendet werden können, und oft das <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Typ ist implizit in das Protokoll.</target>       </trans-unit>
        <trans-unit id="157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If the combination of address family, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> type, and protocol type results in an invalid <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, this constructor throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn die Kombination aus Adressfamilie, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Typ, und geben Sie die Ergebnisse in ein ungültiges Protokoll <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, löst der Konstruktor eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>If this constructor throws a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn dieses Konstruktors löst eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The following code example demonstrates how to create an instance of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer Instanz von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="163" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)">
          <source>The combination of <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph>, and <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> results in an invalid socket.</source>
          <target state="translated">Die Kombination von <ph id="ph1">&lt;paramref name="addressFamily" /&gt;</ph>, <ph id="ph2">&lt;paramref name="socketType" /&gt;</ph> und <ph id="ph3">&lt;paramref name="protocolType" /&gt;</ph> führt zu einem ungültigen Socket.</target>       </trans-unit>
        <trans-unit id="164" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">Erstellt einen neuen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> für eine neu erstellte Verbindung.</target>       </trans-unit>
        <trans-unit id="165" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> for a newly created connection.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> für eine neu erstellte Verbindung.</target>       </trans-unit>
        <trans-unit id="166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> synchron extrahiert das erste ausstehende verbindungsanforderung aus der Warteschlange die empfangsbereiten Sockets und Verbindung erstellt und gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Können keine diesem zurückgegebenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren.</target>       </trans-unit>
        <trans-unit id="168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>However, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> method of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">Sie können jedoch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> Methode des zurückgegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf dem Remotehost Netzwerk Adresse und Anschlussnummer identifizieren.</target>       </trans-unit>
        <trans-unit id="169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>In blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blocks until an incoming connection attempt is queued.</source>
          <target state="translated">Im blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> blockiert, bis eine eingehende Verbindung in die Warteschlange gestellt wird.</target>       </trans-unit>
        <trans-unit id="170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Once a connection is accepted, the original <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> continues queuing incoming connection requests until you close it.</source>
          <target state="translated">Sobald eine Verbindung akzeptiert wird, die ursprüngliche <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> queuing eingehende verbindungsanforderungen bis schließen sie fortgesetzt.</target>       </trans-unit>
        <trans-unit id="171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you call this method using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and no connection requests are queued, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie diese Methode mit einem nicht blockierenden Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, und es ist keine Verbindung mit dem Anforderungen sind in der Warteschlange, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method, you must first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode, müssen Sie zuerst Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.</target>       </trans-unit>
        <trans-unit id="175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The following code example accepts a simple <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird akzeptiert, ein einfaches <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung.</target>       </trans-unit>
        <trans-unit id="178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Der annehmende Socket überwacht keine Verbindungen.</target>       </trans-unit>
        <trans-unit id="181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Accept">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>.</source>
          <target state="translated">Vor dem Aufruf von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> müssen Sie <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> und <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</target>       </trans-unit>
        <trans-unit id="184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Verbindungsorientierte Protokolle können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht.</target>       </trans-unit>
        <trans-unit id="189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.</target>       </trans-unit>
        <trans-unit id="190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> -Methode, die Sie aufrufen müssen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.</target>       </trans-unit>
        <trans-unit id="191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and hook it to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegieren und verknüpfen Sie ihn auf die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich:</target>       </trans-unit>
        <trans-unit id="193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller can optionally specify an existing <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use for the incoming connection by specifying the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to use with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Der Aufrufer angeben kann, optional eine vorhandene <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> verwenden für die eingehende Verbindung durch Angabe der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Verwendung mit der <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property is null, a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is constructed with the same <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, and <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> as the current <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and set as the <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> property.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft null ist, ist ein neues <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wird erstellt, mit dem gleichen <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AddressFamily%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph>, und <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> wie die aktuelle <ph id="ph6">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und legen Sie als die <ph id="ph7">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Optional kann ein Puffer bereitgestellt werden, in dem den erste Block von Daten auf den Socket empfangen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to receive and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the maximum number of bytes of data to receive in the buffer.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, zum Empfangen und die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss auf die maximale Anzahl der Bytes der Daten festgelegt werden, um in den Puffer zu erhalten.</target>       </trans-unit>
        <trans-unit id="199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>These properties can be set using the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Diese Eigenschaften können festgelegt werden, mithilfe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</source>
          <target state="translated">Teil des übergebenen Puffers wird intern für die Verwendung durch den zugrunde liegenden Winsock AcceptEx-Aufruf genutzt werden.</target>       </trans-unit>
        <trans-unit id="201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This means that the amount of data returned will always be less than the value of the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> instance provided.</source>
          <target state="translated">Dies bedeutet, dass die Menge der zurückgegebenen Daten immer kleiner als der Wert, der die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> bereitgestellten Instanz.</target>       </trans-unit>
        <trans-unit id="202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The amount of the buffer used internally varies based on the address family of the socket.</source>
          <target state="translated">Die Menge des Puffers wird intern verwendet, hängt von der Adressfamilie des Sockets.</target>       </trans-unit>
        <trans-unit id="203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The minimum buffer size required is 288 bytes.</source>
          <target state="translated">Die erforderliche minimale Puffergröße ist 288 Byte.</target>       </trans-unit>
        <trans-unit id="204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a larger buffer size is specified, then the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</source>
          <target state="translated">Wenn Sie ein größeren Puffer angegeben wird, und klicken Sie dann die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> erwarten, dass einige zusätzlichen Daten außer den Adressdaten von Winsock AcceptEx empfangene und wartet, bis diese zusätzlichen Daten empfangen werden.</target>       </trans-unit>
        <trans-unit id="205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a timeout occurs, the connection is reset.</source>
          <target state="translated">Wenn ein Timeout auftritt, wird die Verbindung zurückgesetzt.</target>       </trans-unit>
        <trans-unit id="206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</source>
          <target state="translated">Also wenn zusätzliche Daten von einem bestimmten Zeitraum erwartet werden, sollten dann die Größe des Puffers an der minimalen Puffergröße plus diese Menge festgelegt werden.</target>       </trans-unit>
        <trans-unit id="207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The completion callback method should examine the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> operation was successful.</source>
          <target state="translated">Die Abschlussrückrufmethode überprüfen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um festzustellen, wo die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> Vorgang war erfolgreich.</target>       </trans-unit>
        <trans-unit id="208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event can occur in some cases when no connection has been accepted and cause the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> property to be set to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis kann in einigen Fällen auftreten, wenn keine Verbindung akzeptiert wurde, und dazu führen, dass die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft festgelegt werden, um <ph id="ph3">&lt;xref:System.Net.Sockets.SocketError.ConnectionReset&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can occur as a result of port scanning using a half-open SYN type scan (a SYN -&gt; SYN-ACK -&gt; RST sequence).</source>
          <target state="translated">Dies ist möglich durch Scannen von Ports mit einem halb geöffneten SYN-Typ-Scan (SYN-SYN-ACK-&gt; -&gt; RST-Sequenz).</target>       </trans-unit>
        <trans-unit id="210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Applications using the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> method should be prepared to handle this condition.</source>
          <target state="translated">Anwendungen, die mithilfe der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph> Methode sollten darauf vorbereitet sein, diese Konstellation behandeln.</target>       </trans-unit>
        <trans-unit id="211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Ein Argument ist ungültig.</target>       </trans-unit>
        <trans-unit id="212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the buffer provided is not large enough.</source>
          <target state="translated">Diese Ausnahme tritt auf, wenn der bereitgestellte Puffer nicht groß genug ist.</target>       </trans-unit>
        <trans-unit id="213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The buffer must be at least 2 * (sizeof(SOCKADDR_STORAGE + 16) bytes.</source>
          <target state="translated">Der Puffer muss wenigstens 2 * (sizeof(SOCKADDR_STORAGE + 16) Bytes betragen.</target>       </trans-unit>
        <trans-unit id="214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Diese Ausnahme tritt auch auf, wenn mehrere Puffer angegeben werden und die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph>-Eigenschaft nicht NULL ist.</target>       </trans-unit>
        <trans-unit id="215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is out of range.</source>
          <target state="translated">Ein Argument liegt außerhalb des gültigen Bereichs.</target>       </trans-unit>
        <trans-unit id="216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The exception occurs if the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> is less than 0.</source>
          <target state="translated">Die Ausnahme tritt auf, wenn <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /&gt;</ph> kleiner als 0 ist.</target>       </trans-unit>
        <trans-unit id="217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An invalid operation was requested.</source>
          <target state="translated">Es wurde eine ungültige Operation angefordert.</target>       </trans-unit>
        <trans-unit id="218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if the accepting <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not listening for connections or the accepted socket is bound.</source>
          <target state="translated">Diese Ausnahme tritt auf, wenn der annehmende <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> keine Verbindungen überwacht oder der angenommene Socket gebunden ist.</target>       </trans-unit>
        <trans-unit id="219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must call the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> method before calling the <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> method.</source>
          <target state="translated">Sie müssen die <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph>-Methode und die <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>-Methode aufrufen, bevor Sie die <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>-Methode aufrufen.</target>       </trans-unit>
        <trans-unit id="220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Diese Ausnahme tritt auch auf, wenn der Socket bereits verbunden ist oder bereits ein Socketvorgang mit dem angegebenen <ph id="ph1">&lt;paramref name="e" /&gt;</ph>-Parameter ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="224" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>Gets the address family of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft die Adressfamilie des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="225" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="226" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> specifies the addressing scheme that an instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class can use.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> gibt an, die Adressierung von Schemas, die einer Instanz von der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse verwenden kann.</target>       </trans-unit>
        <trans-unit id="227" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>This property is read-only and is set when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated">Diese Eigenschaft ist schreibgeschützt und wird festgelegt, wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wird erstellt.</target>       </trans-unit>
        <trans-unit id="228" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.AddressFamily">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> an die Konsole.</target>       </trans-unit>
        <trans-unit id="229" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>Gets the amount of data that has been received from the network and is available to be read.</source>
          <target state="translated">Ruft die Datenmenge ab, die über das Netzwerk empfangen wurde und gelesen werden kann.</target>       </trans-unit>
        <trans-unit id="230" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The number of bytes of data received from the network and available to be read.</source>
          <target state="translated">Die Anzahl der Datenbytes, die vom Netzwerk empfangen wurden und zum Lesen zur Verfügung stehen.</target>       </trans-unit>
        <trans-unit id="231" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you are using a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is a good way to determine whether data is queued for reading, before calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie einen nicht blockierenden verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist eine gute Möglichkeit, um festzustellen, ob die Daten lesen, vor einem Aufruf in die Warteschlange eingereiht werden <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="232" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The available data is the total amount of data queued in the network buffer for reading.</source>
          <target state="translated">Die verfügbaren Daten ist die Gesamtmenge der Daten im Netzwerkpuffer zum Lesen in die Warteschlange eingereiht.</target>       </trans-unit>
        <trans-unit id="233" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If no data is queued in the network buffer, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> returns 0.</source>
          <target state="translated">Wenn keine Daten im Netzwerkpuffer, in der Warteschlange ist <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> gibt 0 zurück.</target>       </trans-unit>
        <trans-unit id="234" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If the remote host shuts down or closes the connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> can throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren oder die Verbindung schließt <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> festgehaltenen eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="235" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="236" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="237" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="238" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="239" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Available">
          <source>The following code example compares the results of calling IOControl with FIONREAD and the Available property.</source>
          <target state="translated">Im folgenden Codebeispiel werden die Ergebnisse des Aufrufs von IOControl mit FIONREAD und verfügbare Eigenschaft verglichen.</target>       </trans-unit>
        <trans-unit id="240" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="241" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Available">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="242" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</target>       </trans-unit>
        <trans-unit id="243" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="244" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="245" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt.</source>
          <target state="translated">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</target>       </trans-unit>
        <trans-unit id="246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Erstellung verweist.</target>       </trans-unit>
        <trans-unit id="247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Verbindungsorientierte Protokolle können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht.</target>       </trans-unit>
        <trans-unit id="248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.</target>       </trans-unit>
        <trans-unit id="249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode, die Sie aufrufen müssen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.</target>       </trans-unit>
        <trans-unit id="250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Müssen Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Dazu zumindest müssen Sie übergeben, der überwacht <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Objekt <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> über die <ph id="ph3">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> bis eine ausstehende Verbindung abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> will return a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Gibt zurück, ein neues <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt, das Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können.</target>       </trans-unit>
        <trans-unit id="257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Können keine diesem zurückgegebenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren.</target>       </trans-unit>
        <trans-unit id="258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen.</target>       </trans-unit>
        <trans-unit id="261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> Eigenschaft für das zurückgegebene <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> festgelegt, um anzugeben, dass die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to identify the remote host's network address and port number.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> -Eigenschaft des zurückgegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf dem Remotehost Netzwerk Adresse und Anschlussnummer identifizieren.</target>       </trans-unit>
        <trans-unit id="267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</source>
          <target state="translated">Nachdem Sie diesen Code erhalten haben, finden Sie in MSDN in der Dokumentation zu API-Code Windows Sockets, Version 2, eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The following code example attempts to receive an incoming connection asynchronously.</source>
          <target state="translated">Im folgenden Codebeispiel wird versucht, eine eingehende Verbindung asynchron zu empfangen.</target>       </trans-unit>
        <trans-unit id="274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Der annehmende Socket überwacht keine Verbindungen.</target>       </trans-unit>
        <trans-unit id="277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vor dem Aufruf von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> müssen Sie <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> und <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Der angenommene Socket ist gebunden.</target>       </trans-unit>
        <trans-unit id="280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes to accept from the sender.</source>
          <target state="translated">Die Anzahl der Bytes vom Absender, die angenommen werden sollen.</target>       </trans-unit>
        <trans-unit id="283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</source>
          <target state="translated">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</target>       </trans-unit>
        <trans-unit id="286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> creation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Erstellung verweist.</target>       </trans-unit>
        <trans-unit id="287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Verbindungsorientierte Protokolle können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht.</target>       </trans-unit>
        <trans-unit id="288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</source>
          <target state="translated">Akzeptieren von Verbindungen asynchron ermöglicht es Ihnen zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.</target>       </trans-unit>
        <trans-unit id="289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Diese Überladung ermöglicht Ihnen die Angabe der Anzahl der Bytes, die in der ersten Übertragung akzeptiert die <ph id="ph1">`receiveSize`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode, die Sie aufrufen müssen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.</target>       </trans-unit>
        <trans-unit id="291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Müssen Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Dazu zumindest müssen Sie übergeben, der überwacht <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Objekt <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> über die <ph id="ph3">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> bis eine ausstehende Verbindung abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , dass Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können.</target>       </trans-unit>
        <trans-unit id="298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Können keine diesem zurückgegebenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren.</target>       </trans-unit>
        <trans-unit id="299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen.</target>       </trans-unit>
        <trans-unit id="302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> Eigenschaft für das zurückgegebene <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> festgelegt, um anzugeben, dass die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You can call use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Sie können mit Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> -Eigenschaft des zurückgegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt, mit dem Remotehost Netzwerk-Adresse und Port-Nummer angegeben.</target>       </trans-unit>
        <trans-unit id="308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data.</source>
          <target state="translated">In diesem Beispiel nimmt der Socket die ersten 10 Bytes der Daten.</target>       </trans-unit>
        <trans-unit id="316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes und die Daten werden vom Rückrufdelegaten auf der Konsole angezeigt.</target>       </trans-unit>
        <trans-unit id="317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> eine Beschreibung, wie die übrigen Daten empfangen werden.</target>       </trans-unit>
        <trans-unit id="318" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Der annehmende Socket überwacht keine Verbindungen.</target>       </trans-unit>
        <trans-unit id="321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vor dem Aufruf von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> müssen Sie <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> und <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Der angenommene Socket ist gebunden.</target>       </trans-unit>
        <trans-unit id="324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Das angenommene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This value may be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Wert kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The maximum number of bytes to receive.</source>
          <target state="translated">Die maximale Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</source>
          <target state="translated">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung von einem angegebenen Socket anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</target>       </trans-unit>
        <trans-unit id="332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object creation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekterstellung verweist.</target>       </trans-unit>
        <trans-unit id="333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Connection-oriented protocols can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to asynchronously process incoming connection attempts.</source>
          <target state="translated">Verbindungsorientierte Protokolle können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht.</target>       </trans-unit>
        <trans-unit id="334" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Akzeptieren von Verbindungen asynchron bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.</target>       </trans-unit>
        <trans-unit id="335" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This overload allows you to specify the accepted socket in the <ph id="ph1">`acceptSocket`</ph> parameter.</source>
          <target state="translated">Diese Überladung ermöglicht Ihnen das Festlegen der angenommenen Sockets in der <ph id="ph1">`acceptSocket`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this parameter is <ph id="ph1">`null`</ph>, the accepted socket is created by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn dieser Parameter ist <ph id="ph1">`null`</ph>, angenommenen Sockets wird erstellt, indem die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can specify the number of bytes to accept in the initial transfer in the <ph id="ph1">`receiveSize`</ph> parameter.</source>
          <target state="translated">Sie können angeben, die Anzahl der Bytes, die in der ersten Übertragung akzeptiert die <ph id="ph1">`receiveSize`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, you must call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method to listen for and queue incoming connection requests.</source>
          <target state="translated">Vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode, die Sie aufrufen müssen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> -Methode Lauschen und verbindungsanforderungen für eingehende in die Warteschlange.</target>       </trans-unit>
        <trans-unit id="339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Müssen Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, you must pass the listening <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Dazu zumindest müssen Sie übergeben, der überwacht <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Objekt <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> über die <ph id="ph3">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, the system usually uses a separate thread to execute the specified callback method and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> until a pending connection is retrieved.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> bis eine ausstehende Verbindung abgerufen wurde.</target>       </trans-unit>
        <trans-unit id="345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object that you can use to send and receive data with the remote host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt, das Sie zum Senden und Empfangen von Daten mit dem Remotehost verwenden können.</target>       </trans-unit>
        <trans-unit id="346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You cannot use this returned <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept any additional connections from the connection queue.</source>
          <target state="translated">Können keine diesem zurückgegebenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren.</target>       </trans-unit>
        <trans-unit id="347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The system may also use the calling thread to invoke the callback method.</source>
          <target state="translated">Das System kann den aufrufenden Thread auch verwenden, die Rückrufmethode aufgerufen.</target>       </trans-unit>
        <trans-unit id="350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> property on the returned <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> will be set to indicate that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method completed synchronously.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.IAsyncResult.CompletedSynchronously%2A&gt;</ph> Eigenschaft für das zurückgegebene <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> festgelegt, um anzugeben, dass die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property of the returned <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object to identify the remote host's network address and port number.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> -Eigenschaft des zurückgegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt, mit dem Remotehost Netzwerk-Adresse und Port-Nummer angegeben.</target>       </trans-unit>
        <trans-unit id="356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example opens a socket and accepts an asynchronous connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>In this example, the socket accepts the initial 10 bytes of data and the <ph id="ph1">`acceptSocket`</ph> parameter is <ph id="ph2">`null`</ph>, which forces the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method to create the accepted socket.</source>
          <target state="translated">In diesem Beispiel wird der Socket akzeptiert die ersten 10 Bytes der Daten und die <ph id="ph1">`acceptSocket`</ph> Parameter ist <ph id="ph2">`null`</ph>, welche erzwingt, dass die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode, um die angenommenen Sockets erstellen.</target>       </trans-unit>
        <trans-unit id="364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The number of bytes received and the data are displayed on the console by the callback delegate.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes und die Daten werden vom Rückrufdelegaten auf der Konsole angezeigt.</target>       </trans-unit>
        <trans-unit id="365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>See <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> for a description of how the remaining data is received.</source>
          <target state="translated">Finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> eine Beschreibung, wie die übrigen Daten empfangen werden.</target>       </trans-unit>
        <trans-unit id="366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepting socket is not listening for connections.</source>
          <target state="translated">Der annehmende Socket überwacht keine Verbindungen.</target>       </trans-unit>
        <trans-unit id="369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>You must call <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> before calling <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated">Vor dem Aufruf von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> müssen Sie <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> und <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> aufrufen.</target>       </trans-unit>
        <trans-unit id="370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="371" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>The accepted socket is bound.</source>
          <target state="translated">Der angenommene Socket ist gebunden.</target>       </trans-unit>
        <trans-unit id="372" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="receiveSize" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="373" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="374" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="377" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="378" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone Verbindung verweist.</target>       </trans-unit>
        <trans-unit id="379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method starts an asynchronous request for a connection to the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode startet eine asynchrone Anforderung einer Verbindung mit der <ph id="ph2">`remoteEP`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</source>
          <target state="translated">Herstellen einer Verbindung oder die Standard-Remotehost asynchron festlegen bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.</target>       </trans-unit>
        <trans-unit id="382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>At the very minimum, you must pass the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> through the <ph id="ph3">`state`</ph> parameter.</source>
          <target state="translated">Sie müssen zumindest, übergeben die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> über die <ph id="ph3">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, und die anderen erforderlichen Informationen.</target>       </trans-unit>
        <trans-unit id="385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connects successfully or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> eine Verbindung hergestellt oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="391" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="392" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> für die Kommunikation mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="393" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen.</target>       </trans-unit>
        <trans-unit id="394" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you wish to set your default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> und legen Sie die Übertragung auf <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="395" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you cannot, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht möglich, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine lokale Adresse und Anschlussnummer Netzwerknummer erst nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.</target>       </trans-unit>
        <trans-unit id="411" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="412" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="413" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</target>       </trans-unit>
        <trans-unit id="416" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> of the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> des Remotehosts.</target>       </trans-unit>
        <trans-unit id="417" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="418" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="419" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="420" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="421" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and a port number.</source>
          <target state="translated">Der Host wird durch eine <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> und eine Anschlussnummer angegeben.</target>       </trans-unit>
        <trans-unit id="422" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone Verbindung verweist.</target>       </trans-unit>
        <trans-unit id="423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`requestCallback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> -methodenüberladungen, oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>asynchron aufrufen synchroner Methoden<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Auch die <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> also verwendet, müssen jedoch verschieden sein.</target>       </trans-unit>
        <trans-unit id="436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.</target>       </trans-unit>
        <trans-unit id="441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="444" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not in the socket family.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ist kein Mitglied der Socketfamilie.</target>       </trans-unit>
        <trans-unit id="445" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="446" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="447" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</target>       </trans-unit>
        <trans-unit id="448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>At least one <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, designating the remote host.</source>
          <target state="translated">Mindestens eine <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>, die den Remotehost angibt.</target>       </trans-unit>
        <trans-unit id="449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="451" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="452" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="453" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by an <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> array and a port number.</source>
          <target state="translated">Der Host wird durch ein <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph>-Array und eine Anschlussnummer angegeben.</target>       </trans-unit>
        <trans-unit id="454" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connections.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchronen Verbindungen verweist.</target>       </trans-unit>
        <trans-unit id="455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`requestCallback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Auch die <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> also verwendet, müssen jedoch verschieden sein.</target>       </trans-unit>
        <trans-unit id="468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.</target>       </trans-unit>
        <trans-unit id="473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets that use <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</source>
          <target state="translated">Diese Methode ist für Sockets gültig, die <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> verwenden.</target>       </trans-unit>
        <trans-unit id="477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="479" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</target>       </trans-unit>
        <trans-unit id="480" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The name of the remote host.</source>
          <target state="translated">Der Name des Remotehosts.</target>       </trans-unit>
        <trans-unit id="481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the connect operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <bpt id="p1">&lt;c&gt;</bpt>requestCallback<ept id="p1">&lt;/c&gt;</ept>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request for a remote host connection.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</target>       </trans-unit>
        <trans-unit id="486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous connection.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf die asynchrone Verbindung verweist.</target>       </trans-unit>
        <trans-unit id="487" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`requestCallback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`requestCallback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>To cancel a pending call to the  <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method, close the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Einen ausstehenden Aufruf Abbrechen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> -Methode schließen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method is called while an asynchronous operation is in progress, the callback provided to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method is called.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> der Rückruf-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode wird aufgerufen.</target>       </trans-unit>
        <trans-unit id="493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>A subsequent call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method will throw an <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> to indicate that the operation has been cancelled.</source>
          <target state="translated">Ein nachfolgender Aufruf von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.ObjectDisposedException&gt;</ph> um anzugeben, dass der Vorgang abgebrochen wurde.</target>       </trans-unit>
        <trans-unit id="494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>asynchron aufrufen synchroner Methoden<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>If this socket has previously been disconnected, then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> must be called on a thread that will not exit until the operation is complete.</source>
          <target state="translated">Wenn diesem Socket zuvor, klicken Sie dann getrennt wurde <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>Also the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> that is used must be different.</source>
          <target state="translated">Auch die <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> also verwendet, müssen jedoch verschieden sein.</target>       </trans-unit>
        <trans-unit id="500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The following code example initiates an asynchronous connection attempt.</source>
          <target state="translated">Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.</target>       </trans-unit>
        <trans-unit id="505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Methode gilt für Sockets der Familie <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>, or an asynchronous operation is already in progress.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</target>       </trans-unit>
        <trans-unit id="510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieser Socket wiederverwendet werden kann, nachdem die Verbindung geschlossen wurde, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</target>       </trans-unit>
        <trans-unit id="514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that references the asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das auf den asynchronen Vorgang verweist.</target>       </trans-unit>
        <trans-unit id="515" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you can call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method to request a disconnect from a remote endpoint.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie rufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> Methode, um eine Trennung der Verbindung von einem remote-Endpunkt anzufordern.</target>       </trans-unit>
        <trans-unit id="516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">Wenn <ph id="ph1">`reuseSocket`</ph> ist <ph id="ph2">`true`</ph>, können Sie den Socket wiederverwenden.</target>       </trans-unit>
        <trans-unit id="517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> method uses a separate thread to invoke the specified callback method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> Methode verwendet einen eigenen Thread, um die angegebene Rückrufmethode aufzurufen.</target>       </trans-unit>
        <trans-unit id="518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the pending disconnect is complete.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> Methode blockiert, bis der ausstehende Trennung der Verbindung ist abgeschlossen.</target>       </trans-unit>
        <trans-unit id="519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit Ausnahme der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Wenn die Daten gesendet wurden, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> wird aufgerufen, um das Beenden der Send und receive-Aktivität.</target>       </trans-unit>
        <trans-unit id="526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Klicken Sie dann <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> wird aufgerufen, um eine Anforderung zum Trennen der beginnen.</target>       </trans-unit>
        <trans-unit id="527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Klicken Sie nach Abschluss die Anforderung der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.</target>       </trans-unit>
        <trans-unit id="528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</target>       </trans-unit>
        <trans-unit id="529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="530" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="531" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`callback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="551" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="552" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="553" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="563" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="564" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`callback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the received data.</source>
          <target state="translated">Die nullbasierte Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die empfangenen Daten gespeichert werden.</target>       </trans-unit>
        <trans-unit id="585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`callback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="601" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="602" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="603" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="604" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="605" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="606" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins to asynchronously receive data from a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird asynchron empfangen von Daten aus einer verbundenen beginnt <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="610" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="611" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="612" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="613" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="614" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="615" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="616" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="617" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="618" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">Die Position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, an der die empfangenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="619" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="620" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate that references the method to invoke when the operation is complete.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="621" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains information about the receive operation.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</target>       </trans-unit>
        <trans-unit id="622" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This object is passed to the <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> delegate when the operation is complete.</source>
          <target state="translated">Dieses Objekt wird bei Abschluss des Vorgangs an den <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph>-Delegaten übergeben.</target>       </trans-unit>
        <trans-unit id="623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> operation must be completed by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method.</source>
          <target state="translated">Der asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Vorgang muss abgeschlossen werden, durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`callback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`callback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation is complete.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="628" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To block until the operation is complete, use one of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method overloads.</source>
          <target state="translated">Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Überladungen der Methode.</target>       </trans-unit>
        <trans-unit id="629" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="630" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>Aufrufen synchroner Methoden asynchron<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept>.</target>       </trans-unit>
        <trans-unit id="631" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="632" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="633" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="634" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="635" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="640" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="641" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="642" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="643" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="644" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="645" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="646" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="647" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="648" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="649" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="650" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="651" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">Die nullbasierte Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die Daten gespeichert werden.</target>       </trans-unit>
        <trans-unit id="652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</target>       </trans-unit>
        <trans-unit id="656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="657" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method starts asynchronously reading connectionless datagrams from a remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode startet verbindungslose Datagramme von einem Remotehost asynchron zu lesen.</target>       </trans-unit>
        <trans-unit id="658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method gives you the ability to receive data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread empfangen.</target>       </trans-unit>
        <trans-unit id="659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and it will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> reads data or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> liest Daten aus, oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method, use <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> -Methode <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods, see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will throw a <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, müssen Sie explizit Binden der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode oder <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> löst eine <ph id="ph5">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent.</source>
          <target state="translated">Diese Methode liest Daten in den <ph id="ph1">`buffer`</ph> Parameter und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet werden.</target>       </trans-unit>
        <trans-unit id="670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Informationen zum Abrufen von diesem Endpunkt finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode eignet sich am besten, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts empfangen werden.</target>       </trans-unit>
        <trans-unit id="672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">In diesen Fällen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen.</target>       </trans-unit>
        <trans-unit id="673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Datagramm Sie erhalten größer als die Größe des <ph id="ph1">`buffer`</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode füllt <ph id="ph3">`buffer`</ph> mit so viel wie möglich und löst der Meldung ein <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten.</target>       </trans-unit>
        <trans-unit id="675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode mit einer ausreichend großen Puffer.</target>       </trans-unit>
        <trans-unit id="676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method and then call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method with the <ph id="ph4">`optionLevel`</ph> parameter set to <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph> or <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> as appropriate, the <ph id="ph7">`optionName`</ph> parameter set to <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, and the <ph id="ph9">`optionValue`</ph> parameter to enable this option before calling the <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Um sicherzustellen, dass der Endpunkt des remote-Host wird immer zurückgegeben, eine Anwendung sollten explizit Binden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, und rufen Sie dann die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode mit der <ph id="ph4">`optionLevel`</ph> Parametersatz auf <ph id="ph5">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>oder <ph id="ph6">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6&gt;</ph> nach Bedarf, die <ph id="ph7">`optionName`</ph> Parametersatz auf <ph id="ph8">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph>, und die <ph id="ph9">`optionValue`</ph> Parameter zum Aktivieren dieser Option vor dem Aufruf der <ph id="ph10">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Andernfalls ist es möglich, dass der remote-Host-Endpunkt nicht zurückgegeben werden, wenn der Absender eine Reihe von Datagrammen gesendet hat, bevor der Empfänger aufgerufen hat die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll.</target>       </trans-unit>
        <trans-unit id="679" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph><ph id="ph2"> / </ph><ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method or accept an incoming connection request by calling the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> <ph id="ph2"> / </ph> <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende verbindungsanforderung durch Aufrufen der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="680" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method before establishing or accepting a connection, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> -Methode vor dem herstellen oder annehmen einer Verbindung erhalten Sie eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">In diesen Fällen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> -Methode ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Mit verbindungsorientierte Sockets <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> liest so viel verfügbaren Daten bis zur Anzahl der Bytes, die gemäß der <ph id="ph2">`size`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously receives connectionless datagrams from a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird empfängt verbindungslose Datagramme asynchron von einem Remotehost.</target>       </trans-unit>
        <trans-unit id="692" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="693" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="694" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="695" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="696" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="697" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="698" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="699" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="700" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="701" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to store the data.</source>
          <target state="translated">Die nullbasierte Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die Daten gespeichert werden.</target>       </trans-unit>
        <trans-unit id="707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the source of the data.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der die Datenquelle darstellt.</target>       </trans-unit>
        <trans-unit id="710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="711" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="712" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information..</source>
          <target state="translated">Beginnt unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</target>       </trans-unit>
        <trans-unit id="713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous read.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Lesevorgang verweist.</target>       </trans-unit>
        <trans-unit id="714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The asynchronous receive operation must be completed by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Die asynchronen Empfangsvorgang abgeschlossen werden muss, durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>Typically, the method is invoked by the <ph id="ph1">`asyncCallback`</ph> delegate.</source>
          <target state="translated">In der Regel wird die Methode aufgerufen, indem die <ph id="ph1">`asyncCallback`</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method does not block until the operation completes.</source>
          <target state="translated">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To block until the operation completes, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For detailed information about using the asynchronous programming model, see <bpt id="p1">[</bpt>Calling Synchronous Methods Asynchronously<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></source>
          <target state="translated">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter <bpt id="p1">[</bpt>asynchron aufrufen synchroner Methoden<ept id="p1">](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)</ept></target>       </trans-unit>
        <trans-unit id="720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method reads data into the <ph id="ph1">`buffer`</ph> parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</source>
          <target state="translated">Diese Methode liest Daten in den <ph id="ph1">`buffer`</ph> Parameter, und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet werden, sowie Informationen über das empfangene Paket.</target>       </trans-unit>
        <trans-unit id="721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For information on how to retrieve this endpoint, refer to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</source>
          <target state="translated">Informationen zum Abrufen von diesem Endpunkt finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode eignet sich am besten, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts empfangen werden.</target>       </trans-unit>
        <trans-unit id="723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="729" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="730" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="738" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="739" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</target>       </trans-unit>
        <trans-unit id="742" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten asynchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten asynchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Sendevorgang verweist.</target>       </trans-unit>
        <trans-unit id="749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode, mit der <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</target>       </trans-unit>
        <trans-unit id="766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="785" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="786" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="787" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="788" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="789" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten asynchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="790" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Sendevorgang verweist.</target>       </trans-unit>
        <trans-unit id="791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode, mit der <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode auf eine <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> in die Rückrufmethode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.</target>       </trans-unit>
        <trans-unit id="802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="805" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</target>       </trans-unit>
        <trans-unit id="808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="824" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="825" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="826" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="827" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">Die nullbasierte Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der das Senden der Daten beginnen soll.</target>       </trans-unit>
        <trans-unit id="828" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="829" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="830" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="831" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="832" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten asynchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Sendevorgang verweist.</target>       </trans-unit>
        <trans-unit id="835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="840" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="841" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="842" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode, mit der <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</target>       </trans-unit>
        <trans-unit id="852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="865" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="866" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="867" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="868" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="869" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="870" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="871" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The zero-based position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter at which to begin sending data.</source>
          <target state="translated">Die nullbasierte Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der das Senden der Daten beginnen soll.</target>       </trans-unit>
        <trans-unit id="878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten asynchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Sendevorgang verweist.</target>       </trans-unit>
        <trans-unit id="883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine kleine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode, mit der <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</target>       </trans-unit>
        <trans-unit id="900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`state`</ph> is an instantiation of a user-defined class.</source>
          <target state="translated"><ph id="ph1">`state`</ph> ist eine Instanziierung einer benutzerdefinierten Klasse.</target>       </trans-unit>
        <trans-unit id="907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="908" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="909" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="910" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="911" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="912" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="913" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The following code example begins asynchronously sending data to a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird startet das asynchrone Senden von Daten mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="925" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Sendet eine Datei asynchron an ein verbundenes <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to send.</source>
          <target state="translated">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält.</target>       </trans-unit>
        <trans-unit id="927" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="928" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> flag.</source>
          <target state="translated">Sendet die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> unter Verwendung des <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Flags an ein verbundenes <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="931" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das den asynchronen Sendevorgang darstellt.</target>       </trans-unit>
        <trans-unit id="932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Diese Überladung sendet die Datei <ph id="ph1">`fileName`</ph> an den verbundenen Socket.</target>       </trans-unit>
        <trans-unit id="933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Wenn <ph id="ph1">`fileName`</ph> wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden.</target>       </trans-unit>
        <trans-unit id="934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Platzhalter ("... <ph id="ph1">\\</ph>\myfile.txt ") und UNC-Freigabenamen ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared Directory<ph id="ph5">\\</ph>\myfile.txt ") werden unterstützt.</target>       </trans-unit>
        <trans-unit id="935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die Datei nicht gefunden wird, wird die Ausnahme <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Diese Methode verwendet die <ph id="ph1">`TransmitFile`</ph> -Funktion, die in der Windows Sockets-API 2 gefunden.</target>       </trans-unit>
        <trans-unit id="937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu den <ph id="ph1">`TransmitFile`</ph> -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.</target>       </trans-unit>
        <trans-unit id="938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>,<ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method enables you to send a file within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode können Sie eine Datei in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Zum Abschließen des Vorgangs können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> Parameter zu delegieren.</target>       </trans-unit>
        <trans-unit id="942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Hierzu zumindest, die <ph id="ph1">`state`</ph> Parameter muss enthalten die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen muss die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die gesamte Datei oder eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie Sie sicher, dass sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</target>       </trans-unit>
        <trans-unit id="950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit Ausnahme der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="952" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="953" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="954" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="955" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="956" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="957" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation.</target>       </trans-unit>
        <trans-unit id="958" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>First, the file "text.txt" is sent asynchronously to the remote host.</source>
          <target state="translated">Zunächst wird die Datei "text.txt" asynchron mit dem Remotehost gesendet.</target>       </trans-unit>
        <trans-unit id="959" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> um die Übertragung abzuschließen.</target>       </trans-unit>
        <trans-unit id="960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Der Socket ist nicht mit einem Remotehost verbunden.</target>       </trans-unit>
        <trans-unit id="962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A string that contains the path and name of the file to be sent.</source>
          <target state="translated">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält.</target>       </trans-unit>
        <trans-unit id="966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird.</target>       </trans-unit>
        <trans-unit id="968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde.</target>       </trans-unit>
        <trans-unit id="970" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="971" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A bitwise combination of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination von <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>-Werten.</target>       </trans-unit>
        <trans-unit id="972" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate to be invoked when this operation completes.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat, der nach Abschluss dieses Vorgangs aufgerufen werden soll.</target>       </trans-unit>
        <trans-unit id="973" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="974" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>A user-defined object that contains state information for this request.</source>
          <target state="translated">Ein benutzerdefiniertes Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="975" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="976" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Sends a file and buffers of data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Sendet eine Datei und Datenpuffer asynchron an ein verbundenes <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="977" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that represents the asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das den asynchronen Vorgang darstellt.</target>       </trans-unit>
        <trans-unit id="978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Diese Überladung muss der Name der Datei, die Sie senden möchten und eine bitweise Kombination von <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">Die <ph id="ph1">`preBuffer`</ph> Parameter enthält alle Daten, die vor der Datei gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> enthält Daten, die Sie die Datei folgen soll.</target>       </trans-unit>
        <trans-unit id="981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Wenn <ph id="ph1">`fileName`</ph> wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden.</target>       </trans-unit>
        <trans-unit id="982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Platzhalter ("... <ph id="ph1">\\</ph>\myfile.txt ") und UNC-Freigabenamen ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared Directory<ph id="ph5">\\</ph>\myfile.txt ") werden unterstützt.</target>       </trans-unit>
        <trans-unit id="983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die Datei nicht gefunden wird, wird die Ausnahme <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="984" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Die <ph id="ph1">`flags`</ph> Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit.</target>       </trans-unit>
        <trans-unit id="985" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="986" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Diese Methode verwendet die <ph id="ph1">`TransmitFile`</ph> -Funktion, die in der Windows Sockets-API 2 gefunden.</target>       </trans-unit>
        <trans-unit id="987" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu den <ph id="ph1">`TransmitFile`</ph> -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.</target>       </trans-unit>
        <trans-unit id="988" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> methods.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="989" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="990" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method gives you the ability to send a file within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, eine Datei in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="991" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To complete the operation, you can create a callback method that is invoked by the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate parameter.</source>
          <target state="translated">Zum Abschließen des Vorgangs können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> Parameter zu delegieren.</target>       </trans-unit>
        <trans-unit id="992" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, the <ph id="ph1">`state`</ph> parameter must contain the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object being used for communication.</source>
          <target state="translated">Hierzu zumindest, die <ph id="ph1">`state`</ph> Parameter muss enthalten die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Objekt für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="993" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a class or structure to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können Sie erstellen eine Klasse oder Struktur zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und andere erforderliche Informationen.</target>       </trans-unit>
        <trans-unit id="994" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this custom object to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="995" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Your callback method must invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen muss die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="996" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, the system uses a separate thread to execute the specified callback method, and blocks on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the entire file or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die gesamte Datei oder eine Ausnahme auslöst.</target>       </trans-unit>
        <trans-unit id="997" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For additional information on writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="998" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>Although intended for connection-oriented protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="999" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</target>       </trans-unit>
        <trans-unit id="1000" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="1001" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit Ausnahme der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1002" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="1006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="1007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>In this example, a <ph id="ph1">`preBuffer`</ph> and a <ph id="ph2">`postBuffer`</ph> of data is created to send with the file and the default <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> value is used.</source>
          <target state="translated">In diesem Beispiel wird eine <ph id="ph1">`preBuffer`</ph> und ein <ph id="ph2">`postBuffer`</ph> der Daten erstellt, um mit der Datei und der standardmäßige senden <ph id="ph3">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> Wert wird verwendet.</target>       </trans-unit>
        <trans-unit id="1009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> um die Übertragung abzuschließen.</target>       </trans-unit>
        <trans-unit id="1010" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1011" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1012" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="1013" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">Das Betriebssystem ist nicht Windows NT oder höher.</target>       </trans-unit>
        <trans-unit id="1014" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="1015" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Der Socket ist nicht mit einem Remotehost verbunden.</target>       </trans-unit>
        <trans-unit id="1016" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="1017" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to send.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="1018" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The zero-based position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> at which to begin sending data.</source>
          <target state="translated">Die nullbasierte Position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, an der das Senden der Daten beginnen soll.</target>       </trans-unit>
        <trans-unit id="1019" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="1020" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph> delegate.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.AsyncCallback" /&gt;</ph>-Delegat.</target>       </trans-unit>
        <trans-unit id="1021" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An object that contains state information for this request.</source>
          <target state="translated">Ein Objekt mit Zustandsinformationen für diese Anforderung.</target>       </trans-unit>
        <trans-unit id="1022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Sendet asynchron Daten an einen angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="1023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that references the asynchronous send.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das auf den asynchronen Sendevorgang verweist.</target>       </trans-unit>
        <trans-unit id="1024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">`remoteEP`</ph> parameter.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang mit dem Remotehost, angegeben der <ph id="ph2">`remoteEP`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1025" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="1026" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Obwohl für verbindungslose Protokolle vorgesehen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="1027" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You can create a callback method that implements the <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegate and pass its name to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method.</source>
          <target state="translated">Können Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph1">&lt;xref:System.AsyncCallback&gt;</ph> delegieren, und übergeben Sie den Namen in der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1028" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>To do this, at the very minimum, your <ph id="ph1">`state`</ph> parameter must contain the connected or default <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> being used for communication.</source>
          <target state="translated">Hierzu zumindest, Ihre <ph id="ph1">`state`</ph> Parameter enthalten, die verbundene oder default muss <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die Kommunikation verwendet wird.</target>       </trans-unit>
        <trans-unit id="1029" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If your callback needs more information, you can create a small class to hold the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, and the other required information.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen benötigt werden, können, erstellen Sie eine kleine Klasse zum Speichern der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, und die anderen erforderlichen Informationen.</target>       </trans-unit>
        <trans-unit id="1030" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Pass an instance of this class to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method through the <ph id="ph2">`state`</ph> parameter.</source>
          <target state="translated">Übergeben Sie eine Instanz dieser Klasse, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> Methode über die <ph id="ph2">`state`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1031" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Your callback method should invoke the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method.</source>
          <target state="translated">Die Rückrufmethode aufrufen sollten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1032" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>When your application calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, the system will use a separate thread to execute the specified callback method, and will block on <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> until the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sends the number of bytes requested or throws an exception.</source>
          <target state="translated">Wenn die Anwendung aufruft, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> bis der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> sendet die Anzahl der angeforderten Bytes oder löst eine Ausnahme aus.</target>       </trans-unit>
        <trans-unit id="1033" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want the original thread to block after you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method, use the <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> method.</source>
          <target state="translated">Wenn Sie möchten, dass den ursprünglichen Thread blockiert wird, nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> -Methode, mit der <ph id="ph2">&lt;xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</source>
          <target state="translated">Rufen Sie die Set-Methode für eine: System.Threading.ManualResetEvent der Rückrufmethode, wenn Sie möchten, dass den ursprünglichen Thread weiterhin ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="1035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For additional information about writing callback methods see <bpt id="p1">[</bpt>Marshaling a Delegate as a Callback Method<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter <bpt id="p1">[</bpt>Marshalling von Delegaten als Rückrufmethode<ept id="p1">](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will throw a <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> löst eine <ph id="ph6">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und sendet Daten an die <ph id="ph3">&lt;xref:System.Net.EndPoint&gt;</ph> hergestellt, die der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, oder <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph4">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, die <ph id="ph4">`remoteEP`</ph> Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="1041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>In this case, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">In diesem Fall wird der zugrunde liegende Dienstanbieter die am besten geeignete LAN-Adresse und Anschlussnummer Anzahl zuweisen.</target>       </trans-unit>
        <trans-unit id="1043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Verwenden Sie die Portnummer 0 (null), wenn die zugrunde liegenden Service-Anbieter einen Port frei auswählen soll.</target>       </trans-unit>
        <trans-unit id="1044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">-Sie müssen auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="1047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="1049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> methods.</source>
          <target state="translated">Der Ausführungskontext (der Sicherheitskontext, die Identität eines Benutzers und den aufrufenden Kontext) wird für den asynchronen zwischengespeichert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="1054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>After the first use of a particular context (a specific asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> method, a specific <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</source>
          <target state="translated">Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Methode, die einen bestimmten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz und ein bestimmter Rückruf), nachfolgende Verwendung des diesem Kontext werden eine leistungsverbesserung angezeigt.</target>       </trans-unit>
        <trans-unit id="1055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The following code example asynchronously sends data to the specified remote host.</source>
          <target state="translated">Im folgenden Codebeispiel sendet Daten asynchron mit dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="1056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1060" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="1061" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="1065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="1067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The local <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> to associate with the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Der lokale <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der dem <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> zugeordnet werden soll.</target>       </trans-unit>
        <trans-unit id="1070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associates a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> with a local endpoint.</source>
          <target state="translated">Ordnet einem <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> einen lokalen Endpunkt zu.</target>       </trans-unit>
        <trans-unit id="1071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you need to use a specific local endpoint.</source>
          <target state="translated">Verwenden Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen.</target>       </trans-unit>
        <trans-unit id="1072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> method.</source>
          <target state="translated">Rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf können die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You do not need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method unless you need to use a specific local endpoint.</source>
          <target state="translated">Sie müssen nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor der Verwendung der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen.</target>       </trans-unit>
        <trans-unit id="1074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method on both connectionless and connection-oriented protocols.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode Verbindungs- und verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="1075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, you must first create the local <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> from which you intend to communicate data.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph>, müssen Sie zunächst die lokale erstellen <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> aus dem Sie Daten kommuniziert werden soll.</target>       </trans-unit>
        <trans-unit id="1076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local address is assigned, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> as the address parameter, and the underlying service provider will assign the most appropriate network address.</source>
          <target state="translated">Wenn unwichtig ist, welche lokale Adresse zugewiesen wird, können Sie erstellen eine <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> mit <ph id="ph2">&lt;xref:System.Net.IPAddress.Any?displayProperty=nameWithType&gt;</ph> als Adressenparameter und der zugrunde liegende Dienst Anbieter die am besten geeignete Netzwerkadresse zugewiesen wird.</target>       </trans-unit>
        <trans-unit id="1077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This might help simplify your application if you have multiple network interfaces.</source>
          <target state="translated">Das kann hilfreich sein, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen.</target>       </trans-unit>
        <trans-unit id="1078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you do not care which local port is used, you can create an <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> using 0 for the port number.</source>
          <target state="translated">Wenn unwichtig ist, welche lokaler Port verwendet wird, können Sie erstellen eine <ph id="ph1">&lt;xref:System.Net.IPEndPoint&gt;</ph> mit dem Wert 0 für die Portnummer an.</target>       </trans-unit>
        <trans-unit id="1079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>In this case, the service provider will assign an available port number between 1024 and 5000.</source>
          <target state="translated">In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000.</target>       </trans-unit>
        <trans-unit id="1080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you use the above approach, you can discover what local network address and port number has been assigned by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie die oben beschriebene Ansatz verwenden, können Sie ermitteln, welche LAN-Adresse und Anschlussnummer Anzahl durch den Aufruf zugewiesen wurde die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> will not return the locally assigned network address until after you have made a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> die lokal zugewiesene Netzwerkadresse erst nicht zurückgegeben, nachdem Sie einen Aufruf vorgenommen haben die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, werden Sie keinen Zugriff auf diese Informationen, bis einen Sendevorgang abgeschlossen haben oder erhalten.</target>       </trans-unit>
        <trans-unit id="1083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If a UDP socket wants to receive interface information on received packets,  the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method should be explicitly called with the socket option set to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> immediately after calling the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Wenn ein UDP-Socket Schnittstelleninformationen auf empfangene Pakete empfangen möchte die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode sollte explizit aufgerufen werden, mit der Socketoption auf <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> unmittelbar nach dem Aufrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you intend to receive multicast datagrams, you must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method with a multicast port number.</source>
          <target state="translated">Wenn Sie Multicastdatagramme empfangen möchten, müssen Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode mit einer multicast-Anschlussnummer.</target>       </trans-unit>
        <trans-unit id="1085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method if you intend to receive connectionless datagrams using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode, wenn Sie beabsichtigen, verbindungslose Datagramme mit empfangen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> beim Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, mit der <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The following code example binds a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> using the specified local endpoint.</source>
          <target state="translated">Im folgenden Codebeispiel Beispiel bindet einen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> mit den angegebenen lokalen Endpunkt.</target>       </trans-unit>
        <trans-unit id="1091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="localEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1092" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1093" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1094" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>for accepting connections from the host defined by <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</source>
          <target state="translated">zum Akzeptieren von Verbindungen vom Host durch definierten <ph id="ph1">&lt;paramref name="localEP" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1097" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>Gets or sets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is in blocking mode.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob sich der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> im blockierenden Modus befindet.</target>       </trans-unit>
        <trans-unit id="1098" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will block; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> blockiert wird, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1099" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1100" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property indicates whether a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is in blocking mode.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft gibt an, ob eine <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> im blockierenden Modus befindet.</target>       </trans-unit>
        <trans-unit id="1101" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</source>
          <target state="translated">Wenn Sie in Blockierungsmodus befinden, und Sie stellen eine Methode aufrufen, die nicht sofort abgeschlossen wird, wird Ihre Anwendung Ausführung blockiert, bis der angeforderte Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1102" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you want execution to continue even though the requested operation is not complete, change the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Wenn die Ausführung fortgesetzt werden, obwohl der angeforderte Vorgang nicht abgeschlossen ist, ändern soll, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1103" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property has no effect on asynchronous methods.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft wirkt sich nicht auf asynchrone Methoden.</target>       </trans-unit>
        <trans-unit id="1104" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you are sending and receiving data asynchronously and want to block execution, use the <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> class.</source>
          <target state="translated">Wenn Sie senden und Empfangen von Daten asynchron und die Ausführung blockieren möchten, verwenden Sie die <ph id="ph1">&lt;xref:System.Threading.ManualResetEvent&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="1105" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1106" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1107" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1109" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1110" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Blocking">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1111" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object used to request the connection to the remote host by calling one of the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph> methods.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das verwendet wurde, um die Verbindung mit dem Remotehost durch Aufrufen einer der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>-Methoden anzufordern.</target>       </trans-unit>
        <trans-unit id="1112" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">Bricht eine asynchrone Anforderung einer Remotehostverbindung ab.</target>       </trans-unit>
        <trans-unit id="1113" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> method cancels an asynchronous request for a remote host connection.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.CancelConnectAsync%2A&gt;</ph> -Methode bricht eine asynchrone Anforderung einer Remotehostverbindung.</target>       </trans-unit>
        <trans-unit id="1114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="e" /&gt;</ph>-Parameter kann nicht NULL und der <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> kann nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="1115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1117" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Schließt die <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Verbindung und gibt alle zugeordneten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="1119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources.</source>
          <target state="translated">Schließt die <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Verbindung und gibt alle zugeordneten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="1120" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode schließt die Remotehostverbindung und Releases alle verwalteten und nicht verwaltete Ressourcen für die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1121" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Nach Abschluss der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> -Eigenschaftensatz auf <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1122" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Für verbindungsorientierte Protokolle wird empfohlen, die Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> vor dem Aufruf der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Wenn Sie aufrufen müssen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> erst nach Aufrufen von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option <ph id="ph5">`false`</ph> und ein Timeoutintervall ungleich NULL angeben.</target>       </trans-unit>
        <trans-unit id="1125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> wird dann blockieren, bis die Daten gesendet werden oder das angegebene Timeout abläuft.</target>       </trans-unit>
        <trans-unit id="1126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Wenn Sie festlegen, <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> auf <ph id="ph2">`false`</ph> , und geben Sie ein Timeoutintervall NULL <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.</target>       </trans-unit>
        <trans-unit id="1127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time out period.</source>
          <target state="translated">Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> Socketoption auf <ph id="ph2">`false`</ph>, erstellen eine <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, legen Sie die enabled-Eigenschaft auf <ph id="ph4">`true`</ph>, und legen Sie die <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> Eigenschaft, um das gewünschte Zeitlimit.</target>       </trans-unit>
        <trans-unit id="1128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Verwenden Sie diese <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> zusammen mit den <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> Socketoption zum Aufrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close">
          <source>The following code example closes a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel Beispiel schließt eine <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1132" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Wait up to <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> seconds to send any remaining data, then close the socket.</source>
          <target state="translated">Warten Sie bis zu <bpt id="p1">&lt;c&gt;</bpt>timeout<ept id="p1">&lt;/c&gt;</ept> Sekunden, damit alle verbleibenden Daten gesendet werden, und schließen Sie dann den Socket.</target>       </trans-unit>
        <trans-unit id="1133" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Closes the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</source>
          <target state="translated">Schließt die <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Verbindung und gibt alle zugeordneten Ressourcen mit einem angegebenen Timeout frei, damit in der Warteschlange befindliche Daten gesendet werden können.</target>       </trans-unit>
        <trans-unit id="1134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method closes the remote host connection and releases all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode schließt die Remotehostverbindung und Releases alle verwalteten und nicht verwaltete Ressourcen für die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Upon closing, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is set to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Nach Abschluss der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> -Eigenschaftensatz auf <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For connection-oriented protocols, it is recommended that you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</source>
          <target state="translated">Für verbindungsorientierte Protokolle wird empfohlen, die Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can ensure that data queued for outgoing transmission will be sent by setting the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option to <ph id="ph4">`false`</ph> and specifying a non-zero time-out interval.</source>
          <target state="translated">Wenn Sie aufrufen müssen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> erst nach Aufrufen von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> option <ph id="ph4">`false`</ph> und ein Timeoutintervall ungleich NULL angeben.</target>       </trans-unit>
        <trans-unit id="1139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> will then block until this data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> wird dann blockieren, bis die Daten gesendet werden oder das angegebene Timeout abläuft.</target>       </trans-unit>
        <trans-unit id="1140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Wenn Sie festlegen, <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> auf <ph id="ph2">`false`</ph> , und geben Sie ein Timeoutintervall NULL <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.</target>       </trans-unit>
        <trans-unit id="1141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>To set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to <ph id="ph2">`false`</ph>, create a <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, set the enabled property to <ph id="ph4">`true`</ph>, and set the <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property to the desired time-out period.</source>
          <target state="translated">Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> Socketoption auf <ph id="ph2">`false`</ph>, erstellen eine <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph>, legen Sie die enabled-Eigenschaft auf <ph id="ph4">`true`</ph>, und legen Sie die <ph id="ph5">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> Eigenschaft, um den gewünschten Timeoutzeitraum.</target>       </trans-unit>
        <trans-unit id="1142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>Use this <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> along with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> socket option to call the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Verwenden Sie diese <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> zusammen mit den <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> Socketoption zum Aufrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Close(System.Int32)">
          <source>The following code example demonstrates how to close a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Schließen einer <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1146" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Stellt eine Verbindung mit einem Remotehost her.</target>       </trans-unit>
        <trans-unit id="1147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the remote device.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der das Remotegerät darstellt.</target>       </trans-unit>
        <trans-unit id="1148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Stellt eine Verbindung mit einem Remotehost her.</target>       </trans-unit>
        <trans-unit id="1149" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> -Methode synchron richtet eine Verbindung zwischen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> und der angegebenen Remoteendpunkt.</target>       </trans-unit>
        <trans-unit id="1150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="1151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, Senden von Daten an das Remotegerät mit dem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1152" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1153" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> synchron mit einem Remotehost kommunizieren.</target>       </trans-unit>
        <trans-unit id="1154" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen.</target>       </trans-unit>
        <trans-unit id="1155" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1156" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> da Zeit zum Herstellen die Verbindung benötigt.</target>       </trans-unit>
        <trans-unit id="1160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="1161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> um den spezifischen Fehlercode abzurufen.</target>       </trans-unit>
        <trans-unit id="1162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, aber noch nicht erfolgreich abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode, um zu bestimmen, wann die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist eine Verbindung herstellen.</target>       </trans-unit>
        <trans-unit id="1165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang.</target>       </trans-unit>
        <trans-unit id="1167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Verwenden Sie eine der asynchronen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methoden, die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="1171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.</target>       </trans-unit>
        <trans-unit id="1174" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1175" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1176" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1177" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert.</target>       </trans-unit>
        <trans-unit id="1179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>for connecting to the remote host.</source>
          <target state="translated">zum Herstellen einer Verbindung mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Connect" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The IP address of the remote host.</source>
          <target state="translated">Die IP-Adresse des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1183" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Stellt eine Verbindung mit einem Remotehost her.</target>       </trans-unit>
        <trans-unit id="1184" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The host is specified by an IP address and a port number.</source>
          <target state="translated">Der Host wird mit einer IP-Adresse und einer Portnummer angegeben.</target>       </trans-unit>
        <trans-unit id="1185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> -Methode synchron richtet eine Verbindung zwischen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> und der angegebenen Remoteendpunkt.</target>       </trans-unit>
        <trans-unit id="1186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="1187" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Senden von Daten an das Remotegerät mit dem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1188" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1189" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> synchron mit einem Remotehost kommunizieren.</target>       </trans-unit>
        <trans-unit id="1190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen.</target>       </trans-unit>
        <trans-unit id="1191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> da Zeit zum Herstellen die Verbindung benötigt.</target>       </trans-unit>
        <trans-unit id="1196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="1197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> um den spezifischen Fehlercode abzurufen.</target>       </trans-unit>
        <trans-unit id="1198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, aber noch nicht erfolgreich abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode, um zu bestimmen, wann die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist eine Verbindung herstellen.</target>       </trans-unit>
        <trans-unit id="1201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang.</target>       </trans-unit>
        <trans-unit id="1203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Verwenden Sie eine der asynchronen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methoden, die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="1207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.</target>       </trans-unit>
        <trans-unit id="1210" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="address" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="1212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Methode gilt für Sockets der Familie <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1216" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert.</target>       </trans-unit>
        <trans-unit id="1217" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The IP addresses of the remote host.</source>
          <target state="translated">Die IP-Adressen des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Stellt eine Verbindung mit einem Remotehost her.</target>       </trans-unit>
        <trans-unit id="1220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The host is specified by an array of IP addresses and a port number.</source>
          <target state="translated">Der Host wird durch ein Array von IP-Adressen und eine Portnummer angegeben.</target>       </trans-unit>
        <trans-unit id="1221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is typically used immediately after a call to <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, which can return multiple IP addresses for a single host.</source>
          <target state="translated">Diese Methode wird in der Regel verwendet, sofort nach einem Aufruf von <ph id="ph1">&lt;xref:System.Net.Dns.GetHostAddresses%2A&gt;</ph>, dem können mehrere IP-Adressen für einen einzelnen Host zurückgeben.</target>       </trans-unit>
        <trans-unit id="1222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote endpoint.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> -Methode synchron richtet eine Verbindung zwischen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> und der angegebenen Remoteendpunkt.</target>       </trans-unit>
        <trans-unit id="1223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="1224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Senden von Daten an das Remotegerät mit dem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> synchron mit einem Remotehost kommunizieren.</target>       </trans-unit>
        <trans-unit id="1227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen.</target>       </trans-unit>
        <trans-unit id="1228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> da Zeit zum Herstellen die Verbindung benötigt.</target>       </trans-unit>
        <trans-unit id="1233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="1234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> um den spezifischen Fehlercode abzurufen.</target>       </trans-unit>
        <trans-unit id="1235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, aber noch nicht erfolgreich abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode, um zu bestimmen, wann die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist eine Verbindung herstellen.</target>       </trans-unit>
        <trans-unit id="1238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang.</target>       </trans-unit>
        <trans-unit id="1240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Verwenden Sie eine der asynchronen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methoden, die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="1244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.</target>       </trans-unit>
        <trans-unit id="1247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="addresses" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="1249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Methode gilt für Sockets der Familie <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The length of <ph id="ph1">&lt;paramref name="address" /&gt;</ph> is zero.</source>
          <target state="translated">Die Länge von <ph id="ph1">&lt;paramref name="address" /&gt;</ph> ist 0 (null).</target>       </trans-unit>
        <trans-unit id="1253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert.</target>       </trans-unit>
        <trans-unit id="1254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The name of the remote host.</source>
          <target state="translated">Der Name des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number of the remote host.</source>
          <target state="translated">Die Portnummer des Remotehosts.</target>       </trans-unit>
        <trans-unit id="1256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Establishes a connection to a remote host.</source>
          <target state="translated">Stellt eine Verbindung mit einem Remotehost her.</target>       </trans-unit>
        <trans-unit id="1257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The host is specified by a host name and a port number.</source>
          <target state="translated">Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</target>       </trans-unit>
        <trans-unit id="1258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol such as TCP, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method synchronously establishes a network connection between <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> and the specified remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> -Methode synchron richtet eine Verbindung zwischen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> und dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="1259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="1260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> you can send data to the remote device with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method, or receive data from the remote device with the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Senden von Daten an das Remotegerät mit dem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> -Methode, oder Empfangen von Daten aus dem Remotegerät mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> to synchronously communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> synchron mit einem Remotehost kommunizieren.</target>       </trans-unit>
        <trans-unit id="1263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> , die über eine andere Adresse als der angegebene Standardwert eingehen Datagramme werden verworfen.</target>       </trans-unit>
        <trans-unit id="1264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to set your default remote host to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1266" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1267" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method will block, unless you specifically set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> property to <ph id="ph3">`false`</ph> prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode blockiert, es sei denn, Sie ausdrücklich Festlegen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Blocking%2A&gt;</ph> Eigenschaft <ph id="ph3">`false`</ph> vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1268" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol like TCP and you do disable blocking, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> because it needs time to make the connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wie TCP und Sie deaktivieren, blockieren, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> da Zeit zum Herstellen die Verbindung benötigt.</target>       </trans-unit>
        <trans-unit id="1269" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Connectionless protocols will not throw an exception because they simply establish a default remote host.</source>
          <target state="translated">Verbindungslose Protokolle werden keine Ausnahme auslöst, weil sie einfach einen Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="1270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> to obtain the specific error code.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> um den spezifischen Fehlercode abzurufen.</target>       </trans-unit>
        <trans-unit id="1271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, but has not yet completed successfully.</source>
          <target state="translated">Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die Remotehostverbindung durch einen verbindungsorientierten initiiert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, aber noch nicht erfolgreich abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method to determine when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is finished connecting.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode, um zu bestimmen, wann die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist eine Verbindung herstellen.</target>       </trans-unit>
        <trans-unit id="1274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If IPv6 is enabled and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</source>
          <target state="translated">Wenn IPv6 aktiviert ist und die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29&gt;</ph> Methode wird aufgerufen, um eine Verbindung zu einem Host herzustellen, der sowohl IPv6-aufgelöst wird und IPv4-Adressen, die Verbindung mit der IPv6-Adresse versucht zuerst, bevor Sie die IPv4-Adresse.</target>       </trans-unit>
        <trans-unit id="1275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</source>
          <target state="translated">Dies kann wirken sich die Zeit zum Herstellen der Verbindung, wenn der Host nicht auf die IPv6-Adresse lauscht verzögern.</target>       </trans-unit>
        <trans-unit id="1276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connection-oriented protocol and did not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the underlying service provider will assign the local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden und nicht aufgerufen haben, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, wird der Dienstanbieter nicht lokalen Netzwerk Adresse und Port weisen einen bis einen Sendevorgang abgeschlossen oder receive-Vorgang.</target>       </trans-unit>
        <trans-unit id="1278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If you want to change the default remote host, call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>If the socket has been previously disconnected, then you cannot use this method to restore the connection.</source>
          <target state="translated">Wenn die Socketverbindung zuvor getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>Use one of the asynchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> methods to reconnect.</source>
          <target state="translated">Verwenden Sie eine der asynchronen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methoden, die Verbindung wiederherzustellen.</target>       </trans-unit>
        <trans-unit id="1281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This is a limitation of the underlying provider.</source>
          <target state="translated">Dies ist eine Einschränkung des zugrunde liegenden Anbieter.</target>       </trans-unit>
        <trans-unit id="1282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The following code example connects to a remote endpoint and then verifies the connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt hergestellt und anschließend überprüft die Verbindung.</target>       </trans-unit>
        <trans-unit id="1285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source><ph id="ph1">&lt;paramref name="host" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="host" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The port number is not valid.</source>
          <target state="translated">Die Portnummer ist ungültig.</target>       </trans-unit>
        <trans-unit id="1287" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1288" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1289" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>This method is valid for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Methode gilt für Sockets der Familie <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> oder <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1290" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been placed in a listening state by calling <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde durch den Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> in einem Wartezustand platziert.</target>       </trans-unit>
        <trans-unit id="1291" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="1295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="1296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="1298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode startet eine asynchrone Anforderung für eine Verbindung mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> stellt eine Standard-Remotehost her.</target>       </trans-unit>
        <trans-unit id="1300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegieren, und fügen Sie den Rückruf, der die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="1301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">Der Aufrufer muss Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um die <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> des Remotehosts, für die Verbindung.</target>       </trans-unit>
        <trans-unit id="1302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="1304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> für die Kommunikation mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen.</target>       </trans-unit>
        <trans-unit id="1307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> und legen Sie die Übertragung auf <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies nicht erfolgt, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich:</target>       </trans-unit>
        <trans-unit id="1311" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Optional ein Puffer kann angegeben werden die auf den Socket atomar gesendet werden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1312" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, um zu senden und die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden.</target>       </trans-unit>
        <trans-unit id="1313" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Sobald eine Verbindung hergestellt ist, wird dieser Puffer von Daten gesendet.</target>       </trans-unit>
        <trans-unit id="1314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl erst nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="1316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> -Methode löst <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> Wenn die Adressfamilie von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> sind nicht die gleiche Adressfamilie.</target>       </trans-unit>
        <trans-unit id="1317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> verwenden Sie beim Aufrufen dieser Methode die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1319" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Ein Argument ist ungültig.</target>       </trans-unit>
        <trans-unit id="1320" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph>-Eigenschaft nicht NULL ist.</target>       </trans-unit>
        <trans-unit id="1321" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="e" /&gt;</ph>-Parameter kann nicht NULL und der <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> kann nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="1322" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="1323" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1324" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="1325" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> nicht die gleiche Adressfamilie aufweisen.</target>       </trans-unit>
        <trans-unit id="1326" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1327" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1331" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request for a connection to a remote host.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="1333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="1334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="1336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, beginnt die m:System.NET.Sockets.Socket.ConnectAsync(System.NET.Sockets.SocketType,System.NET.Sockets.ProtocolType,System.NET.Sockets.SocketAsyncEventArgs)-Methode eine asynchrone Anforderung einer Verbindung mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> establishes a default remote host specified by the <ph id="ph2">`socketType`</ph> and <ph id="ph3">`protocolType`</ph> parameters.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> richtet einen Standard-Remotehost gemäß der <ph id="ph2">`socketType`</ph> und <ph id="ph3">`protocolType`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegieren, und fügen Sie den Rückruf, der die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="1339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host to connect to.</source>
          <target state="translated">Der Aufrufer muss Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um die <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> des Remotehosts, für die Verbindung.</target>       </trans-unit>
        <trans-unit id="1340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="1342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol such as UDP, you do not have to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> before sending and receiving data.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll wie UDP verwenden, müssen Sie nicht aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> vor dem Senden und Empfangen von Daten.</target>       </trans-unit>
        <trans-unit id="1343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> to communicate with a remote host.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> für die Kommunikation mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, any datagrams that arrive from an address other than the specified default will be discarded.</source>
          <target state="translated">Wenn Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen, werden verworfen.</target>       </trans-unit>
        <trans-unit id="1345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to change the default remote host, call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method again with the desired endpoint.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode erneut mit den gewünschten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you wish to set the default remote host to a broadcast address, you must first call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> and set Broadcast to <ph id="ph2">`true`</ph>.</source>
          <target state="translated">Wenn Sie die Standard-Remotehost an eine Broadcastadresse festlegen möchten, müssen Sie zuerst eine Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> und legen Sie die Übertragung auf <ph id="ph2">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If this is not done, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies nicht erfolgt, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich:</target>       </trans-unit>
        <trans-unit id="1349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Optionally, a buffer may be provided which will atomically be sent on the socket after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method succeeds.</source>
          <target state="translated">Optional ein Puffer kann angegeben werden die auf den Socket atomar gesendet werden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="1350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the buffer containing the data to send and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> property needs to be set to the number of bytes of data to send from the buffer.</source>
          <target state="translated">In diesem Fall die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss in den Puffer mit den Daten festgelegt werden, um zu senden und die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden.</target>       </trans-unit>
        <trans-unit id="1351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Once a connection is established, this buffer of data is sent.</source>
          <target state="translated">Sobald eine Verbindung hergestellt ist, wird dieser Puffer von Daten gesendet.</target>       </trans-unit>
        <trans-unit id="1352" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol and do not call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll und Sie nicht rufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.</target>       </trans-unit>
        <trans-unit id="1353" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, der Service Provider nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl erst nach dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="1354" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method throws <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> if the address family of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and the <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> are not the same address family.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> -Methode löst <ph id="ph2">&lt;xref:System.NotSupportedException&gt;</ph> Wenn die Adressfamilie von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und <ph id="ph4">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> sind nicht die gleiche Adressfamilie.</target>       </trans-unit>
        <trans-unit id="1355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling this method, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> verwenden Sie beim Aufrufen dieser Methode die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument is not valid.</source>
          <target state="translated">Ein Argument ist ungültig.</target>       </trans-unit>
        <trans-unit id="1358" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception occurs if multiple buffers are specified, the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> property is not null.</source>
          <target state="translated">Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph>-Eigenschaft nicht NULL ist.</target>       </trans-unit>
        <trans-unit id="1359" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null and the <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="e" /&gt;</ph>-Parameter kann nicht NULL und der <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> kann nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="1360" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is listening or a socket operation was already in progress using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="1361" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1362" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="1363" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the local endpoint and the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> are not the same address family.</source>
          <target state="translated">Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> nicht die gleiche Adressfamilie aufweisen.</target>       </trans-unit>
        <trans-unit id="1364" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A caller higher in the call stack does not have permission for the requested operation.</source>
          <target state="translated">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</target>       </trans-unit>
        <trans-unit id="1366" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Connected">
          <source>Gets a value that indicates whether a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is connected to a remote host as of the last <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> or <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> operation.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> mit dem Remotehost des letzten <ph id="ph2">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph>-Vorgangs oder <ph id="ph3">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph>-Vorgangs verbunden ist.</target>       </trans-unit>
        <trans-unit id="1367" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> was connected to a remote resource as of the most recent operation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> beim letzten Vorgang mit einer Remoteressource verbunden war, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1368" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The <ph id="ph1">`Connected`</ph> property gets the connection state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> as of the last I/O operation.</source>
          <target state="translated">Die <ph id="ph1">`Connected`</ph> Eigenschaft ruft den Verbindungsstatus des der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zum Zeitpunkt der letzten e/a-Vorgang.</target>       </trans-unit>
        <trans-unit id="1369" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>When it returns <ph id="ph1">`false`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was either never connected, or is no longer connected.</source>
          <target state="translated">Bei der Rückgabe <ph id="ph1">`false`</ph>der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wurde entweder nie verbunden, oder ist nicht mehr verbunden.</target>       </trans-unit>
        <trans-unit id="1370" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The value of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property reflects the state of the connection as of the most recent operation.</source>
          <target state="translated">Der Wert, der die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> Eigenschaft gibt den Status der Verbindung zum Zeitpunkt des letzten Vorgangs wieder.</target>       </trans-unit>
        <trans-unit id="1371" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</source>
          <target state="translated">Wenn Sie den aktuellen Zustand der Verbindung bestimmen müssen, stellen Sie einen nicht blockierenden, 0 Byte senden, aufrufen.</target>       </trans-unit>
        <trans-unit id="1372" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</source>
          <target state="translated">Wenn der Aufruf erfolgreich zurückgegeben oder einen Fehlercode WAEWOULDBLOCK (10035 aufgeführt löst), wird der Socket noch verbunden. Andernfalls wird der Socket nicht mehr verbunden.</target>       </trans-unit>
        <trans-unit id="1373" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>If you call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> on a User Datagram Protocol (UDP) socket, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property always returns <ph id="ph3">`true`</ph>; however, this action does not change the inherent connectionless nature of UDP.</source>
          <target state="translated">Beim Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> für ein Socket User Datagram Protocol (UDP) der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> -Eigenschaft gibt immer <ph id="ph3">`true`</ph>, aber diese Aktion ändert sich nicht auf den inhärenten verbindungslosen Charakter UDP.</target>       </trans-unit>
        <trans-unit id="1374" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Connected">
          <source>The following code example connects to a remote endpoint, checks the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property, and checks the current state of the connection.</source>
          <target state="translated">Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt, überprüft der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> -Eigenschaft, und überprüft den aktuellen Zustand der Verbindung.</target>       </trans-unit>
        <trans-unit id="1375" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if this socket can be reused after the current connection is closed; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn dieser Socket wiederverwendet werden kann, nachdem die aktuelle Verbindung geschlossen wurde, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1376" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>Closes the socket connection and allows reuse of the socket.</source>
          <target state="translated">Schließt die Socketverbindung und ermöglicht die Wiederverwendung des Sockets.</target>       </trans-unit>
        <trans-unit id="1377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you are using a connection-oriented protocol, you can use this method to close the socket.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie diese Methode, um den Socket schließen.</target>       </trans-unit>
        <trans-unit id="1378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method ends the connection and sets the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property to <ph id="ph2">`false`</ph>.</source>
          <target state="translated">Diese Methode beendet die Verbindung und stellt die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> Eigenschaft <ph id="ph2">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>However, if <ph id="ph1">`reuseSocket`</ph> is <ph id="ph2">`true`</ph>, you can reuse the socket.</source>
          <target state="translated">Jedoch wenn <ph id="ph1">`reuseSocket`</ph> ist <ph id="ph2">`true`</ph>, können Sie den Socket wiederverwenden.</target>       </trans-unit>
        <trans-unit id="1380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>To ensure that all data is sent and received before the socket is closed, you should call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> method.</source>
          <target state="translated">Um sicherzustellen, dass alle Daten gesendet und empfangen, bevor der Socket geschlossen ist, rufen Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> vor dem Aufruf der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you need to call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> without first calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, you can set the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option to <ph id="ph5">`false`</ph> and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</source>
          <target state="translated">Wenn Sie aufrufen müssen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> erst nach Aufrufen von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, können Sie festlegen, die <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option <ph id="ph5">`false`</ph> , und geben Sie einen Wert ungleich NULL Timeoutintervall um sicherzustellen, dass die Daten in der Warteschlange für ausgehende Übertragung gesendet wird.</target>       </trans-unit>
        <trans-unit id="1382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> then blocks until the data is sent or until the specified time-out expires.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph> Klicken Sie dann blockiert, bis die Daten gesendet werden oder das angegebene Timeout abläuft.</target>       </trans-unit>
        <trans-unit id="1383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> to <ph id="ph2">`false`</ph> and specify a zero time-out interval, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> releases the connection and automatically discards outgoing queued data.</source>
          <target state="translated">Wenn Sie festlegen, <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.DontLinger&gt;</ph> auf <ph id="ph2">`false`</ph> , und geben Sie ein Timeoutintervall NULL <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> gibt die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.</target>       </trans-unit>
        <trans-unit id="1384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The following code example creates a socket for synchronous communication and sends some data to a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket für die synchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>It then calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>, to stop the send and receive activity, and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, to close the socket connection.</source>
          <target state="translated">Er ruft dann <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph>beenden Senden und empfangen-Aktivität, und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Disconnect%2A&gt;</ph>, um die Socketverbindung zu schließen.</target>       </trans-unit>
        <trans-unit id="1390" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>This method requires Windows 2000 or earlier, or the exception will be thrown.</source>
          <target state="translated">Für diese Methode wird Windows 2000 oder früher benötigt, andernfalls wird eine Ausnahme ausgelöst.</target>       </trans-unit>
        <trans-unit id="1391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="1394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to disconnect from a remote endpoint.</source>
          <target state="translated">Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</target>       </trans-unit>
        <trans-unit id="1395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="1396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="1397" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="1398" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="1399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> method requests a disconnect from a remote endpoint.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden zu können, Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DisconnectAsync%2A&gt;</ph> -Methode fordert eine Trennung der Verbindung mit einem Remoteendpunkt.</target>       </trans-unit>
        <trans-unit id="1400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you set <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> to <ph id="ph2">`true`</ph> in the <ph id="ph3">`e`</ph> parameter, the socket can be reused.</source>
          <target state="translated">Wenn Sie festlegen, <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType&gt;</ph> auf <ph id="ph2">`true`</ph> in der <ph id="ph3">`e`</ph> -Parameter, der Socket wiederverwendet werden kann.</target>       </trans-unit>
        <trans-unit id="1401" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;paramref name="e" /&gt;</ph> parameter cannot be null.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="e" /&gt;</ph>-Parameter darf nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="1402" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="1403" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="1404" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1406" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Gibt alle von der aktuellen Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse verwendeten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="1407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Releases all resources used by the current instance of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Gibt alle von der aktuellen Instanz der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse verwendeten Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="1408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Call <ph id="ph1">`Dispose`</ph> when you are finished using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Rufen Sie <ph id="ph1">`Dispose`</ph> auf, wenn Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> nicht mehr benötigen.</target>       </trans-unit>
        <trans-unit id="1409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>The <ph id="ph1">`Dispose`</ph> method leaves the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in an unusable state.</source>
          <target state="translated">Die <ph id="ph1">`Dispose`</ph>-Methode bewirkt, dass <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> nicht mehr verwendet werden kann.</target>       </trans-unit>
        <trans-unit id="1410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>After calling <ph id="ph1">`Dispose`</ph>, you must release all references to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> so the garbage collector can reclaim the memory that the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> was occupying.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">`Dispose`</ph>, müssen Sie alle Verweise auf Freigeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> belegt wurde.</target>       </trans-unit>
        <trans-unit id="1411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>For more information, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Implementing a Dispose Method<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Bereinigen von nicht verwalteten Ressourcen<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> und <bpt id="p2">[</bpt>Implementieren einer Dispose-Methode<ept id="p2">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Always call <ph id="ph1">`Dispose`</ph> before you release your last reference to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Rufen Sie immer <ph id="ph1">`Dispose`</ph> auf, bevor Sie den letzten Verweis auf das <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> freigeben.</target>       </trans-unit>
        <trans-unit id="1413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose">
          <source>Otherwise, the resources it is using will not be freed until the garbage collector calls the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> object's <ph id="ph2">`Finalize`</ph> method.</source>
          <target state="translated">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>-Methode des <ph id="ph2">`Finalize`</ph>-Objekts aufruft.</target>       </trans-unit>
        <trans-unit id="1414" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> to release both managed and unmanaged resources; <ph id="ph2">&lt;see langword="false" /&gt;</ph> to releases only unmanaged resources.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <ph id="ph2">&lt;see langword="false" /&gt;</ph>, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</target>       </trans-unit>
        <trans-unit id="1415" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>Releases the unmanaged resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, and optionally disposes of the managed resources.</source>
          <target state="translated">Gibt die vom <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</target>       </trans-unit>
        <trans-unit id="1416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method is called by the public <ph id="ph1">`Dispose()`</ph> method and the <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> method.</source>
          <target state="translated">Diese Methode wird aufgerufen, der öffentlich <ph id="ph1">`Dispose()`</ph> Methode und die <ph id="ph2">&lt;xref:System.Object.Finalize%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">`Dispose()`</ph> invokes the protected <ph id="ph2">`Dispose(Boolean)`</ph> method with the <ph id="ph3">`disposing`</ph> parameter set to <ph id="ph4">`true`</ph>.</source>
          <target state="translated"><ph id="ph1">`Dispose()`</ph> Ruft die geschützte <ph id="ph2">`Dispose(Boolean)`</ph> Methode mit dem <ph id="ph3">`disposing`</ph> Parametersatz auf <ph id="ph4">`true`</ph>.</target>       </trans-unit>
        <trans-unit id="1418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> invokes <ph id="ph2">`Dispose`</ph> with <ph id="ph3">`disposing`</ph> set to <ph id="ph4">`false`</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Object.Finalize%2A&gt;</ph> Ruft <ph id="ph2">`Dispose`</ph> mit <ph id="ph3">`disposing`</ph> festgelegt <ph id="ph4">`false`</ph>.</target>       </trans-unit>
        <trans-unit id="1419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When the <ph id="ph1">`disposing`</ph> parameter is <ph id="ph2">`true`</ph>, this method releases all resources held by any managed objects that this <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> references.</source>
          <target state="translated">Wenn der <ph id="ph1">`disposing`</ph>-Parameter <ph id="ph2">`true`</ph> ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> verweist.</target>       </trans-unit>
        <trans-unit id="1420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This method invokes the <ph id="ph1">`Dispose()`</ph> method of each referenced object.</source>
          <target state="translated">Diese Methode ruft die <ph id="ph1">`Dispose()`</ph>-Methode aller Objekte auf, auf die verwiesen wird.</target>       </trans-unit>
        <trans-unit id="1421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> can be called multiple times by other objects.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> kann von anderen Objekten mehrmals aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="1424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>When overriding <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, be careful not to reference objects that have been previously disposed of in an earlier call to <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph>.</source>
          <target state="translated">Beim Überschreiben von <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <ph id="ph2">&lt;see langword="Dispose" /&gt;</ph> freigegeben wurden.</target>       </trans-unit>
        <trans-unit id="1425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about how to implement <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, see <bpt id="p1">[</bpt>Implementing a Dispose Method<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</source>
          <target state="translated">Weitere Informationen zum Implementieren <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Implementieren einer Dispose-Methode<ept id="p1">](~/docs/standard/garbage-collection/implementing-dispose.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Dispose(System.Boolean)">
          <source>For more information about <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> and <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, see <bpt id="p1">[</bpt>Cleaning Up Unmanaged Resources<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> and <bpt id="p2">[</bpt>Overriding the Finalize Method<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</source>
          <target state="translated">Weitere Informationen zu <ph id="ph1">&lt;see langword="Dispose" /&gt;</ph> und <ph id="ph2">&lt;see cref="M:System.Object.Finalize" /&gt;</ph>, finden Sie unter <bpt id="p1">[</bpt>Bereinigen von nicht verwalteten Ressourcen<ept id="p1">](~/docs/standard/garbage-collection/unmanaged.md)</ept> und <bpt id="p2">[</bpt>Überschreiben der Finalize-Methode<ept id="p2">](http://msdn.microsoft.com/library/8026cb68-fe93-43fc-96c1-c09ad7d64cd3)</ept>.</target>       </trans-unit>
        <trans-unit id="1427" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows Internet Protocol (IP) datagrams to be fragmented.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert ab, der angibt, ob der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> die Fragmentierung von IP (Internet Protocol)-Datagrammen zulässt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1428" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows datagram fragmentation; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> die Datagrammfragmentierung zulässt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1429" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1430" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</source>
          <target state="translated">Datagramme erfordern eine Fragmentierung, wenn ihre Größe das Maximum Transfer Unit (MTU) des Übertragungsmediums übersteigt.</target>       </trans-unit>
        <trans-unit id="1431" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</source>
          <target state="translated">Datagramme können vom sendenden Host (alle Versionen für Internet Protocol) oder einen zwischengeschalteten Router (nur Internet Protocol Version 4) fragmentiert.</target>       </trans-unit>
        <trans-unit id="1432" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>If a datagram must be fragmented, and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</source>
          <target state="translated">Wenn ein Datagramm fragmentiert werden muss, und die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> Option festgelegt ist, das Datagramm verworfen und Internet Control Message Protocol (ICMP) folgende Fehlermeldung zurück an den Absender der das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="1433" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.</target>       </trans-unit>
        <trans-unit id="1434" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DontFragment%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1435" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Eigenschaft kann nur für Sockets in der <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>-Familie oder der <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>-Familie festgelegt werden.</target>       </trans-unit>
        <trans-unit id="1436" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1437" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DontFragment">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1438" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a dual-mode socket used for both IPv4 and IPv6.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert ab, der angibt, ob der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ein für IPv4 und IPv6 verwendeter Dualmodussocket ist, oder legt ihn fest.</target>       </trans-unit>
        <trans-unit id="1439" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is a  dual-mode socket; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ein Dualmodussocket ist; andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1440" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.DualMode">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1441" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The ID of the target process where a duplicate of the socket reference is created.</source>
          <target state="translated">Die ID des Zielprozesses, in dem ein Duplikat des Socketverweises erstellt wird.</target>       </trans-unit>
        <trans-unit id="1442" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplicates the socket reference for the target process, and closes the socket for this process.</source>
          <target state="translated">Dupliziert den Socketverweis für den Zielprozess und schließt den Socket für diesen Prozess.</target>       </trans-unit>
        <trans-unit id="1443" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The socket reference to be passed to the target process.</source>
          <target state="translated">Der Socketverweis, der an den Zielprozess übergeben werden soll.</target>       </trans-unit>
        <trans-unit id="1444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>The target process should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> to create the duplicate socket instance.</source>
          <target state="translated">Der Zielprozess die zu verwendende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> auf die doppelte Socketinstanz zu erstellen.</target>       </trans-unit>
        <trans-unit id="1445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If you call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances with the same underlying socket.</source>
          <target state="translated">Beim Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanzen mit dem gleichen zugrunde liegenden Socket.</target>       </trans-unit>
        <trans-unit id="1446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>This practice is strongly discouraged.</source>
          <target state="translated">Dieses Vorgehen wird dringend abgeraten.</target>       </trans-unit>
        <trans-unit id="1447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>If the process creating the socket uses asynchronous methods (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), the process must first set the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> to be thrown on the target process.</source>
          <target state="translated">Wenn der Prozess zum Erstellen des Sockets asynchrone Methoden verwendet (<ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>), muss zunächst Festlegen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A&gt;</ph> Eigenschaft auf "true" ist, andernfalls wird der Socket an den Abschlussport des erstellen-Prozesses, was eine bewirkenkanngebunden<ph id="ph4">&lt;xref:System.ArgumentNullException&gt;</ph> auf den Zielprozess ausgelöst werden.</target>       </trans-unit>
        <trans-unit id="1448" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> is not a valid process id.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="targetProcessID" /&gt;</ph> ist keine gültige Prozess-ID.</target>       </trans-unit>
        <trans-unit id="1449" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1450" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)">
          <source>Duplication of the socket reference failed.</source>
          <target state="translated">Die Duplizierung des Socketverweises ist fehlgeschlagen.</target>       </trans-unit>
        <trans-unit id="1451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> can send or receive broadcast packets.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert ab, der angibt, ob der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> Broadcastpakete senden oder empfangen kann, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows broadcast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> Broadcastpakete zulässt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</source>
          <target state="translated">Übertragung muss auf ein bestimmtes Subnetz beschränkt, und User Datagram-Protokolls (UDP). Internetprotokoll Version 4 können Sie Ihrem lokalen Subnetz durch Senden eines Pakets 255.255.255.255 übertragen. oder Sie können die gesteuerte Broadcastadresse, die der Netzwerkteil einer Adresse Internetprotokoll (IP), mit der alle Bits in den Hostteil festgelegt ist.</target>       </trans-unit>
        <trans-unit id="1455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</source>
          <target state="translated">Angenommen, Ihre IP-Adresse 192.168.1.40 ist (eine Adresse der Klasse C mit einer 255.255.255.0--der Netzwerkteil gibt die ersten drei Oktette und der Hostteil ist das letzte Oktett), die gesteuerte Broadcastadresse ist 192.168.1.255.</target>       </trans-unit>
        <trans-unit id="1456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.</target>       </trans-unit>
        <trans-unit id="1457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EnableBroadcast%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1458" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>This option is valid for a datagram socket only.</source>
          <target state="translated">Diese Option ist nur für Datagrammsockets gültig.</target>       </trans-unit>
        <trans-unit id="1459" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.EnableBroadcast">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1460" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Asynchronously accepts an incoming connection attempt.</source>
          <target state="translated">Nimmt einen eingehenden Verbindungsversuch asynchron an.</target>       </trans-unit>
        <trans-unit id="1461" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die übertragenen Bytes enthält.</target>       </trans-unit>
        <trans-unit id="1462" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</target>       </trans-unit>
        <trans-unit id="1463" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt zum Behandeln der Remotehostkommunikation.</target>       </trans-unit>
        <trans-unit id="1464" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data transferred.</source>
          <target state="translated">Diese Methode gibt einen Puffer zurück, der die ersten übertragenen Daten enthält.</target>       </trans-unit>
        <trans-unit id="1465" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1466" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Schließt einen Aufruf von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1467" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, indem Sie die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1468" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode zurückkehrt.</target>       </trans-unit>
        <trans-unit id="1469" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">In der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">`asyncResult`</ph> Parameter zum Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf der der Verbindungsversuch erfolgt.</target>       </trans-unit>
        <trans-unit id="1470" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode den Verbindungsversuch erfolgreich abgeschlossen.</target>       </trans-unit>
        <trans-unit id="1471" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">Die <ph id="ph1">`buffer`</ph> Parameter dieser Überladung enthält Daten, die im Aufruf empfangen wurde <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> und <ph id="ph3">`bytesTransferred`</ph> Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.</target>       </trans-unit>
        <trans-unit id="1472" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen.</target>       </trans-unit>
        <trans-unit id="1473" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.</target>       </trans-unit>
        <trans-unit id="1474" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1475" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1476" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1477" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1478" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> zum Erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten.</target>       </trans-unit>
        <trans-unit id="1479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> , die asynchrone Anforderung zu beenden.</target>       </trans-unit>
        <trans-unit id="1480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der <ph id="ph1">`buffer`</ph> und <ph id="ph2">`bytesTransferred`</ph> Parameter dieser Methode und in der Konsole angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="1482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="1484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="1485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph>-Methode wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="1486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph></source>
          <target state="translated">Fehler beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle remote host communication.</source>
          <target state="translated">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> zum Behandeln der Remotehostkommunikation.</target>       </trans-unit>
        <trans-unit id="1488" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> to handle communication with the remote host.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> zum Behandeln der Kommunikation mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Schließt einen Aufruf von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode zurückkehrt.</target>       </trans-unit>
        <trans-unit id="1492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Es zustimmen der <ph id="ph1">`asyncResult`</ph> Parameter zurückgegeben, aus der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">In der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">`asyncResult`</ph> Parameter zum Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf der der Verbindungsversuch erfolgt.</target>       </trans-unit>
        <trans-unit id="1494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode den Verbindungsversuch erfolgreich abgeschlossen.</target>       </trans-unit>
        <trans-unit id="1495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen.</target>       </trans-unit>
        <trans-unit id="1496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.</target>       </trans-unit>
        <trans-unit id="1497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The following code example ends an asynchronous request and creates a new <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to accept an incoming connection request.</source>
          <target state="translated">Im folgenden Codebeispiel wird beendet eine asynchrone Anforderung und erstellt einen neuen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> eine eingehende verbindungsanforderung zu akzeptieren.</target>       </trans-unit>
        <trans-unit id="1502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter <bpt id="p1">[</bpt>Socket-Codebeispiele<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1503" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1504" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="1505" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1506" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>See the Remarks section for more information.</source>
          <target state="translated">Weitere Informationen finden Sie im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="1507" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1508" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph>-Methode wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="1509" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="1510" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the bytes transferred.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die übertragenen Bytes enthält.</target>       </trans-unit>
        <trans-unit id="1511" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transferred.</source>
          <target state="translated">Die Anzahl der übertragenen Bytes.</target>       </trans-unit>
        <trans-unit id="1512" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation as well as any user defined data.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</target>       </trans-unit>
        <trans-unit id="1513" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Asynchronously accepts an incoming connection attempt and creates a new <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle remote host communication.</source>
          <target state="translated">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt zum Behandeln der Remotehostkommunikation.</target>       </trans-unit>
        <trans-unit id="1514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This method returns a buffer that contains the initial data and the number of bytes transferred.</source>
          <target state="translated">Diese Methode gibt einen Puffer zurück, der die ersten Daten und die Anzahl der übertragenen Bytes enthält.</target>       </trans-unit>
        <trans-unit id="1515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object to handle communication with the remote host.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1516" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Schließt einen Aufruf von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1517" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, you need to create a callback method that is invoked by the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, indem Sie die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1518" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This callback method executes in a separate thread, and is called by the system after the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method returns.</source>
          <target state="translated">Diese Rückrufmethode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> -Methode zurückkehrt.</target>       </trans-unit>
        <trans-unit id="1519" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>It must accept the <ph id="ph1">`asyncResult`</ph> parameter returned from the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> method.</source>
          <target state="translated">Es zustimmen der <ph id="ph1">`asyncResult`</ph> Parameter zurückgegeben, aus der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1520" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">`asyncResult`</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">In der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">`asyncResult`</ph> Parameter zum Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf der der Verbindungsversuch erfolgt.</target>       </trans-unit>
        <trans-unit id="1521" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode den Verbindungsversuch erfolgreich abgeschlossen.</target>       </trans-unit>
        <trans-unit id="1522" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">`buffer`</ph> parameter of this overload contains the data that was received in the call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> and the <ph id="ph3">`bytesTransferred`</ph> parameter contains the number of bytes that were transferred in the call.</source>
          <target state="translated">Die <ph id="ph1">`buffer`</ph> Parameter dieser Überladung enthält Daten, die im Aufruf empfangen wurde <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> und <ph id="ph3">`bytesTransferred`</ph> Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.</target>       </trans-unit>
        <trans-unit id="1523" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method blocks until a connection is pending in the incoming connection queue.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode blockiert, bis eine Verbindung ausstehend ist in der Warteschlange für eingehende Verbindungen.</target>       </trans-unit>
        <trans-unit id="1524" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> method accepts the incoming connection and returns a new <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> that can be used to send data to and receive data from the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> Methode akzeptiert die eingehende Verbindung, und gibt eine neue <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> , die verwendet werden kann, um Daten zu senden und Empfangen von Daten vom Remotehost aus.</target>       </trans-unit>
        <trans-unit id="1525" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1526" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1527" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1528" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1529" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to create and connect a socket and accept the initial 10 bytes of data.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> zum Erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten.</target>       </trans-unit>
        <trans-unit id="1530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndAccept%2A&gt;</ph> , die asynchrone Anforderung zu beenden.</target>       </trans-unit>
        <trans-unit id="1531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The number of bytes transmitted and the data are returned in the <ph id="ph1">`buffer`</ph> and <ph id="ph2">`bytesTransferred`</ph> parameters of this method and are displayed on the console.</source>
          <target state="translated">Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der <ph id="ph1">`buffer`</ph> und <ph id="ph2">`bytesTransferred`</ph> Parameter dieser Methode und in der Konsole angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="1533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="1535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not created by a call to <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf von <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /&gt;</ph> erstellt.</target>       </trans-unit>
        <trans-unit id="1536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph> method was previously called.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /&gt;</ph>-Methode wurde bereits zuvor aufgerufen.</target>       </trans-unit>
        <trans-unit id="1537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Fehler beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1538" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous connection request.</source>
          <target state="translated">Beendet eine ausstehende asynchrone Verbindungsanforderung.</target>       </trans-unit>
        <trans-unit id="1539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> is a blocking method that completes the asynchronous remote host connection request started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> ist eine blockierende Methode, die die verbindungsanforderung asynchrone Remotehost abgeschlossen wird gestartet wurde, der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> on which the connection attempt is being made.</source>
          <target state="translated">In der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Parameter zum Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> auf der der Verbindungsversuch erfolgt.</target>       </trans-unit>
        <trans-unit id="1544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> method to successfully complete the connection attempt.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndConnect%2A&gt;</ph> Methode den Verbindungsversuch erfolgreich abgeschlossen.</target>       </trans-unit>
        <trans-unit id="1545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The following code example ends the asynchronous connection attempt.</source>
          <target state="translated">Im folgenden Codebeispiel wird der asynchronen Verbindungsversuch beendet.</target>       </trans-unit>
        <trans-unit id="1550" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter <bpt id="p1">[</bpt>Socket-Codebeispiele<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /&gt;</ph> wurde bereits für die asynchrone Verbindung aufgerufen.</target>       </trans-unit>
        <trans-unit id="1554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information and any user-defined data for this asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</target>       </trans-unit>
        <trans-unit id="1557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Ends a pending asynchronous disconnect request.</source>
          <target state="translated">Beendet eine ausstehende asynchrone Anforderung zur Trennung der Verbindung.</target>       </trans-unit>
        <trans-unit id="1558" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> completes a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> Schließt einen Aufruf von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1559" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> method blocks until the disconnect completes.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> Methode blockiert, bis der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1560" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</source>
          <target state="translated">Informationen zu asynchronen Vorgängen finden Sie unter der asynchronen Programmierung Übersichtsthema in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1561" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1562" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The following code example creates a socket for asynchronous communication and sends some data to a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet einige Daten mit einem Remotehost.</target>       </trans-unit>
        <trans-unit id="1566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the data has been sent, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> is called to stop the send and receive activity.</source>
          <target state="translated">Wenn die Daten gesendet wurden, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> wird aufgerufen, um das Beenden der Send und receive-Aktivität.</target>       </trans-unit>
        <trans-unit id="1567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>Then <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> is called to begin a disconnect request.</source>
          <target state="translated">Klicken Sie dann <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginDisconnect%2A&gt;</ph> wird aufgerufen, um eine Anforderung zum Trennen der beginnen.</target>       </trans-unit>
        <trans-unit id="1568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> to end the asynchronous request.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndDisconnect%2A&gt;</ph> , die asynchrone Anforderung zu beenden.</target>       </trans-unit>
        <trans-unit id="1569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>When the request completes, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> property is queried to test whether the socket is disconnected.</source>
          <target state="translated">Klicken Sie nach Abschluss die Anforderung der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connected%2A&gt;</ph> Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.</target>       </trans-unit>
        <trans-unit id="1570" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</target>       </trans-unit>
        <trans-unit id="1571" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1572" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1573" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1574" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous connection.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /&gt;</ph> wurde bereits für die asynchrone Verbindung aufgerufen.</target>       </trans-unit>
        <trans-unit id="1575" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1576" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)">
          <source>The disconnect request has timed out.</source>
          <target state="translated">Das Timeout der Anforderung zum Trennen der Verbindung wurde überschritten.</target>       </trans-unit>
        <trans-unit id="1577" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Lesevorgang.</target>       </trans-unit>
        <trans-unit id="1578" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Lesevorgang.</target>       </trans-unit>
        <trans-unit id="1579" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="1580" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode schließt den asynchronen Lesevorgang gestartet werden, der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1581" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1582" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1583" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1584" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> übergebene, um das Zustandsobjekt, das Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1585" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrahieren Sie den Empfang <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aus dieses Zustandsobjekt.</target>       </trans-unit>
        <trans-unit id="1586" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1587" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="1588" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar.</target>       </trans-unit>
        <trans-unit id="1589" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der <ph id="ph2">`size`</ph> Parameter von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1590" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1591" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Aufrufen, um die empfangenen Daten zu erhalten, die <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.</target>       </trans-unit>
        <trans-unit id="1592" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>To cancel a pending <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method.</source>
          <target state="translated">Auf "Abbrechen" eine ausstehende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1593" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1594" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1595" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="1596" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1597" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1598" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous read.</source>
          <target state="translated">Im folgenden Codebeispiel wird einen ausstehenden asynchronen Lesevorgang beendet.</target>       </trans-unit>
        <trans-unit id="1600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>For a complete example that demonstrates asynchronous communications with sockets, see <bpt id="p1">[</bpt>Socket Code Examples<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</source>
          <target state="translated">Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter <bpt id="p1">[</bpt>Socket-Codebeispiele<ept id="p1">](~/docs/framework/network-programming/socket-code-examples.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> wurde bereits für den asynchronen Lesevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</target>       </trans-unit>
        <trans-unit id="1607" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="1608" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous read.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Lesevorgang.</target>       </trans-unit>
        <trans-unit id="1609" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="1610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode schließt den asynchronen Lesevorgang gestartet werden, der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> übergebene, um das Zustandsobjekt, das Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrahieren Sie den Empfang <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aus dieses Zustandsobjekt.</target>       </trans-unit>
        <trans-unit id="1616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="1618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar.</target>       </trans-unit>
        <trans-unit id="1619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der <ph id="ph2">`size`</ph> Parameter von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Aufrufen, um die empfangenen Daten zu erhalten, die <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph>, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.</target>       </trans-unit>
        <trans-unit id="1622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1623" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1624" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="1625" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1626" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1627" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1628" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1629" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1630" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /&gt;</ph> wurde bereits für den asynchronen Lesevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1631" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1632" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1633" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1634" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">Wenn erfolgreich, die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="1635" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1636" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method completes the asynchronous read operation started in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode schließt den asynchronen Lesevorgang gestartet werden, der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1637" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1638" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1639" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1640" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> to obtain the state object passed to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> übergebene, um das Zustandsobjekt, das Abrufen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1641" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Extract the receiving <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> from this state object.</source>
          <target state="translated">Extrahieren Sie den Empfang <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> aus dieses Zustandsobjekt.</target>       </trans-unit>
        <trans-unit id="1642" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method to successfully complete the read operation and return the number of bytes read.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode für die erfolgreiche den Lesevorgang abgeschlossen und die Anzahl der gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1643" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="1644" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> will read the first enqueued datagram available in the incoming network buffer.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> liest das erste Datagramm im eingehenden Netzwerkpuffer verfügbar.</target>       </trans-unit>
        <trans-unit id="1645" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will read as much data as is available up to the number of bytes you specified in the <ph id="ph2">`size`</ph> parameter of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode wird bis zur Anzahl von Bytes verfügbar ist, in angegebenen, Daten Lesen der <ph id="ph2">`size`</ph> Parameter von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1646" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.EndReceiveFrom%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1647" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To obtain the received data, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> object, and extract the buffer contained in the resulting state object.</source>
          <target state="translated">Aufrufen, um die empfangenen Daten zu erhalten, die <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Objekt, und extrahieren Sie den im resultierenden Zustandsobjekt enthaltenen Puffer.</target>       </trans-unit>
        <trans-unit id="1648" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>To identify the originating host, extract the <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> and cast it to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</source>
          <target state="translated">Um den Ausgangshost zu identifizieren, extrahieren Sie die <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> und wandeln Sie sie in einer <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1649" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to obtain the IP address and the <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to obtain the port number.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> Methode, um die IP-Adresse abzurufen und die <ph id="ph2">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Portnummer abzurufen.</target>       </trans-unit>
        <trans-unit id="1650" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1651" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1652" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1653" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1654" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The following code example ends a pending asynchronous read from a specific <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> wurde bereits für den asynchronen Lesevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1658" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1659" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1660" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information and any user defined data for this asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</target>       </trans-unit>
        <trans-unit id="1661" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values for the received packet.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte für das empfangene Paket.</target>       </trans-unit>
        <trans-unit id="1662" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The source <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</source>
          <target state="translated">Der Quell-<ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1663" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> and interface of the received packet.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Net.IPAddress" /&gt;</ph> und die Schnittstelle des empfangenen Pakets.</target>       </trans-unit>
        <trans-unit id="1664" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Ends a pending asynchronous read from a specific endpoint.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</target>       </trans-unit>
        <trans-unit id="1665" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method also reveals more information about the packet than <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph>.</source>
          <target state="translated">Diese Methode stellt außerdem mehr Informationen über das Paket als <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /&gt;</ph> bereit.</target>       </trans-unit>
        <trans-unit id="1666" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If successful, the number of bytes received.</source>
          <target state="translated">Wenn erfolgreich, die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="1667" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If unsuccessful, returns 0.</source>
          <target state="translated">Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If the operation has not completed, this method blocks until it does.</source>
          <target state="translated">Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.</target>       </trans-unit>
        <trans-unit id="1669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To perform this operation synchronously, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Um diesen Vorgang synchron auszuführen, verwenden Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Examine <ph id="ph1">`ipPacketInformation`</ph> if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Untersuchen Sie <ph id="ph1">`ipPacketInformation`</ph> Wenn müssen Sie wissen, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.</target>       </trans-unit>
        <trans-unit id="1671" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist gleich <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1672" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1673" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="endPoint" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1674" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1675" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> was previously called for the asynchronous read.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /&gt;</ph> wurde bereits für den asynchronen Lesevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1676" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1677" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1678" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Sendevorgang.</target>       </trans-unit>
        <trans-unit id="1679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Sendevorgang.</target>       </trans-unit>
        <trans-unit id="1680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Wenn erfolgreich, die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1681" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Schließt den asynchronen Sendevorgang in gestartet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1682" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1683" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1684" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1685" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Parameter zum Abrufen der Versand <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1686" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1687" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="1688" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> blockiert, bis einige des Puffers gesendet wurde.</target>       </trans-unit>
        <trans-unit id="1689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Wenn der Rückgabewert von <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erneut, den Puffer zum Speichern von nicht gesendeten Daten zu ändern.</target>       </trans-unit>
        <trans-unit id="1690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="1692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="1693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="1696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="1698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="1699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The following code example ends a pending asynchronous send.</source>
          <target state="translated">Im folgenden Codebeispiel wird einen ausstehenden asynchronen Sendevorgang beendet.</target>       </trans-unit>
        <trans-unit id="1702" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1703" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1704" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> wurde bereits für den asynchronen Sendevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1705" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1706" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1707" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> that stores state information for this asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>, das Zustandsinformation für den asynchronen Vorgang speichert.</target>       </trans-unit>
        <trans-unit id="1708" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="1709" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Ends a pending asynchronous send.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Sendevorgang.</target>       </trans-unit>
        <trans-unit id="1710" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If successful, the number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>; otherwise, an invalid <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Wenn erfolgreich, die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Schließt den asynchronen Sendevorgang in gestartet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1713" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1714" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1715" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Parameter zum Abrufen der Versand <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1716" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1717" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="1718" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> will block until some of the buffer was sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> blockiert, bis einige des Puffers gesendet wurde.</target>       </trans-unit>
        <trans-unit id="1719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If the return value from <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> indicates that the buffer was not completely sent, call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method again, modifying the buffer to hold the unsent data.</source>
          <target state="translated">Wenn der Rückgabewert von <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSend%2A&gt;</ph> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> -Methode erneut, den Puffer zum Speichern von nicht gesendeten Daten zu ändern.</target>       </trans-unit>
        <trans-unit id="1720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="1722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="1723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>All I/O initiated by a given thread is canceled when that thread exits.</source>
          <target state="translated">Alle e/as, die durch einen bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads.</target>       </trans-unit>
        <trans-unit id="1726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>A pending asynchronous operation can fail if the thread exits before the operation completes.</source>
          <target state="translated">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</target>       </trans-unit>
        <trans-unit id="1727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="1728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="1729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1731" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1732" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1733" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /&gt;</ph> wurde bereits für den asynchronen Sendevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1734" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1735" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1736" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph> object that stores state information for this asynchronous operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IAsyncResult" /&gt;</ph>-Objekt, das Zustandsinformation für den asynchronen Vorgang speichert.</target>       </trans-unit>
        <trans-unit id="1737" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Ends a pending asynchronous send of a file.</source>
          <target state="translated">Beendet ein ausstehendes asynchrones Senden einer Datei.</target>       </trans-unit>
        <trans-unit id="1738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> Schließt den asynchronen Sendevorgang in gestartet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, you must create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph>, müssen Sie eine Rückrufmethode, die implementiert erstellen die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1740" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1741" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> object returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes Objekt die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1742" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Parameter zum Abrufen der Versand <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1743" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> method to successfully complete the send operation.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, können Sie rufen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> Methode, um den Sendevorgang erfolgreich abgeschlossen.</target>       </trans-unit>
        <trans-unit id="1744" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="1745" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> blockiert, bis die gesamte Datei gesendet wird.</target>       </trans-unit>
        <trans-unit id="1746" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1747" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="1748" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendFile%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="1749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="1754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The callback delegate calls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> to complete the transmission.</source>
          <target state="translated">Der Rückrufdelegat ruft <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendFile%2A&gt;</ph> um die Übertragung abzuschließen.</target>       </trans-unit>
        <trans-unit id="1755" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>Windows NT is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows NT erforderlich.</target>       </trans-unit>
        <trans-unit id="1756" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1757" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="1758" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1759" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /&gt;</ph> wurde bereits für das asynchrone <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /&gt;</ph> aufgerufen.</target>       </trans-unit>
        <trans-unit id="1760" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1761" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="1762" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Ends a pending asynchronous send to a specific location.</source>
          <target state="translated">Beendet einen ausstehenden asynchronen Sendevorgang an einen bestimmten Zielort.</target>       </trans-unit>
        <trans-unit id="1763" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If successful, the number of bytes sent; otherwise, an invalid <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> error.</source>
          <target state="translated">Wenn erfolgreich, die Anzahl der gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> completes the asynchronous send operation started in <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> Schließt den asynchronen Sendevorgang in gestartet <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, you need to create a callback method that implements the <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegate.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <ph id="ph2">&lt;xref:System.AsyncCallback&gt;</ph> delegieren.</target>       </trans-unit>
        <trans-unit id="1766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This callback method executes in a separate thread and is called by the system after <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> returns.</source>
          <target state="translated">Diese Rückrufmethode wird in einem separaten Thread ausgeführt und wird aufgerufen, durch das System nach <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginReceive%2A&gt;</ph> zurückgibt.</target>       </trans-unit>
        <trans-unit id="1767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The callback method must accept the <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method as a parameter.</source>
          <target state="translated">Die Rückrufmethode muss akzeptieren die <ph id="ph1">&lt;xref:System.IAsyncResult&gt;</ph> zurückgegebenes die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> Methode als Parameter.</target>       </trans-unit>
        <trans-unit id="1768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>Within the callback method, call the <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> method of the <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> parameter to obtain the sending <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Innerhalb der Rückrufmethode Aufrufen der <ph id="ph1">&lt;xref:System.IAsyncResult.AsyncState%2A&gt;</ph> Methode der <ph id="ph2">&lt;xref:System.IAsyncResult&gt;</ph> Parameter zum Abrufen der Versand <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After obtaining the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, you can call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> method to successfully complete the send operation and return the number of bytes sent.</source>
          <target state="translated">Nach dem Erhalt der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, Sie erreichen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> Methode für die erfolgreiche den Sendevorgang abgeschlossen und die Anzahl der gesendeten Bytes zurück.</target>       </trans-unit>
        <trans-unit id="1770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="1771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> will block until the requested number of bytes are sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.EndSendTo%2A&gt;</ph> blockiert, bis die angeforderte Anzahl von Bytes gesendet werden.</target>       </trans-unit>
        <trans-unit id="1772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="1773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="1774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSendTo%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="1775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1776" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1777" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1778" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1779" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The following code example ends an asynchronous send to a specific location.</source>
          <target state="translated">Im folgenden Codebeispiel wird einen asynchronen Sendevorgang an einem bestimmten Speicherort beendet.</target>       </trans-unit>
        <trans-unit id="1780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> was not returned by a call to the <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="asyncResult" /&gt;</ph> wurde nicht durch einen Aufruf der <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /&gt;</ph>-Methode zurückgegeben.</target>       </trans-unit>
        <trans-unit id="1782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> was previously called for the asynchronous send.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /&gt;</ph> wurde bereits für den asynchronen Sendevorgang aufgerufen.</target>       </trans-unit>
        <trans-unit id="1783" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1784" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1785" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one process to bind to a port.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert ab, der angibt, ob der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> das Binden nur eines einzigen Prozesses an einen Anschluss zulässt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1786" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> allows only one socket to bind to a specific port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> das Binden nur eines einzigen Sockets an einen bestimmten Anschluss zulässt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1787" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The default is <ph id="ph1">&lt;see langword="true" /&gt;</ph> for Windows Server 2003 and Windows XP Service Pack 2, and <ph id="ph2">&lt;see langword="false" /&gt;</ph> for all other versions.</source>
          <target state="translated">Die Standardeinstellung ist <ph id="ph1">&lt;see langword="true" /&gt;</ph> für Windows Server 2003 und Windows XP Service Pack 2 und <ph id="ph2">&lt;see langword="false" /&gt;</ph> für alle anderen Versionen.</target>       </trans-unit>
        <trans-unit id="1788" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`false`</ph>, multiple sockets can use the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> ist <ph id="ph2">`false`</ph>, mehrere Sockets können die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode zum Binden an einen bestimmten Port, jedoch nur eine der Sockets Vorgänge für den Netzwerkdatenverkehr an den Port gesendete ausführen kann.</target>       </trans-unit>
        <trans-unit id="1789" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If more than one socket attempts to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</source>
          <target state="translated">Wenn mehr als ein Socket versucht, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29&gt;</ph> Methode an einen bestimmten Port gebunden werden soll, und klicken Sie dann das Laufwerk mit die spezifische IP-Adresse den Netzwerkdatenverkehr, die an diesen Port gesendet behandelt.</target>       </trans-unit>
        <trans-unit id="1790" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>If <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> is <ph id="ph2">`true`</ph>, the first use of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to attempt to bind to that port will fail until the original bound socket is destroyed.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> ist <ph id="ph2">`true`</ph>, der ersten Verwendung von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode versucht, binden an einen bestimmten Port, unabhängig von der Adresse Internetprotokoll (IP), wird erfolgreich ausgeführt werden; alle nachfolgenden Verwendungen von der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode versucht, die an diesen Port gebunden wird fehl, bis der ursprüngliche gebundene Socket zerstört wird.</target>       </trans-unit>
        <trans-unit id="1791" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>This property must be set before <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> is called; otherwise an <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> will be thrown.</source>
          <target state="translated">Diese Eigenschaft muss festgelegt werden, bevor <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> aufgerufen; andernfalls wird eine <ph id="ph2">&lt;xref:System.InvalidOperationException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="1792" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1793" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1794" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1795" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ExclusiveAddressUse">
          <source><ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> has been called for this <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Für diesen <ph id="ph1">&lt;see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /&gt;</ph> wurde <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> aufgerufen.</target>       </trans-unit>
        <trans-unit id="1796" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>Frees resources used by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> class.</source>
          <target state="translated">Gibt von der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Klasse verwendete Ressourcen frei.</target>       </trans-unit>
        <trans-unit id="1797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Finalize">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class finalizer calls the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to close the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> and free resources associated with the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> -Klasse Finalizer Ruft die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode zum Schließen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> und zugeordneten Ressourcen frei der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1798" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Returns the value of a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Gibt den Wert einer <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option zurück.</target>       </trans-unit>
        <trans-unit id="1799" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1800" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1801" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Returns the value of a specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option, represented as an object.</source>
          <target state="translated">Gibt den Wert einer angegebenen, als Objekt dargestellten <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option zurück.</target>       </trans-unit>
        <trans-unit id="1802" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An object that represents the value of the option.</source>
          <target state="translated">Ein Objekt, das den Wert der Option darstellt.</target>       </trans-unit>
        <trans-unit id="1803" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When the <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> parameter is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> the return value is an instance of the <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> class.</source>
          <target state="translated">Wenn der <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph>-Parameter auf <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.Linger" /&gt;</ph> festgelegt ist, ist der Rückgabewert eine Instanz der <ph id="ph3">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="1804" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is set to <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph>, the return value is an instance of the <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> class.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> auf <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /&gt;</ph> festgelegt ist, ist der Rückgabewert eine Instanz der <ph id="ph4">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph>-Klasse.</target>       </trans-unit>
        <trans-unit id="1805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>When <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> is any other value, the return value is an integer.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> einen anderen Wert hat, ist der Rückgabewert eine ganze Zahl.</target>       </trans-unit>
        <trans-unit id="1806" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1807" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>Use this overload to get the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Verwenden Sie diese Überladung zum Abrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen.</target>       </trans-unit>
        <trans-unit id="1808" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Für die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> mit <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die <ph id="ph3">`optionLevel`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="1809" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, verwenden Sie <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1810" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you want to set the value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie verwenden möchten, legen Sie den Wert aller oben aufgeführten Optionen, verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1811" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1812" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1813" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Der folgende code Beispiel ruft die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeout Werte und zeigt sie an die Konsole.</target>       </trans-unit>
        <trans-unit id="1816" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1817" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1818" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> was set to the unsupported value <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionName" /&gt;</ph> wurde auf den nicht unterstützten Wert <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /&gt;</ph> festgelegt.</target>       </trans-unit>
        <trans-unit id="1819" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1820" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1821" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1822" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is to receive the option setting.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die Optionseinstellung erhalten soll.</target>       </trans-unit>
        <trans-unit id="1823" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Returns the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option setting, represented as a byte array.</source>
          <target state="translated">Gibt die angegebene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Optionseinstellung als Bytearray dargestellt zurück.</target>       </trans-unit>
        <trans-unit id="1824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Upon successful completion of this method, the array specified by the <ph id="ph1">`optionValue`</ph> parameter contains the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option.</source>
          <target state="translated">Nach erfolgreichem Abschluss dieser Methode ein Array gemäß der <ph id="ph1">`optionValue`</ph> Parameter enthält den Wert des angegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Option.</target>       </trans-unit>
        <trans-unit id="1826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>When the length of the <ph id="ph1">`optionValue`</ph> array is smaller than the number of bytes required to store the value of the specified <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> option, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn die Länge des der <ph id="ph1">`optionValue`</ph> Array ist kleiner als die erforderliche Anzahl von Bytes zum Speichern des Werts des angegebenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Option <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.</target>       </trans-unit>
        <trans-unit id="1830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Der folgende code Beispiel ruft die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeout Werte und zeigt sie an die Konsole.</target>       </trans-unit>
        <trans-unit id="1833" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1834" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="1835" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt.</target>       </trans-unit>
        <trans-unit id="1836" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">Sie können den Pufferspeicher pro Socket durch den Aufruf von <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph> ändern.</target>       </trans-unit>
        <trans-unit id="1837" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1838" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1839" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The length, in bytes, of the expected return value.</source>
          <target state="translated">Die Länge des erwarteten Rückgabewerts in Bytes.</target>       </trans-unit>
        <trans-unit id="1841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Returns the value of the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option in an array.</source>
          <target state="translated">Gibt den Wert der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option in einem Array zurück.</target>       </trans-unit>
        <trans-unit id="1842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the value of the socket option.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das den Wert der Socketoption enthält.</target>       </trans-unit>
        <trans-unit id="1843" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">`optionLength`</ph> parameter sets the maximum size of the returned byte array.</source>
          <target state="translated">Die <ph id="ph1">`optionLength`</ph> Parameter legt die maximale Größe des zurückgegebenen Bytearrays.</target>       </trans-unit>
        <trans-unit id="1844" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires fewer bytes, the array will contain only that many bytes.</source>
          <target state="translated">Wenn der Optionswert weniger Bytes erforderlich ist, wird das Array enthalten nur die Anzahl an Bytes.</target>       </trans-unit>
        <trans-unit id="1845" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If the option value requires more bytes, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Optionswert mehr Bytes erfordert <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1846" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Use this overload for any sockets that are represented by Boolean values or integers.</source>
          <target state="translated">Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.</target>       </trans-unit>
        <trans-unit id="1847" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1848" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1849" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1850" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example retrieves the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values and displays them to the console.</source>
          <target state="translated">Der folgende code Beispiel ruft die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeout Werte und zeigt sie an die Konsole.</target>       </trans-unit>
        <trans-unit id="1852" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1853" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="1854" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</source>
          <target state="translated">In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt.</target>       </trans-unit>
        <trans-unit id="1855" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>You can change the per socket buffer space by calling <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph>.</source>
          <target state="translated">Sie können den Pufferspeicher pro Socket durch den Aufruf von <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /&gt;</ph> ändern.</target>       </trans-unit>
        <trans-unit id="1856" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1857" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Handle">
          <source>Gets the operating system handle for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft das Betriebssystemhandle für den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="1858" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Handle">
          <source>An <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph> that represents the operating system handle for the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.IntPtr" /&gt;</ph>, der das Betriebssystemhandle für den <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> darstellt.</target>       </trans-unit>
        <trans-unit id="1859" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Legt Betriebsmodi auf niedriger Ebene für den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> fest.</target>       </trans-unit>
        <trans-unit id="1860" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</target>       </trans-unit>
        <trans-unit id="1861" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the input data required by the operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das die für den Vorgang erforderlichen Eingabedaten enthält.</target>       </trans-unit>
        <trans-unit id="1862" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains the output data returned by the operation.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das die durch den Vorgang zurückgegebenen Ausgabedaten enthält.</target>       </trans-unit>
        <trans-unit id="1863" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using numerical control codes.</source>
          <target state="translated">Legt mit numerischen Steuerungscodes die Betriebsmodi niedriger Ebene für den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> fest.</target>       </trans-unit>
        <trans-unit id="1864" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">Die Anzahl der Bytes im <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>-Parameter.</target>       </trans-unit>
        <trans-unit id="1865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> method provides low-level access to the operating system <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> -Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zugrunde liegenden der aktuellen Instanz der dem <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="1866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Weitere Informationen finden Sie in der WSAIoctl-Dokumentation in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of FIONREAD and the Available property.</source>
          <target state="translated">Im folgenden Codebeispiel werden die Ergebnisse von FIONREAD und verfügbare Eigenschaft verglichen.</target>       </trans-unit>
        <trans-unit id="1872" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Es wurde versucht, den blockierenden Modus ohne Verwendung der <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph>-Eigenschaft zu ändern.</target>       </trans-unit>
        <trans-unit id="1875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="1876" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">Ausführen von nicht verwaltetem Code.</target>       </trans-unit>
        <trans-unit id="1877" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> value that specifies the control code of the operation to perform.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph>-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</target>       </trans-unit>
        <trans-unit id="1879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the input data required by the operation.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die für den Vorgang erforderlichen Eingabedaten enthält.</target>       </trans-unit>
        <trans-unit id="1880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the output data returned by the operation.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die von dem Vorgang zurückgegebenen Ausgabedaten enthält.</target>       </trans-unit>
        <trans-unit id="1881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Sets low-level operating modes for the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> enumeration to specify control codes.</source>
          <target state="translated">Legt mithilfe der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Enumeration zum Angeben von Steuerungscodes Betriebsmodi niedriger Ebene für den <ph id="ph2">&lt;see cref="T:System.Net.Sockets.IOControlCode" /&gt;</ph> fest.</target>       </trans-unit>
        <trans-unit id="1882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The number of bytes in the <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph> parameter.</source>
          <target state="translated">Die Anzahl der Bytes im <ph id="ph1">&lt;paramref name="optionOutValue" /&gt;</ph>-Parameter.</target>       </trans-unit>
        <trans-unit id="1883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This method provides low-level access to the operating system <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> underlying the current instance of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> class.</source>
          <target state="translated">Diese Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zugrunde liegenden der aktuellen Instanz der dem <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Klasse.</target>       </trans-unit>
        <trans-unit id="1884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more, see the WSAIoctl documentation in the MSDN library.</source>
          <target state="translated">Weitere finden Sie in der WSAIoctl-Dokumentation in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="1885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The following code example compares the results of calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> with <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> and the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property.</source>
          <target state="translated">Im folgenden Codebeispiel werden die Ergebnisse des Aufrufs verglichen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IOControl%2A&gt;</ph> mit <ph id="ph2">&lt;xref:System.Net.Sockets.IOControlCode.DataToRead&gt;</ph> und <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1890" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1891" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1892" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>An attempt was made to change the blocking mode without using the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph> property.</source>
          <target state="translated">Es wurde versucht, den blockierenden Modus ohne Verwendung der <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.Blocking" /&gt;</ph>-Eigenschaft zu ändern.</target>       </trans-unit>
        <trans-unit id="1893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>to execute unmanaged code.</source>
          <target state="translated">Ausführen von nicht verwaltetem Code.</target>       </trans-unit>
        <trans-unit id="1894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="1895" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>Gets a value that indicates whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a specific local port.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an einen bestimmten lokalen Anschluss gebunden ist.</target>       </trans-unit>
        <trans-unit id="1896" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is bound to a local port; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an einen lokalen Anschluss gebunden ist, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1897" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>A socket is considered bound to a local port if it is explicitly bound by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, or implicitly bound by calling members like <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method to bind to a well-known port so that clients may connect to them.</source>
          <target state="translated">Ein Socket wird als gebunden an einen lokalen Port angesehen, wenn sie explizit durch Aufrufen von gebunden ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode oder implizit durch Aufrufen von Membern wie gebundene <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, oder <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, welche verwenden einen kurzlebigen lokalen Anschluss (eine frei größer als 1024, vom Betriebssystem ausgewählt.) Server verwenden die <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode, um an einem bekannten Port binden, damit Clients eine Verbindung damit herstellen können.</target>       </trans-unit>
        <trans-unit id="1898" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.IsBound">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.IsBound%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1899" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Gets or sets a value that specifies whether the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> will delay closing a socket in an attempt to send all pending data.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> bei einem Versuch, alle ausstehenden Daten zu senden, das Schließen eines Sockets verzögert, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1900" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> that specifies how to linger while closing a socket.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph>, die angibt, wie der Nachlauf während des Schließens eines Sockets erfolgen soll.</target>       </trans-unit>
        <trans-unit id="1901" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property changes the way <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method behaves.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> -Eigenschaft ändert das <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode verhält sich.</target>       </trans-unit>
        <trans-unit id="1902" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property when set modifies the conditions under which the connection can be reset by Winsock.</source>
          <target state="translated">Diese Eigenschaft wird beim Festlegen der Bedingungen ändert, unter denen die Verbindung durch Winsock zurückgesetzt werden kann.</target>       </trans-unit>
        <trans-unit id="1903" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Connection resets can still occur based on the IP protocol behavior.</source>
          <target state="translated">Verbindungszurücksetzungen können weiterhin basierend auf dem IP-Protokoll-Verhalten auftreten.</target>       </trans-unit>
        <trans-unit id="1904" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property controls the length of time that a connection-oriented connection will remain open after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> when data remains to be sent.</source>
          <target state="translated">Diese Eigenschaft steuert die Zeitspanne, die eine Verbindung mit einem verbindungsorientierten geöffnet, nach einem Aufruf von gehalten wird <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> bleibt, wenn noch weitere Daten gesendet werden.</target>       </trans-unit>
        <trans-unit id="1905" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</source>
          <target state="translated">Beim Aufrufen von Methoden zum Senden von Daten für einen Peer werden diese Daten im ausgehenden Netzwerkpuffer platziert.</target>       </trans-unit>
        <trans-unit id="1906" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This property can be used to ensure that this data is sent to the remote host before the <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> method drops the connection.</source>
          <target state="translated">Diese Eigenschaft kann verwendet werden, um sicherzustellen, dass diese Daten mit dem Remotehost, bevor Sie gesendet werden die <ph id="ph1">&lt;xref:System.Net.Sockets.TcpClient.Close%2A&gt;</ph> Methode löscht die Verbindung.</target>       </trans-unit>
        <trans-unit id="1907" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>To enable lingering, create a <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> instance containing the desired values, and set the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property to this instance.</source>
          <target state="translated">Erstellen Sie aktivieren, indem eine <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> -Instanz, die die gewünschten Werte enthält, und legen Sie die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> Eigenschaft dieser Instanz.</target>       </trans-unit>
        <trans-unit id="1908" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following table describes the behavior of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method for the possible values of the <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> property and the <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">Die folgende Tabelle beschreibt das Verhalten des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode für die möglichen Werte für die <ph id="ph2">&lt;xref:System.Net.Sockets.LingerOption.Enabled%2A&gt;</ph> Eigenschaft und die <ph id="ph3">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> Eigenschaft gespeichert, der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1909" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.Enabled</source>
          <target state="translated">LingerState.Enabled</target>       </trans-unit>
        <trans-unit id="1910" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>LingerState.LingerTime</source>
          <target state="translated">LingerState.LingerTime</target>       </trans-unit>
        <trans-unit id="1911" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Behavior</source>
          <target state="translated">Verhalten</target>       </trans-unit>
        <trans-unit id="1912" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`false`</ph> (disabled), the default value</source>
          <target state="translated"><ph id="ph1">`false`</ph> (deaktiviert), den Standardwert</target>       </trans-unit>
        <trans-unit id="1913" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The time-out is not applicable, (default).</source>
          <target state="translated">Das Timeout ist nicht anwendbar (Standard).</target>       </trans-unit>
        <trans-unit id="1914" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the default IP protocol time-out expires.</source>
          <target state="translated">Versucht, ausstehende Daten zu senden, bis das Zeitlimit für IP-Protokoll abläuft.</target>       </trans-unit>
        <trans-unit id="1915" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (aktiviert)</target>       </trans-unit>
        <trans-unit id="1916" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A nonzero time-out</source>
          <target state="translated">Ein Wert ungleich NULL Timeout</target>       </trans-unit>
        <trans-unit id="1917" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</source>
          <target state="translated">Versucht, ausstehende Daten senden, bis das angegebene Timeout abläuft, und wenn der Versuch fehlschlägt, klicken Sie dann Winsock setzt die Verbindung zurück.</target>       </trans-unit>
        <trans-unit id="1918" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source><ph id="ph1">`true`</ph> (enabled)</source>
          <target state="translated"><ph id="ph1">`true`</ph> (aktiviert)</target>       </trans-unit>
        <trans-unit id="1919" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>A zero timeout.</source>
          <target state="translated">0 (null) ein Timeout.</target>       </trans-unit>
        <trans-unit id="1920" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>Discards any pending data.</source>
          <target state="translated">Verwirft alle ausstehenden Daten.</target>       </trans-unit>
        <trans-unit id="1921" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>For connection-oriented socket (TCP, for example), Winsock resets the connection.</source>
          <target state="translated">Für verbindungsorientierte Sockets (z. B. TCP) und setzt Winsock die Verbindung zurück.</target>       </trans-unit>
        <trans-unit id="1922" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</source>
          <target state="translated">Der IP-Stapel berechnet die Timeoutzeitspanne standardmäßig IP-Protokoll verwenden, basierend auf die Roundtripzeit der Verbindung.</target>       </trans-unit>
        <trans-unit id="1923" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>In most cases, the time-out computed by the stack is more relevant than one defined by an application.</source>
          <target state="translated">In den meisten Fällen ist das Timeout berechnet, indem der Stapel relevanter als ein von einer Anwendung definiert.</target>       </trans-unit>
        <trans-unit id="1924" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>This is the default behavior for a socket when the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is not set.</source>
          <target state="translated">Dies ist das Standardverhalten für ein Socket bei der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> Eigenschaft nicht festgelegt ist.</target>       </trans-unit>
        <trans-unit id="1925" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>When the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> property stored in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</source>
          <target state="translated">Wenn die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption.LingerTime%2A&gt;</ph> Eigenschaft gespeichert, der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> Eigenschaft größer als das Standardtimeout für IP-Protokoll festgelegt ist, das Standardtimeout für IP-Protokoll wird weiterhin gelten, und überschreiben.</target>       </trans-unit>
        <trans-unit id="1926" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LingerState%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1927" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1928" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LingerState">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1929" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The maximum length of the pending connections queue.</source>
          <target state="translated">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</target>       </trans-unit>
        <trans-unit id="1930" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Places a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in a listening state.</source>
          <target state="translated">Versetzt einen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in den Überwachungszustand.</target>       </trans-unit>
        <trans-unit id="1931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> causes a connection-oriented <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connection attempts.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> bewirkt, dass eine verbindungsorientierten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zum Abhören von eingehenden Verbindungsversuche.</target>       </trans-unit>
        <trans-unit id="1932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">`backlog`</ph> parameter specifies the number of incoming connections that can be queued for acceptance.</source>
          <target state="translated">Die <ph id="ph1">`backlog`</ph> Parameter gibt die Anzahl der eingehenden Verbindungen, die für seine Annahme abgefragt werden können.</target>       </trans-unit>
        <trans-unit id="1933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>To determine the maximum number of connections you can specify, retrieve the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> value.</source>
          <target state="translated">Um die maximale Anzahl von Verbindungen zu ermitteln, können Sie angeben, Abrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.MaxConnections&gt;</ph> Wert.</target>       </trans-unit>
        <trans-unit id="1934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> does not block.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> wird nicht blockiert.</target>       </trans-unit>
        <trans-unit id="1935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> to accept a connection from the queue.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> annehmen eine Verbindung aus der Warteschlange.</target>       </trans-unit>
        <trans-unit id="1938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You must call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method before calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> will throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Listen%2A&gt;</ph> löst eine <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The backlog parameter is limited to different values depending on the Operating System.</source>
          <target state="translated">Der Backlog-Parameter ist beschränkt auf verschiedene Werte je nach Betriebssystem.</target>       </trans-unit>
        <trans-unit id="1942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>You may specify a higher value, but the backlog will be limited based on the Operating System.</source>
          <target state="translated">Sie können einen höheren Wert angeben, aber der Rückstand ist beschränkt, basierend auf dem Betriebssystem.</target>       </trans-unit>
        <trans-unit id="1943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to listen for incoming connections.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> zum Lauschen auf eingehende Verbindungen.</target>       </trans-unit>
        <trans-unit id="1944" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1945" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Listen(System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1946" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>Gets the local endpoint.</source>
          <target state="translated">Ruft den lokalen Endpunkt ab.</target>       </trans-unit>
        <trans-unit id="1947" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using for communications.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, den der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> für die Kommunikation verwendet.</target>       </trans-unit>
        <trans-unit id="1948" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property gets an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the local IP address and port number to which your <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is bound.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft ruft eine <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> , enthält die lokale IP-Adresse und Anschlussnummer Zahl an, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> gebunden ist.</target>       </trans-unit>
        <trans-unit id="1949" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Müssen Sie eine Umwandlung dies <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> auf eine <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> vor dem Abrufen von Informationen.</target>       </trans-unit>
        <trans-unit id="1950" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the local port number.</source>
          <target state="translated">Rufen Sie dann die <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> Methode zum Abrufen des lokalen <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, und die <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> Methode, um die lokalen Portnummer abzurufen.</target>       </trans-unit>
        <trans-unit id="1951" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property is usually set after you make a call to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft wird normalerweise festgelegt, nachdem Sie einen Aufruf zum Ausführen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1952" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you allow the system to assign your socket's local IP address and port number, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property will be set after the first I/O operation.</source>
          <target state="translated">Wenn Sie zulassen, dass das System Zuweisen des Sockets lokale IP-Adresse und Portnummer an, dass die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> -Eigenschaft wird festgelegt, nach dem ersten e/a-Vorgang.</target>       </trans-unit>
        <trans-unit id="1953" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connection-oriented protocols, the first I/O operation would be a call to the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Für verbindungsorientierte Protokolle, wäre der erste e/a-Vorgang ein Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="1954" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For connectionless protocols, the first I/O operation would be any of the send or receive calls.</source>
          <target state="translated">Für verbindungslose Protokolle würde der erste e/a-Vorgang werden für das Senden oder Empfangen von Aufrufe.</target>       </trans-unit>
        <trans-unit id="1955" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="1956" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="1957" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="1958" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="1959" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">Im folgenden Codebeispiel wird abgerufen, und die lokalen und Remoteendpunkte angezeigt.</target>       </trans-unit>
        <trans-unit id="1960" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1961" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.LocalEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1962" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1963" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> receives outgoing multicast packets; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ausgehende Multicastpakete empfängt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1964" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Multicast is a scalable method for many-to-many communication on the Internet.</source>
          <target state="translated">Multicast ist eine skalierbare Methode für die m: n-Kommunikation über das Internet.</target>       </trans-unit>
        <trans-unit id="1965" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</source>
          <target state="translated">Ein Prozess abonniert eine Multicastadresse; Alle Pakete von einem abonnierte Prozess gesendet werden anschließend von jedem anderen Prozess abonniert die Multicastadresse empfangen.</target>       </trans-unit>
        <trans-unit id="1966" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</source>
          <target state="translated">Durch Festlegen dieser Eigenschaft für ein Socket Protokoll TCP (Transmission Control) werden keine Auswirkungen haben.</target>       </trans-unit>
        <trans-unit id="1967" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.MulticastLoopback%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1968" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="1969" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.MulticastLoopback">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1970" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Gets or sets a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph> value that specifies whether the stream <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is using the Nagle algorithm.</source>
          <target state="translated">Ruft einen <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert ab, der angibt, ob der Stream-<ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> den Nagle-Algorithmus verwendet, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="1971" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source><ph id="ph1">&lt;see langword="false" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses the Nagle algorithm; otherwise, <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="false" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> den Nagle-Algorithmus verwendet, andernfalls <ph id="ph3">&lt;see langword="true" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1972" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1973" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</source>
          <target state="translated">Der Nagle-Algorithmus wurde entwickelt, um den Netzwerkverkehr zu reduzieren, den Socket kleine Pakete und kombinieren, und senden Sie diese in einem Paket unter bestimmten Umständen zu verursachen.</target>       </trans-unit>
        <trans-unit id="1974" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>A TCP packet consists of 40 bytes of header plus the data being sent.</source>
          <target state="translated">Ein TCP-Paket besteht aus 40 Byte der Header und der Daten, die gesendet werden.</target>       </trans-unit>
        <trans-unit id="1975" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</source>
          <target state="translated">Wenn kleine Datenpakete mit TCP gesendet werden, kann der Mehraufwand des TCP-Headers ein wesentlicher Teil des Netzwerkdatenverkehrs werden. In stark ausgelasteten Netzwerken kann die Überlastung, die aus diesen zusätzlichen Aufwand stammenden verloren Datagramme und-Pakete voneinander trennt sowie eine übermäßige Weitergabe Zeit aufgrund von Überlastung führen.</target>       </trans-unit>
        <trans-unit id="1976" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The Nagle algorithm inhibits the sending of new TCP segmentswhen new outgoing data arrives from the user if any previouslytransmitted data on the connection remains unacknowledged.</source>
          <target state="translated">Der Nagle-Algorithmus wird verhindert, dass das Senden von neuen TCP Segmentswhen neue ausgehende Daten des Benutzers eintrifft werden, wenn alle zuvor übertragene Daten für die Verbindung nicht bestätigte bleibt.</target>       </trans-unit>
        <trans-unit id="1977" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The majority of network applications should use the Nagle algorithm.</source>
          <target state="translated">Die meisten netzwerkanwendungen sollte den Nagle-Algorithmus verwenden.</target>       </trans-unit>
        <trans-unit id="1978" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</source>
          <target state="translated">Durch Festlegen dieser Eigenschaft für ein Socket User Datagram Protocol (UDP), wird keine Auswirkungen haben.</target>       </trans-unit>
        <trans-unit id="1979" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.NoDelay%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="1980" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>An error occurred when attempting to access the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Fehler beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1981" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.NoDelay">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="1982" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</source>
          <target state="translated">Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv4 (Internet Protocol, Version 4) unterstützen.</target>       </trans-unit>
        <trans-unit id="1983" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Betriebssystem und die Netzwerkkarten das IPv4-Protokoll unterstützen, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1984" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.</target>       </trans-unit>
        <trans-unit id="1985" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</source>
          <target state="translated">Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv6 (Internet Protocol, Version 6) unterstützen.</target>       </trans-unit>
        <trans-unit id="1986" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the operating system and network adaptors support the IPv6 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Betriebssystem und die Netzwerkkarten das Protokoll IPv6 unterstützen, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1987" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.OSSupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.</target>       </trans-unit>
        <trans-unit id="1988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The time to wait for a response, in microseconds.</source>
          <target state="translated">Die Zeit in Mikrosekunden, die auf eine Antwort gewartet werden soll.</target>       </trans-unit>
        <trans-unit id="1989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="1990" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Determines the status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Bestimmt den Status des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="1991" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The status of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> based on the polling mode value passed in the <ph id="ph2">&lt;paramref name="mode" /&gt;</ph> parameter.</source>
          <target state="translated">Der Status des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> basierend auf dem im <ph id="ph2">&lt;paramref name="mode" /&gt;</ph>-Parameter übergebenen Abfragemoduswert.</target>       </trans-unit>
        <trans-unit id="1992" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Mode</source>
          <target state="translated"><ph id="ph1">&lt;list type="table"&gt;</ph><ph id="ph2">&lt;listheader&gt;</ph><ph id="ph3">&lt;term&gt;</ph> Modus</target>       </trans-unit>
        <trans-unit id="1993" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Return Value</source>
          <target state="translated"><ph id="ph1">&lt;/term&gt;</ph><ph id="ph2">&lt;description&gt;</ph> Rückgabewert</target>       </trans-unit>
        <trans-unit id="1994" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> has been called and a connection is pending;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/listheader&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectRead" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /&gt;</ph> aufgerufen wurde und eine Verbindung aussteht;</target>       </trans-unit>
        <trans-unit id="1995" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1996" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data is available for reading;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="1997" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="1998" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the connection has been closed, reset, or terminated;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn die Verbindung geschlossen, zurückgesetzt oder beendet wurde.</target>       </trans-unit>
        <trans-unit id="1999" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Andernfalls wird <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph>, and the connection has succeeded;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph> <ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, wenn ein <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> verarbeitet wird und die Verbindung erfolgreich war;</target>       </trans-unit>
        <trans-unit id="2001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if data can be sent;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn Daten gesendet werden können.</target>       </trans-unit>
        <trans-unit id="2003" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Andernfalls wird <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2004" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph> if processing a <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> that does not block, and the connection has failed;</source>
          <target state="translated"><ph id="ph1">&lt;/description&gt;</ph><ph id="ph2">&lt;/item&gt;</ph><ph id="ph3">&lt;item&gt;</ph><bpt id="p1">&lt;term&gt;</bpt><ph id="ph4">&lt;see cref="F:System.Net.Sockets.SelectMode.SelectError" /&gt;</ph><ept id="p1">&lt;/term&gt;</ept><ph id="ph5">&lt;description&gt;</ph><ph id="ph6">&lt;see langword="true" /&gt;</ph>, wenn ein <ph id="ph7">&lt;see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /&gt;</ph> ohne Blockierung verarbeitet wird und der Verbindungsaufbau fehlgeschlagen ist;</target>       </trans-unit>
        <trans-unit id="2005" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2006" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> is not set and out-of-band data is available;</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn <ph id="ph2">&lt;see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /&gt;</ph> nicht festgelegt ist und Out-of-Band-Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2007" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>otherwise, returns <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Andernfalls wird <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method will check the state of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode überprüft den Status der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> for the <ph id="ph2">`selectMode`</ph> parameter to determine if the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is readable.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType&gt;</ph> für die <ph id="ph2">`selectMode`</ph> Parameter, um festzustellen, wo die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> lesbar ist.</target>       </trans-unit>
        <trans-unit id="2010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Specify <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> to determine if the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is writable.</source>
          <target state="translated">Geben Sie <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType&gt;</ph> zum bestimmen, ob die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> geschrieben werden kann.</target>       </trans-unit>
        <trans-unit id="2011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Use <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> to detect an error condition.</source>
          <target state="translated">Verwendung <ph id="ph1">&lt;xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType&gt;</ph> eine fehlerbedingung erkannt.</target>       </trans-unit>
        <trans-unit id="2012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> will block execution until the specified time period, measured in <ph id="ph2">`microseconds`</ph>, elapses.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> blockiert die Ausführung bis zum angegebenen Zeitraum, gemessen in <ph id="ph2">`microseconds`</ph>, verstrichen ist.</target>       </trans-unit>
        <trans-unit id="2013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>Set the <ph id="ph1">`microSeconds`</ph> parameter to a negative integer if you would like to wait indefinitely for a response.</source>
          <target state="translated">Legen Sie die <ph id="ph1">`microSeconds`</ph> Parameter, um eine negative ganze Zahl, wenn Sie, um unbegrenzt zu warten, bis eine Antwort möchten.</target>       </trans-unit>
        <trans-unit id="2014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you want to check the status of multiple sockets, you might prefer to use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie den Status mehrerer Sockets überprüfen möchten, Sie möchten möglicherweise verwenden Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Diese Methode nicht erkannt werden bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde.</target>       </trans-unit>
        <trans-unit id="2018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Sie müssen versuchen zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.</target>       </trans-unit>
        <trans-unit id="2019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The following code example creates a socket, connects to a server, and uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> to check the status of the socket.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket erstellt, eine Verbindung mit einem Server her und verwendet <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> zum Überprüfen des Status des Sockets.</target>       </trans-unit>
        <trans-unit id="2022" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;paramref name="mode" /&gt;</ph> parameter is not one of the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph> values.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="mode" /&gt;</ph>-Parameter ist keiner der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SelectMode" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2023" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2024" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>See remarks below.</source>
          <target state="translated">Weitere Informationen finden Sie weiter unten im Abschnitt "Hinweise".</target>       </trans-unit>
        <trans-unit id="2025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2026" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>Gets the protocol type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft den Protokolltyp des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="2027" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.ProtocolType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2028" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> property is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created, and specifies the protocol used by that <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ProtocolType%2A&gt;</ph> Eigenschaft wird festgelegt, wenn die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> erstellt wird, und gibt das Protokoll verwendet wird, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2029" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ProtocolType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> an die Konsole.</target>       </trans-unit>
        <trans-unit id="2030" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="2032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in einem Empfangspuffer.</target>       </trans-unit>
        <trans-unit id="2033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2034" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2035" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> verbindungsorientierten und verbindungslose Sockets.</target>       </trans-unit>
        <trans-unit id="2036" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This overload only requires you to provide a receive buffer.</source>
          <target state="translated">Diese Überladung müssen nur einen Empfangspuffer bereitstellen.</target>       </trans-unit>
        <trans-unit id="2037" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Der Pufferoffset hat den Standardwert 0, die Größe der Standardwert ist die Länge des Pufferparameters und der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von den Remotehost eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen.</target>       </trans-unit>
        <trans-unit id="2048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffer`</ph> Parameter <ph id="ph2">`buffer`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The following code example receives data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird empfängt Daten über einen verbundenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2056" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2057" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2058" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2059" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[])">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2062" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Eine Liste mit <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph>, die die empfangenen Daten enthält.</target>       </trans-unit>
        <trans-unit id="2063" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> und fügt sie in die Liste der Empfangspuffer ein.</target>       </trans-unit>
        <trans-unit id="2064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2065" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This method reads data into the buffers parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Diese Methode liest Daten in den Puffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2066" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.</target>       </trans-unit>
        <trans-unit id="2067" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer.</target>       </trans-unit>
        <trans-unit id="2068" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2069" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2070" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2071" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2072" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2073" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2074" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2075" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2076" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen.</target>       </trans-unit>
        <trans-unit id="2078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffers`</ph> Parameter <ph id="ph2">`buffers`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><bpt id="p1">**</bpt>Note<ept id="p1">**</ept> This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated"><bpt id="p1">**</bpt>Hinweis<ept id="p1">**</ept> dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2085" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="buffer" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2086" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="2087" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2088" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="2089" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2090" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in einem Empfangspuffer, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2091" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> verbindungsorientierten und verbindungslose Sockets.</target>       </trans-unit>
        <trans-unit id="2094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Diese Überladung erfordert nur einen Empfangspuffer und die erforderlichen bereitstellen <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</source>
          <target state="translated">Der Pufferoffset hat den Standardwert 0, und die Größe wird standardmäßig auf die Länge des Byteparameters.</target>       </trans-unit>
        <trans-unit id="2096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von den Remotehost eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2101" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierenden Modus, und es keine Daten in der Protokoll-Stack-Puffer sind der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2102" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2103" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie Ihre Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2104" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available up to the size of the buffer.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist.</target>       </trans-unit>
        <trans-unit id="2105" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2106" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2107" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffer`</ph> Parameter <ph id="ph2">`buffer`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2108" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2109" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2110" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2111" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2112" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for receiving data on a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel gibt einen Datenpuffer und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> für den Empfang von Daten über einen verbundenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2113" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2114" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2115" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2116" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2117" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2118" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Eine Liste mit <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph>, die die empfangenen Daten enthält.</target>       </trans-unit>
        <trans-unit id="2120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in der Liste der Empfangspuffer, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Diese Methode liest Daten in den <ph id="ph1">`buffers`</ph> Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen.</target>       </trans-unit>
        <trans-unit id="2124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.</target>       </trans-unit>
        <trans-unit id="2125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer.</target>       </trans-unit>
        <trans-unit id="2126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> löst das Aufrufen einer <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen.</target>       </trans-unit>
        <trans-unit id="2137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first enqueued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben das erste Datagramm Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffers`</ph> Parameter <ph id="ph2">`buffers`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates how to receive data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, wie zum Empfangen von Daten über einen verbundenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2145" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2146" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2147" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count ist 0 (null).</target>       </trans-unit>
        <trans-unit id="2148" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="2149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2150" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2151" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="2153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes of data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt die angegebene Anzahl von Datenbytes aus einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in einem Empfangspuffer, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2157" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen.</target>       </trans-unit>
        <trans-unit id="2158" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> verbindungsorientierten und verbindungslose Sockets.</target>       </trans-unit>
        <trans-unit id="2159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Diese Überladung nur mus eine Empfangspuffer, die Anzahl der Bytes, die Sie erhalten möchten, und die erforderlichen <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von den Remotehost eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry your receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie Ihre Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the <ph id="ph3">`size`</ph> parameter.</source>
          <target state="translated">Bei einem verbindungsorientierten Verwendung <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode so viele Daten wie bis zur Anzahl der vom angegebenen Bytes verfügbar ist, liest die <ph id="ph3">`size`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffer`</ph> Parameter <ph id="ph2">`buffer`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following receives the data found into <ph id="ph1">`buffer`</ph>, and specifies <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Die nachfolgenden Empfänge, die Daten in den <ph id="ph1">`buffer`</ph>, und gibt <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> für <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2178" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2179" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2180" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2181" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2182" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2185" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the received data.</source>
          <target state="translated">Eine Liste mit <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph>, die die empfangenen Daten enthält.</target>       </trans-unit>
        <trans-unit id="2186" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="2188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the list of receive buffers, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in der Liste der Empfangspuffer, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2190" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This method reads data into the <ph id="ph1">`buffers`</ph> parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Diese Methode liest Daten in den <ph id="ph1">`buffers`</ph> Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen.</target>       </trans-unit>
        <trans-unit id="2191" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können aus einem verbindungsorientierten und verbindungslose Sockets aufrufen.</target>       </trans-unit>
        <trans-unit id="2192" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires you to provide one or more receive buffers.</source>
          <target state="translated">Diese Überladung erfordert, dass Sie zur Verfügung stellen oder Empfangspuffer.</target>       </trans-unit>
        <trans-unit id="2193" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2194" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2195" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host connection established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von der Verbindung die remote-Host in Eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2196" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2197" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> löst das Aufrufen einer <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the size of the buffer.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode werden so viele Daten wie verfügbar ist, bis die Größe des Puffers zu lesen.</target>       </trans-unit>
        <trans-unit id="2204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>,<ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffers`</ph> parameter, <ph id="ph2">`buffers`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffers`</ph> Parameter <ph id="ph2">`buffers`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2211" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2212" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2213" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count is zero.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph>.Count ist 0 (null).</target>       </trans-unit>
        <trans-unit id="2214" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred while attempting to access the socket.</source>
          <target state="translated">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</target>       </trans-unit>
        <trans-unit id="2215" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2218" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Ein Array des Typs <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, bei dem es sich um den Speicherort für empfangene Daten handelt.</target>       </trans-unit>
        <trans-unit id="2219" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The location in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> to store the received data.</source>
          <target state="translated">Die Position in <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>, an der die empfangenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="2220" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2221" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2222" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Receives the specified number of bytes from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into the specified offset position of the receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt die angegebene Anzahl von Bytes aus einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an der angegebenen Offsetposition des Empfangspuffers, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2223" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> verbindungsorientierten und verbindungslose Sockets.</target>       </trans-unit>
        <trans-unit id="2226" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2227" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von den Remotehost eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2228" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2229" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2230" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2231" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2232" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2233" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2234" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>See Remarks below.</source>
          <target state="translated">Finden Sie unter "Hinweise" weiter unten.</target>       </trans-unit>
        <trans-unit id="2235" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2236" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2237" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die Size-Parameter angegeben wird.</target>       </trans-unit>
        <trans-unit id="2238" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffer`</ph> Parameter <ph id="ph2">`buffer`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Das folgende Codebeispiel gibt einen Datenpuffer, ein Offset, Größe und ein Socket-Flag vor dem Empfangen von Daten über einen verbundenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2246" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2247" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2248" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2249" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2250" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2251" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2252" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2253" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="2254" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2255" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2256" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph>-Eigenschaft wurde nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="2257" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2258" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="2259" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2260" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2263" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="2264" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Die Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die empfangenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="2265" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="2268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Receives data from a bound <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> into a receive buffer, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Empfängt Daten von einem gebundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> in einem Empfangspuffer, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2270" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method reads data into the buffer parameter and returns the number of bytes successfully read.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2271" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> from both connection-oriented and connectionless sockets.</source>
          <target state="translated">Sie können Aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> verbindungsorientierten und verbindungslose Sockets.</target>       </trans-unit>
        <trans-unit id="2272" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection prior to calling <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> zum Herstellen einer Verbindung mit remote-Host oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> auf eine eingehende Verbindung vor dem Aufruf <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2273" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will only read data that arrives from the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest nur Daten, die von den Remotehost eintreffen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2274" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you can also use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2275" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will allow you to receive data arriving from any host.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> können Sie Daten von jedem Host zu erhalten.</target>       </trans-unit>
        <trans-unit id="2276" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will block until data is available, unless a time-out value was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode blockiert, bis Daten verfügbar ist, es sei denn, ein Timeoutwert mit festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2277" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2278" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2279" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2280" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>See Remarks below.</source>
          <target state="translated">Finden Sie unter "Hinweise" weiter unten.</target>       </trans-unit>
        <trans-unit id="2281" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2282" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2283" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will read as much data as is available, up to the number of bytes specified by the size parameter.</source>
          <target state="translated">Wenn Sie einen verbindungsorientierten verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> -Methode liest so viele Daten wie verfügbar ist, bis zur Anzahl der Bytes, die Size-Parameter angegeben wird.</target>       </trans-unit>
        <trans-unit id="2284" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2285" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will read the first queued datagram from the destination address you specify in the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird die Zieladresse, die Sie, in angeben der ersten Datagrammnachricht Auslesen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2286" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the datagram you receive is larger than the size of the <ph id="ph1">`buffer`</ph> parameter, <ph id="ph2">`buffer`</ph> gets filled with the first part of the message, the excess data is lost and a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> is thrown.</source>
          <target state="translated">Ist das Datagramm Sie erhalten größer als die Größe des der <ph id="ph1">`buffer`</ph> Parameter <ph id="ph2">`buffer`</ph> gefüllt mit dem ersten Teil der Nachricht, ist die überzähligen Daten verloren und eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> ausgelöst.</target>       </trans-unit>
        <trans-unit id="2287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2291" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2292" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2293" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2294" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2295" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2296" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2297" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2298" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="2299" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2300" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2301" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property is not set.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph>-Eigenschaft ist nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="2302" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2303" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="2304" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2305" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2308" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2309" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins an asynchronous request to receive data from a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Startet eine asynchrone Anforderung, um Daten von einem verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt zu empfangen.</target>       </trans-unit>
        <trans-unit id="2310" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="2311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="2312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="2313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="2314" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> Methode wird verwendet, für verbundene Sockets oder gebundene Sockets ohne Verbindung und wird verwendet, um eingehende Daten gelesen.</target>       </trans-unit>
        <trans-unit id="2315" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Der lokale Socketadresse muss bekannt sein.</target>       </trans-unit>
        <trans-unit id="2316" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</source>
          <target state="translated">Für gebundene Sockets ohne Verbindung schränkt diese Funktion die Adressen aus dem empfangene Nachrichten akzeptiert werden.</target>       </trans-unit>
        <trans-unit id="2317" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The function only returns messages from the remote address specified in the connection.</source>
          <target state="translated">Die Funktion gibt nur Nachrichten aus der in der Verbindung angegebenen Remoteadresse.</target>       </trans-unit>
        <trans-unit id="2318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Messages from other addresses are silently discarded.</source>
          <target state="translated">Nachrichten von anderen Adressen werden automatisch verworfen.</target>       </trans-unit>
        <trans-unit id="2319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die <ph id="ph2">`e`</ph> Parameter enthält das Fenster Sockets Dienstanbieter mit zusätzlichen Informationen über die leseanforderung.</target>       </trans-unit>
        <trans-unit id="2320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="2322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> festgelegt ist</target>       </trans-unit>
        <trans-unit id="2324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> festgelegt ist</target>       </trans-unit>
        <trans-unit id="2325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="2327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Für Sockets Byte im Stream-Format verwenden werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder die intern gepufferten Daten erschöpft ist.</target>       </trans-unit>
        <trans-unit id="2328" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the <ph id="ph1">`e`</ph> parameter.</source>
          <target state="translated">Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers zugeordnet platziert die <ph id="ph1">`e`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2329" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the message is larger than the buffer, the buffer is filled with the first part of the message.</source>
          <target state="translated">Wenn die Nachricht größer als der Puffer ist, wird der Puffer mit dem ersten Teil der Nachricht gefüllt.</target>       </trans-unit>
        <trans-unit id="2330" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For connection-oriented sockets, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</source>
          <target state="translated">Für verbindungsorientierte Sockets die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveAsync%2A&gt;</ph> Methode kann ein ordnungsgemäße Beenden der virtuellen Verbindung in einer von zwei Methoden, die abhängig, ob der Socket Bytestream oder dienstorientierten Nachricht ist angeben.</target>       </trans-unit>
        <trans-unit id="2331" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</source>
          <target state="translated">Bei Bytestreams gibt 0 (null) Bytes gelesen ordnungsgemäß geschlossen werden, sodass keine weiteren Bytes mehr gelesen werden.</target>       </trans-unit>
        <trans-unit id="2332" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, where a zero byte message is often allowable, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</source>
          <target state="translated">Für nachrichtenorientierter Sockets, in dem eine 0 (null) Bytes Nachricht häufig zulässige ist, eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> auf den systemeigenen WSAEDISCON Winsock-Fehlercode (10101) wird verwendet, um ordnungsgemäß geschlossen anzugeben.</target>       </trans-unit>
        <trans-unit id="2333" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In any case, a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</source>
          <target state="translated">In jedem Fall eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> der systemeigenen Winsock WSAECONNRESET Fehlercode (10054) zeigt an einem abbrechenden schließen aufgetreten.</target>       </trans-unit>
        <trans-unit id="2334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An argument was invalid.</source>
          <target state="translated">Ein Argument war ungültig.</target>       </trans-unit>
        <trans-unit id="2335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph>-Eigenschaft oder <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph>-Eigenschaft des <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Parameters muss auf gültige Puffer verweisen.</target>       </trans-unit>
        <trans-unit id="2336" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</target>       </trans-unit>
        <trans-unit id="2337" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="2338" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="2339" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2340" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2341" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Gets or sets a value that specifies the size of the receive buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der die Größe des Empfangspuffers des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> angibt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="2342" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the receive buffer.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, das die Größe des Empfangspuffer in Bytes enthält.</target>       </trans-unit>
        <trans-unit id="2343" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">Der Standard ist 8192.</target>       </trans-unit>
        <trans-unit id="2344" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</source>
          <target state="translated">Ein größeren Puffer potenziell reduziert die Anzahl der leeren Bestätigungen (TCP-Paketen mit keine Datenteil), aber möglicherweise auch dann verzögern, die Erkennung von Problemen bei der Verbindung.</target>       </trans-unit>
        <trans-unit id="2345" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Erhöhen Sie die Größe des Puffers, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. ein Satellit Breitband-Anbieter.)</target>       </trans-unit>
        <trans-unit id="2346" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2347" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2348" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2349" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2350" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Receives a datagram and stores the source endpoint.</source>
          <target state="translated">Empfängt ein Datagramm und speichert den Endpunkt der Quelle.</target>       </trans-unit>
        <trans-unit id="2351" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Ein Array des Typs <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, bei dem es sich um den Speicherort für empfangene Daten handelt.</target>       </trans-unit>
        <trans-unit id="2352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Ein als Verweis übergebener <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Remoteserver darstellt.</target>       </trans-unit>
        <trans-unit id="2353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer and stores the endpoint.</source>
          <target state="translated">Empfängt ein Datagramm im Datenpuffer und speichert den Endpunkt.</target>       </trans-unit>
        <trans-unit id="2354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2355" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden.</target>       </trans-unit>
        <trans-unit id="2356" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.</target>       </trans-unit>
        <trans-unit id="2357" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive <ph id="ph1">`buffer`</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Diese Überladung erfordert nur eine Receive-Anweisung bereitstellen <ph id="ph1">`buffer`</ph>, und ein <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> , der den Remotehost darstellt.</target>       </trans-unit>
        <trans-unit id="2358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Der Pufferoffset hat den Standardwert 0.</target>       </trans-unit>
        <trans-unit id="2359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The size defaults to the length of the <ph id="ph1">`buffer`</ph> parameter and the <ph id="ph2">`socketFlags`</ph> value defaults to <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</source>
          <target state="translated">Die Standardgröße der Länge der <ph id="ph1">`buffer`</ph> Parameter und die <ph id="ph2">`socketFlags`</ph> -Wert wird standardmäßig <ph id="ph3">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, müssen Sie explizit Binden der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keinen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Mit verbindungslose Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen.</target>       </trans-unit>
        <trans-unit id="2363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Datagramm Sie erhalten größer als die Größe des <ph id="ph1">`buffer`</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode füllt <ph id="ph3">`buffer`</ph> mit so viel wie möglich und löst der Meldung ein <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten.</target>       </trans-unit>
        <trans-unit id="2365" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode mit einer ausreichend großen Puffer.</target>       </trans-unit>
        <trans-unit id="2366" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2367" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2368" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2369" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2370" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll.</target>       </trans-unit>
        <trans-unit id="2371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode erhalten Sie eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">In diesen Fällen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Mit verbindungsorientierte Sockets <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest so viele Daten bis zur Größe des verfügbaren <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> muss übereinstimmen der <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2383" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2384" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2385" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2386" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2387" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2388" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for the received data.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das der Speicherort für die empfangenen Daten ist.</target>       </trans-unit>
        <trans-unit id="2392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Ein als Verweis übergebener <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Remoteserver darstellt.</target>       </trans-unit>
        <trans-unit id="2394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives a datagram into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Empfängt mithilfe der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> ein Datagramm im Datenpuffer und speichert den Endpunkt.</target>       </trans-unit>
        <trans-unit id="2395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2396" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden.</target>       </trans-unit>
        <trans-unit id="2397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.</target>       </trans-unit>
        <trans-unit id="2398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Diese Überladung erfordert nur einen Empfangspuffer, die erforderlichen bereitstellen <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, und ein <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> , der den Remotehost darstellt.</target>       </trans-unit>
        <trans-unit id="2399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset defaults to 0 and the size defaults to the length of the buffer parameter.</source>
          <target state="translated">Der Offset der Standardwert ist 0 und der Größe der Standardwert ist die Länge des Pufferparameters.</target>       </trans-unit>
        <trans-unit id="2400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, müssen Sie explizit Binden der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keinen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Mit verbindungslose Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen.</target>       </trans-unit>
        <trans-unit id="2403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Datagramm Sie erhalten größer als die Größe des <ph id="ph1">`buffer`</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode füllt <ph id="ph3">`buffer`</ph> mit so viel wie möglich und löst der Meldung ein <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten.</target>       </trans-unit>
        <trans-unit id="2405" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode mit einer ausreichend großen Puffer.</target>       </trans-unit>
        <trans-unit id="2406" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2407" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2408" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2409" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll.</target>       </trans-unit>
        <trans-unit id="2411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode erhalten Sie eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">In diesen Fällen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the size of <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Mit verbindungsorientierte Sockets <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest so viele Daten bis zur Größe des verfügbaren <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="2416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> muss übereinstimmen der <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> zum Übergeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2424" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2425" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2426" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2427" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2428" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2429" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2432" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Ein Array des Typs <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, bei dem es sich um den Speicherort für empfangene Daten handelt.</target>       </trans-unit>
        <trans-unit id="2433" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2434" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2435" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Ein als Verweis übergebener <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Remoteserver darstellt.</target>       </trans-unit>
        <trans-unit id="2436" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes into the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Empfängt mithilfe der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> die angegebene Anzahl von Bytes im Datenpuffer und speichert den Endpunkt.</target>       </trans-unit>
        <trans-unit id="2437" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden.</target>       </trans-unit>
        <trans-unit id="2439" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.</target>       </trans-unit>
        <trans-unit id="2440" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, and an <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that represents the remote host.</source>
          <target state="translated">Diese Überladung erfordert nur einen Empfangspuffer, die Anzahl der Bytes Geben Sie erhalten möchten, die erforderlichen <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>, und ein <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> , der den Remotehost darstellt.</target>       </trans-unit>
        <trans-unit id="2441" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer offset defaults to 0.</source>
          <target state="translated">Der Pufferoffset hat den Standardwert 0.</target>       </trans-unit>
        <trans-unit id="2442" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Mit verbindungslose Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen.</target>       </trans-unit>
        <trans-unit id="2443" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Datagramm Sie erhalten größer als die Größe des <ph id="ph1">`buffer`</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode füllt <ph id="ph3">`buffer`</ph> mit so viel wie möglich und löst der Meldung ein <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2444" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten.</target>       </trans-unit>
        <trans-unit id="2445" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode mit einer ausreichend großen Puffer.</target>       </trans-unit>
        <trans-unit id="2446" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2447" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2448" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2449" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2450" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll.</target>       </trans-unit>
        <trans-unit id="2451" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2452" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode erhalten Sie eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2453" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2454" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">In diesen Fällen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2455" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the number of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Mit verbindungsorientierte Sockets <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest so viel verfügbaren Daten bis zur Anzahl der Bytes, die gemäß der <ph id="ph2">`size`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2456" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2457" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, müssen Sie explizit Binden der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2458" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keinen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2459" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2460" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2461" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> muss übereinstimmen der <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2462" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2463" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2464" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2465" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Die Größe des Puffers und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> übergeben werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2466" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2467" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2468" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2469" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2470" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2471" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2472" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2473" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2474" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph>-Eigenschaft wurde nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="2475" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2476" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="2477" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2478" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="2479" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2480" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2481" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Ein Array des Typs <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, bei dem es sich um den Speicherort für empfangene Daten handelt.</target>       </trans-unit>
        <trans-unit id="2482" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Die Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die empfangenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="2483" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2484" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2485" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Ein als Verweis übergebener <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Remoteserver darstellt.</target>       </trans-unit>
        <trans-unit id="2486" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint.</source>
          <target state="translated">Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> und speichert den Endpunkt.</target>       </trans-unit>
        <trans-unit id="2487" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2488" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden.</target>       </trans-unit>
        <trans-unit id="2489" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</source>
          <target state="translated">Diese Methode ist nützlich, wenn Sie beabsichtigen, die von einem unbekannten Host oder mehreren Hosts verbindungslosen Datagramme zu empfangen.</target>       </trans-unit>
        <trans-unit id="2490" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read the first enqueued datagram received into the local network buffer.</source>
          <target state="translated">Mit verbindungslose Protokolle <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest das erste Datagramm im lokalen Netzwerk Puffer empfangen.</target>       </trans-unit>
        <trans-unit id="2491" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the datagram you receive is larger than the size of <ph id="ph1">`buffer`</ph>, the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will fill <ph id="ph3">`buffer`</ph> with as much of the message as is possible, and throw a <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Datagramm Sie erhalten größer als die Größe des <ph id="ph1">`buffer`</ph>, die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode füllt <ph id="ph3">`buffer`</ph> mit so viel wie möglich und löst der Meldung ein <ph id="ph4">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2492" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using an unreliable protocol, the excess data will be lost.</source>
          <target state="translated">Bei Verwendung einer unzuverlässigen Protokoll verloren die überzähligen Daten.</target>       </trans-unit>
        <trans-unit id="2493" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method with a large enough buffer.</source>
          <target state="translated">Wenn Sie ein zuverlässiges Protokoll verwenden, die Daten vom Dienstanbieter zurückgehalten werden und können durch den Aufruf abgerufen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode mit einer ausreichend großen Puffer.</target>       </trans-unit>
        <trans-unit id="2494" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If no data is available for reading, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will block until data is available.</source>
          <target state="translated">Wenn keine Daten für das Lesen, ist die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode blockiert, bis Daten verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2495" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie in nicht blockierend Modus, und es keine Daten in sind der in der Protokoll-Stack-Puffer der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2496" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> property to determine if data is available for reading.</source>
          <target state="translated">Sie können die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> Eigenschaft, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2497" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>When <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> is non-zero, retry the receive operation.</source>
          <target state="translated">Wenn <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Available%2A&gt;</ph> ist ungleich NULL ist, wiederholen Sie den Empfangsvorgang.</target>       </trans-unit>
        <trans-unit id="2498" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Although <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</source>
          <target state="translated">Obwohl <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll.</target>       </trans-unit>
        <trans-unit id="2499" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you choose to do so, you must first either establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming remote host connection by calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie sich dazu entschließen, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2500" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not establish or accept a connection before calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method, you will get a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht herstellen oder eine Verbindung vor dem Aufruf akzeptieren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode erhalten Sie eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2501" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2502" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>In either of these cases, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only receive data from the connected or default remote host.</source>
          <target state="translated">In diesen Fällen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> -Methode ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Daten aus verbundenen oder Standard-Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2503" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>With connection-oriented sockets, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will read as much data as is available up to the amount of bytes specified by the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Mit verbindungsorientierte Sockets <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> liest so viel verfügbaren Daten bis zu die Anzahl der Bytes, die gemäß der <ph id="ph2">`size`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2504" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If the remote host shuts down the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> connection with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, and all available data has been Received, the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method will complete immediately and return zero bytes.</source>
          <target state="translated">Wenn der remote-Host heruntergefahren der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Verbindung mit der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, und alle verfügbaren Daten empfangen wurden, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode sofort beendet und gibt 0 (null) Bytes zurück.</target>       </trans-unit>
        <trans-unit id="2505" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Before calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, you must explicitly bind the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> to a local endpoint using the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Vor dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph>, müssen Sie explizit Binden der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> in einen lokalen Endpunkt mit der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2506" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you do not, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keinen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2507" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2508" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2509" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> muss übereinstimmen der <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2510" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2511" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2512" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The following code example receives a connectionless datagram from a remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.</target>       </trans-unit>
        <trans-unit id="2513" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The offset, buffer size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> method.</source>
          <target state="translated">Der Offset, die Puffergröße und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> übergeben werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2514" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2515" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2516" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2517" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2518" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2519" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2520" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2521" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2522" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2523" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des offset-Parameters.</target>       </trans-unit>
        <trans-unit id="2524" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2525" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2526" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph>-Eigenschaft wurde nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="2527" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2528" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2529" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2530" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2531" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2532" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2533" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive data from a specified network device.</source>
          <target state="translated">Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</target>       </trans-unit>
        <trans-unit id="2534" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="2535" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="2536" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="2537" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="2538" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method is used primarily to receive data on a connectionless socket.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> Methode wird in erster Linie zum Empfangen von Daten auf einem verbindungslosen Socket verwendet.</target>       </trans-unit>
        <trans-unit id="2539" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Der lokale Socketadresse muss bekannt sein.</target>       </trans-unit>
        <trans-unit id="2540" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">Der Aufrufer muss Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um die <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> des Remotehosts, aus dem die Daten empfangen werden soll.</target>       </trans-unit>
        <trans-unit id="2541" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the read request.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die <ph id="ph2">`e`</ph> Parameter enthält das Fenster Sockets Dienstanbieter mit zusätzlichen Informationen über die leseanforderung.</target>       </trans-unit>
        <trans-unit id="2542" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2543" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="2544" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2545" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="2546" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers eingefügt.</target>       </trans-unit>
        <trans-unit id="2547" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.</target>       </trans-unit>
        <trans-unit id="2548" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For byte stream–style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</source>
          <target state="translated">Für Byte-Datenstrom Stil Sockets werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder die intern gepufferten Daten erschöpft ist.</target>       </trans-unit>
        <trans-unit id="2549" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.</target>       </trans-unit>
        <trans-unit id="2550" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> darf nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="2551" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="2552" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="2553" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2554" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2555" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that is the storage location for received data.</source>
          <target state="translated">Ein Array des Typs <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, bei dem es sich um den Speicherort für empfangene Daten handelt.</target>       </trans-unit>
        <trans-unit id="2556" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The position in the <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept> parameter to store the received data.</source>
          <target state="translated">Die Position im <bpt id="p1">&lt;c&gt;</bpt>buffer<ept id="p1">&lt;/c&gt;</ept>-Parameter, an der die empfangenen Daten gespeichert werden sollen.</target>       </trans-unit>
        <trans-unit id="2557" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes to receive.</source>
          <target state="translated">Die Anzahl der zu empfangenden Bytes.</target>       </trans-unit>
        <trans-unit id="2558" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2559" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, passed by reference, that represents the remote server.</source>
          <target state="translated">Ein als Verweis übergebener <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Remoteserver darstellt.</target>       </trans-unit>
        <trans-unit id="2560" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph> holding address and interface information.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.IPPacketInformation" /&gt;</ph>-Objekt, das Adress- und Schnittstelleninformationen enthält.</target>       </trans-unit>
        <trans-unit id="2561" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> und speichert die Endpunkt- und Paketinformationen.</target>       </trans-unit>
        <trans-unit id="2562" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The number of bytes received.</source>
          <target state="translated">Die Anzahl der empfangenen Bytes.</target>       </trans-unit>
        <trans-unit id="2563" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method reads data into the <ph id="ph2">`buffer`</ph> parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> -Methode liest Daten in den <ph id="ph2">`buffer`</ph> Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten, sowie Informationen über das empfangene Paket gesendet wurden.</target>       </trans-unit>
        <trans-unit id="2564" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> Methode wird in erster Linie zum Empfangen von Nachrichtendaten auf einem verbindungslosen Socket verwendet.</target>       </trans-unit>
        <trans-unit id="2565" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Der lokale Socketadresse muss bekannt sein.</target>       </trans-unit>
        <trans-unit id="2566" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden.</target>       </trans-unit>
        <trans-unit id="2567" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">Der Socket muss initialisiert werden, mit der Socket <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> vor dem Aufrufen dieser Methode.</target>       </trans-unit>
        <trans-unit id="2568" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Dies ist möglich, wenn der Socket erstellt wurde, mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2569" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For message-oriented sockets, an incoming message is placed into the <ph id="ph1">`buffer`</ph> parameter up to the total size specified in the <ph id="ph2">`size`</ph> parameter.</source>
          <target state="translated">Für Sockets nachrichtenorientierter befindet sich eine eingehende Nachricht in die <ph id="ph1">`buffer`</ph> Parameter bis zu der Gesamtgröße angegeben, der <ph id="ph2">`size`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2570" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">`offset`</ph> parameter determines where in the <ph id="ph2">`buffer`</ph> the data is placed.</source>
          <target state="translated">Die <ph id="ph1">`offset`</ph> Parameter bestimmt, wo in der <ph id="ph2">`buffer`</ph> Daten befindet.</target>       </trans-unit>
        <trans-unit id="2571" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The actual amount of data placed into the <ph id="ph1">`buffer`</ph> is returned by the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method.</source>
          <target state="translated">Die tatsächliche Datenmenge platziert, in der <ph id="ph1">`buffer`</ph> wird zurückgegeben, durch die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2572" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method automatically method sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> -Methode legt automatisch die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> Socketoption auf <ph id="ph3">`true`</ph> beim ersten für Aufruf eine angegebene <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2573" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>However, the returned <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">Allerdings das zurückgegebene <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekt ist nur für Pakete, die auf dem lokalen Computer ankommen, nachdem die Socketoption festgelegt wurde ungültig wird.</target>       </trans-unit>
        <trans-unit id="2574" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and its first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> method will return invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Wenn ein Socket Pakete zwischen gesendet wird, wenn es an einen lokalen Endpunkt gebunden ist (explizit durch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode oder implizit durch einen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> Methoden) und dem ersten Aufruf der <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> Methodenaufrufe <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A&gt;</ph> wird Methodenrückgabewert ungültige <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekte für diese Pakete.</target>       </trans-unit>
        <trans-unit id="2575" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Um sicherzustellen, dass alle <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekte gültig sind, sollte eine Anwendung festlegen, die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> Socketoption auf <ph id="ph3">`true`</ph> , bevor sie an einen lokalen Endpunkt gebunden ist die <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2576" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An application can examine the <ph id="ph1">`ipPacketInformation`</ph> parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Eine Anwendung kann Untersuchen der <ph id="ph1">`ipPacketInformation`</ph> Parameter an, wenn sie wissen muss, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.</target>       </trans-unit>
        <trans-unit id="2577" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> needs to match the <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> of the <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> used in <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ReceiveFrom%2A&gt;</ph> muss übereinstimmen der <ph id="ph4">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph> von der <ph id="ph5">&lt;xref:System.Net.EndPoint&gt;</ph> verwendet <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2578" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2579" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2580" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2581" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">\-</ph> or-</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="2582" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2583" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2584" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2585" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2586" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2587" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2588" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2589" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of the <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the offset parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des offset-Parameters.</target>       </trans-unit>
        <trans-unit id="2590" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2591" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2592" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph> property was not set.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /&gt;</ph>-Eigenschaft wurde nicht festgelegt.</target>       </trans-unit>
        <trans-unit id="2593" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2594" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The .NET Framework is running on an AMD 64-bit processor.</source>
          <target state="translated">.NET Framework wird mit einem AMD 64 Bit-Prozessor ausgeführt.</target>       </trans-unit>
        <trans-unit id="2595" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2596" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2597" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2598" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>The operating system is Windows 2000 or earlier, and this method requires Windows XP.</source>
          <target state="translated">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</target>       </trans-unit>
        <trans-unit id="2599" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>for accepting connections from the network.</source>
          <target state="translated">zum Akzeptieren von Verbindungen über das Netzwerk.</target>       </trans-unit>
        <trans-unit id="2600" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)">
          <source>Associated enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph>.</source>
          <target state="translated">Zugeordnete Enumeration: <ph id="ph1">&lt;see cref="F:System.Net.NetworkAccess.Accept" /&gt;</ph></target>       </trans-unit>
        <trans-unit id="2601" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2602" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph>, and stores the endpoint and packet information.</source>
          <target state="translated">Beginnt unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /&gt;</ph> den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</target>       </trans-unit>
        <trans-unit id="2603" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="2604" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="2605" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="2606" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="2607" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method is used primarily to receive message data on a connectionless socket.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> Methode wird in erster Linie zum Empfangen von Nachrichtendaten auf einem verbindungslosen Socket verwendet.</target>       </trans-unit>
        <trans-unit id="2608" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket's local address must be known.</source>
          <target state="translated">Der lokale Socketadresse muss bekannt sein.</target>       </trans-unit>
        <trans-unit id="2609" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can only be used with datagram and raw sockets.</source>
          <target state="translated">Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden.</target>       </trans-unit>
        <trans-unit id="2610" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The socket must be initialized with the socket type set to <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> before calling this method.</source>
          <target state="translated">Der Socket muss initialisiert werden, mit der Socket <ph id="ph1">&lt;xref:System.Net.Sockets.SocketType.Dgram&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType.Raw&gt;</ph> vor dem Aufrufen dieser Methode.</target>       </trans-unit>
        <trans-unit id="2611" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This can be done when the socket is constructed using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</source>
          <target state="translated">Dies ist möglich, wenn der Socket erstellt wurde, mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.%23ctor%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2612" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller must set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property to the <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> of the remote host from which the data is to be received.</source>
          <target state="translated">Der Aufrufer muss Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um die <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> des Remotehosts, aus dem die Daten empfangen werden soll.</target>       </trans-unit>
        <trans-unit id="2613" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="2614" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2615" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="2616" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</source>
          <target state="translated">Für nachrichtenorientierter Sockets wird eine eingehende Nachricht in den Puffer bis zu der Gesamtgröße des Puffers eingefügt.</target>       </trans-unit>
        <trans-unit id="2617" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> properties determine where in the buffer the data is placed and the amount of data.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.</target>       </trans-unit>
        <trans-unit id="2618" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method automatically sets the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to <ph id="ph3">`true`</ph> the first time it is called for a given <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> -Methode legt automatisch die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> Socketoption auf <ph id="ph3">`true`</ph> zum ersten Mal er, für aufgerufen wird einen angegebenen <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2619" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>However, the <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> object will only be valid for packets which arrive at the local computer after the socket option has been set.</source>
          <target state="translated">Allerdings die <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekt ist nur für Pakete, die auf dem lokalen Computer ankommen, nachdem die Socketoption festgelegt wurde ungültig wird.</target>       </trans-unit>
        <trans-unit id="2620" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method or implicitly by one of the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, or <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> methods) and the first call to the <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method, calls to <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> method will result in invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects for these packets.</source>
          <target state="translated">Wenn ein Socket Pakete zwischen gesendet wird, wenn der Socket an einen lokalen Endpunkt gebunden ist (explizit durch die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode oder implizit durch eine von der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, oder <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> Methoden) und der erste Aufruf der <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph>Methodenaufrufe <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A&gt;</ph> Methode führt dazu, Invalid <ph id="ph8">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekte für diese Pakete.</target>       </trans-unit>
        <trans-unit id="2621" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To ensure that all <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects are valid, an application should set the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> socket option to<ph id="ph3">`true`</ph> before it is bound to a local endpoint using the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> method.</source>
          <target state="translated">Um sicherzustellen, dass alle <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekte gültig sind, sollte eine Anwendung festlegen, die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.PacketInformation&gt;</ph> Socketoption auf<ph id="ph3">`true`</ph> , bevor sie an einen lokalen Endpunkt gebunden ist die <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2622" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An application can examine the resulting <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</source>
          <target state="translated">Eine Anwendung kann die resultierende untersuchen <ph id="ph1">&lt;xref:System.Net.Sockets.IPPacketInformation&gt;</ph> Objekten zurück, wenn sie wissen muss, ob das Datagramm mit einer Unicast-, Multicast- oder Broadcastnetzwerkverkehr gesendet wurde.</target>       </trans-unit>
        <trans-unit id="2623" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> darf nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="2624" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="2625" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2626" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2627" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph> call will time out.</source>
          <target state="translated">Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Receive" /&gt;</ph>-Aufrufs angibt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="2628" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">Der Timeoutwert in Millisekunden.</target>       </trans-unit>
        <trans-unit id="2629" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an.</target>       </trans-unit>
        <trans-unit id="2630" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</target>       </trans-unit>
        <trans-unit id="2631" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> calls only.</source>
          <target state="translated">Diese Option gilt für synchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> nur aufruft.</target>       </trans-unit>
        <trans-unit id="2632" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Timeoutintervall überschritten wird, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2633" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.ReceiveTimeout%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2634" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2635" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2636" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.ReceiveTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</target>       </trans-unit>
        <trans-unit id="2637" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>Gets the remote endpoint.</source>
          <target state="translated">Ruft den Remoteendpunkt ab.</target>       </trans-unit>
        <trans-unit id="2638" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> with which the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is communicating.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, mit dem der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> kommuniziert.</target>       </trans-unit>
        <trans-unit id="2639" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> property gets the <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> that contains the remote IP address and port number to which the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is connected.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> -Eigenschaft ruft die <ph id="ph2">&lt;xref:System.Net.EndPoint&gt;</ph> , enthält die remote-IP-Adresse und Anschlussnummer Zahl an, die <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> verbunden ist.</target>       </trans-unit>
        <trans-unit id="2640" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you are using a connectionless protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> contains the default remote IP address and port number with which the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> will communicate.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> enthält die standardmäßige remote IP-Adresse und Port-Nummer, mit denen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> kommuniziert.</target>       </trans-unit>
        <trans-unit id="2641" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You must cast this <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> to an <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> before retrieving any information.</source>
          <target state="translated">Müssen Sie eine Umwandlung dies <ph id="ph1">&lt;xref:System.Net.EndPoint&gt;</ph> auf eine <ph id="ph2">&lt;xref:System.Net.IPEndPoint&gt;</ph> vor dem Abrufen von Informationen.</target>       </trans-unit>
        <trans-unit id="2642" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>You can then call the <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, and the <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> method to retrieve the remote port number.</source>
          <target state="translated">Rufen Sie dann die <ph id="ph1">&lt;xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType&gt;</ph> Methode zum Abrufen der entfernten <ph id="ph2">&lt;xref:System.Net.IPAddress&gt;</ph>, und die <ph id="ph3">&lt;xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType&gt;</ph> Methode, um die Nummer des Remoteports abzurufen.</target>       </trans-unit>
        <trans-unit id="2643" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> is set after a call to either <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> festgelegt ist, nach einem Aufruf von entweder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2644" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you try to access this property earlier, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie versuchen, Zugriff auf diese Eigenschaft zuvor <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.RemoteEndPoint%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2645" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2646" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2647" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2648" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2649" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The following code example retrieves and displays the local and remote endpoints.</source>
          <target state="translated">Im folgenden Codebeispiel wird abgerufen, und die lokalen und Remoteendpunkte angezeigt.</target>       </trans-unit>
        <trans-unit id="2650" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2651" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.RemoteEndPoint">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2652" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for readability.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> von <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Instanzen, bei denen geprüft werden soll, ob sie gelesen werden können.</target>       </trans-unit>
        <trans-unit id="2653" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for writability.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> von <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Instanzen, bei denen geprüft werden soll, ob in sie geschrieben werden kann.</target>       </trans-unit>
        <trans-unit id="2654" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> of <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> instances to check for errors.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Collections.IList" /&gt;</ph> von <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Instanzen, die auf Fehler überprüft werden sollen.</target>       </trans-unit>
        <trans-unit id="2655" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The time-out value, in microseconds.</source>
          <target state="translated">Der Timeoutwert in Mikrosekunden.</target>       </trans-unit>
        <trans-unit id="2656" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>A -1 value indicates an infinite time-out.</source>
          <target state="translated">Ein Wert von -1 gibt ein unendliches Timeout an.</target>       </trans-unit>
        <trans-unit id="2657" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Determines the status of one or more sockets.</source>
          <target state="translated">Bestimmt den Status von einem oder mehreren Sockets.</target>       </trans-unit>
        <trans-unit id="2658" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> is a static method that determines the status of one or more <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instances.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> ist eine statische Methode, die den Status einer oder mehrerer bestimmt <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanzen.</target>       </trans-unit>
        <trans-unit id="2659" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must place one or more sockets into an <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> before you can use the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> method.</source>
          <target state="translated">Richten Sie eine oder mehrere Sockets in einer <ph id="ph1">&lt;xref:System.Collections.IList&gt;</ph> vor der Verwendung der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2660" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Check for readability by calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> with the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> as the <ph id="ph3">`checkRead`</ph> parameter.</source>
          <target state="translated">Überprüfen Sie zur besseren Lesbarkeit durch Aufrufen von <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> mit der <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> als die <ph id="ph3">`checkRead`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2661" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>To check your sockets for writability, use the <ph id="ph1">`checkWrite`</ph> parameter.</source>
          <target state="translated">Verwenden Sie zum Überprüfen Ihrer Sockets können die <ph id="ph1">`checkWrite`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="2662" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>For detecting error conditions, use <ph id="ph1">`checkError`</ph>.</source>
          <target state="translated">Verwenden Sie Fehlerzustände zu erkennen, <ph id="ph1">`checkError`</ph>.</target>       </trans-unit>
        <trans-unit id="2663" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>, the <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> will be filled with only those sockets that satisfy the conditions.</source>
          <target state="translated">Nach dem Aufruf <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph>die <ph id="ph2">&lt;xref:System.Collections.IList&gt;</ph> ausgefüllt mit nur diese Sockets, die die Bedingung erfüllen.</target>       </trans-unit>
        <trans-unit id="2664" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you are in a listening state, readability means that a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> will succeed without blocking.</source>
          <target state="translated">Wenn Sie in einem Wartezustand befinden, Lesbarkeit bedeutet, dass einen Aufruf von <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> wird erfolgreich ausgeführt, ohne zu blockieren.</target>       </trans-unit>
        <trans-unit id="2665" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have already accepted the connection, readability means that data is available for reading.</source>
          <target state="translated">Wenn Sie die Verbindung bereits akzeptiert haben, bedeutet die Lesbarkeit, dass Daten zum Lesen verfügbar sind.</target>       </trans-unit>
        <trans-unit id="2666" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>In these cases, all receive operations will succeed without blocking.</source>
          <target state="translated">In diesen Fällen werden alle Empfangsvorgänge wird erfolgreich ausgeführt, ohne zu blockieren.</target>       </trans-unit>
        <trans-unit id="2667" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Readability can also indicate whether the remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> has shut down the connection; in that case a call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> will return immediately, with zero bytes returned.</source>
          <target state="translated">Lesbarkeit kann auch darauf hinweisen, ob die Remote <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wurde die Verbindung; in diesem Fall heruntergefahren einen Aufruf von <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> wird sofort zurückgegeben werden, und 0 (null) Bytes zurückgegeben.</target>       </trans-unit>
        <trans-unit id="2668" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> returns when at least one of the sockets of interest (the sockets in the <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, and <ph id="ph4">`checkError`</ph> lists) meets its specified criteria, or the <ph id="ph5">`microSeconds`</ph> parameter is exceeded, whichever comes first.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> Gibt zurück, wenn mindestens eines der Sockets von Interesse sind (die Sockets in der <ph id="ph2">`checkRead`</ph>, <ph id="ph3">`checkWrite`</ph>, und <ph id="ph4">`checkError`</ph> aufgeführt) die angegebenen Kriterien erfüllt oder <ph id="ph5">`microSeconds`</ph> Parameter überschritten wird, welcher Fall zuerst eintritt.</target>       </trans-unit>
        <trans-unit id="2669" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Setting <ph id="ph1">`microSeconds`</ph> to -1 specifies an infinite time-out.</source>
          <target state="translated">Festlegen von <ph id="ph1">`microSeconds`</ph> auf-1 gibt ein unbegrenztes Timeout.</target>       </trans-unit>
        <trans-unit id="2670" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you make a nonblocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, writability means that you have connected successfully.</source>
          <target state="translated">Wenn Sie einen nicht blockierenden Aufruf vornehmen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, Schreibberechtigung bedeutet, dass Sie erfolgreich eine Verbindung hergestellt haben.</target>       </trans-unit>
        <trans-unit id="2671" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you already have a connection established, writability means that all send operations will succeed without blocking.</source>
          <target state="translated">Wenn Sie bereits eine Verbindung hergestellt haben, also können alle senden, ohne Blockierung Vorgänge werden zwar erfolgreich ausgeführt werden.</target>       </trans-unit>
        <trans-unit id="2672" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you have made a non-blocking call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, the <ph id="ph2">`checkerror`</ph> parameter identifies sockets that have not connected successfully.</source>
          <target state="translated">Wenn Sie einen nicht blockierenden Aufruf vorgenommen haben <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>die <ph id="ph2">`checkerror`</ph> Parameter identifiziert Sockets, die nicht verbunden.</target>       </trans-unit>
        <trans-unit id="2673" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>Use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> method if you only want to determine the status of a single <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Poll%2A&gt;</ph> Methode, wenn Sie nur den Status einer einzelnen bestimmen möchten <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2674" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</source>
          <target state="translated">Diese Methode nicht erkannt werden bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde.</target>       </trans-unit>
        <trans-unit id="2675" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>You must attempt to send or receive data to detect these kinds of errors.</source>
          <target state="translated">Sie müssen versuchen zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.</target>       </trans-unit>
        <trans-unit id="2676" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2677" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2678" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> to determine which listening sockets have a connection request.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Select%2A&gt;</ph> um zu bestimmen, welche empfangsbereiten Sockets eine verbindungsanforderung haben.</target>       </trans-unit>
        <trans-unit id="2679" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="checkRead" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder leer.</target>       </trans-unit>
        <trans-unit id="2680" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="2681" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="checkWrite" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder leer.</target>       </trans-unit>
        <trans-unit id="2682" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>-and-</source>
          <target state="translated">- und -</target>       </trans-unit>
        <trans-unit id="2683" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>The <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph> parameter is <ph id="ph2">&lt;see langword="null" /&gt;</ph> or empty.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="checkError" /&gt;</ph>-Parameter ist <ph id="ph2">&lt;see langword="null" /&gt;</ph> oder leer.</target>       </trans-unit>
        <trans-unit id="2684" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2685" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2686" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="2687" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2688" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2689" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sendet Daten synchron mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten.</target>       </trans-unit>
        <trans-unit id="2690" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2691" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This overload requires a buffer that contains the data you want to send.</source>
          <target state="translated">Diese Überladung muss es sich um einen Puffer, der die Daten enthält, die Sie senden möchten.</target>       </trans-unit>
        <trans-unit id="2692" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> Wert hat den Standardwert 0, der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes, die Standardwerte auf die Größe des Puffers zu senden.</target>       </trans-unit>
        <trans-unit id="2693" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2694" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2695" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2696" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2697" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2698" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2699" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2700" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2701" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2702" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2703" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2704" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2705" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2706" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2707" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2708" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2709" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2710" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2711" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2712" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2713" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2714" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2715" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2716" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Eine Liste von <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> mit den zu sendenden Daten.</target>       </trans-unit>
        <trans-unit id="2717" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet den Satz der Puffer in der Liste an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2718" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2719" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2720" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten.</target>       </trans-unit>
        <trans-unit id="2721" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2722" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2723" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2724" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2725" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2726" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2727" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2728" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2729" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2730" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2731" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2732" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2733" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2734" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2735" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2736" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2737" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2738" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2739" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2740" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2741" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="2742" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2743" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>See remarks section below.</source>
          <target state="translated">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</target>       </trans-unit>
        <trans-unit id="2744" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2745" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="2746" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2747" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>Sends data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten mithilfe der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an einen verbundenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2748" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2749" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sendet Daten synchron an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten.</target>       </trans-unit>
        <trans-unit id="2750" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode kann bei einem verbindungsorientierten und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2751" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Diese Überladung muss ein Puffer mit den Daten gesendet werden soll und eine bitweise Kombination von <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2752" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</source>
          <target state="translated">Der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes, die Standardwerte auf die Größe des Puffers zu senden.</target>       </trans-unit>
        <trans-unit id="2753" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter value, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameterwert, der die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2754" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2755" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2756" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2757" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jeder Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2758" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2759" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2760" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2761" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2762" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2763" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="2764" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2765" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2766" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2767" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="2768" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2769" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2770" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2771" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2772" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2773" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2774" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2775" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The following code example demonstrates sending data on a connected <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2776" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2777" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2778" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2779" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Eine Liste von <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> mit den zu sendenden Daten.</target>       </trans-unit>
        <trans-unit id="2780" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2781" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an einen verbundenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2782" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2783" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten.</target>       </trans-unit>
        <trans-unit id="2784" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig auf 0.</target>       </trans-unit>
        <trans-unit id="2785" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketFlags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2786" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2787" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2788" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2789" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2790" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2791" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2792" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2793" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2794" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">Im Modus nicht blockierend <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2795" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2796" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2797" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2798" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2799" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2800" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2801" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2802" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2803" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2804" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2805" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2806" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="2807" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2808" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2809" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="2810" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="2811" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2812" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, wobei die angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="2813" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2814" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sendet Daten synchron an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten.</target>       </trans-unit>
        <trans-unit id="2815" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2816" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Diese Überladung muss ein Puffer mit den Daten zu senden, die Anzahl der Bytes, die Sie senden möchten, und eine bitweise Kombination von <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2817" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2818" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2819" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2820" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2821" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method before each call to the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jeder Aufruf von der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2822" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2823" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2824" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>With a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Mit einem verbindungsorientiertes Protokoll <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2825" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2826" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern.</target>       </trans-unit>
        <trans-unit id="2827" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="2828" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2829" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2830" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2831" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen sicherstellen, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="2832" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2833" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2834" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2835" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2836" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2837" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2838" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2839" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example sends the data found in buffer, and specifies <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel sendet die Daten in Puffer und gibt <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.None&gt;</ph> für <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2840" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2841" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0 or exceeds the size of the buffer.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als 0 oder übersteigt die Puffergröße.</target>       </trans-unit>
        <trans-unit id="2842" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2843" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2844" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the socket.</source>
          <target state="translated">Beim Zugriff auf den Socket ist ein Fehler auf Betriebssystemebene aufgetreten.</target>       </trans-unit>
        <trans-unit id="2845" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2846" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A list of <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph>s of type <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Eine Liste von <ph id="ph1">&lt;see cref="T:System.ArraySegment`1" /&gt;</ph> vom Typ <ph id="ph2">&lt;see cref="T:System.Byte" /&gt;</ph> mit den zu sendenden Daten.</target>       </trans-unit>
        <trans-unit id="2847" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2848" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="2849" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the set of buffers in the list to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> an einen verbundenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2850" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2851" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This overload requires at least one buffer that contains the data you want to send.</source>
          <target state="translated">Diese Überladung erfordert mindestens einen Puffer mit den Daten, die Sie senden möchten.</target>       </trans-unit>
        <trans-unit id="2852" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig auf 0.</target>       </trans-unit>
        <trans-unit id="2853" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketFlags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketFlags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2854" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2855" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2856" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, sollten Sie verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2857" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> -Methode, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2858" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2859" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2860" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2861" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2862" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In non-blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes in the buffer.</source>
          <target state="translated">Im Modus nicht blockierend <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2863" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</target>       </trans-unit>
        <trans-unit id="2864" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2865" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2866" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2867" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2868" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2869" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2870" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2871" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2872" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2873" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2874" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> is empty.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffers" /&gt;</ph> ist leer.</target>       </trans-unit>
        <trans-unit id="2875" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2876" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2877" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="2878" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="2879" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="2880" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2881" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, beginnend bei einem angegebenen Offset und unter Verwendung der angegebenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2882" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2883" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sendet Daten synchron mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten.</target>       </trans-unit>
        <trans-unit id="2884" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2885" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">In dieser Überladung, wenn Sie angeben, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> kennzeichnen als die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2886" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2887" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2888" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2889" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2890" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2891" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2892" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="2893" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2894" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2895" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2896" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern.</target>       </trans-unit>
        <trans-unit id="2897" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="2898" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2899" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2900" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2901" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2902" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2903" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2904" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2905" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2906" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2907" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> zum Senden von Daten an einen verbundenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2908" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2909" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2910" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2911" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2912" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2913" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2914" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2915" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="2916" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2917" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2918" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="2919" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2920" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="2921" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="2922" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="2923" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="2924" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph> object that stores the socket error.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketError" /&gt;</ph>-Objekt, in dem der Socketfehler gespeichert wird.</target>       </trans-unit>
        <trans-unit id="2925" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>Sends the specified number of bytes of data to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>, starting at the specified offset, and using the specified <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph></source>
          <target state="translated">Sendet unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> die angegebene Anzahl von Datenbytes an einen verbundenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>, beginnend beim angegebenen Offset.</target>       </trans-unit>
        <trans-unit id="2926" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The number of bytes sent to the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Die Anzahl der an den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="2927" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> synchronously sends data to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method and returns the number of bytes successfully sent.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sendet Daten synchron mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten.</target>       </trans-unit>
        <trans-unit id="2928" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> can be used for both connection-oriented and connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="2929" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">In dieser Überladung, wenn Sie angeben, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> kennzeichnen als die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="2930" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2931" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="2932" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connectionless protocol and plan to send data to several different hosts, you should use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, Daten an mehrere verschiedene Hosts senden möchten, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2933" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you do not use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, you will have to call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before each call to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie nicht verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, müssen Sie rufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor jedem Aufruf von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2934" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is okay to use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> even after you have established a default remote host with <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Es ist angemessen, verwenden Sie <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> sogar, wenn Sie mit einen Standard-Remotehost eingerichtet haben <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2935" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You can also change the default remote host prior to calling <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> by making another call to <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</source>
          <target state="translated">Sie können auch vor dem Aufruf der Standard-Remotehost ändern <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> durch einen anderen Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2936" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="2937" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2938" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> will block until the requested number of bytes are sent, unless a time-out was set by using <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout mithilfe festgelegter <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2939" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If the time-out value was exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> call will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn der Timeoutwert überschritten wurde, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Aufruf löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2940" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> may complete successfully even if it sends less than the number of bytes you request.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern.</target>       </trans-unit>
        <trans-unit id="2941" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="2942" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="2943" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="2944" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="2945" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="2946" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="2947" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The successful completion of a send does not indicate that the data was successfully delivered.</source>
          <target state="translated">Vom erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2948" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</source>
          <target state="translated">Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, wird der Sendevorgang blockiert, es sei denn, der Socket in nicht blockierenden Modus versetzt wurde.</target>       </trans-unit>
        <trans-unit id="2949" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="2950" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="2951" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The following code example specifies the data buffer, an offset, a size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> for sending data to a connected <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> zum Senden von Daten an einen verbundenen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2952" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2953" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2954" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2955" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2956" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2957" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2958" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2959" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="2960" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="2961" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="2962" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="2963" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2964" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="2965" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Sendet Daten asynchron an ein verbundenes <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="2966" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="2967" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="2968" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="2969" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="2970" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> Methode wird verwendet, um ausgehende Daten aus einem oder mehreren Puffern für einen verbindungsorientierten Socket zu schreiben.</target>       </trans-unit>
        <trans-unit id="2971" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</source>
          <target state="translated">Diese Methode kann auch, allerdings auf verbindungslosen Sockets verwendet werden, die einen Remotehost auf ein Verbindungsvorgang angegeben haben.</target>       </trans-unit>
        <trans-unit id="2972" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host established in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang an den Remotehost, der der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="2973" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="2974" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType&gt;</ph></target>       </trans-unit>
        <trans-unit id="2975" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> festgelegt ist</target>       </trans-unit>
        <trans-unit id="2976" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> if <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> is set</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType&gt;</ph> Wenn <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType&gt;</ph> festgelegt ist</target>       </trans-unit>
        <trans-unit id="2977" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="2978" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="2979" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method will throw an exception if you do not first call <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph><ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> Methode löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph> <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="2980" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="2981" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</source>
          <target state="translated">Überschreiten Sie für nachrichtenorientierter Sockets Sie die maximale Nachrichtengröße des zugrunde liegenden Windows Sockets-Dienstanbieters nicht.</target>       </trans-unit>
        <trans-unit id="2982" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> with the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> set to the native Winsock WSAEMSGSIZE error code (10040).</source>
          <target state="translated">Wenn die Daten der zugrunde liegenden Dienstanbieter atomar passieren zu lang sind, werden keine Daten übertragen und die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> -Methode löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit der <ph id="ph3">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType&gt;</ph> auf den systemeigenen WSAEMSGSIZE Winsock-Fehlercode (10040) festgelegt.</target>       </trans-unit>
        <trans-unit id="2983" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that the successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">Beachten Sie, dass beim erfolgreichen Abschluss der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> Methode nicht, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="2984" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph> or <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph> properties on the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> parameter must reference valid buffers.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /&gt;</ph>-Eigenschaft oder <ph id="ph2">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /&gt;</ph>-Eigenschaft des <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Parameters muss auf gültige Puffer verweisen.</target>       </trans-unit>
        <trans-unit id="2985" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>One or the other of these properties may be set, but not both at the same time.</source>
          <target state="translated">Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</target>       </trans-unit>
        <trans-unit id="2986" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="2987" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="2988" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2989" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected or was not obtained via an <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>, <ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>,or <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>, method.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ist noch nicht verbunden oder wurde nicht über eine <ph id="ph2">&lt;see cref="M:System.Net.Sockets.Socket.Accept" /&gt;</ph>-<ph id="ph3">&lt;see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /&gt;</ph>- oder <ph id="ph4">&lt;see cref="Overload:System.Net.Sockets.Socket.BeginAccept" /&gt;</ph>-Methode abgerufen.</target>       </trans-unit>
        <trans-unit id="2990" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Gets or sets a value that specifies the size of the send buffer of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der die Größe des Sendepuffers für den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> angibt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="2991" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph> that contains the size, in bytes, of the send buffer.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Int32" /&gt;</ph>, das die Größe des Sendepuffer in Bytes enthält.</target>       </trans-unit>
        <trans-unit id="2992" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The default is 8192.</source>
          <target state="translated">Der Standard ist 8192.</target>       </trans-unit>
        <trans-unit id="2993" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>A larger buffer size might delay the recognition of connection difficulties.</source>
          <target state="translated">Die Erkennung von Problemen bei der Verbindung ein größeren Puffers möglicherweise verzögert werden.</target>       </trans-unit>
        <trans-unit id="2994" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</source>
          <target state="translated">Erhöhen Sie die Größe des Puffers, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. ein Satellit Breitband-Anbieter.)</target>       </trans-unit>
        <trans-unit id="2995" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendBufferSize%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="2996" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="2997" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="2998" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendBufferSize">
          <source>The value specified for a set operation is less than 0.</source>
          <target state="translated">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="2999" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends a file and optional data synchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Sendet eine Datei und optionale Daten synchron an einen verbundenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3000" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der den Pfad und Namen der Datei enthält, die gesendet werden soll.</target>       </trans-unit>
        <trans-unit id="3001" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3002" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object with the <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph> transmit flag.</source>
          <target state="translated">Sendet die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> mit dem <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Übertragungsflag an ein verbundenes <ph id="ph3">&lt;see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3003" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This overload sends the file <ph id="ph1">`fileName`</ph> to the connected socket.</source>
          <target state="translated">Diese Überladung sendet die Datei <ph id="ph1">`fileName`</ph> an den verbundenen Socket.</target>       </trans-unit>
        <trans-unit id="3004" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">`flags`</ph> parameter defaults to <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), and the <ph id="ph3">`preBuffer`</ph> and <ph id="ph4">`postBuffer`</ph> parameters default to <ph id="ph5">`null`</ph>.</source>
          <target state="translated">Die <ph id="ph1">`flags`</ph> Parameter hat den Standardwert <ph id="ph2">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread&gt;</ph> (0), und die <ph id="ph3">`preBuffer`</ph> und <ph id="ph4">`postBuffer`</ph> Parameter standardmäßig <ph id="ph5">`null`</ph>.</target>       </trans-unit>
        <trans-unit id="3005" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If <ph id="ph1">`fileName`</ph> is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Wenn <ph id="ph1">`fileName`</ph> wird in das lokale Verzeichnis es mit nur der Name der Datei identifiziert werden kann; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden.</target>       </trans-unit>
        <trans-unit id="3006" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Platzhalter ("... <ph id="ph1">\\</ph>\myfile.txt ") und UNC-Freigabenamen ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared Directory<ph id="ph5">\\</ph>\myfile.txt ") werden unterstützt.</target>       </trans-unit>
        <trans-unit id="3007" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If the file is not found, the exception <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die Datei nicht gefunden wird, wird die Ausnahme <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="3008" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Diese Methode verwendet die <ph id="ph1">`TransmitFile`</ph> -Funktion, die in der Windows Sockets-API 2 gefunden.</target>       </trans-unit>
        <trans-unit id="3009" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu den <ph id="ph1">`TransmitFile`</ph> -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.</target>       </trans-unit>
        <trans-unit id="3010" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> sendet synchron eine Datei mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3011" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> kann für beide verbindungsorientierten und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="3012" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method, otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode andernfalls <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="3013" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> eine Remotehostverbindung oder mit <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="3014" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the file is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blockiert, bis die Datei gesendet wird.</target>       </trans-unit>
        <trans-unit id="3015" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, bevor die gesamte Datei gesendet wurde.</target>       </trans-unit>
        <trans-unit id="3016" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3017" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3018" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3019" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3020" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3021" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3022" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3023" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The following code example creates and connects a socket and then sends a file to the remote host.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und einen Socket verbunden und sendet dann eine Datei mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="3024" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.</target>       </trans-unit>
        <trans-unit id="3025" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Der Socket ist nicht mit einem Remotehost verbunden.</target>       </trans-unit>
        <trans-unit id="3026" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3027" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</target>       </trans-unit>
        <trans-unit id="3028" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3029" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3030" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph> that contains the path and name of the file to be sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.String" /&gt;</ph>, der den Pfad und Namen der Datei enthält, die gesendet werden soll.</target>       </trans-unit>
        <trans-unit id="3031" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3032" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent before the file is sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird.</target>       </trans-unit>
        <trans-unit id="3033" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3034" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> array that contains data to be sent after the file is sent.</source>
          <target state="translated">Ein <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde.</target>       </trans-unit>
        <trans-unit id="3035" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This parameter can be <ph id="ph1">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated">Dieser Parameter kann <ph id="ph1">&lt;see langword="null" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3036" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>One or more of <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> values.</source>
          <target state="translated">Mindestens ein <ph id="ph1">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>-Wert.</target>       </trans-unit>
        <trans-unit id="3037" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Sends the file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> and buffers of data to a connected <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object using the specified <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph> value.</source>
          <target state="translated">Sendet die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> und puffert Daten mit dem angegebenen <ph id="ph3">&lt;see cref="T:System.Net.Sockets.TransmitFileOptions" /&gt;</ph>-Wert in einem verbundenen <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3038" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This overload requires the name of the file you want to send and a bitwise combination of <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> values.</source>
          <target state="translated">Diese Überladung muss der Name der Datei, die Sie senden möchten und eine bitweise Kombination von <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> Werte.</target>       </trans-unit>
        <trans-unit id="3039" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`preBuffer`</ph> parameter contains any data you want to precede the file.</source>
          <target state="translated">Die <ph id="ph1">`preBuffer`</ph> Parameter enthält alle Daten, die vor der Datei gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="3040" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">`postBuffer`</ph> contains data you want to follow the file.</source>
          <target state="translated"><ph id="ph1">`postBuffer`</ph> enthält Daten, die Sie die Datei folgen soll.</target>       </trans-unit>
        <trans-unit id="3041" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If <ph id="ph1">`fileName`</ph> is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Wenn <ph id="ph1">`fileName`</ph> ist im aktuellen Arbeitsverzeichnis, es mit nur der Name der Datei identifiziert werden kann; andernfalls den vollständigen Pfad und Name der Datei müssen angegeben werden.</target>       </trans-unit>
        <trans-unit id="3042" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>Wildcards ("..<ph id="ph1">\\</ph>\myfile.txt") and UNC share names ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared directory<ph id="ph5">\\</ph>\myfile.txt") are supported.</source>
          <target state="translated">Platzhalter ("... <ph id="ph1">\\</ph>\myfile.txt ") und UNC-Freigabenamen ("<ph id="ph2">\\</ph><ph id="ph3">\\</ph><ph id="ph4">\\</ph>\shared Directory<ph id="ph5">\\</ph>\myfile.txt ") werden unterstützt.</target>       </trans-unit>
        <trans-unit id="3043" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">`flags`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Die <ph id="ph1">`flags`</ph> Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit.</target>       </trans-unit>
        <trans-unit id="3044" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3045" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This method uses the <ph id="ph1">`TransmitFile`</ph> function found in the Windows Sockets 2 API.</source>
          <target state="translated">Diese Methode verwendet die <ph id="ph1">`TransmitFile`</ph> -Funktion, die in der Windows Sockets-API 2 gefunden.</target>       </trans-unit>
        <trans-unit id="3046" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information about the <ph id="ph1">`TransmitFile`</ph> function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu den <ph id="ph1">`TransmitFile`</ph> -Funktion und den Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.</target>       </trans-unit>
        <trans-unit id="3047" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> synchronously sends a file to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> sendet synchron eine Datei mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3048" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> can be used for both connection-oriented and for connectionless protocols.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> kann für beide verbindungsorientierten und verbindungslose Protokolle verwendet werden.</target>       </trans-unit>
        <trans-unit id="3049" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connectionless protocol, you must call <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> before calling this method; otherwise <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> throws a <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> vor dem Aufrufen dieser Methode; andernfalls <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> löst eine <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3050" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, you must either use <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> to establish a remote host connection, or use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> to accept an incoming connection.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> um eine Verbindung herzustellen, oder verwenden Sie <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> eine eingehende Verbindung akzeptiert.</target>       </trans-unit>
        <trans-unit id="3051" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you are using a connection-oriented protocol, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blocks until the entire file is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> blockiert, bis die gesamte Datei gesendet wird.</target>       </trans-unit>
        <trans-unit id="3052" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In nonblocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> may complete successfully before the entire file has been sent.</source>
          <target state="translated">In nicht blockierenden Modus <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> möglicherweise erfolgreich abgeschlossen, bevor die gesamte Datei gesendet wurde.</target>       </trans-unit>
        <trans-unit id="3053" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>There is no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Es gibt keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3054" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3055" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendFile%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3056" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3057" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3058" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3059" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3060" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The following code example creates and connects a socket.</source>
          <target state="translated">Im folgenden Codebeispiel wird erstellt und einen Socket verbunden.</target>       </trans-unit>
        <trans-unit id="3061" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file "test.txt" is located in the root directory of the local machine.</source>
          <target state="translated">Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.</target>       </trans-unit>
        <trans-unit id="3062" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</source>
          <target state="translated">In diesem Beispiel werden eine Prebuffer und Postbuffer von Daten erstellen und senden sie mit der Datei mit dem Remotehost.</target>       </trans-unit>
        <trans-unit id="3063" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The default <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> are used.</source>
          <target state="translated">Die Standardeinstellung <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="3064" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The operating system is not Windows NT or later.</source>
          <target state="translated">Das Betriebssystem ist nicht Windows NT oder höher.</target>       </trans-unit>
        <trans-unit id="3065" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source><ph id="ph1">\-</ph> or -</source>
          <target state="translated"><ph id="ph1">\-</ph> oder –</target>       </trans-unit>
        <trans-unit id="3066" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The socket is not connected to a remote host.</source>
          <target state="translated">Der Socket ist nicht mit einem Remotehost verbunden.</target>       </trans-unit>
        <trans-unit id="3067" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3068" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object is not in blocking mode and cannot accept this synchronous call.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</target>       </trans-unit>
        <trans-unit id="3069" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>The file <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> was not found.</source>
          <target state="translated">Die Datei <ph id="ph1">&lt;paramref name="fileName" /&gt;</ph> wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3070" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3071" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3072" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends a collection of files or in memory data buffers asynchronously to a connected <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object.</source>
          <target state="translated">Sendet eine Auflistung von Dateien oder Datenpuffern im Speicher asynchron an ein verbundenes <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt.</target>       </trans-unit>
        <trans-unit id="3073" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="3074" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="3075" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="3076" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="3077" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is used to send a collection of files or in memory data buffers to remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methode wird verwendet, um eine Auflistung von Dateien oder im Arbeitsspeicher Datenpuffer an remote-Host zu senden.</target>       </trans-unit>
        <trans-unit id="3078" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> must already be connected to the remote host.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> muss bereits mit dem Remotehost verbunden sein.</target>       </trans-unit>
        <trans-unit id="3079" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If a <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</source>
          <target state="translated">Wenn eine <ph id="ph1">&lt;xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType&gt;</ph> Verweise auf eine Datei in das Arbeitsverzeichnis, können Sie den Namen der Datei identifiziert werden; andernfalls, den vollständigen Pfad und Name der Datei müssen angegeben werden.</target>       </trans-unit>
        <trans-unit id="3080" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Wildcards and UNC share names are supported.</source>
          <target state="translated">Platzhalter und UNC-Freigabenamen werden unterstützt.</target>       </trans-unit>
        <trans-unit id="3081" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the file is not found, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> is thrown.</source>
          <target state="translated">Wenn die Datei nicht gefunden wird, <ph id="ph1">&lt;xref:System.IO.FileNotFoundException&gt;</ph> ausgelöst wird.</target>       </trans-unit>
        <trans-unit id="3082" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegieren, und fügen Sie den Rückruf, der die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="3083" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph2">`e`</ph> parameter provides the Window Sockets service provider with additional information about the file transfer.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die <ph id="ph2">`e`</ph> Parameter stellt die Fenster Sockets-Dienstanbieter mit zusätzlichen Informationen über die Übertragung von Dateien bereit.</target>       </trans-unit>
        <trans-unit id="3084" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about how to use this parameter, see <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</source>
          <target state="translated">Weitere Informationen zur Verwendung dieses Parameters finden Sie unter <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3085" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="3086" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3087" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="3088" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This method uses the TransmitPackets function found in the Windows Sockets 2 API.</source>
          <target state="translated">Diese Methode verwendet die vorhandene TransmitPackets-Funktion in der Windows Sockets-API 2 an.</target>       </trans-unit>
        <trans-unit id="3089" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For more information about the TransmitPackets function and its flags, see the Windows Sockets documentation in the MSDN Library.</source>
          <target state="translated">Weitere Informationen zu TransmitPackets-Funktion und den Flags finden Sie unter der Windows Sockets-Dokumentation in der MSDN Library.</target>       </trans-unit>
        <trans-unit id="3090" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although intended for connection-oriented protocols, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method also works for connectionless protocols, provided that you first call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method to establish a default remote host.</source>
          <target state="translated">Gedacht für verbindungsorientierte Protokolle der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methode kann auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode, um eine Standard-Remotehost herstellen.</target>       </trans-unit>
        <trans-unit id="3091" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</target>       </trans-unit>
        <trans-unit id="3092" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> throws a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception.</source>
          <target state="translated">Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> Ausnahme.</target>       </trans-unit>
        <trans-unit id="3093" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized according to the operating system on which it is used.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methode optimiert, nach dem Betriebssystem, auf denen es verwendet wird.</target>       </trans-unit>
        <trans-unit id="3094" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows server editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for high performance.</source>
          <target state="translated">Auf Windows Server-Editionen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methode ist für hohe Leistung optimiert.</target>       </trans-unit>
        <trans-unit id="3095" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>On Windows client editions, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method is optimized for minimum memory and resource utilization.</source>
          <target state="translated">Für Editionen von Windows-Client die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methode ist für die minimale Arbeitsspeicher und der ressourcennutzung optimiert.</target>       </trans-unit>
        <trans-unit id="3096" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use of the <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> flag in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> property on the <ph id="ph3">`e`</ph> parameter can deliver significant performance benefits.</source>
          <target state="translated">Verwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType&gt;</ph> -flag in der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft auf die <ph id="ph3">`e`</ph> Parameter kann beachtliche Leistungsvorteile bieten.</target>       </trans-unit>
        <trans-unit id="3097" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the thread initiating the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</source>
          <target state="translated">Wenn der Thread initiiert die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendPacketsAsync%2A&gt;</ph> Methodenaufruf für umfangreiche Berechnungen verwendet wird, es ist möglich, obwohl unwahrscheinlich, dass APCs starten verhindert werden können.</target>       </trans-unit>
        <trans-unit id="3098" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Note that there is a difference between kernel and user-mode APCs.</source>
          <target state="translated">Beachten Sie, dass es ein Unterschied zwischen Kernel und im Benutzermodus APCs.</target>       </trans-unit>
        <trans-unit id="3099" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Kernel APCs launch when a thread is in a wait state.</source>
          <target state="translated">Kernel-APCs starten, wenn ein Thread in einen Wartezustand versetzt ist.</target>       </trans-unit>
        <trans-unit id="3100" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>User-mode APCs launch when a thread is in an alertable wait state</source>
          <target state="translated">Im Benutzermodus APCs starten, wenn ein Thread in einem warnpflichtigen Wartezustand ist.</target>       </trans-unit>
        <trans-unit id="3101" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The file specified in the <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph> property was not found.</source>
          <target state="translated">Die in der <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /&gt;</ph>-Eigenschaft angegebene Datei wurde nicht gefunden.</target>       </trans-unit>
        <trans-unit id="3102" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="3103" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="3104" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>This exception also occurs if the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not connected to a remote host.</source>
          <target state="translated">Diese Ausnahme tritt auch auf, wenn <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> nicht mit einem Remotehost verbunden ist.</target>       </trans-unit>
        <trans-unit id="3105" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3106" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A connectionless <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</source>
          <target state="translated">Ein verbindungsloser <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wird verwendet, und die verwendete Datei überschreitet die maximale Paketgröße des zugrunde liegenden Transports.</target>       </trans-unit>
        <trans-unit id="3107" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Gets or sets a value that specifies the amount of time after which a synchronous <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph> call will time out.</source>
          <target state="translated">Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <ph id="ph1">&lt;see cref="Overload:System.Net.Sockets.Socket.Send" /&gt;</ph>-Aufrufs angibt, oder legt diesen fest.</target>       </trans-unit>
        <trans-unit id="3108" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The time-out value, in milliseconds.</source>
          <target state="translated">Der Timeoutwert in Millisekunden.</target>       </trans-unit>
        <trans-unit id="3109" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If you set the property with a value between 1 and 499, the value will be changed to 500.</source>
          <target state="translated">Wenn Sie die Eigenschaft auf einen Wert zwischen 1 und 499 festlegen, wird der Wert in 500 geändert.</target>       </trans-unit>
        <trans-unit id="3110" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The default value is 0, which indicates an infinite time-out period.</source>
          <target state="translated">Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an.</target>       </trans-unit>
        <trans-unit id="3111" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>Specifying -1 also indicates an infinite time-out period.</source>
          <target state="translated">Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</target>       </trans-unit>
        <trans-unit id="3112" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>This option applies to synchronous <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> calls only.</source>
          <target state="translated">Diese Option gilt für synchrone <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> nur aufruft.</target>       </trans-unit>
        <trans-unit id="3113" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>If the time-out period is exceeded, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn das Timeoutintervall überschritten wird, die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3114" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTimeout%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3115" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3116" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3117" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SendTimeout">
          <source>The value specified for a set operation is less than -1.</source>
          <target state="translated">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</target>       </trans-unit>
        <trans-unit id="3118" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sends data to a specific endpoint.</source>
          <target state="translated">Sendet Daten an einen bestimmten Endpunkt.</target>       </trans-unit>
        <trans-unit id="3119" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="3120" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination for the data.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der das Ziel der Daten darstellt.</target>       </trans-unit>
        <trans-unit id="3121" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Sends data to the specified endpoint.</source>
          <target state="translated">Sendet Daten an den angegebenen Endpunkt.</target>       </trans-unit>
        <trans-unit id="3122" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Die Anzahl der gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="3123" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph> parameter, and the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> value defaults to 0.</source>
          <target state="translated">In dieser Überladung der Pufferoffset hat den Standardwert 0, die Anzahl der Bytes die Größe des Standards an die <ph id="ph1">`buffer`</ph> Parameter, und die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> -Wert wird standardmäßig auf 0.</target>       </trans-unit>
        <trans-unit id="3124" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3125" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3126" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, die <ph id="ph3">`remoteEP`</ph> Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="3127" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist.</target>       </trans-unit>
        <trans-unit id="3128" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="3129" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Obwohl für verbindungslose Protokolle vorgesehen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> funktioniert auch mit verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="3130" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3131" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3132" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3133" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">In diesen Fällen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.</target>       </trans-unit>
        <trans-unit id="3134" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Blocking sockets will block until the all of the bytes in the buffer are sent.</source>
          <target state="translated">Blockierende Sockets blockiert, bis alle Bytes im Puffer gesendet werden.</target>       </trans-unit>
        <trans-unit id="3135" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Da ein nicht blockierenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist, es möglicherweise nicht umgehend aller Bytes in der <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3136" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Es liegt in Ihrer Anwendung Verantwortung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in sendet der <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3137" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3138" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis sehr viel ausgehender Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3139" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3140" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="3141" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3142" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="3143" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3144" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3145" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3146" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3147" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3148" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="3149" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3150" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3151" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3152" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3153" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3154" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="3155" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3156" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Zielort der Daten darstellt.</target>       </trans-unit>
        <trans-unit id="3157" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends data to a specific endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet Daten an einen bestimmten Endpunkt unter Verwendung der angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3158" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Die Anzahl der gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="3159" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">In dieser Überladung der Pufferoffset hat den Standardwert 0, und die Anzahl der Bytes die Größe des Standards an die <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3160" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="3161" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3162" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3163" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, die <ph id="ph3">`remoteEP`</ph> Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="3164" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist.</target>       </trans-unit>
        <trans-unit id="3165" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="3166" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Obwohl für verbindungslose Protokolle vorgesehen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> funktioniert auch mit verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="3167" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3168" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3169" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3170" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">In diesen Fällen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.</target>       </trans-unit>
        <trans-unit id="3171" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested all of the bytes in the <ph id="ph1">`buffer`</ph> are sent.</source>
          <target state="translated">Blockierende Sockets blockieren, bis die angeforderte aller Bytes in den <ph id="ph1">`buffer`</ph> gesendet werden.</target>       </trans-unit>
        <trans-unit id="3172" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes in the <ph id="ph2">`buffer`</ph>.</source>
          <target state="translated">Da ein nicht blockierenden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist, es möglicherweise nicht umgehend aller Bytes in der <ph id="ph2">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3173" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the <ph id="ph1">`buffer`</ph>.</source>
          <target state="translated">Es liegt in Ihrer Anwendung Verantwortung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in sendet der <ph id="ph1">`buffer`</ph>.</target>       </trans-unit>
        <trans-unit id="3174" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3175" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3176" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3177" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="3178" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3179" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="3180" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3181" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3182" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3183" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3184" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3185" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="3186" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> zum Übergeben der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3187" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3188" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3189" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3190" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3191" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3192" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="3193" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="3194" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3195" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Zielort der Daten darstellt.</target>       </trans-unit>
        <trans-unit id="3196" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt, wobei die angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="3197" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Die Anzahl der gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="3198" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, the buffer offset defaults to 0.</source>
          <target state="translated">In dieser Überladung der Pufferoffset hat den Standardwert 0.</target>       </trans-unit>
        <trans-unit id="3199" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">Bei Angabe der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> als flag die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="3200" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3201" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3202" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, die <ph id="ph3">`remoteEP`</ph> Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="3203" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist.</target>       </trans-unit>
        <trans-unit id="3204" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="3205" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Obwohl für verbindungslose Protokolle vorgesehen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> funktioniert auch mit verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="3206" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3207" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3208" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3209" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">In diesen Fällen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.</target>       </trans-unit>
        <trans-unit id="3210" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Blockierende Sockets wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden.</target>       </trans-unit>
        <trans-unit id="3211" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a nonblocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Da eine nicht blockierende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist, es möglicherweise nicht umgehend alle Bytes in einem einzigen Vorgang angefordert.</target>       </trans-unit>
        <trans-unit id="3212" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es ist Zuständigkeit der Anwendung zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="3213" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3214" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3215" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3216" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="3217" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3218" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="3219" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3220" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3221" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3222" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3223" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3224" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="3225" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The size and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Die Größe und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> übergeben werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3226" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3227" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3228" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3229" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The specified <ph id="ph1">&lt;paramref name="size" /&gt;</ph> exceeds the size of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated">Die angegebene <ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3230" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3231" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3232" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that contains the data to be sent.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das die zu sendenden Daten enthält.</target>       </trans-unit>
        <trans-unit id="3233" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The position in the data buffer at which to begin sending data.</source>
          <target state="translated">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</target>       </trans-unit>
        <trans-unit id="3234" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes to send.</source>
          <target state="translated">Die Anzahl von Bytes, die gesendet werden sollen.</target>       </trans-unit>
        <trans-unit id="3235" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A bitwise combination of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> values.</source>
          <target state="translated">Eine bitweise Kombination der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3236" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph> that represents the destination location for the data.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.EndPoint" /&gt;</ph>, der den Zielort der Daten darstellt.</target>       </trans-unit>
        <trans-unit id="3237" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph>.</source>
          <target state="translated">Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt und beginnt dabei an der angegebenen Position im Puffer, wobei die angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketFlags" /&gt;</ph> verwendet werden.</target>       </trans-unit>
        <trans-unit id="3238" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The number of bytes sent.</source>
          <target state="translated">Die Anzahl der gesendeten Bytes.</target>       </trans-unit>
        <trans-unit id="3239" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In this overload, if you specify the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> flag as the <ph id="ph2">`socketflags`</ph> parameter, the data you are sending will not be routed.</source>
          <target state="translated">In dieser Überladung, wenn Sie angeben, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags.DontRoute&gt;</ph> kennzeichnen als die <ph id="ph2">`socketflags`</ph> Parameter, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="3240" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3241" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> method.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3242" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method prior to calling <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, the <ph id="ph3">`remoteEP`</ph> parameter will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph>, die <ph id="ph3">`remoteEP`</ph> Parameter wird die angegebene Standard-Remotehost außer Kraft setzen, die nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="3243" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method, because the underlying service provider will assign the most appropriate local network address and port number.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> -Methode, da der zugrunde liegende Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist.</target>       </trans-unit>
        <trans-unit id="3244" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you need to identify the assigned local network address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method successfully completes.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN Adresse und Anschlussnummer identifizieren möchten, können Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode erfolgreich ausgeführt wird.</target>       </trans-unit>
        <trans-unit id="3245" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Although intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> also works with connection-oriented protocols.</source>
          <target state="translated">Obwohl für verbindungslose Protokolle vorgesehen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> funktioniert auch mit verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="3246" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> method or accept an incoming connection request using the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zunächst eine Remotehostverbindung einrichten, durch Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3247" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you do not establish or accept a remote host connection, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3248" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You can also establish a default remote host for a connectionless protocol prior to calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Sie können auch festlegen, eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3249" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>In either of these cases, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will ignore the <ph id="ph2">`remoteEP`</ph> parameter and only send data to the connected or default remote host.</source>
          <target state="translated">In diesen Fällen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> ignoriert die <ph id="ph2">`remoteEP`</ph> Parameter und nur Senden von Daten auf den verbundenen oder Standard-Remotehost.</target>       </trans-unit>
        <trans-unit id="3250" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Blocking sockets will block until the requested number of bytes are sent.</source>
          <target state="translated">Blockierende Sockets wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden.</target>       </trans-unit>
        <trans-unit id="3251" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>Since a non-blocking <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> completes immediately, it might not send all of the bytes requested in a single operation.</source>
          <target state="translated">Da ein nicht blockierender <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abgeschlossen ist, es möglicherweise nicht umgehend alle Bytes in einem einzigen Vorgang angefordert.</target>       </trans-unit>
        <trans-unit id="3252" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</source>
          <target state="translated">Es liegt in Ihrer Verantwortung Anwendungen zum Nachverfolgen der Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</target>       </trans-unit>
        <trans-unit id="3253" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>There is also no guarantee that the data you send will appear on the network immediately.</source>
          <target state="translated">Außerdem besteht keine Garantie, die die gesendeten Daten sofort im Netzwerk angezeigt werden.</target>       </trans-unit>
        <trans-unit id="3254" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</source>
          <target state="translated">Um die Netzwerkeffizienz steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis eine erhebliche Menge an ausgehenden Daten gesammelt werden.</target>       </trans-unit>
        <trans-unit id="3255" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A successful completion of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method means that the underlying system has had room to buffer your data for a network send.</source>
          <target state="translated">Ein erfolgreicher Abschluss des der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode bedeutet, dass die zugrunde liegenden Systems Raum aufbewahren, um Puffer hatte Ihre Daten für ein Netzwerk zu senden.</target>       </trans-unit>
        <trans-unit id="3256" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you are using a connectionless protocol in blocking mode, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will block until the datagram is sent.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus arbeiten <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> blockiert, bis das Datagramm gesendet wird.</target>       </trans-unit>
        <trans-unit id="3257" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3258" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="3259" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3260" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3261" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3262" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3263" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3264" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The following code example sends a connectionless datagram to the specified remote host.</source>
          <target state="translated">Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="3265" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The offset, size, and <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> are passed to the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> method.</source>
          <target state="translated">Der Offset, Größe und <ph id="ph1">&lt;xref:System.Net.Sockets.SocketFlags&gt;</ph> übergeben werden, um die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendTo%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3266" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="buffer" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3267" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3268" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="remoteEP" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3269" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="3270" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3271" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="offset" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3272" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3273" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is less than 0.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist kleiner als 0.</target>       </trans-unit>
        <trans-unit id="3274" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3275" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="size" /&gt;</ph> is greater than the length of <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus the value of the <ph id="ph3">&lt;paramref name="offset" /&gt;</ph> parameter.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="size" /&gt;</ph> ist größer als die Länge von <ph id="ph2">&lt;paramref name="buffer" /&gt;</ph> minus dem Wert des <ph id="ph3">&lt;paramref name="offset" /&gt;</ph>-Parameters.</target>       </trans-unit>
        <trans-unit id="3276" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> is not a valid combination of values.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="socketFlags" /&gt;</ph> ist keine gültige Kombination von Werten.</target>       </trans-unit>
        <trans-unit id="3277" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>-or-</source>
          <target state="translated">- oder - </target>       </trans-unit>
        <trans-unit id="3278" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>An operating system error occurs while accessing the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Beim Zugriff auf den <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> tritt ein Betriebssystemfehler auf.</target>       </trans-unit>
        <trans-unit id="3279" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3280" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)">
          <source>A caller in the call stack does not have the required permissions.</source>
          <target state="translated">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</target>       </trans-unit>
        <trans-unit id="3281" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object to use for this asynchronous socket operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</target>       </trans-unit>
        <trans-unit id="3282" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Sends data asynchronously to a specific remote host.</source>
          <target state="translated">Sendet asynchron Daten an einen angegebenen Remotehost.</target>       </trans-unit>
        <trans-unit id="3283" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="true" /&gt;</ph> if the I/O operation is pending.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="true" /&gt;</ph> zurück, wenn der E/A-Vorgang aussteht.</target>       </trans-unit>
        <trans-unit id="3284" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will be raised upon completion of the operation.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</target>       </trans-unit>
        <trans-unit id="3285" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Returns <ph id="ph1">&lt;see langword="false" /&gt;</ph> if the I/O operation completed synchronously.</source>
          <target state="translated">Gibt <ph id="ph1">&lt;see langword="false" /&gt;</ph> zurück, wenn der E/A-Vorgang synchron abgeschlossen wurde.</target>       </trans-unit>
        <trans-unit id="3286" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, The <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph> event on the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter will not be raised and the <ph id="ph3">&lt;paramref name="e" /&gt;</ph> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</source>
          <target state="translated">In diesem Fall wird das <ph id="ph1">&lt;see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /&gt;</ph>-Ereignis für den <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter nicht ausgelöst, und das als Parameter übergebene <ph id="ph3">&lt;paramref name="e" /&gt;</ph>-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</target>       </trans-unit>
        <trans-unit id="3287" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method starts an asynchronous send operation to the remote host specified in the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property of the <ph id="ph3">`e`</ph> parameter.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> Methode startet einen asynchronen Sendevorgang mit dem Remotehost, angegeben der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft von der <ph id="ph3">`e`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3288" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Calling the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method gives you the ability to send data within a separate execution thread.</source>
          <target state="translated">Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> -Methode erhalten Sie die Möglichkeit, Daten in einem separaten Ausführungsthread senden.</target>       </trans-unit>
        <trans-unit id="3289" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Although this method is intended for connectionless protocols, <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> works with both connectionless and connection-oriented protocols.</source>
          <target state="translated">Obwohl diese Methode für verbindungslose Protokolle bestimmt ist <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.</target>       </trans-unit>
        <trans-unit id="3290" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>To be notified of completion, you must create a callback method that implements the EventHandler<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs&gt; delegate and attach the callback to the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event.</source>
          <target state="translated">Zum Abschluss des benachrichtigt zu werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen<ph id="ph1">\&lt;</ph>SocketAsyncEventArgs &gt; delegieren, und fügen Sie den Rückruf, der die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis.</target>       </trans-unit>
        <trans-unit id="3291" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The following properties and events on the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> object are required to successfully call this method:</source>
          <target state="translated">Die folgenden Eigenschaften und Ereignisse auf die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType&gt;</ph> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</target>       </trans-unit>
        <trans-unit id="3292" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The caller may set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> property to any user state object desired before calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method, so that the information will be retrievable in the callback method.</source>
          <target state="translated">Der Aufrufer kann festlegen, die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft vor dem Aufruf gewünscht Statusobjekt für alle Benutzer der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3293" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</source>
          <target state="translated">Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.</target>       </trans-unit>
        <trans-unit id="3294" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connection-oriented protocol, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3295" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Otherwise <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Andernfalls <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3296" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>When using a connection-oriented protocol, the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method will ignore the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property and send data to the <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> established in the <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method.</source>
          <target state="translated">Bei Verwendung einer verbindungsorientiertes Protokoll der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> Methode ignoriert die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft und sendet Daten an die <ph id="ph3">&lt;xref:System.Net.EndPoint?displayProperty=nameWithType&gt;</ph> in vielen Branchen der <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.Accept%2A&gt;</ph>, <ph id="ph5">&lt;xref:System.Net.Sockets.Socket.AcceptAsync%2A&gt;</ph>, <ph id="ph6">&lt;xref:System.Net.Sockets.Socket.BeginAccept%2A&gt;</ph>, <ph id="ph7">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph8">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph> , oder <ph id="ph9">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3297" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you are using a connectionless protocol, you do not need to establish a default remote host with the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einen Standard-Remotehost herstellen die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3298" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You only need to do this if you intend to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> or <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> methods.</source>
          <target state="translated">Nur müssen Sie dies tun, wenn Sie beabsichtigen, rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginSend%2A&gt;</ph> oder <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.SendAsync%2A&gt;</ph> Methoden.</target>       </trans-unit>
        <trans-unit id="3299" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you do call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> method prior to calling <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, the <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> property will override the specified default remote host for that send operation only.</source>
          <target state="translated">Wenn Sie Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.BeginConnect%2A&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Connect%2A&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.ConnectAsync%2A&gt;</ph> Methode vor dem Aufruf <ph id="ph4">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph>, die <ph id="ph5">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType&gt;</ph> Überschreiben der Eigenschaft die angegebene Standard-Remotehost, der nur für Sendevorgang.</target>       </trans-unit>
        <trans-unit id="3300" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You are also not required to call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> method.</source>
          <target state="translated">Sind Sie auch nicht aufrufen erforderlich die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Bind%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3301" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</source>
          <target state="translated">In diesem Fall wird der zugrunde liegende Dienstanbieter die am besten geeignete lokale IP-Adresse und Anschlussnummer Netzwerknummer zuweisen.</target>       </trans-unit>
        <trans-unit id="3302" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Use a port number of zero if you want the underlying service provider to select a free port.</source>
          <target state="translated">Verwenden Sie die Portnummer 0 (null), wenn die zugrunde liegenden Service-Anbieter einen Port frei auswählen soll.</target>       </trans-unit>
        <trans-unit id="3303" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you need to identify the assigned local network IP address and port number, you can use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> property after the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> event is signaled and the associated delegates are called.</source>
          <target state="translated">Wenn Sie die zugewiesenen LAN-IP-Adresse und Portnummer Anzahl identifizieren müssen, können Sie mithilfe der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.LocalEndPoint%2A&gt;</ph> Eigenschaft nach der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType&gt;</ph> Ereignis signalisiert wurde und die entsprechenden Delegaten aufgerufen werden.</target>       </trans-unit>
        <trans-unit id="3304" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you want to send data to a broadcast address, you must first call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> method and set the socket option for <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> to true.</source>
          <target state="translated">Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst eine Aufrufen der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetSocketOption%2A&gt;</ph> -Methode und die Socketoption option <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType&gt;</ph> auf "true".</target>       </trans-unit>
        <trans-unit id="3305" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</source>
          <target state="translated">Sie müssen auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschritten wird.</target>       </trans-unit>
        <trans-unit id="3306" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If it does, the datagram will not be sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn dies der Fall ist, wird das Datagramm nicht gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3307" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If you specify the DontRoute flag in the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> property, the data you are sending will not be routed.</source>
          <target state="translated">Wenn Sie angeben, dass das DontRoute-Flag in der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType&gt;</ph> -Eigenschaft, die Daten, die Sie senden nicht weitergeleitet werden.</target>       </trans-unit>
        <trans-unit id="3308" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</source>
          <target state="translated">Für Sockets nachrichtenorientierter muss darauf geachtet werden, nicht zu überschreiten die maximale Nachrichtengröße des zugrunde liegenden Transports.</target>       </trans-unit>
        <trans-unit id="3309" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> will throw a <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</source>
          <target state="translated">Wenn die Größe des Puffers die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet, wird nicht das Datagramm gesendet und <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> löst eine <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3310" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The successful completion of a <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> method does not indicate that the data was successfully delivered.</source>
          <target state="translated">Beim erfolgreichen Abschluss einer <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SendToAsync%2A&gt;</ph> Methode nicht, dass die Daten erfolgreich übermittelt wurde.</target>       </trans-unit>
        <trans-unit id="3311" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> cannot be null.</source>
          <target state="translated"><ph id="ph1">&lt;see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /&gt;</ph> darf nicht NULL sein.</target>       </trans-unit>
        <trans-unit id="3312" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>A socket operation was already in progress using the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph> object specified in the <ph id="ph2">&lt;paramref name="e" /&gt;</ph> parameter.</source>
          <target state="translated">Es wird bereits ein Socketvorgang mit dem im <ph id="ph2">&lt;paramref name="e" /&gt;</ph>-Parameter angegebenen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /&gt;</ph>-Objekt ausgeführt.</target>       </trans-unit>
        <trans-unit id="3313" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>Windows XP or later is required for this method.</source>
          <target state="translated">Für diese Methode ist Windows XP oder höher erforderlich.</target>       </trans-unit>
        <trans-unit id="3314" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3315" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)">
          <source>The protocol specified is connection-oriented, but the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> is not yet connected.</source>
          <target state="translated">Das angegebene Protokoll ist verbindungsorientiert, aber der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde noch nicht verbunden.</target>       </trans-unit>
        <trans-unit id="3316" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level to set on this socket.</source>
          <target state="translated">Die für diesen Socket festzulegende IP-Schutzebene.</target>       </trans-unit>
        <trans-unit id="3317" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Set the IP protection level on a socket.</source>
          <target state="translated">Legt die IP-Schutzebene für einen Socket fest.</target>       </trans-unit>
        <trans-unit id="3318" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> -Methode ermöglicht die Einschränkung einen eine IPv6- oder IP-Sockets auf einen angegebenen Bereich, zu überwachen, wie z. B. Adressen mit demselben linklokalen oder standortlokalen Präfix.</target>       </trans-unit>
        <trans-unit id="3319" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option enables applications to place access restrictions on IPv6 or IP sockets.</source>
          <target state="translated">Diese Socketoption kann Anwendungen zugriffseinschränkungen für IPv6- oder IP-Sockets zu platzieren.</target>       </trans-unit>
        <trans-unit id="3320" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</source>
          <target state="translated">Mit solchen Einschränkungen kann sich eine im privaten LAN ausgeführte Anwendung selbst einfach und stabil vor externen Angriffen schützen.</target>       </trans-unit>
        <trans-unit id="3321" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option can also be used to remove access restrictions if the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</source>
          <target state="translated">Diese Socketoption kann auch verwendet werden, um zugriffsbeschränkungen zu entfernen, wenn die <ph id="ph1">`level`</ph> Parametersatz auf <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.Unrestricted&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3322" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</source>
          <target state="translated">Diese Socketoption erweitert oder beschränkt den Bereich eines empfangsbereiten Sockets und ermöglicht so bei Bedarf den uneingeschränkten Zugriff von öffentlichen und privaten Benutzern oder beschränkt den Zugriff nur auf denselben Standort.</target>       </trans-unit>
        <trans-unit id="3323" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>This socket option has defined protection levels specified in the <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph> enumeration.</source>
          <target state="translated">Für diese Socketoption sind in der <ph id="ph1">&lt;xref:System.Net.Sockets.IPProtectionLevel&gt;</ph>-Enumeration angegebene Schutzebenen definiert.</target>       </trans-unit>
        <trans-unit id="3324" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> method is used to enable or disable Network Address Traversal (NAT) for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">Die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A&gt;</ph> Methode dient zum Aktivieren oder deaktivieren (Network Address Traversal, NAT) für eine <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="3325" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</source>
          <target state="translated">NAT-Durchlauf kann mit Teredo, 6to4 oder einen ISATAP-Tunnel bereitgestellt werden.</target>       </trans-unit>
        <trans-unit id="3326" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, or <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, this explicitly disables NAT traversal for a <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> instance.</source>
          <target state="translated">Wenn die <ph id="ph1">`level`</ph> Parameter auf festgelegt ist <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, oder <ph id="ph3">&lt;xref:System.Net.Sockets.IPProtectionLevel.Restricted&gt;</ph>, dies explizit deaktiviert NAT-Durchlauf für eine <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Instanz.</target>       </trans-unit>
        <trans-unit id="3327" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>When the <ph id="ph1">`level`</ph> parameter is set to <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, this may allow NAT traversal for a <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> depending on firewall rules in place on the system.</source>
          <target state="translated">Wenn die <ph id="ph1">`level`</ph> Parameter auf festgelegt ist <ph id="ph2">&lt;xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted&gt;</ph>, kann dieser NAT-Durchlauf für eine <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph> abhängig von Firewallregeln auf dem System vorhanden.</target>       </trans-unit>
        <trans-unit id="3328" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;paramref name="level" /&gt;</ph> parameter cannot be <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph>.</source>
          <target state="translated">Der <ph id="ph1">&lt;paramref name="level" /&gt;</ph>-Parameter darf nicht <ph id="ph2">&lt;see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3329" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The IP protection level cannot be set to unspecified.</source>
          <target state="translated">Die IP-Schutzebene kann nicht auf nicht angegeben festgelegt werden.</target>       </trans-unit>
        <trans-unit id="3330" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> of the socket must be either <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> or <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>.</source>
          <target state="translated">Die <ph id="ph1">&lt;see cref="T:System.Net.Sockets.AddressFamily" /&gt;</ph> des Sockets muss <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> oder <ph id="ph3">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> sein.</target>       </trans-unit>
        <trans-unit id="3331" translate="yes" xml:space="preserve" uid="T:System.Net.Sockets.Socket">
          <source>Sets a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option.</source>
          <target state="translated">Legt eine <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option fest.</target>       </trans-unit>
        <trans-unit id="3332" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3333" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3334" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The value of the option, represented as a <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>.</source>
          <target state="translated">Der als <ph id="ph1">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert dargestellte Wert der Option.</target>       </trans-unit>
        <trans-unit id="3335" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph> value.</source>
          <target state="translated">Legt die angegebene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option auf den angegebenen <ph id="ph2">&lt;see cref="T:System.Boolean" /&gt;</ph>-Wert fest.</target>       </trans-unit>
        <trans-unit id="3336" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3337" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Set <ph id="ph1">`optionValue`</ph> to <ph id="ph2">`true`</ph> to enable the option, or to <ph id="ph3">`false`</ph> to disable the option.</source>
          <target state="translated">Legen Sie <ph id="ph1">`optionValue`</ph> auf <ph id="ph2">`true`</ph> So aktivieren Sie die Option oder <ph id="ph3">`false`</ph> zum Deaktivieren der Option.</target>       </trans-unit>
        <trans-unit id="3338" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen werden nach Maß an Unterstützung für das Protokoll gruppiert.</target>       </trans-unit>
        <trans-unit id="3339" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Unten sind die verschiedenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3340" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value.</source>
          <target state="translated">Diese Optionen werden von der entsprechenden gruppiert <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> Wert.</target>       </trans-unit>
        <trans-unit id="3341" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> value for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, den entsprechenden verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> Wert für die <ph id="ph2">`optionLevel`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3342" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">Die Option wählen, dass einrichten muss angegeben werden, der <ph id="ph1">`optionName`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3343" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3344" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3345" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3346" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3347" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3348" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>For more information on these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu diesen Optionen finden Sie in der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="3349" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> exception, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> mit Ausnahme der <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3350" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3351" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The following code example opens a socket and enables the <ph id="ph1">`DontLinger`</ph> and the <ph id="ph2">`OutOfBandInline`</ph> socket options.</source>
          <target state="translated">Im folgenden Codebeispiel wird ein Socket geöffnet und ermöglicht die <ph id="ph1">`DontLinger`</ph> und <ph id="ph2">`OutOfBandInline`</ph> Socketoptionen.</target>       </trans-unit>
        <trans-unit id="3352" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> object has been closed.</source>
          <target state="translated">Das <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Objekt wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3353" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3354" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3355" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3356" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An array of type <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph> that represents the value of the option.</source>
          <target state="translated">Ein Array vom Typ <ph id="ph1">&lt;see cref="T:System.Byte" /&gt;</ph>, das den Wert der Option darstellt.</target>       </trans-unit>
        <trans-unit id="3357" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as a byte array.</source>
          <target state="translated">Legt die angegebene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option auf den angegebenen, als Bytearray dargestellten Wert fest.</target>       </trans-unit>
        <trans-unit id="3358" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3359" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>Use this overload to set those <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that require a byte array as an option value.</source>
          <target state="translated">Verwenden Sie diese Überladung, die festzulegende <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen, die ein Bytearray als Optionswert erfordern.</target>       </trans-unit>
        <trans-unit id="3360" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3361" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3362" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3363" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3364" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeoutwerte.</target>       </trans-unit>
        <trans-unit id="3365" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3366" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3367" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3368" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3369" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>A value of the option.</source>
          <target state="translated">Ein Wert der Option.</target>       </trans-unit>
        <trans-unit id="3370" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified integer value.</source>
          <target state="translated">Legt die angegebene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option auf den angegebenen ganzzahligen Wert fest.</target>       </trans-unit>
        <trans-unit id="3371" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3372" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with a <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</source>
          <target state="translated">Für eine Option mit einem <ph id="ph1">&lt;xref:System.Boolean&gt;</ph> -Datentyp, geben Sie einen Wert ungleich NULL, um die Option zu aktivieren und einen Wert von 0 zum Deaktivieren der Option.</target>       </trans-unit>
        <trans-unit id="3373" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For an option with an integer data type, specify the appropriate value.</source>
          <target state="translated">Geben Sie für eine Option mit einem Integer-Datentyp den entsprechenden Wert ein.</target>       </trans-unit>
        <trans-unit id="3374" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options are grouped by level of protocol support.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen werden nach Maß an Unterstützung für das Protokoll gruppiert.</target>       </trans-unit>
        <trans-unit id="3375" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>Listed below are the various <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options that can be set using this overload.</source>
          <target state="translated">Unten sind die verschiedenen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3376" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>These options are grouped by the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</source>
          <target state="translated">Diese Optionen werden von der entsprechenden gruppiert <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3377" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you intend to set any of these options, be sure to use the appropriate <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> for the <ph id="ph2">`optionLevel`</ph> parameter.</source>
          <target state="translated">Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, den entsprechenden verwenden <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel&gt;</ph> für die <ph id="ph2">`optionLevel`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3378" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The option you choose to set must be specified in the <ph id="ph1">`optionName`</ph> parameter.</source>
          <target state="translated">Die Option wählen, dass einrichten muss angegeben werden, der <ph id="ph1">`optionName`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3379" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you want to get the current value of any of the options listed, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3380" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3381" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3382" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3383" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3384" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> options that can be set using this overload.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType&gt;</ph> Optionen, die mit dieser Überladung festgelegt werden können.</target>       </trans-unit>
        <trans-unit id="3385" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information about these options, refer to the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> enumeration.</source>
          <target state="translated">Weitere Informationen zu diesen Optionen finden Sie in der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName&gt;</ph> Enumeration.</target>       </trans-unit>
        <trans-unit id="3386" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3387" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3388" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3389" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3390" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time-out values.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeoutwerte.</target>       </trans-unit>
        <trans-unit id="3391" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3392" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3393" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionLevel" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3394" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketOptionName" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3395" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>A <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> or <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> that contains the value of the option.</source>
          <target state="translated">Eine <ph id="ph1">&lt;see cref="T:System.Net.Sockets.LingerOption" /&gt;</ph> oder <ph id="ph2">&lt;see cref="T:System.Net.Sockets.MulticastOption" /&gt;</ph> mit dem Wert der Option.</target>       </trans-unit>
        <trans-unit id="3396" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Sets the specified <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> option to the specified value, represented as an object.</source>
          <target state="translated">Legt die angegebene <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>-Option auf den angegebenen, als Objekt dargestellten Wert fest.</target>       </trans-unit>
        <trans-unit id="3397" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options determine the behavior of the current <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen bestimmen das Verhalten des aktuellen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3398" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>Use this overload to set the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph><ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> options.</source>
          <target state="translated">Verwenden Sie diese Überladung zum Festlegen der <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph> <ph id="ph4">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Optionen.</target>       </trans-unit>
        <trans-unit id="3399" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> option, use <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> for the <ph id="ph3">`optionLevel`</ph> parameter.</source>
          <target state="translated">Für die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.Linger&gt;</ph> mit <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> für die <ph id="ph3">`optionLevel`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3400" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>For <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, use <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</source>
          <target state="translated">Für <ph id="ph1">&lt;xref:System.Net.Sockets.SocketOptionName.AddMembership&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.SocketOptionName.DropMembership&gt;</ph>, verwenden Sie <ph id="ph3">&lt;xref:System.Net.Sockets.SocketOptionLevel.IP&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3401" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you want to get the current value of any of the options listed above, use the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> method.</source>
          <target state="translated">Wenn Sie den aktuellen Wert eines der oben aufgeführten Optionen abzurufen, verwenden Sie möchten die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.GetSocketOption%2A&gt;</ph> Methode.</target>       </trans-unit>
        <trans-unit id="3402" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3403" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3404" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The following code example sets the <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> and <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> time out values.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.LingerOption&gt;</ph> und <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> Timeoutwerte.</target>       </trans-unit>
        <trans-unit id="3405" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> is <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;paramref name="optionValue" /&gt;</ph> ist <ph id="ph2">&lt;see langword="null" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3406" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3407" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3408" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph> values that specifies the operation that will no longer be allowed.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketShutdown" /&gt;</ph>-Werte, der den Vorgang angibt, der nicht mehr zulässig ist.</target>       </trans-unit>
        <trans-unit id="3409" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disables sends and receives on a <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Deaktiviert Senden und Empfangen für einen <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3410" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>When using a connection-oriented <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, always call the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method before closing the <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Bei Verwendung einer verbindungsorientierten <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, rufen Sie immer die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> Methode vor dem Schließen der <ph id="ph3">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3411" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This ensures that all data is sent and received on the connected socket before it is closed.</source>
          <target state="translated">Dadurch wird sichergestellt, dass alle Daten gesendet und empfangen auf dem verbundenen Socket, bevor er geschlossen wurde.</target>       </trans-unit>
        <trans-unit id="3412" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Call the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> method to free all managed and unmanaged resources associated with the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Rufen Sie die <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Close%2A&gt;</ph> Methode, um alle freizugeben verwaltete und nicht verwaltete Ressourcen, die zugeordneten der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3413" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Do not attempt to reuse the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> after closing.</source>
          <target state="translated">Versuchen Sie nicht, Wiederverwenden der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph> nach dem Schließen.</target>       </trans-unit>
        <trans-unit id="3414" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following table shows the <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> enumeration values that are valid for the <ph id="ph2">`how`</ph> parameter.</source>
          <target state="translated">Die folgende Tabelle zeigt die <ph id="ph1">&lt;xref:System.Net.Sockets.SocketShutdown&gt;</ph> gültige Enumerationswerte für die <ph id="ph2">`how`</ph> Parameter.</target>       </trans-unit>
        <trans-unit id="3415" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Value</source>
          <target state="translated">Wert</target>       </trans-unit>
        <trans-unit id="3416" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Description</source>
          <target state="translated">Beschreibung </target>       </trans-unit>
        <trans-unit id="3417" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Send</source>
          <target state="translated">Senden</target>       </trans-unit>
        <trans-unit id="3418" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable sending on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Deaktiviert das Senden für dieses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3419" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Receive</source>
          <target state="translated">Empfangen</target>       </trans-unit>
        <trans-unit id="3420" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Deaktiviert das Empfangen für dieses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3421" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Both</source>
          <target state="translated">Beides</target>       </trans-unit>
        <trans-unit id="3422" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Disable both sending and receiving on this <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Deaktiviert das Senden und empfangen auf diese <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3423" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Festlegen von <ph id="ph1">`how`</ph> auf <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> gibt an, dass bei nachfolgenden Aufrufe von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Send%2A&gt;</ph> sind nicht zulässig.</target>       </trans-unit>
        <trans-unit id="3424" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, specifying <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> will have no effect.</source>
          <target state="translated">Bei einem verbindungslosen <ph id="ph1">&lt;xref:System.Net.Sockets.Socket&gt;</ph>, wobei <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Send&gt;</ph> hat keine Auswirkungen.</target>       </trans-unit>
        <trans-unit id="3425" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> specifies that subsequent calls to <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> are not allowed.</source>
          <target state="translated">Festlegen von <ph id="ph1">`how`</ph> auf <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Receive&gt;</ph> gibt an, dass bei nachfolgenden Aufrufe von <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.Receive%2A&gt;</ph> sind nicht zulässig.</target>       </trans-unit>
        <trans-unit id="3426" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This has no effect on lower protocol layers.</source>
          <target state="translated">Dies wirkt sich nicht auf niedrigeren Protokollebenen.</target>       </trans-unit>
        <trans-unit id="3427" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</source>
          <target state="translated">Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wird die Verbindung beendet, wenn eine der folgenden Bedingungen, nach einem Aufruf von vorhanden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> :</target>       </trans-unit>
        <trans-unit id="3428" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Data is in the incoming network buffer waiting to be received.</source>
          <target state="translated">Daten sind in der eingehenden Netzwerkpuffer darauf warten, empfangen werden.</target>       </trans-unit>
        <trans-unit id="3429" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>More data has arrived.</source>
          <target state="translated">Mehr Daten empfangen hat.</target>       </trans-unit>
        <trans-unit id="3430" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you are using a connectionless protocol, datagrams are accepted and queued.</source>
          <target state="translated">Wenn Sie ein verbindungsloses Protokoll verwenden, sind Datagramme akzeptiert und in die Warteschlange eingereiht.</target>       </trans-unit>
        <trans-unit id="3431" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</source>
          <target state="translated">Wenn kein Pufferplatz für weitere eingehende Datagramme verfügbar ist, werden sie verworfen und wird kein Fehler an den Absender zurückgegeben werden.</target>       </trans-unit>
        <trans-unit id="3432" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Using <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> on a connectionless <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is not recommended.</source>
          <target state="translated">Mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> auf einem verbindungslosen <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wird nicht empfohlen.</target>       </trans-unit>
        <trans-unit id="3433" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>Setting <ph id="ph1">`how`</ph> to <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> disables both sends and receives as described above.</source>
          <target state="translated">Festlegen von <ph id="ph1">`how`</ph> auf <ph id="ph2">&lt;xref:System.Net.Sockets.SocketShutdown.Both&gt;</ph> deaktiviert sowohl senden und empfangen, wie oben beschrieben.</target>       </trans-unit>
        <trans-unit id="3434" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> when calling the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> method, use the <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Erhalten Sie eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph> beim Aufrufen der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> -Methode, mit der <ph id="ph3">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3435" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3436" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>This member outputs trace information when you enable network tracing in your application.</source>
          <target state="translated">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</target>       </trans-unit>
        <trans-unit id="3437" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>For more information, see <bpt id="p1">[</bpt>Network Tracing in the .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</source>
          <target state="translated">Weitere Informationen finden Sie unter <bpt id="p1">[</bpt>Netzwerkablaufverfolgung in .NET Framework<ept id="p1">](~/docs/framework/network-programming/network-tracing.md)</ept>.</target>       </trans-unit>
        <trans-unit id="3438" translate="yes" xml:space="preserve" extradata="MT" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The following code example uses <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> to disable the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</source>
          <target state="translated">Im folgenden Codebeispiel wird mit <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Shutdown%2A&gt;</ph> zum Deaktivieren der <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3439" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3440" translate="yes" xml:space="preserve" uid="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3441" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>Gets the type of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft den Typ des <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> ab.</target>       </trans-unit>
        <trans-unit id="3442" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>One of the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph> values.</source>
          <target state="translated">Einer der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.SocketType" /&gt;</ph>-Werte.</target>       </trans-unit>
        <trans-unit id="3443" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> is read-only and is set when the <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> is created.</source>
          <target state="translated"><ph id="ph1">&lt;xref:System.Net.Sockets.Socket.SocketType%2A&gt;</ph> ist schreibgeschützt und wird festgelegt, wenn die <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> wird erstellt.</target>       </trans-unit>
        <trans-unit id="3444" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SocketType">
          <source>The following code example displays the <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, and <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> to the console.</source>
          <target state="translated">Im folgenden Codebeispiel wird die <ph id="ph1">&lt;xref:System.Net.Sockets.AddressFamily&gt;</ph>, <ph id="ph2">&lt;xref:System.Net.Sockets.SocketType&gt;</ph>, und <ph id="ph3">&lt;xref:System.Net.Sockets.ProtocolType&gt;</ph> an die Konsole.</target>       </trans-unit>
        <trans-unit id="3445" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>Gets a value indicating whether IPv4 support is available and enabled on the current host.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob IPv4-Unterstützung verfügbar und auf dem aktuellen Host aktiviert ist.</target>       </trans-unit>
        <trans-unit id="3446" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the current host supports the IPv4 protocol; otherwise, <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der aktuelle Host das Protokoll IPv4 unterstützt, andernfalls <ph id="ph2">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3447" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv4">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.</target>       </trans-unit>
        <trans-unit id="3448" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph> members.</source>
          <target state="translated">Ruft einen Wert ab, der angibt, ob das Framework IPv6 für bestimmte veraltete <ph id="ph1">&lt;see cref="T:System.Net.Dns" /&gt;</ph>-Member unterstützt.</target>       </trans-unit>
        <trans-unit id="3449" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the Framework supports IPv6 for certain obsolete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph> methods; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn das Framework IPv6 für bestimmte veraltete <ph id="ph2">&lt;see cref="T:System.Net.Dns" /&gt;</ph>-Methoden unterstützt, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3450" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.SupportsIPv6">
          <source>The operating system may support both IPv4 and IPv6 protocols.</source>
          <target state="translated">Das Betriebssystem kann sowohl IPv4 als auch IPv6 unterstützt.</target>       </trans-unit>
        <trans-unit id="3451" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph>.</source>
          <target state="translated">Ruft einen Wert ab, der die Gültigkeitsdauer (TTL) von IP (Internet Protocol)-Paketen angibt, die vom <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> gesendet werden.</target>       </trans-unit>
        <trans-unit id="3452" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value.</source>
          <target state="translated">Der TTL-Wert.</target>       </trans-unit>
        <trans-unit id="3453" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</source>
          <target state="translated">Der TTL-Wert gibt die maximale Anzahl von Routern, die das Paket durchlaufen kann, bevor der Router verwirft das Paket und eine Internet ICMP Control Message Protocol () "Gültigkeitsdauer überschritten" Fehlermeldung an den Absender zurückgegeben.</target>       </trans-unit>
        <trans-unit id="3454" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value may be set to a value from 0 to 255.</source>
          <target state="translated">Der TTL-Wert kann auf einen Wert von 0 bis 255 festgelegt werden.</target>       </trans-unit>
        <trans-unit id="3455" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>When this property is not set, the default TTL value for a socket is 32.</source>
          <target state="translated">Wenn diese Eigenschaft nicht festgelegt ist, ist der Standardwert für die Gültigkeitsdauer (TTL) für ein Socket 32.</target>       </trans-unit>
        <trans-unit id="3456" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</source>
          <target state="translated">Durch Festlegen dieser Eigenschaft für ein Protokoll TCP (Transmission Control)-Socket wird vom TCP/IP-Stapel ignoriert, wenn eine erfolgreiche Verbindung mit dem Socket hergestellt wurde.</target>       </trans-unit>
        <trans-unit id="3457" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>If you receive a <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, use the <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> property to obtain the specific error code.</source>
          <target state="translated">Wenn Sie erhalten eine <ph id="ph1">&lt;xref:System.Net.Sockets.SocketException&gt;</ph>, verwenden die <ph id="ph2">&lt;xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType&gt;</ph> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</target>       </trans-unit>
        <trans-unit id="3458" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>After you have obtained this code, refer to the Windows Sockets version 2 API error code documentation in the MSDN library for a detailed description of the error.</source>
          <target state="translated">Wenn Sie diesen Code erhalten haben, finden Sie unter der Windows Sockets-Version 2-API-Fehler Code-Dokumentation in der MSDN Library für eine ausführliche Beschreibung des Fehlers.</target>       </trans-unit>
        <trans-unit id="3459" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The following code example demonstrates the use of the <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> property.</source>
          <target state="translated">Das folgende Codebeispiel veranschaulicht die Verwendung von der <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.Ttl%2A&gt;</ph> Eigenschaft.</target>       </trans-unit>
        <trans-unit id="3460" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The TTL value can't be set to a negative number.</source>
          <target state="translated">Für den TTL-Wert kann keine negative Zahl festgelegt werden.</target>       </trans-unit>
        <trans-unit id="3461" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This property can be set only for sockets in the <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph> or <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph> families.</source>
          <target state="translated">Diese Eigenschaft kann nur für Sockets in der <ph id="ph1">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /&gt;</ph>-Familie oder der <ph id="ph2">&lt;see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /&gt;</ph>-Familie festgelegt werden.</target>       </trans-unit>
        <trans-unit id="3462" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>An error occurred when attempting to access the socket.</source>
          <target state="translated">Fehler beim Versuch, auf den Socket zuzugreifen.</target>       </trans-unit>
        <trans-unit id="3463" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>This error is also returned when an attempt was made to set TTL to a value higher than 255.</source>
          <target state="translated">Dieser Fehler wird auch zurückgegeben, wenn versucht wird, TTL auf einen höheren Wert als 255 festzulegen.</target>       </trans-unit>
        <trans-unit id="3464" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.Ttl">
          <source>The <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> has been closed.</source>
          <target state="translated">Der <ph id="ph1">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> wurde geschlossen.</target>       </trans-unit>
        <trans-unit id="3465" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Specifies whether the socket should only use Overlapped I/O mode.</source>
          <target state="translated">Gibt an, ob der Socket nur den Modus für überlappende E/A-Vorgänge verwenden soll.</target>       </trans-unit>
        <trans-unit id="3466" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source><ph id="ph1">&lt;see langword="true" /&gt;</ph> if the <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> uses only overlapped I/O; otherwise, <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated"><ph id="ph1">&lt;see langword="true" /&gt;</ph>, wenn der <ph id="ph2">&lt;see cref="T:System.Net.Sockets.Socket" /&gt;</ph> nur überlappende E/A-Vorgänge verwendet, andernfalls <ph id="ph3">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3467" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The default is <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</source>
          <target state="translated">Der Standardwert ist <ph id="ph1">&lt;see langword="false" /&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3468" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Set this property to <ph id="ph1">`true`</ph> for a <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> you intend to call <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Legen Sie diese Eigenschaft auf <ph id="ph1">`true`</ph> für eine <ph id="ph2">&lt;xref:System.Net.Sockets.Socket&gt;</ph> Sie aufrufen möchten <ph id="ph3">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3469" translate="yes" xml:space="preserve" extradata="MT" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</source>
          <target state="translated">Ordnen Sie andernfalls das Framework kann ein Abschlussport an den Socket, die die Verwendung von verhindern würden <ph id="ph1">&lt;xref:System.Net.Sockets.Socket.DuplicateAndClose%2A&gt;</ph>.</target>       </trans-unit>
        <trans-unit id="3470" translate="yes" xml:space="preserve" uid="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO">
          <source>The socket has been bound to a completion port.</source>
          <target state="translated">Der Socket wurde an einen Abschlussanschluss gebunden.</target>       </trans-unit>
      </group>
    </body>
  </file>
</xliff>