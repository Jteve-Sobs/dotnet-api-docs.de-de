<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="63769c1816253f4132d9d7d8227469536645f718" /><Meta Name="ms.sourcegitcommit" Value="1617f40ee47f4336ea7edb156fc31f853fadd853" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/13/2020" /><Meta Name="ms.locfileid" Value="88188358" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Sockets" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
    <TypeForwarding From="System.Net" FromVersion="4.0.0.0" To="System" ToVersion="4.0.0.0" FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="d063a-101">Implementiert die Berkeley-Sockets-Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="d063a-101">Implements the Berkeley sockets interface.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-102">Die- <xref:System.Net.Sockets.Socket> Klasse stellt einen umfangreichen Satz von Methoden und Eigenschaften für die Netzwerkkommunikation bereit.</span><span class="sxs-lookup"><span data-stu-id="d063a-102">The <xref:System.Net.Sockets.Socket> class provides a rich set of methods and properties for network communications.</span></span> <span data-ttu-id="d063a-103">Die <xref:System.Net.Sockets.Socket> -Klasse ermöglicht es Ihnen, sowohl synchrone als auch asynchrone Datenübertragungen mithilfe eines der in der-Enumeration aufgeführten Kommunikationsprotokolle auszuführen <xref:System.Net.Sockets.ProtocolType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-103">The <xref:System.Net.Sockets.Socket> class allows you to perform both synchronous and asynchronous data transfer using any of the communication protocols listed in the <xref:System.Net.Sockets.ProtocolType> enumeration.</span></span>  
  
 <span data-ttu-id="d063a-104">Die- <xref:System.Net.Sockets.Socket> Klasse folgt dem .NET Framework Benennungs Muster für asynchrone Methoden.</span><span class="sxs-lookup"><span data-stu-id="d063a-104">The <xref:System.Net.Sockets.Socket> class follows the .NET Framework naming pattern for asynchronous methods.</span></span> <span data-ttu-id="d063a-105">Beispielsweise entspricht die synchrone <xref:System.Net.Sockets.Socket.Receive%2A> -Methode den asynchronen <xref:System.Net.Sockets.Socket.BeginReceive%2A> -und- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methoden.</span><span class="sxs-lookup"><span data-stu-id="d063a-105">For example, the synchronous <xref:System.Net.Sockets.Socket.Receive%2A> method corresponds to the asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods.</span></span>  
  
 <span data-ttu-id="d063a-106">Wenn für die Anwendung nur ein Thread während der Ausführung erforderlich ist, verwenden Sie die folgenden Methoden, die für den synchronen Betriebsmodus vorgesehen sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-106">If your application only requires one thread during execution, use the following methods, which are designed for synchronous operation mode.</span></span>  
  
-   <span data-ttu-id="d063a-107">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, kann der Server mit der-Methode auf Verbindungen lauschen <xref:System.Net.Sockets.Socket.Listen%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-107">If you are using a connection-oriented protocol such as TCP, your server can listen for connections using the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="d063a-108">Die <xref:System.Net.Sockets.Socket.Accept%2A> -Methode verarbeitet alle eingehenden Verbindungsanforderungen und gibt einen zurück <xref:System.Net.Sockets.Socket> , den Sie verwenden können, um Daten mit dem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-108">The <xref:System.Net.Sockets.Socket.Accept%2A> method processes any incoming connection requests and returns a <xref:System.Net.Sockets.Socket> that you can use to communicate data with the remote host.</span></span> <span data-ttu-id="d063a-109">Verwenden Sie diese Rückgabe <xref:System.Net.Sockets.Socket> , um die-oder-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-109">Use this returned <xref:System.Net.Sockets.Socket> to call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span> <span data-ttu-id="d063a-110">Rufen <xref:System.Net.Sockets.Socket.Bind%2A> Sie die-Methode vor dem Aufrufen der <xref:System.Net.Sockets.Socket.Listen%2A> -Methode auf, wenn Sie die lokale IP-Adresse und die Portnummer angeben möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-110">Call the <xref:System.Net.Sockets.Socket.Bind%2A> method prior to calling the <xref:System.Net.Sockets.Socket.Listen%2A> method if you want to specify the local IP address and port number.</span></span> <span data-ttu-id="d063a-111">Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port zuweisen soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-111">Use a port number of zero if you want the underlying service provider to assign a free port for you.</span></span> <span data-ttu-id="d063a-112">Wenn Sie eine Verbindung mit einem Überwachungshost herstellen möchten, müssen Sie die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-112">If you want to connect to a listening host, call the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-113">Um Daten zu kommunizieren, können Sie die- <xref:System.Net.Sockets.Socket.Send%2A> oder- <xref:System.Net.Sockets.Socket.Receive%2A> Methode abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-113">To communicate data, call the <xref:System.Net.Sockets.Socket.Send%2A> or <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
-   <span data-ttu-id="d063a-114">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie nicht auf Verbindungen lauschen.</span><span class="sxs-lookup"><span data-stu-id="d063a-114">If you are using a connectionless protocol such as UDP, you do not need to listen for connections at all.</span></span> <span data-ttu-id="d063a-115">Ruft die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode auf, um eingehende Datagramme zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-115">Call the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method to accept any incoming datagrams.</span></span> <span data-ttu-id="d063a-116">Verwenden Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode, um Datagramme an einen Remote Host zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-116">Use the <xref:System.Net.Sockets.Socket.SendTo%2A> method to send datagrams to a remote host.</span></span>  
  
 <span data-ttu-id="d063a-117">Verwenden Sie die folgenden Methoden, die für den asynchronen Betriebsmodus entwickelt wurden, um die Kommunikation mit separaten Threads während der Ausführung zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-117">To process communications using separate threads during execution, use the following methods, which are designed for asynchronous operation mode.</span></span>  
  
-   <span data-ttu-id="d063a-118">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, verwenden Sie die <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, und, <xref:System.Net.Sockets.Socket.EndConnect%2A> um eine Verbindung mit einem lauschenden Host herzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-118">If you are using a connection-oriented protocol such as TCP, use the <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, and <xref:System.Net.Sockets.Socket.EndConnect%2A> methods to connect with a listening host.</span></span> <span data-ttu-id="d063a-119">Verwenden <xref:System.Net.Sockets.Socket.BeginSend%2A> Sie die-Methode und die <xref:System.Net.Sockets.Socket.EndSend%2A> <xref:System.Net.Sockets.Socket.BeginReceive%2A> -Methode und die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode, um Daten asynchron</span><span class="sxs-lookup"><span data-stu-id="d063a-119">Use the <xref:System.Net.Sockets.Socket.BeginSend%2A> and <xref:System.Net.Sockets.Socket.EndSend%2A> or <xref:System.Net.Sockets.Socket.BeginReceive%2A> and <xref:System.Net.Sockets.Socket.EndReceive%2A> methods to communicate data asynchronously.</span></span> <span data-ttu-id="d063a-120">Eingehende Verbindungsanforderungen können mithilfe von <xref:System.Net.Sockets.Socket.BeginAccept%2A> und verarbeitet werden <xref:System.Net.Sockets.Socket.EndAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-120">Incoming connection requests can be processed using <xref:System.Net.Sockets.Socket.BeginAccept%2A> and <xref:System.Net.Sockets.Socket.EndAccept%2A>.</span></span>  
  
-   <span data-ttu-id="d063a-121">Wenn Sie ein verbindungsloses Protokoll, z. b. UDP, verwenden, können Sie und verwenden, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> <xref:System.Net.Sockets.Socket.EndSendTo%2A> um Datagramme zu senden, und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> und, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> um Datagramme zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-121">If you are using a connectionless protocol such as UDP, you can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.EndSendTo%2A> to send datagrams, and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> and <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> to receive datagrams.</span></span>  
  
 <span data-ttu-id="d063a-122">Wenn Sie mehrere asynchrone Vorgänge für einen Socket ausführen, werden diese nicht notwendigerweise in der Reihenfolge, in der Sie gestartet wurden, vervollständigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-122">If you perform multiple asynchronous operations on a socket, they do not necessarily complete in the order in which they are started.</span></span>  
  
 <span data-ttu-id="d063a-123">Wenn Sie mit dem Senden und empfangen von Daten fertig sind, verwenden Sie die- <xref:System.Net.Sockets.Socket.Shutdown%2A> Methode, um zu deaktivieren <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-123">When you are finished sending and receiving data, use the <xref:System.Net.Sockets.Socket.Shutdown%2A> method to disable the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-124"><xref:System.Net.Sockets.Socket.Shutdown%2A>Rufen Sie nach dem Aufrufen der- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf, um alle dem zugeordneten Ressourcen freizugeben <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-124">After calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method to release all resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 <span data-ttu-id="d063a-125">Die- <xref:System.Net.Sockets.Socket> Klasse ermöglicht es Ihnen, <xref:System.Net.Sockets.Socket> mit der-Methode zu konfigurieren <xref:System.Net.Sockets.Socket.SetSocketOption%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-125">The <xref:System.Net.Sockets.Socket> class allows you to configure your <xref:System.Net.Sockets.Socket> using the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span> <span data-ttu-id="d063a-126">Rufen Sie diese Einstellungen mithilfe der- <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-126">Retrieve these settings using the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-127">Wenn Sie eine relativ einfache Anwendung schreiben und keine maximale Leistung benötigen, sollten Sie die Verwendung von, und in Erwägung gezogen <xref:System.Net.Sockets.TcpClient> <xref:System.Net.Sockets.TcpListener> <xref:System.Net.Sockets.UdpClient> .</span><span class="sxs-lookup"><span data-stu-id="d063a-127">If you are writing a relatively simple application and do not require maximum performance, consider using <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, and <xref:System.Net.Sockets.UdpClient>.</span></span> <span data-ttu-id="d063a-128">Diese Klassen stellen eine einfachere und benutzerfreundlichere Oberfläche für die <xref:System.Net.Sockets.Socket> Kommunikation bereit.</span><span class="sxs-lookup"><span data-stu-id="d063a-128">These classes provide a simpler and more user-friendly interface to <xref:System.Net.Sockets.Socket> communications.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-129">Im folgenden Codebeispiel wird gezeigt, wie die <xref:System.Net.Sockets.Socket> -Klasse zum Senden von Daten an einen HTTP-Server und zum Empfangen der Antwort verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-129">The following code example shows how the <xref:System.Net.Sockets.Socket> class can be used to send data to an HTTP server and receive the response.</span></span> <span data-ttu-id="d063a-130">Dieses Beispiel wird so lange blockiert, bis die gesamte Seite empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-130">This example blocks until the entire page is received.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <threadsafe><span data-ttu-id="d063a-131">Instanzen dieser Klasse sind Thread sicher.</span><span class="sxs-lookup"><span data-stu-id="d063a-131">Instances of this class are thread safe.</span></span></threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="/dotnet/framework/network-programming/"><span data-ttu-id="d063a-132">Netzwerkprogrammierung in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d063a-132">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/best-practices-for-system-net-classes"><span data-ttu-id="d063a-133">Bewährte Methoden für System.Net-Klassen</span><span class="sxs-lookup"><span data-stu-id="d063a-133">Best Practices for System.Net Classes</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/cache-management-for-network-applications"><span data-ttu-id="d063a-134">Cacheverwaltung für Netzwerkanwendungen</span><span class="sxs-lookup"><span data-stu-id="d063a-134">Cache Management for Network Applications</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/internet-protocol-version-6"><span data-ttu-id="d063a-135">Internetprotokoll Version 6</span><span class="sxs-lookup"><span data-stu-id="d063a-135">Internet Protocol Version 6</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/network-programming-samples"><span data-ttu-id="d063a-136">Beispiele zur Netzwerkprogrammierung</span><span class="sxs-lookup"><span data-stu-id="d063a-136">Network Programming Samples</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/network-tracing"><span data-ttu-id="d063a-137">Netzwerkablaufverfolgung in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="d063a-137">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/security-in-network-programming"><span data-ttu-id="d063a-138">Sicherheit in der Netzwerkprogrammierung</span><span class="sxs-lookup"><span data-stu-id="d063a-138">Security in Network Programming</span></span></related>
    <related type="Article" href="/dotnet/framework/network-programming/socket-performance-enhancements-in-version-3-5"><span data-ttu-id="d063a-139">Erweiterungen der Socketleistung in Version 3.5</span><span class="sxs-lookup"><span data-stu-id="d063a-139">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-140">Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-140">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SafeSocketHandle handle);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.Sockets.SafeSocketHandle handle) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SafeSocketHandle)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (handle As SafeSocketHandle)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SafeSocketHandle ^ handle);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SafeSocketHandle -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket handle" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="handle" Type="System.Net.Sockets.SafeSocketHandle" Index="0" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="handle"><span data-ttu-id="d063a-141">Das Sockethandle für den Socket, der vom <see cref="T:System.Net.Sockets.Socket" />-Objekt gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-141">The socket handle for the socket that the <see cref="T:System.Net.Sockets.Socket" /> object will encapsulate.</span></span></param>
        <summary><span data-ttu-id="d063a-142">Initialisiert für das angegebene Sockethandle eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-142">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class for the specified socket handle.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d063a-143">Diese Methode füllt die- <xref:System.Net.Sockets.Socket> Instanz mit den Daten auf, die aus dem angegebenen erfasst wurden <xref:System.Net.Sockets.SafeSocketHandle> .</span><span class="sxs-lookup"><span data-stu-id="d063a-143">This method populates the <xref:System.Net.Sockets.Socket> instance with data gathered from the supplied <xref:System.Net.Sockets.SafeSocketHandle>.</span></span>
<span data-ttu-id="d063a-144">Unterschiedliche Betriebssysteme bieten unterschiedliche Ebenen der Unterstützung für das Abfragen eines Sockethandles oder Datei Deskriptors für die Eigenschaften und die Konfiguration.</span><span class="sxs-lookup"><span data-stu-id="d063a-144">Different operating systems provide varying levels of support for querying a socket handle or file descriptor for its properties and configuration.</span></span> <span data-ttu-id="d063a-145">Einige der öffentlichen APIs auf der resultierenden <xref:System.Net.Sockets.Socket> Instanz können sich je nach Betriebssystem, z. b <xref:System.Net.Sockets.Socket.ProtocolType> . und, unterscheiden <xref:System.Net.Sockets.Socket.Blocking> .</span><span class="sxs-lookup"><span data-stu-id="d063a-145">Some of the public APIs on the resulting <xref:System.Net.Sockets.Socket> instance may differ based on operating system, such as <xref:System.Net.Sockets.Socket.ProtocolType> and <xref:System.Net.Sockets.Socket.Blocking>.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-146"><paramref name="handle" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-146"><paramref name="handle" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-147"><paramref name="handle" /> ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-147"><paramref name="handle" /> is invalid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-148"><paramref name="handle" /> ist kein Socket, oder auf Informationen zum Socket konnte nicht zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-148"><paramref name="handle" /> is not a socket or information about the socket could not be accessed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketInformation As SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="socketInformation"><span data-ttu-id="d063a-149">Die von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegebenen Socketinformationen.</span><span class="sxs-lookup"><span data-stu-id="d063a-149">The socket information returned by <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></param>
        <summary><span data-ttu-id="d063a-150">Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse mit dem angegebenen Wert, der von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-150">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified value returned from <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-151">Wenn Sie den- <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit dem gleichen Bytearray wie das-Argument für jeden-Befehl aufzurufen, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket> s mit dem gleichen zugrunde liegenden Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-151">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket>s with the same underlying socket.</span></span> <span data-ttu-id="d063a-152">Diese Vorgehensweise wird dringend davon abgeraten.</span><span class="sxs-lookup"><span data-stu-id="d063a-152">This practice is strongly discouraged.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="d063a-153">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-153">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="d063a-154">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-154">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-155">Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Sockettyps und Protokolls.</span><span class="sxs-lookup"><span data-stu-id="d063a-155">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-156">Der `socketType` -Parameter gibt den Typ der <xref:System.Net.Sockets.Socket> Klasse an, und der- `protocolType` Parameter gibt das von verwendete Protokoll an <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-156">The `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-157">Die beiden Parameter sind nicht unabhängig.</span><span class="sxs-lookup"><span data-stu-id="d063a-157">The two parameters are not independent.</span></span> <span data-ttu-id="d063a-158">Häufig <xref:System.Net.Sockets.Socket> ist der Typ im Protokoll implizit.</span><span class="sxs-lookup"><span data-stu-id="d063a-158">Often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="d063a-159">Wenn die Kombination aus <xref:System.Net.Sockets.Socket> Typ und Protokolltyp zu einem ungültigen führt <xref:System.Net.Sockets.Socket> , löst dieser Konstruktor einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-159">If the combination of <xref:System.Net.Sockets.Socket> type and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-160">Wenn dieser Konstruktor eine auslöst <xref:System.Net.Sockets.SocketException> , verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-160">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-161">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-161">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-162">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-162">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-163">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-163">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-164">Die Kombination von <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-164">The combination of  <paramref name="socketType" /> and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (addressFamily As AddressFamily, socketType As SocketType, protocolType As ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily"><span data-ttu-id="d063a-165">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-165">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></param>
        <param name="socketType"><span data-ttu-id="d063a-166">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-166">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="d063a-167">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-167">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-168">Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Adressfamilie sowie des angegebenen Sockettyps und Protokolls.</span><span class="sxs-lookup"><span data-stu-id="d063a-168">Initializes a new instance of the <see cref="T:System.Net.Sockets.Socket" /> class using the specified address family, socket type and protocol.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-169">Der- `addressFamily` Parameter gibt das Adressierungs Schema an, das von der- <xref:System.Net.Sockets.Socket> Klasse verwendet wird, der `socketType` -Parameter gibt den Typ der <xref:System.Net.Sockets.Socket> Klasse an, und der- `protocolType` Parameter gibt das von verwendete Protokoll an <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-169">The `addressFamily` parameter specifies the addressing scheme that the <xref:System.Net.Sockets.Socket> class uses, the `socketType` parameter specifies the type of the <xref:System.Net.Sockets.Socket> class, and the `protocolType` parameter specifies the protocol used by <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-170">Die drei Parameter sind nicht unabhängig.</span><span class="sxs-lookup"><span data-stu-id="d063a-170">The three parameters are not independent.</span></span> <span data-ttu-id="d063a-171">Einige Adressfamilien beschränken, welche Protokolle mit Ihnen verwendet werden können, und häufig <xref:System.Net.Sockets.Socket> ist der Typ im Protokoll implizit.</span><span class="sxs-lookup"><span data-stu-id="d063a-171">Some address families restrict which protocols can be used with them, and often the <xref:System.Net.Sockets.Socket> type is implicit in the protocol.</span></span> <span data-ttu-id="d063a-172">Wenn die Kombination aus Adressfamilie, <xref:System.Net.Sockets.Socket> Typ und Protokolltyp zu einem ungültigen führt <xref:System.Net.Sockets.Socket> , löst dieser Konstruktor einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-172">If the combination of address family, <xref:System.Net.Sockets.Socket> type, and protocol type results in an invalid <xref:System.Net.Sockets.Socket>, this constructor throws a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-173">Wenn dieser Konstruktor eine auslöst <xref:System.Net.Sockets.SocketException> , verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-173">If this constructor throws a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-174">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-174">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-175">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-175">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-176">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-176">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-177">Im folgenden Codebeispiel wird veranschaulicht, wie eine Instanz der- <xref:System.Net.Sockets.Socket> Klasse erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-177">The following code example demonstrates how to create an instance of the <xref:System.Net.Sockets.Socket> class.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-178">Die Kombination von <paramref name="addressFamily" />, <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-178">The combination of <paramref name="addressFamily" />, <paramref name="socketType" />, and <paramref name="protocolType" /> results in an invalid socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-179">Erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-179">Creates a new <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></summary>
        <returns><span data-ttu-id="d063a-180">Ein <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-180">A <see cref="T:System.Net.Sockets.Socket" /> for a newly created connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-181"><xref:System.Net.Sockets.Socket.Accept%2A> extrahiert synchron die erste ausstehende Verbindungsanforderung aus der Verbindungs Anforderungs Warteschlange des Abhör Sockets und erstellt dann ein neues und gibt es zurück <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-181"><xref:System.Net.Sockets.Socket.Accept%2A> synchronously extracts the first pending connection request from the connection request queue of the listening socket, and then creates and returns a new <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-182">Sie können diese Rückgabe nicht verwenden <xref:System.Net.Sockets.Socket> , um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-182">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d063a-183">Sie können jedoch die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Methode der zurückgegebenen aufzurufen <xref:System.Net.Sockets.Socket> , um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-183">However, you can call the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> method of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
 <span data-ttu-id="d063a-184">Blockiert im Blockierungs Modus, <xref:System.Net.Sockets.Socket.Accept%2A> bis ein eingehender Verbindungsversuch in die Warteschlange eingereiht wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-184">In blocking mode, <xref:System.Net.Sockets.Socket.Accept%2A> blocks until an incoming connection attempt is queued.</span></span> <span data-ttu-id="d063a-185">Nachdem eine Verbindung akzeptiert wurde, setzt das ursprüngliche die <xref:System.Net.Sockets.Socket> Warteschlange für eingehende Verbindungsanforderungen fort, bis Sie Sie schließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-185">Once a connection is accepted, the original <xref:System.Net.Sockets.Socket> continues queuing incoming connection requests until you close it.</span></span>  
  
 <span data-ttu-id="d063a-186">Wenn Sie diese Methode mit einer nicht blockierenden Methode aufzurufen <xref:System.Net.Sockets.Socket> und keine Verbindungsanforderungen in die Warteschlange eingereiht werden, löst <xref:System.Net.Sockets.Socket.Accept%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-186">If you call this method using a non-blocking <xref:System.Net.Sockets.Socket>, and no connection requests are queued, <xref:System.Net.Sockets.Socket.Accept%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-187">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-187">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-188">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-188">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-189">Vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.Accept%2A> Methode müssen Sie zuerst die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange eingereiht</span><span class="sxs-lookup"><span data-stu-id="d063a-189">Before calling the <xref:System.Net.Sockets.Socket.Accept%2A> method, you must first call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-190">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-190">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-191">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-191">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-192">Im folgenden Codebeispiel wird eine einfache <xref:System.Net.Sockets.Socket> Verbindung akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-192">The following code example accepts a simple <xref:System.Net.Sockets.Socket> connection.</span></span>  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-193">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-193">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-194">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-194">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-195">Der annehmende Socket überwacht keine Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-195">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="d063a-196">Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.Accept" /> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-196">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.Accept" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-197">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-197">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-198">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-198">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="d063a-199"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-199"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-200">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-200">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-201"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-201"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-202">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-202">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-203">Verbindungs orientierte Protokolle können die- <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-203">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d063a-204">Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-204">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d063a-205">Vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange eingereiht</span><span class="sxs-lookup"><span data-stu-id="d063a-205">Before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d063a-206">Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-Delegaten implementiert \<SocketAsyncEventArgs> und ihn mit dem <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis verknüpft.</span><span class="sxs-lookup"><span data-stu-id="d063a-206">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and hook it to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d063a-207">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:</span><span class="sxs-lookup"><span data-stu-id="d063a-207">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-208">Der Aufrufer kann optional eine vorhandene angeben <xref:System.Net.Sockets.Socket> , die für die eingehende Verbindung verwendet werden soll, indem er die <xref:System.Net.Sockets.Socket> zur Verwendung mit der- <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft angibt</span><span class="sxs-lookup"><span data-stu-id="d063a-208">The caller can optionally specify an existing <xref:System.Net.Sockets.Socket> to use for the incoming connection by specifying the <xref:System.Net.Sockets.Socket> to use with the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="d063a-209">Wenn die- <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft NULL ist, wird ein neues <xref:System.Net.Sockets.Socket> mit demselben <xref:System.Net.Sockets.Socket.AddressFamily%2A> , <xref:System.Net.Sockets.Socket.SocketType%2A> , und <xref:System.Net.Sockets.Socket.ProtocolType%2A> wie dem aktuellen erstellt <xref:System.Net.Sockets.Socket> und als-Eigenschaft festgelegt <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-209">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property is null, a new <xref:System.Net.Sockets.Socket> is constructed with the same <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, and <xref:System.Net.Sockets.Socket.ProtocolType%2A> as the current <xref:System.Net.Sockets.Socket> and set as the <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> property.</span></span>  
  
 <span data-ttu-id="d063a-210">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-210">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-211">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-211">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-212">Optional kann ein Puffer bereitgestellt werden, in dem der anfängliche Datenblock im Socket empfangen werden kann, nachdem die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-212">Optionally, a buffer may be provided in which to receive the initial block of data on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d063a-213">In diesem Fall muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> Eigenschaft auf den Puffer festgelegt werden, der die zu empfangenden Daten enthält, und die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft muss auf die maximale Anzahl von Daten Bytes festgelegt werden, die im Puffer empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-213">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to receive and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the maximum number of bytes of data to receive in the buffer.</span></span> <span data-ttu-id="d063a-214">Diese Eigenschaften können mithilfe der-Methode festgelegt werden <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-214">These properties can be set using the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-215">Ein Teil des verworfenen Puffers wird intern für die Verwendung durch den zugrunde liegenden Winsock-Accept-Accept-Vorgang verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-215">Part of the buffer passed in will be consumed internally for use by the underlying Winsock AcceptEx call.</span></span> <span data-ttu-id="d063a-216">Dies bedeutet, dass die Menge der zurückgegebenen Daten immer kleiner ist als der Wert der- <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft für die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> bereitgestellte-Instanz.</span><span class="sxs-lookup"><span data-stu-id="d063a-216">This means that the amount of data returned will always be less than the value of the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> instance provided.</span></span> <span data-ttu-id="d063a-217">Die intern verwendete Puffergröße variiert abhängig von der Adressfamilie des Sockets.</span><span class="sxs-lookup"><span data-stu-id="d063a-217">The amount of the buffer used internally varies based on the address family of the socket.</span></span> <span data-ttu-id="d063a-218">Die mindestens erforderliche Puffergröße beträgt 288 bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-218">The minimum buffer size required is 288 bytes.</span></span> <span data-ttu-id="d063a-219">Wenn eine größere Puffergröße angegeben wird, erwartet das <xref:System.Net.Sockets.Socket> andere zusätzliche Daten als die vom Winsock-Accept-Accept empfangenen Adressdaten und wartet, bis diese zusätzlichen Daten empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-219">If a larger buffer size is specified, then the <xref:System.Net.Sockets.Socket> will expect some extra data other than the address data received by the Winsock AcceptEx call and will wait until this extra data is received.</span></span> <span data-ttu-id="d063a-220">Wenn ein Timeout auftritt, wird die Verbindung zurückgesetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-220">If a timeout occurs, the connection is reset.</span></span> <span data-ttu-id="d063a-221">Wenn also zusätzliche Daten eines bestimmten Betrags erwartet werden, sollte die Puffergröße auf die minimale Puffergröße Plus diese Menge festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-221">So if extra data is expected of  a specific amount, then the buffer size should be set to the minimum buffer size plus this amount.</span></span>  
  
 <span data-ttu-id="d063a-222">Die Abschluss Rückruf Methode sollte die- <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft überprüfen, um zu bestimmen, ob der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Vorgang erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="d063a-222">The completion callback method should examine the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to determine if the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> operation was successful.</span></span>  
  
 <span data-ttu-id="d063a-223">Das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis kann in einigen Fällen auftreten, wenn keine Verbindung akzeptiert wurde und die- <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft auf festgelegt wurde <xref:System.Net.Sockets.SocketError.ConnectionReset> .</span><span class="sxs-lookup"><span data-stu-id="d063a-223">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event can occur in some cases when no connection has been accepted and cause the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> property to be set to <xref:System.Net.Sockets.SocketError.ConnectionReset>.</span></span> <span data-ttu-id="d063a-224">Dies kann das Ergebnis der Überprüfung des Ports mithilfe eines halb geöffneten SYN-typscans sein (eine SYN-> SYN-ACK-> RST-Sequenz).</span><span class="sxs-lookup"><span data-stu-id="d063a-224">This can occur as a result of port scanning using a half-open SYN type scan (a SYN -> SYN-ACK -> RST sequence).</span></span> <span data-ttu-id="d063a-225">Anwendungen, die die- <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode verwenden, sollten darauf vorbereitet sein, diese Bedingung zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-225">Applications using the <xref:System.Net.Sockets.Socket.AcceptAsync%2A> method should be prepared to handle this condition.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-226">Ein Argument ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-226">An argument is not valid.</span></span> <span data-ttu-id="d063a-227">Diese Ausnahme tritt auf, wenn der bereitgestellte Puffer nicht groß genug ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-227">This exception occurs if the buffer provided is not large enough.</span></span> <span data-ttu-id="d063a-228">Der Puffer muss wenigstens 2 \* (sizeof(SOCKADDR_STORAGE + 16) Bytes betragen.</span><span class="sxs-lookup"><span data-stu-id="d063a-228">The buffer must be at least 2 \* (sizeof(SOCKADDR_STORAGE + 16) bytes.</span></span>  
  
<span data-ttu-id="d063a-229">Diese Ausnahme tritt auch auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-229">This exception also occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-230">Ein Argument liegt außerhalb des gültigen Bereichs.</span><span class="sxs-lookup"><span data-stu-id="d063a-230">An argument is out of range.</span></span> <span data-ttu-id="d063a-231">Die Ausnahme tritt auf, wenn <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> kleiner als 0 ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-231">The exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> is less than 0.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-232">Es wurde eine ungültige Operation angefordert.</span><span class="sxs-lookup"><span data-stu-id="d063a-232">An invalid operation was requested.</span></span> <span data-ttu-id="d063a-233">Diese Ausnahme tritt auf, wenn der annehmende <see cref="T:System.Net.Sockets.Socket" /> keine Verbindungen überwacht oder der angenommene Socket gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-233">This exception occurs if the accepting <see cref="T:System.Net.Sockets.Socket" /> is not listening for connections or the accepted socket is bound.</span></span>  
  
<span data-ttu-id="d063a-234">Sie müssen die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />-Methode und die <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />-Methode aufrufen, bevor Sie die <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-234">You must call the <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> method before calling the <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span>  
  
<span data-ttu-id="d063a-235">Diese Ausnahme tritt auch auf, wenn der Socket bereits verbunden ist oder bereits ein Socketvorgang mit dem angegebenen <paramref name="e" />-Parameter ausgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-235">This exception also occurs if the socket is already connected or a socket operation was already in progress using the specified <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-236">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-236">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-237">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-237">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-238">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-238">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-239">Ruft die Adressfamilie des <see cref="T:System.Net.Sockets.Socket" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-239">Gets the address family of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-240">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-240">One of the <see cref="T:System.Net.Sockets.AddressFamily" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-241">Die <xref:System.Net.Sockets.AddressFamily> gibt an, die Adressierung von Schemas, die einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse verwenden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-241">The <xref:System.Net.Sockets.AddressFamily> specifies the addressing scheme that an instance of the <xref:System.Net.Sockets.Socket> class can use.</span></span> <span data-ttu-id="d063a-242">Diese Eigenschaft ist schreibgeschützt und wird festgelegt, wenn das <xref:System.Net.Sockets.Socket> erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-242">This property is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-243">Im folgenden Codebeispiel <xref:System.Net.Sockets.AddressFamily> werden, <xref:System.Net.Sockets.SocketType> und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-243">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-244">Ruft die Datenmenge ab, die über das Netzwerk empfangen wurde und gelesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-244">Gets the amount of data that has been received from the network and is available to be read.</span></span></summary>
        <value><span data-ttu-id="d063a-245">Die Anzahl der Datenbytes, die vom Netzwerk empfangen wurden und zum Lesen zur Verfügung stehen.</span><span class="sxs-lookup"><span data-stu-id="d063a-245">The number of bytes of data received from the network and available to be read.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-246">Wenn Sie eine nicht blockierende verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Available%2A> ist eine gute Möglichkeit, um zu bestimmen, ob Daten in die Warteschlange eingereiht werden, bevor aufgerufen wird <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-246">If you are using a non-blocking <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> is a good way to determine whether data is queued for reading, before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-247">Bei den verfügbaren Daten handelt es sich um die Gesamtmenge der Daten im Netzwerk Puffer zum Lesen.</span><span class="sxs-lookup"><span data-stu-id="d063a-247">The available data is the total amount of data queued in the network buffer for reading.</span></span> <span data-ttu-id="d063a-248">Wenn keine Daten im Netzwerk Puffer in die Warteschlange eingereiht werden, wird <xref:System.Net.Sockets.Socket.Available%2A> 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-248">If no data is queued in the network buffer, <xref:System.Net.Sockets.Socket.Available%2A> returns 0.</span></span>  
  
 <span data-ttu-id="d063a-249">Wenn die Verbindung vom Remote Host heruntergefahren oder geschlossen wird, <xref:System.Net.Sockets.Socket.Available%2A> kann eine auslösen <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-249">If the remote host shuts down or closes the connection, <xref:System.Net.Sockets.Socket.Available%2A> can throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-250">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-250">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-251">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-251">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-252">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-252">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-253">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-253">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-254">Im folgenden Codebeispiel werden die Ergebnisse des Abrufens von IOControl mit "dateread" und der verfügbaren Eigenschaft verglichen.</span><span class="sxs-lookup"><span data-stu-id="d063a-254">The following code example compares the results of calling IOControl with FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-255">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-255">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-256">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-256">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-257">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-257">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="callback"><span data-ttu-id="d063a-258">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-258">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-259">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-259">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-260">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-260">Begins an asynchronous operation to accept an incoming connection attempt.</span></span></summary>
        <returns><span data-ttu-id="d063a-261">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-261">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-262">Verbindungs orientierte Protokolle können die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-262">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d063a-263">Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-263">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d063a-264">Vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange eingereiht</span><span class="sxs-lookup"><span data-stu-id="d063a-264">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d063a-265">Sie müssen eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-265">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-266">Um dies zu erreichen, müssen Sie das <xref:System.Net.Sockets.Socket> Überwachungsobjekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den-Parameter an übergeben `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-266">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d063a-267">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-267">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-268">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-268">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-269">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-269">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d063a-270">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A> , verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert, <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-270">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span> <span data-ttu-id="d063a-271"><xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt ein neues- <xref:System.Net.Sockets.Socket> Objekt zurück, das zum Senden und empfangen von Daten mit dem Remote Host verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-271"><xref:System.Net.Sockets.Socket.EndAccept%2A> will return a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d063a-272">Sie können diese Rückgabe nicht verwenden <xref:System.Net.Sockets.Socket> , um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-272">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d063a-273">Wenn Sie den ursprünglichen Thread blockieren möchten, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-273">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-274">Rufen Sie die Set-Methode für einen <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-274">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d063a-275">Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-275">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d063a-276">In diesem Fall wird die- <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-276">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d063a-277">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-277">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-278">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginAccept%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-278">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-279">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginAccept%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-279">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d063a-280">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-280">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-281">Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen verwenden <xref:System.Net.Sockets.Socket> , um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-281">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-282">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-282">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-283">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-283">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-284">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-284">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-285">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-285">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-286">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-286">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-287">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-287">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-288">Im folgenden Codebeispiel wird versucht, asynchron eine eingehende Verbindung zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-288">The following code example attempts to receive an incoming connection asynchronously.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-289">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-289">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-290">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-290">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-291">Der annehmende Socket überwacht keine Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-291">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="d063a-292">Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-292">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="d063a-293">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-293">-or-</span></span> 
<span data-ttu-id="d063a-294">Der angenommene Socket ist gebunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-294">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-295"><paramref name="receiveSize" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-295"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-296">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-296">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-297">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-297">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-298">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-298">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="receiveSize"><span data-ttu-id="d063a-299">Die Anzahl der Bytes vom Absender, die angenommen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-299">The number of bytes to accept from the sender.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-300">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-300">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-301">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-301">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-302">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</span><span class="sxs-lookup"><span data-stu-id="d063a-302">Begins an asynchronous operation to accept an incoming connection attempt and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="d063a-303">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-303">An <see cref="T:System.IAsyncResult" /> that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-304">Verbindungs orientierte Protokolle können die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-304">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d063a-305">Das asynchrone akzeptieren von Verbindungen ermöglicht das Senden und empfangen von Daten in einem separaten Ausführungs Thread.</span><span class="sxs-lookup"><span data-stu-id="d063a-305">Accepting connections asynchronously enables you to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d063a-306">Diese Überladung ermöglicht es Ihnen, die Anzahl der Bytes anzugeben, die bei der anfänglichen Übertragung im-Parameter akzeptiert werden sollen `receiveSize` .</span><span class="sxs-lookup"><span data-stu-id="d063a-306">This overload allows you to specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="d063a-307">Vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange eingereiht</span><span class="sxs-lookup"><span data-stu-id="d063a-307">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d063a-308">Sie müssen eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-308">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-309">Um dies zu erreichen, müssen Sie das <xref:System.Net.Sockets.Socket> Überwachungsobjekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den-Parameter an übergeben `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-309">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d063a-310">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-310">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-311">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-311">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-312">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-312">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d063a-313">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A> , verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert, <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-313">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="d063a-314"><xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt einen neuen <xref:System.Net.Sockets.Socket> -Wert zurück, den Sie zum Senden und empfangen von Daten mit dem Remote Host verwenden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-314"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d063a-315">Sie können diese Rückgabe nicht verwenden <xref:System.Net.Sockets.Socket> , um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-315">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d063a-316">Wenn Sie den ursprünglichen Thread blockieren möchten, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-316">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-317">Rufen Sie die Set-Methode für einen <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-317">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d063a-318">Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-318">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d063a-319">In diesem Fall wird die- <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-319">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d063a-320">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-320">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-321">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginAccept%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-321">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span>  <span data-ttu-id="d063a-322">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginAccept%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-322">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d063a-323">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-323">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-324">Sie können mit der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen-Objekts aufzurufen <xref:System.Net.Sockets.Socket> , um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-324">You can call use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-325">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-325">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-326">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-326">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-327">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-327">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-328">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-328">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-329">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-329">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-330">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-330">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-331">Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-331">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="d063a-332">In diesem Beispiel nimmt der Socket die ersten 10 Bytes an Daten an.</span><span class="sxs-lookup"><span data-stu-id="d063a-332">In this example, the socket accepts the initial 10 bytes of data.</span></span> <span data-ttu-id="d063a-333">Die Anzahl der empfangenen Bytes und die Daten werden vom Rückruf Delegaten in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-333">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="d063a-334"><xref:System.Net.Sockets.Socket.BeginReceive%2A>Eine Beschreibung, wie die restlichen Daten empfangen werden, finden Sie unter.</span><span class="sxs-lookup"><span data-stu-id="d063a-334">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-335">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-335">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-336">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-336">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-337">Der annehmende Socket überwacht keine Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-337">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="d063a-338">Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-338">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="d063a-339">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-339">-or-</span></span> 
<span data-ttu-id="d063a-340">Der angenommene Socket ist gebunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-340">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-341"><paramref name="receiveSize" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-341"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-342">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-342">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-343">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-343">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-344">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-344">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="receiveSize" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="acceptSocket"><span data-ttu-id="d063a-345">Das angenommene <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-345">The accepted <see cref="T:System.Net.Sockets.Socket" /> object.</span></span> <span data-ttu-id="d063a-346">Dieser Wert kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-346">This value may be <see langword="null" />.</span></span></param>
        <param name="receiveSize"><span data-ttu-id="d063a-347">Die maximale Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-347">The maximum number of bytes to receive.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-348">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-348">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-349">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-349">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-350">Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung von einem angegebenen Socket anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</span><span class="sxs-lookup"><span data-stu-id="d063a-350">Begins an asynchronous operation to accept an incoming connection attempt from a specified socket and receives the first block of data sent by the client application.</span></span></summary>
        <returns><span data-ttu-id="d063a-351">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Objekterstellung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-351">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous <see cref="T:System.Net.Sockets.Socket" /> object creation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-352">Verbindungs orientierte Protokolle können die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode verwenden, um eingehende Verbindungsversuche asynchron zu verarbeiten.</span><span class="sxs-lookup"><span data-stu-id="d063a-352">Connection-oriented protocols can use the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to asynchronously process incoming connection attempts.</span></span> <span data-ttu-id="d063a-353">Durch die asynchrone Annahme von Verbindungen haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden und zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-353">Accepting connections asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span> <span data-ttu-id="d063a-354">Mit dieser Überladung können Sie den akzeptierten Socket im- `acceptSocket` Parameter angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-354">This overload allows you to specify the accepted socket in the `acceptSocket` parameter.</span></span> <span data-ttu-id="d063a-355">Wenn dieser Parameter ist `null` , wird der akzeptierte Socket von der- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode erstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-355">If this parameter is `null`, the accepted socket is created by the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-356">Sie können die Anzahl der Bytes angeben, die bei der anfänglichen Übertragung im-Parameter akzeptiert werden sollen `receiveSize` .</span><span class="sxs-lookup"><span data-stu-id="d063a-356">You can specify the number of bytes to accept in the initial transfer in the `receiveSize` parameter.</span></span>  
  
 <span data-ttu-id="d063a-357">Vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode müssen Sie die <xref:System.Net.Sockets.Socket.Listen%2A> -Methode aufrufen, um eingehende Verbindungsanforderungen abzuhören und in die Warteschlange eingereiht</span><span class="sxs-lookup"><span data-stu-id="d063a-357">Before calling the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, you must call the <xref:System.Net.Sockets.Socket.Listen%2A> method to listen for and queue incoming connection requests.</span></span>  
  
 <span data-ttu-id="d063a-358">Sie müssen eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-358">You must create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-359">Um dies zu erreichen, müssen Sie das <xref:System.Net.Sockets.Socket> Überwachungsobjekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über den-Parameter an übergeben `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-359">To do this, at the very minimum, you must pass the listening <xref:System.Net.Sockets.Socket> object to <xref:System.Net.Sockets.Socket.BeginAccept%2A> through the `state` parameter.</span></span> <span data-ttu-id="d063a-360">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-360">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-361">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-361">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-362">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-362">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndAccept%2A> method.</span></span> <span data-ttu-id="d063a-363">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A> , verwendet das System in der Regel einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert, <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-363">When your application calls <xref:System.Net.Sockets.Socket.BeginAccept%2A>, the system usually uses a separate thread to execute the specified callback method and blocks on <xref:System.Net.Sockets.Socket.EndAccept%2A> until a pending connection is retrieved.</span></span>  
  
 <span data-ttu-id="d063a-364"><xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt ein neues- <xref:System.Net.Sockets.Socket> Objekt zurück, das Sie zum Senden und empfangen von Daten mit dem Remote Host verwenden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-364"><xref:System.Net.Sockets.Socket.EndAccept%2A> returns a new <xref:System.Net.Sockets.Socket> object that you can use to send and receive data with the remote host.</span></span> <span data-ttu-id="d063a-365">Sie können diese Rückgabe nicht verwenden <xref:System.Net.Sockets.Socket> , um zusätzliche Verbindungen aus der Verbindungs Warteschlange zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-365">You cannot use this returned <xref:System.Net.Sockets.Socket> to accept any additional connections from the connection queue.</span></span> <span data-ttu-id="d063a-366">Wenn Sie den ursprünglichen Thread blockieren möchten, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-366">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-367">Rufen Sie die Set-Methode für einen <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-367">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span>  
  
 <span data-ttu-id="d063a-368">Das System kann auch den aufrufenden Thread verwenden, um die Rückruf Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-368">The system may also use the calling thread to invoke the callback method.</span></span> <span data-ttu-id="d063a-369">In diesem Fall wird die- <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft des zurückgegebenen <xref:System.IAsyncResult> festgelegt, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-369">In this case, the <xref:System.IAsyncResult.CompletedSynchronously%2A> property on the returned <xref:System.IAsyncResult> will be set to indicate that the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method completed synchronously.</span></span>  
  
 <span data-ttu-id="d063a-370">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-370">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-371">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginAccept%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-371">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-372">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginAccept%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-372">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method is called.</span></span>  <span data-ttu-id="d063a-373">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-373">A subsequent call to the <xref:System.Net.Sockets.Socket.EndAccept%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-374">Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen- <xref:System.Net.Sockets.Socket> Objekts verwenden, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-374">You can use the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property of the returned <xref:System.Net.Sockets.Socket> object to identify the remote host's network address and port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-375">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-375">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-376">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-376">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-377">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-377">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-378">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-378">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-379">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-379">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-380">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-380">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-381">Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-381">The following code example opens a socket and accepts an asynchronous connection.</span></span> <span data-ttu-id="d063a-382">In diesem Beispiel akzeptiert der Socket die anfänglichen 10 Bytes an Daten, und der- `acceptSocket` Parameter ist `null` , was die-Methode zwingt, <xref:System.Net.Sockets.Socket.BeginAccept%2A> den akzeptierten Socket zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-382">In this example, the socket accepts the initial 10 bytes of data and the `acceptSocket` parameter is `null`, which forces the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method to create the accepted socket.</span></span> <span data-ttu-id="d063a-383">Die Anzahl der empfangenen Bytes und die Daten werden vom Rückruf Delegaten in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-383">The number of bytes received and the data are displayed on the console by the callback delegate.</span></span> <span data-ttu-id="d063a-384"><xref:System.Net.Sockets.Socket.BeginReceive%2A>Eine Beschreibung, wie die restlichen Daten empfangen werden, finden Sie unter.</span><span class="sxs-lookup"><span data-stu-id="d063a-384">See <xref:System.Net.Sockets.Socket.BeginReceive%2A> for a description of how the remaining data is received.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-385">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-385">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-386">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-386">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-387">Der annehmende Socket überwacht keine Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-387">The accepting socket is not listening for connections.</span></span> <span data-ttu-id="d063a-388">Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-388">You must call <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> and <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> before calling <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span>  
  
<span data-ttu-id="d063a-389">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-389">-or-</span></span> 
<span data-ttu-id="d063a-390">Der angenommene Socket ist gebunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-390">The accepted socket is bound.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-391"><paramref name="receiveSize" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-391"><paramref name="receiveSize" /> is less than 0.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-392">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-392">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-393">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-393">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-394">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-394">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-395">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-395">Begins an asynchronous request for a remote host connection.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="d063a-396">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-396">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="end_point"><span data-ttu-id="d063a-397">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-397">An <see cref="T:System.Net.EndPoint" /> that represents the remote host.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-398">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-398">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-399">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-399">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-400">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-400">Begins an asynchronous request for a remote host connection.</span></span></summary>
        <returns><span data-ttu-id="d063a-401">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-401">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-402">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode eine asynchrone Anforderung für eine Verbindung mit dem- `remoteEP` Parameter.</span><span class="sxs-lookup"><span data-stu-id="d063a-402">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method starts an asynchronous request for a connection to the `remoteEP` parameter.</span></span> <span data-ttu-id="d063a-403">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.BeginConnect%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-403">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.BeginConnect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d063a-404">Das asynchrone verbinden oder Festlegen des Standard Remote Hosts ermöglicht Ihnen das Senden und empfangen von Daten in einem separaten Ausführungs Thread.</span><span class="sxs-lookup"><span data-stu-id="d063a-404">Connecting or setting the default remote host asynchronously gives you the ability to send and receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-405">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-405">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span> <span data-ttu-id="d063a-406">Sie müssen den- <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.BeginConnect%2A> Parameter mindestens über den-Parameter übergeben `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-406">At the very minimum, you must pass the <xref:System.Net.Sockets.Socket> to <xref:System.Net.Sockets.Socket.BeginConnect%2A> through the `state` parameter.</span></span> <span data-ttu-id="d063a-407">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d063a-407">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="d063a-408">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-408">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-409">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-409">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d063a-410">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginConnect%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndConnect%2A> bis der <xref:System.Net.Sockets.Socket> erfolgreich eine Verbindung herstellt oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-410">When your application calls <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndConnect%2A> until the <xref:System.Net.Sockets.Socket> connects successfully or throws an exception.</span></span> <span data-ttu-id="d063a-411">Wenn Sie den ursprünglichen Thread blockieren möchten, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-411">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A>.</span></span> <span data-ttu-id="d063a-412">Rufen Sie die Set-Methode für einen <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-412">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-413">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-413">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-414">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.BeginConnect%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-414">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.BeginConnect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-415">Sie können <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und verwenden <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , um mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-415">You can use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> and <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d063a-416">Wenn Sie anrufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> , werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eingehen.</span><span class="sxs-lookup"><span data-stu-id="d063a-416">If you do call <xref:System.Net.Sockets.Socket.BeginConnect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-417">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst den Befehl <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf festlegen `true` .</span><span class="sxs-lookup"><span data-stu-id="d063a-417">If you wish to set your default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d063a-418">Wenn dies nicht möglich ist, löst <xref:System.Net.Sockets.Socket.BeginConnect%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-418">If you cannot, <xref:System.Net.Sockets.Socket.BeginConnect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-419">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufrufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> , weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-419">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-420">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie die-oder die-Methode aufgerufen haben <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-420">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-421">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-421">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d063a-422">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-422">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-423">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-423">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d063a-424">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-424">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-425">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-425">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-426">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-426">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-427">Wenn dieser Socket bereits getrennt wurde, <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss in einem Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-427">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d063a-428">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-428">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-429">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-429">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-430">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-430">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-431">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-431">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-432">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-432">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-433">Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-433">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-434"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-434"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-435">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-435">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-436">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-436">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-437">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-437">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-438">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-438">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-439">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-439">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-440">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-440">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-441">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-441">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="d063a-442">Die <see cref="T:System.Net.IPAddress" /> des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-442">The <see cref="T:System.Net.IPAddress" /> of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-443">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-443">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="d063a-444">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-444">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-445">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-445">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-446">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-446">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="d063a-447">Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-447">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-448">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-448">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="d063a-449">Der Host wird durch eine <see cref="T:System.Net.IPAddress" /> und eine Anschlussnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-449">The host is specified by an <see cref="T:System.Net.IPAddress" /> and a port number.</span></span></summary>
        <returns><span data-ttu-id="d063a-450">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-450">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-451">Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-451">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d063a-452">In der Regel wird die-Methode vom-Delegaten aufgerufen `requestCallback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-452">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-453">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-453">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-454">Wenn Sie blockieren möchten, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Connect%2A> Methoden Überladungen oder <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-454">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads, or <xref:System.Net.Sockets.Socket.EndConnect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-455">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-455">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-456">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-456">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d063a-457">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-457">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d063a-458">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously) .</span><span class="sxs-lookup"><span data-stu-id="d063a-458">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-459">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-459">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-460">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-460">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-461">Wenn dieser Socket bereits getrennt wurde, <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss in einem Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-461">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d063a-462">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-462">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d063a-463">Außerdem <xref:System.Net.EndPoint> muss die verwendete verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-463">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-464">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-464">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-465">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-465">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-466">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-466">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-467">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-467">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-468">Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-468">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-469"><paramref name="address" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-469"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-470">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-470">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-471">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-471">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-472">Der <see cref="T:System.Net.Sockets.Socket" /> ist kein Mitglied der Socketfamilie.</span><span class="sxs-lookup"><span data-stu-id="d063a-472">The <see cref="T:System.Net.Sockets.Socket" /> is not in the socket family.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-473">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-473">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-474">Die Länge von <paramref name="address" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-474">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-475">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-475">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-476">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-476">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-477">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-477">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-478">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-478">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="d063a-479">Mindestens eine <see cref="T:System.Net.IPAddress" />, die den Remotehost angibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-479">At least one <see cref="T:System.Net.IPAddress" />, designating the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-480">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-480">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="d063a-481">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-481">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-482">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-482">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-483">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-483">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="d063a-484">Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-484">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-485">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-485">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="d063a-486">Der Host wird durch ein <see cref="T:System.Net.IPAddress" />-Array und eine Anschlussnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-486">The host is specified by an <see cref="T:System.Net.IPAddress" /> array and a port number.</span></span></summary>
        <returns><span data-ttu-id="d063a-487">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchronen Verbindungen verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-487">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connections.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-488">Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-488">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d063a-489">In der Regel wird die-Methode vom-Delegaten aufgerufen `requestCallback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-489">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-490">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-490">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-491">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Connect%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-491">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-492">Um einen ausstehenden-aufzurufenden aufzurufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-492">To cancel a pending call to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-493">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-493">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d063a-494">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-494">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d063a-495">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="d063a-495">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-496">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-496">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-497">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-497">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-498">Wenn dieser Socket bereits getrennt wurde, <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss in einem Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-498">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d063a-499">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-499">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d063a-500">Außerdem <xref:System.Net.EndPoint> muss die verwendete verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-500">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-501">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-501">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-502">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-502">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-503">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-503">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-504">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-504">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-505">Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-505">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-506"><paramref name="addresses" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-506"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-507">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-507">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-508">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-508">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-509">Diese Methode ist für Sockets gültig, die <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-509">This method is valid for sockets that use <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-510">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-510">The port number is not valid.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-511">Die Länge von <paramref name="address" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-511">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-512">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-512">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-513">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-513">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-514">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-514">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-515">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-515">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback? requestCallback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, requestCallback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="d063a-516">Der Name des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-516">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-517">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-517">The port number of the remote host.</span></span></param>
        <param name="requestCallback"><span data-ttu-id="d063a-518">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-518">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-519">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-519">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the connect operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-520">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-520">A user-defined object that contains information about the connect operation.</span></span> <span data-ttu-id="d063a-521">Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-521">This object is passed to the <paramref name="requestCallback" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-522">Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-522">Begins an asynchronous request for a remote host connection.</span></span> <span data-ttu-id="d063a-523">Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-523">The host is specified by a host name and a port number.</span></span></summary>
        <returns><span data-ttu-id="d063a-524">Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-524">An <see cref="T:System.IAsyncResult" /> that references the asynchronous connection.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-525">Der asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-525">The asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d063a-526">In der Regel wird die-Methode vom-Delegaten aufgerufen `requestCallback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-526">Typically, the method is invoked by the `requestCallback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-527">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-527">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-528">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Connect%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-528">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Connect%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-529">Um einen ausstehenden-aufzurufenden aufzurufen  <xref:System.Net.Sockets.Socket.BeginConnect%2A> , schließen Sie den <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-529">To cancel a pending call to the  <xref:System.Net.Sockets.Socket.BeginConnect%2A> method, close the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-530">Wenn die- <xref:System.Net.Sockets.Socket.Close%2A> Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, wird der Rückruf, der der-Methode bereitgestellt wird, <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-530">When the <xref:System.Net.Sockets.Socket.Close%2A> method is called while an asynchronous operation is in progress, the callback provided to the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method is called.</span></span>  <span data-ttu-id="d063a-531">Bei einem nachfolgenden-Aufrufe der- <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode wird eine ausgelöst <xref:System.ObjectDisposedException> , um anzugeben, dass der Vorgang abgebrochen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-531">A subsequent call to the <xref:System.Net.Sockets.Socket.EndConnect%2A> method will throw an <xref:System.ObjectDisposedException> to indicate that the operation has been cancelled.</span></span>  
  
 <span data-ttu-id="d063a-532">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously) .</span><span class="sxs-lookup"><span data-stu-id="d063a-532">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-533">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-533">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-534">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-534">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-535">Wenn dieser Socket bereits getrennt wurde, <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss in einem Thread aufgerufen werden, der nicht beendet wird, bis der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-535">If this socket has previously been disconnected, then <xref:System.Net.Sockets.Socket.BeginConnect%2A> must be called on a thread that will not exit until the operation is complete.</span></span> <span data-ttu-id="d063a-536">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-536">This is a limitation of the underlying provider.</span></span> <span data-ttu-id="d063a-537">Außerdem <xref:System.Net.EndPoint> muss die verwendete verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-537">Also the <xref:System.Net.EndPoint> that is used must be different.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-538">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-538">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-539">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-539">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-540">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-540">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-541">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-541">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-542">Im folgenden Codebeispiel wird ein asynchroner Verbindungsversuch initiiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-542">The following code example initiates an asynchronous connection attempt.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-543"><paramref name="host" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-543"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-544">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-544">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-545">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-545">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-546">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-546">The port number is not valid.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-547">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-547">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />, or an asynchronous operation is already in progress.</span></span></exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-548">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-548">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-549">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-549">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-550">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-550">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="d063a-551"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die Verbindung geschlossen wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-551"><see langword="true" /> if this socket can be reused after the connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-552">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-552">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-553">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-553">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-554">Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-554">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-555">Ein <see cref="T:System.IAsyncResult" />-Objekt, das auf den asynchronen Vorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-555">An <see cref="T:System.IAsyncResult" /> object that references the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-556">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, können Sie die-Methode aufzurufen, <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> um eine Verbindung von einem Remote Endpunkt anzufordern.</span><span class="sxs-lookup"><span data-stu-id="d063a-556">If you are using a connection-oriented protocol, you can call the <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method to request a disconnect from a remote endpoint.</span></span> <span data-ttu-id="d063a-557">Wenn `reuseSocket` `true` den Wert hat, können Sie den Socket wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-557">If `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="d063a-558">Die- <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Methode verwendet einen separaten Thread, um die angegebene Rückruf Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-558">The <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> method uses a separate thread to invoke the specified callback method.</span></span> <span data-ttu-id="d063a-559">Die- <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode wird blockiert, bis die ausstehende Trennung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-559">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the pending disconnect is complete.</span></span> <span data-ttu-id="d063a-560">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-560">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-561">Wenn Sie eine- <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-561">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-562">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-562">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-563">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-563">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-564">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-564">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-565">Das folgende Codebeispiel erstellt einen Socket für die asynchrone Kommunikation und sendet einige Daten an einen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-565">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d063a-566">Wenn die Daten gesendet wurden, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um die Sende-und Empfangs Aktivität anzuhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-566">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="d063a-567">Anschließend <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Disconnect-Anforderung zu starten.</span><span class="sxs-lookup"><span data-stu-id="d063a-567">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="d063a-568">Wenn die Anforderung abgeschlossen ist, <xref:System.Net.Sockets.Socket.Connected%2A> wird die-Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-568">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-569">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-569">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-570">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-570">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-571">Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-571">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-572">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-572">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-573">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-573">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-574">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-574">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-575">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-575">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="d063a-576">Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-576">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-577">Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-577">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-578">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-578">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-579">Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-579">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d063a-580">In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-580">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-581">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-581">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-582">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Receive%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-582">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-583">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceive%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-583">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-584">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="d063a-584">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-585">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-585">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-586">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-586">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-587">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-587">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-588">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-588">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-589">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-589">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-590">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-590">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-591">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-591">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-592">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-592">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-593">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-593">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-594"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-594"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-595">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-595">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-596"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-596"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-597">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-597">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-598">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-598">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-599">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-599">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-600">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-600">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-601">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-601">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-602">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-602">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-603">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-603">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-604">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-604">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="d063a-605">Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-605">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-606">Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-606">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-607">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-607">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-608">Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-608">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d063a-609">In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-609">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-610">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-610">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-611">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Receive%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-611">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-612">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceive%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-612">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-613">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="d063a-613">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-614">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-614">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-615">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-615">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-616">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-616">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-617">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-617">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-618">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-618">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-619">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-619">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-620">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-620">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-621">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-621">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-622">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-622">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-623"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-623"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-624">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-624">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-625"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-625"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-626">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-626">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-627">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-627">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-628">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-628">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-629">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-629">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-630">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-630">The zero-based position in the <paramref name="buffer" /> parameter at which to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-631">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-631">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-632">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-632">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="d063a-633">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-633">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-634">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-634">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-635">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-635">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="d063a-636">Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-636">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-637">Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-637">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-638">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-638">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-639">Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-639">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d063a-640">In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-640">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-641">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-641">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-642">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Receive%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-642">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-643">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceive%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-643">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-644">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="d063a-644">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-645">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-645">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-646">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-646">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-647">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-647">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-648">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-648">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-649">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-649">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-650">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-650">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-651">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-651">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-652">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-652">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-653">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-653">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-654">Im folgenden Codebeispiel wird der asynchrone Empfang von Daten aus einer verbundenen begonnen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-654">The following code example begins to asynchronously receive data from a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-655"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-655"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-656">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-656">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-657"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-657"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-658"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-658"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-659">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-659">-or-</span></span> 
 <span data-ttu-id="d063a-660"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-660"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-661">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-661">-or-</span></span> 
 <span data-ttu-id="d063a-662"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-662"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-663">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-663">-or-</span></span> 
 <span data-ttu-id="d063a-664"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-664"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-665">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-665">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-666">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-666">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-667">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-667">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[]? buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socketFlags, errorCode, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-668">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-668">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-669">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-669">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-670">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-670">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-671">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-671">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="flags"><span data-ttu-id="d063a-672">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-672">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-673">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-673">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="error"><span data-ttu-id="d063a-674">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-674">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-675">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-675">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-676">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-676">A user-defined object that contains information about the receive operation.</span></span> <span data-ttu-id="d063a-677">Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-677">This object is passed to the <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> delegate when the operation is complete.</span></span></param>
        <summary><span data-ttu-id="d063a-678">Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-678">Begins to asynchronously receive data from a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-679">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-679">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-680">Der asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-680">The asynchronous <xref:System.Net.Sockets.Socket.BeginReceive%2A> operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceive%2A> method.</span></span> <span data-ttu-id="d063a-681">In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-681">Typically, the method is invoked by the `callback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-682">Diese Methode wird nicht blockiert, bis der Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-682">This method does not block until the operation is complete.</span></span> <span data-ttu-id="d063a-683">Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der- <xref:System.Net.Sockets.Socket.Receive%2A> Methoden Überladungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-683">To block until the operation is complete, use one of the <xref:System.Net.Sockets.Socket.Receive%2A> method overloads.</span></span>  
  
 <span data-ttu-id="d063a-684">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceive%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-684">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-685">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span><span class="sxs-lookup"><span data-stu-id="d063a-685">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-686">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-686">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-687">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-687">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-688">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-688">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-689">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-689">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-690">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-690">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-691">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-691">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-692">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-692">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-693">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-693">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-694">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-694">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-695"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-695"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-696">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-696">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-697"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-697"><see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-698"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-698"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-699">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-699">-or-</span></span> 
 <span data-ttu-id="d063a-700"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-700"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-701">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-701">-or-</span></span> 
 <span data-ttu-id="d063a-702"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-702"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-703">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-703">-or-</span></span> 
 <span data-ttu-id="d063a-704"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-704"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-705">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-705">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-706">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-706">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-707">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-707">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-708">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-708">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-709">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-709">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-710">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-710">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-711">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-711">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="d063a-712">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-712">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-713">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-713">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="remote_end"><span data-ttu-id="d063a-714">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-714">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-715">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-715">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-716">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-716">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-717">Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</span><span class="sxs-lookup"><span data-stu-id="d063a-717">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="d063a-718">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-718">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-719">Die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode beginnt das asynchrone Lesen von Verbindungs losen Datagramme von einem Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-719">The <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method starts asynchronously reading connectionless datagrams from a remote host.</span></span> <span data-ttu-id="d063a-720">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-720">Calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method gives you the ability to receive data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-721">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-721">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-722">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-722">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-723">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-723">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-724">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-724">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-725">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-725">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-726">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen. Sie wird blockiert, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> bis der <xref:System.Net.Sockets.Socket> Daten liest oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-726">When your application calls <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, the system will use a separate thread to execute the specified callback method, and it will block on <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> until the <xref:System.Net.Sockets.Socket> reads data or throws an exception.</span></span> <span data-ttu-id="d063a-727">Wenn Sie den ursprünglichen Thread blockieren möchten, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode aufgerufen haben, verwenden Sie <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-727">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method, use <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-728">Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-728">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-729">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-729">For additional information on writing callback methods, see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-730">Vor <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> dem Aufrufen von müssen Sie das <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> , oder es <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-730">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method, or <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-731">Diese Methode liest Daten in den `buffer` -Parameter und erfasst den Remote Host Endpunkt, von dem die Daten gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-731">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent.</span></span> <span data-ttu-id="d063a-732">Weitere Informationen zum Abrufen dieses Endpunkts finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-732">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="d063a-733">Diese Methode ist besonders nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts asynchron empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-733">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span> <span data-ttu-id="d063a-734">In diesen Fällen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-734">In these cases, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d063a-735">Wenn das Datagramm, das Sie empfangen, größer als die Größe von ist `buffer` , <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> wird die-Methode so `buffer` viel wie möglich mit der Nachricht aufgefüllt und löst eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-735">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-736">Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="d063a-736">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d063a-737">Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode mit einem ausreichend großen Puffer aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-737">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d063a-738">Um sicherzustellen, dass der Remote Host Endpunkt immer zurückgegeben wird, sollte eine Anwendung den <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> und dann die- <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode aufrufen, wobei der- `optionLevel` Parameter auf oder festgelegt ist <xref:System.Net.Sockets.SocketOptionLevel.IP> <xref:System.Net.Sockets.SocketOptionLevel.IPv6> , der `optionName` -Parameter auf festgelegt ist, <xref:System.Net.Sockets.SocketOptionName.PacketInformation> und der- `optionValue` Parameter, um diese Option vor dem Aufrufen der-Methode zu aktivieren <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A></span><span class="sxs-lookup"><span data-stu-id="d063a-738">To guarantee that the remote host endpoint is always returned, an application should explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method and then call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method with the `optionLevel` parameter set to <xref:System.Net.Sockets.SocketOptionLevel.IP> or <xref:System.Net.Sockets.SocketOptionLevel.IPv6> as appropriate, the `optionName` parameter set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, and the `optionValue` parameter to enable this option before calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-739">Andernfalls ist es möglich, dass der Remote Host Endpunkt nicht zurückgegeben wird, wenn der Absender eine Reihe von Datagramme gesendet hat, bevor der Empfänger die-Methode aufgerufen hat <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-739">Otherwise, it is possible for the remote host endpoint to not be returned when the sender has sent a number of datagrams before the receiver has called the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-740">Obwohl <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> für verbindungslose Protokolle bestimmt ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-740">Although <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d063a-741">Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode aufrufen oder eine eingehende Verbindungsanforderung akzeptieren, indem Sie die- <xref:System.Net.Sockets.Socket.Accept%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-741">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> / <xref:System.Net.Sockets.Socket.BeginConnect%2A> method or accept an incoming connection request by calling the <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-742">Wenn Sie die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode vor dem Einrichten oder akzeptieren einer Verbindung aufzurufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-742">If you call the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method before establishing or accepting a connection, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-743">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-743">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-744">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> ignoriert die-Methode den `remoteEP` -Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-744">In either of these cases, the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-745">Mit Verbindungs orientierten Sockets <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest so viele Daten wie verfügbar, die bis zu der Anzahl der Bytes verfügbar sind, die durch den-Parameter angegeben werden `size` .</span><span class="sxs-lookup"><span data-stu-id="d063a-745">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span>  
  
 <span data-ttu-id="d063a-746">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-746">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-747">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-747">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-748">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-748">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-749">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-749">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-750">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-750">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-751">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-751">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-752">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-752">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-753">Im folgenden Codebeispiel werden verbindungslose Datagramme von einem Remote Host asynchron empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-753">The following code example asynchronously receives connectionless datagrams from a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-754"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-754"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-755">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-755">-or-</span></span> 
 <span data-ttu-id="d063a-756"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-756"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-757">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-757">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-758"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-758"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-759">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-759">-or-</span></span> 
 <span data-ttu-id="d063a-760"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-760"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-761">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-761">-or-</span></span> 
 <span data-ttu-id="d063a-762"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-762"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-763">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-763">-or-</span></span> 
 <span data-ttu-id="d063a-764"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" /> -Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-764"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-765">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-765">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-766">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-766">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-767">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-767">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-768">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-768">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-769">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-769">The zero-based position in the <paramref name="buffer" /> parameter at which to store the data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-770">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-770">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-771">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-771">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-772">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-772">An <see cref="T:System.Net.EndPoint" /> that represents the source of the data.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-773">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-773">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-774">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-774">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-775">Beginnt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />-Klassen den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</span><span class="sxs-lookup"><span data-stu-id="d063a-775">Begins to asynchronously receive the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="d063a-776">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-776">An <see cref="T:System.IAsyncResult" /> that references the asynchronous read.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-777">Der asynchrone Empfangsvorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-777">The asynchronous receive operation must be completed by calling the <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> method.</span></span> <span data-ttu-id="d063a-778">In der Regel wird die-Methode vom-Delegaten aufgerufen `asyncCallback` .</span><span class="sxs-lookup"><span data-stu-id="d063a-778">Typically, the method is invoked by the `asyncCallback` delegate.</span></span>  
  
 <span data-ttu-id="d063a-779">Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-779">This method does not block until the operation completes.</span></span> <span data-ttu-id="d063a-780">Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die- <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-780">To block until the operation completes, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-781">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-781">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-782">Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously) .</span><span class="sxs-lookup"><span data-stu-id="d063a-782">For detailed information about using the asynchronous programming model, see [Calling Synchronous Methods Asynchronously](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously)</span></span>  
  
 <span data-ttu-id="d063a-783">Diese Methode liest Daten in den `buffer` -Parameter und erfasst den Remote Host Endpunkt, von dem die Daten gesendet werden, sowie Informationen über das empfangene Paket.</span><span class="sxs-lookup"><span data-stu-id="d063a-783">This method reads data into the `buffer` parameter, and captures the remote host endpoint from which the data is sent, as well as information about the received packet.</span></span> <span data-ttu-id="d063a-784">Weitere Informationen zum Abrufen dieses Endpunkts finden Sie unter <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-784">For information on how to retrieve this endpoint, refer to <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>.</span></span> <span data-ttu-id="d063a-785">Diese Methode ist besonders nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts asynchron empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-785">This method is most useful if you intend to asynchronously receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-786">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-786">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-787">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-787">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-788">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-788">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-789">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-789">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-790">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-790">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-791">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-791">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-792"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-792"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-793">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-793">-or-</span></span> 
 <span data-ttu-id="d063a-794"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-794"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-795">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-795">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-796"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-796"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-797">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-797">-or-</span></span> 
 <span data-ttu-id="d063a-798"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-798"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-799">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-799">-or-</span></span> 
 <span data-ttu-id="d063a-800"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-800"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-801">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-801">-or-</span></span> 
 <span data-ttu-id="d063a-802"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" /> -Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-802"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-803">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-803">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-804">Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-804">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-805">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-805">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-806">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-806">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-807">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-807">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-808">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-808">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-809">Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-809">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-810">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-810">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-811">Die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der-,-,-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-811">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-812"><xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , oder aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-812"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-813">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-813">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-814">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-814">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d063a-815">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-815">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-816">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-816">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-817">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-817">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-818">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndSend%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-818">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d063a-819">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-819">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d063a-820">Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode aufgerufen haben, verwenden Sie die- <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-820">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-821">Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-821">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-822">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-822">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-823">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSend%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-823">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-824">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-824">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d063a-825">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-825">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-826">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.BeginSend%2A> von ändern, indem Sie einen weiteren Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> oder Ausführen <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-826">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-827">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-827">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-828">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-828">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-829">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-829">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-830">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-830">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-831">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-831">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-832">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-832">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-833">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-833">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-834">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-834">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-835">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-835">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-836">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-836">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-837">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-837">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-838">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-838">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-839">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-839">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-840">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-840">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-841"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-841"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-842"><paramref name="buffers" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-842"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-843">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-843">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-844">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-844">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-845">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-845">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-846">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-846">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-847">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-847">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-848">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-848">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-849">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-849">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-850">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-850">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-851">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-851">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-852">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-852">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-853">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-853">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-854">Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-854">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-855">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-855">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-856">Die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der-,-,-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-856">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-857"><xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , oder aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-857"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-858">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-858">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-859">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-859">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d063a-860">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-860">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-861">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-861">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-862">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-862">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-863">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndSend%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-863">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d063a-864">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-864">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d063a-865">Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode aufgerufen haben, verwenden Sie die- <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-865">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-866">Rufen Sie die Set-Methode für einen <xref:System.Threading.ManualResetEvent> in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-866">Call the Set method on a <xref:System.Threading.ManualResetEvent> in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-867">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-867">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-868">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSend%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-868">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-869">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-869">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d063a-870">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-870">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-871">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.BeginSend%2A> von ändern, indem Sie einen weiteren Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> oder Ausführen <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-871">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-872">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-872">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-873">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-873">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-874">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-874">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-875">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-875">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-876">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-876">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-877">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-877">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-878">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-878">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-879">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-879">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-880">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-880">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-881">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-881">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-882">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-882">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-883">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-883">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-884">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-884">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-885">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-885">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-886"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-886"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-887"><paramref name="buffers" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-887"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-888">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-888">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-889">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-889">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-890">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-890">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-891">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-891">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-892">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-892">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-893">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-893">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[]? buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-894">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-894">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-895">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-895">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-896">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-896">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-897">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-897">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-898">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-898">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-899">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-899">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-900">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-900">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-901">Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-901">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-902">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-902">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-903">Die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der-,-,-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-903">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-904"><xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , oder aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-904"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-905">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-905">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-906">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-906">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d063a-907">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-907">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-908">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-908">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-909">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-909">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-910">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndSend%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-910">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d063a-911">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-911">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d063a-912">Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode aufgerufen haben, verwenden Sie die- <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-912">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-913">Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-913">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-914">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-914">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-915">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSend%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-915">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-916">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-916">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d063a-917">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-917">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-918">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.BeginSend%2A> von ändern, indem Sie einen weiteren Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> oder Ausführen <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-918">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-919">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-919">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-920">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-920">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-921">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-921">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-922">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-922">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-923">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-923">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-924">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-924">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-925">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-925">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-926">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-926">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-927">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-927">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-928">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-928">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-929">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-929">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-930">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-930">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-931">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-931">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-932">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-932">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-933"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-933"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-934">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-934">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-935">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-935">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-936"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-936"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-937">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-937">-or-</span></span> 
 <span data-ttu-id="d063a-938"><paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-938"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-939">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-939">-or-</span></span> 
 <span data-ttu-id="d063a-940"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-940"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-941">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-941">-or-</span></span> 
 <span data-ttu-id="d063a-942"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" /> -Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-942"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-943">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-943">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-944">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-944">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-945">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-945">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-946">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-946">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-947">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-947">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-948">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-948">The zero-based position in the <paramref name="buffer" /> parameter at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-949">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-949">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-950">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-950">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="d063a-951">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-951">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-952">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-952">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-953">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-953">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-954">Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-954">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-955">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-955">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-956">Die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der-,-,-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-956">The <xref:System.Net.Sockets.Socket.BeginSend%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span> <span data-ttu-id="d063a-957"><xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , oder aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-957"><xref:System.Net.Sockets.Socket.BeginSend%2A> will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-958">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-958">Calling the <xref:System.Net.Sockets.Socket.BeginSend%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-959">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-959">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d063a-960">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-960">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-961">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-961">If your callback needs more information, you can create a small class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-962">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-962">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSend%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-963">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndSend%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-963">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSend%2A> method.</span></span> <span data-ttu-id="d063a-964">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndSend%2A> bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-964">When your application calls <xref:System.Net.Sockets.Socket.BeginSend%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSend%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d063a-965">Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode aufgerufen haben, verwenden Sie die- <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-965">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-966">Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-966">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-967">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-967">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-968">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSend%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-968">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSend%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-969">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-969">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span> <span data-ttu-id="d063a-970">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-970">It is okay to use <xref:System.Net.Sockets.Socket.BeginSendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-971">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.BeginSend%2A> von ändern, indem Sie einen weiteren Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> oder Ausführen <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-971">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.BeginSend%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-972">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-972">With connectionless protocols, you must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-973">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-973">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.BeginSend%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-974">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-974">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-975">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-975">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-976">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-976">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-977">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-977">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-978">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-978">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-979">`state` ist eine Instanziierung einer benutzerdefinierten Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-979">`state` is an instantiation of a user-defined class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-980">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-980">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-981">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-981">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-982">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-982">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-983">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-983">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-984">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-984">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-985">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-985">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-986">Das folgende Codebeispiel beginnt mit dem asynchronen Senden von Daten an einen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-986">The following code example begins asynchronously sending data to a remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-987"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-987"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-988">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-988">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-989">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-989">See remarks section below.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-990"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-990"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-991">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-991">-or-</span></span> 
 <span data-ttu-id="d063a-992"><paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-992"><paramref name="offset" /> is less than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-993">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-993">-or-</span></span> 
 <span data-ttu-id="d063a-994"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-994"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-995">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-995">-or-</span></span> 
 <span data-ttu-id="d063a-996"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" /> -Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-996"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-997">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-997">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-998">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-998">Marshaling a Delegate as a Callback Method</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-client-socket-example"><span data-ttu-id="d063a-999">Asynchrone Clientsockets - Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-999">Asynchronous Client Socket Example</span></span></related>
        <related type="Article" href="/dotnet/framework/network-programming/asynchronous-server-socket-example"><span data-ttu-id="d063a-1000">Asynchroner Serversocket, Beispiel</span><span class="sxs-lookup"><span data-stu-id="d063a-1000">Asynchronous Server Socket Example</span></span></related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1001">Sendet eine Datei asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1001">Sends a file asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="d063a-1002">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1002">A string that contains the path and name of the file to send.</span></span> <span data-ttu-id="d063a-1003">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1003">This parameter can be <see langword="null" />.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-1004">Der <see cref="T:System.AsyncCallback" /> -Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-1004">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-1005">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1005">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-1006">Sendet die Datei <paramref name="fileName" /> unter Verwendung des <see cref="T:System.Net.Sockets.Socket" />-Flags an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1006">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> flag.</span></span></summary>
        <returns><span data-ttu-id="d063a-1007">Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Sendevorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1007">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1008">Diese Überladung sendet die Datei `fileName` an den verbundenen Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-1008">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="d063a-1009">Wenn `fileName` sich im lokalen Verzeichnis befindet, kann es mit nur dem Namen der Datei identifiziert werden. andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1009">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d063a-1010">Platzhalter (".. \\\myfile.txt ") und UNC-Freigabe Namen (" \\ \\ \\ \Shared Directory \\\myfile.txt ") werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1010">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d063a-1011">Wenn die Datei nicht gefunden wird, wird die Ausnahme ausgelöst <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1011">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d063a-1012">Diese Methode verwendet die-Funktion, die `TransmitFile` in der Windows Sockets 2-API enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1012">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d063a-1013">Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="d063a-1013">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="d063a-1014">Die- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in den <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden,, oder festgelegt wurde <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1014">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="d063a-1015"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , <xref:System.Net.Sockets.Socket.Connect%2A> oder aufruft <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1015"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-1016">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode können Sie eine Datei in einem separaten Ausführungs Thread senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1016">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method enables you to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-1017">Um den Vorgang abzuschließen, können Sie eine Rückruf Methode erstellen, die vom Delegatparameter aufgerufen wird <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1017">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="d063a-1018">Um dies zu erreichen, muss der-Parameter das `state` <xref:System.Net.Sockets.Socket> für die Kommunikation verwendete-Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1018">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="d063a-1019">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1019">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-1020">Übergeben Sie mithilfe des-Parameters eine Instanz dieses benutzerdefinierten-Objekts an die- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1020">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-1021">Die Rückruf Methode muss die- <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1021">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="d063a-1022">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendFile%2A> , verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bis der die <xref:System.Net.Sockets.Socket> gesamte Datei sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1022">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="d063a-1023">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-1023">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-1024">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSendFile%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1024">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-1025">Bei Verbindungs losen Protokollen müssen Sie sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1025">With connectionless protocols, you must be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-1026">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es wird <xref:System.Net.Sockets.Socket.BeginSendFile%2A> eine- <xref:System.Net.Sockets.SocketException> Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1026">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1027">Wenn Sie eine- <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1027">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1028">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1028">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1029">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1029">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1030">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1030">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1031">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1031">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-1032">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1032">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1033">Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1033">The following code example creates and connects a socket for asynchronous communication.</span></span> <span data-ttu-id="d063a-1034">Zuerst wird die Datei "text.txt" asynchron an den Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1034">First, the file "text.txt" is sent asynchronously to the remote host.</span></span> <span data-ttu-id="d063a-1035">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1035">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1036">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1036">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1037">Der Socket ist nicht mit einem Remotehost verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1037">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d063a-1038">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1038">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1039">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1039">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-1040">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-1040">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="d063a-1041">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1041">A string that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="d063a-1042">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1042">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="d063a-1043">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1043">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="d063a-1044">Dieser Parameter kann <see langword="null" />sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1044">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="d063a-1045">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1045">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="d063a-1046">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1046">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="d063a-1047">Eine bitweise Kombination von <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1047">A bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-1048">Ein <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss dieses Vorgangs aufgerufen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1048">An <see cref="T:System.AsyncCallback" /> delegate to be invoked when this operation completes.</span></span> <span data-ttu-id="d063a-1049">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1049">This parameter can be <see langword="null" />.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-1050">Ein benutzerdefiniertes Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1050">A user-defined object that contains state information for this request.</span></span> <span data-ttu-id="d063a-1051">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1051">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d063a-1052">Sendet eine Datei und Datenpuffer asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1052">Sends a file and buffers of data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="d063a-1053">Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Vorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1053">An <see cref="T:System.IAsyncResult" /> object that represents the asynchronous operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1054">Diese Überladung erfordert den Namen der Datei, die Sie senden möchten, und eine bitweise Kombination von- <xref:System.Net.Sockets.TransmitFileOptions> Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1054">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="d063a-1055">Der- `preBuffer` Parameter enthält alle Daten, die Sie der Datei vorausgehen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1055">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="d063a-1056">`postBuffer` enthält Daten, die Sie der Datei folgen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1056">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="d063a-1057">Wenn `fileName` sich im lokalen Verzeichnis befindet, kann es mit nur dem Namen der Datei identifiziert werden. andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1057">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d063a-1058">Platzhalter (".. \\\myfile.txt ") und UNC-Freigabe Namen (" \\ \\ \\ \Shared Directory \\\myfile.txt ") werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1058">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d063a-1059">Wenn die Datei nicht gefunden wird, wird die Ausnahme ausgelöst <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1059">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d063a-1060">Der- `flags` Parameter stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1060">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d063a-1061">Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d063a-1061">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d063a-1062">Diese Methode verwendet die-Funktion, die `TransmitFile` in der Windows Sockets 2-API enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1062">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d063a-1063">Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="d063a-1063">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="d063a-1064">Die- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in den <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden,, oder festgelegt wurde <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1064">The <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> methods.</span></span> <span data-ttu-id="d063a-1065"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> , <xref:System.Net.Sockets.Socket.Connect%2A> oder aufruft <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1065"><xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.BeginConnect%2A>.</span></span> <span data-ttu-id="d063a-1066">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode haben Sie die Möglichkeit, eine Datei in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1066">Calling the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method gives you the ability to send a file within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-1067">Um den Vorgang abzuschließen, können Sie eine Rückruf Methode erstellen, die vom Delegatparameter aufgerufen wird <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1067">To complete the operation, you can create a callback method that is invoked by the <xref:System.AsyncCallback> delegate parameter.</span></span> <span data-ttu-id="d063a-1068">Um dies zu erreichen, muss der-Parameter das `state` <xref:System.Net.Sockets.Socket> für die Kommunikation verwendete-Objekt enthalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1068">To do this, at the very minimum, the `state` parameter must contain the <xref:System.Net.Sockets.Socket> object being used for communication.</span></span> <span data-ttu-id="d063a-1069">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine Klasse oder Struktur erstellen, die die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1069">If your callback needs more information, you can create a class or structure to hold the <xref:System.Net.Sockets.Socket> and the other required information.</span></span> <span data-ttu-id="d063a-1070">Übergeben Sie mithilfe des-Parameters eine Instanz dieses benutzerdefinierten-Objekts an die- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1070">Pass an instance of this custom object to the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-1071">Die Rückruf Methode muss die- <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1071">Your callback method must invoke the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method.</span></span> <span data-ttu-id="d063a-1072">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendFile%2A> , verwendet das System einen separaten Thread, um die angegebene Rückruf Methode auszuführen, und blockiert, <xref:System.Net.Sockets.Socket.EndSendFile%2A> bis der die <xref:System.Net.Sockets.Socket> gesamte Datei sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1072">When your application calls <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, the system uses a separate thread to execute the specified callback method, and blocks on <xref:System.Net.Sockets.Socket.EndSendFile%2A> until the <xref:System.Net.Sockets.Socket> sends the entire file or throws an exception.</span></span> <span data-ttu-id="d063a-1073">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-1073">For additional information on writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-1074">Obwohl für Verbindungs orientierte Protokolle vorgesehen ist, kann <xref:System.Net.Sockets.Socket.BeginSendFile%2A> auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode zum Einrichten eines standardmäßigen Remote Hosts aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1074">Although intended for connection-oriented protocols, <xref:System.Net.Sockets.Socket.BeginSendFile%2A> also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-1075">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1075">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-1076">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es wird <xref:System.Net.Sockets.Socket.BeginSendFile%2A> eine- <xref:System.Net.Sockets.SocketException> Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1076">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.BeginSendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1077">Wenn Sie eine- <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1077">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1078">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1078">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1079">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1079">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1080">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1080">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1081">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1081">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-1082">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1082">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1083">Im folgenden Codebeispiel wird ein Socket für asynchrone Kommunikation erstellt und verknüpft und die Datei "text.txt" asynchron an den Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1083">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="d063a-1084">In diesem Beispiel werden ein `preBuffer` und ein `postBuffer` von Daten erstellt, um mit der Datei zu senden, und der Standard <xref:System.Net.Sockets.TransmitFileOptions> Wert wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1084">In this example, a `preBuffer` and a `postBuffer` of data is created to send with the file and the default <xref:System.Net.Sockets.TransmitFileOptions> value is used.</span></span> <span data-ttu-id="d063a-1085">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1085">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1086">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1086">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1087">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1087">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-1088">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-1088">See remarks section below.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1089">Das Betriebssystem ist nicht Windows NT oder höher.</span><span class="sxs-lookup"><span data-stu-id="d063a-1089">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="d063a-1090">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1090">-or-</span></span>
  
 <span data-ttu-id="d063a-1091">Der Socket ist nicht mit einem Remotehost verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1091">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d063a-1092">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1092">The file <paramref name="fileName" /> was not found.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback? callback, object? state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socketFlags, remoteEP, callback, state)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="state" Type="System.Object" Index="6" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-1093">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1093">An array of type <see cref="T:System.Byte" /> that contains the data to send.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-1094">Die nullbasierte Position im <paramref name="buffer" />, an der mit dem Senden der Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1094">The zero-based position in <paramref name="buffer" /> at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-1095">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1095">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-1096">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1096">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="socket_flags"><span data-ttu-id="d063a-1097">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1097">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-1098">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1098">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="remote_end"><span data-ttu-id="d063a-1099">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1099">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <param name="callback"><span data-ttu-id="d063a-1100">Der <see cref="T:System.AsyncCallback" />-Delegat.</span><span class="sxs-lookup"><span data-stu-id="d063a-1100">The <see cref="T:System.AsyncCallback" /> delegate.</span></span></param>
        <param name="state"><span data-ttu-id="d063a-1101">Ein Objekt mit Zustandsinformationen für diese Anforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1101">An object that contains state information for this request.</span></span></param>
        <summary><span data-ttu-id="d063a-1102">Sendet asynchron Daten an einen angegebenen Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1102">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="d063a-1103">Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1103">An <see cref="T:System.IAsyncResult" /> that references the asynchronous send.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1104">Die- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der im-Parameter angegeben ist `remoteEP` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1104">The <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method starts an asynchronous send operation to the remote host specified in the `remoteEP` parameter.</span></span> <span data-ttu-id="d063a-1105">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1105">Calling the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="d063a-1106">Obwohl für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> funktioniert sowohl mit Verbindungs orientierten als auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1106">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.BeginSendTo%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d063a-1107">Sie können eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> und seinen Namen an die- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode übergibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1107">You can create a callback method that implements the <xref:System.AsyncCallback> delegate and pass its name to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method.</span></span> <span data-ttu-id="d063a-1108">Zu diesem Zweck `state` muss der Parameter mindestens den verbundenen oder Standardwert enthalten, der für die <xref:System.Net.Sockets.Socket> Kommunikation verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1108">To do this, at the very minimum, your `state` parameter must contain the connected or default <xref:System.Net.Sockets.Socket> being used for communication.</span></span> <span data-ttu-id="d063a-1109">Wenn Ihr Rückruf Weitere Informationen benötigt, können Sie eine kleine Klasse erstellen, um die <xref:System.Net.Sockets.Socket> und die anderen erforderlichen Informationen zu speichern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1109">If your callback needs more information, you can create a small class to hold the <xref:System.Net.Sockets.Socket>, and the other required information.</span></span> <span data-ttu-id="d063a-1110">Übergeben Sie mithilfe des-Parameters eine Instanz dieser Klasse an die- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode `state` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1110">Pass an instance of this class to the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method through the `state` parameter.</span></span>  
  
 <span data-ttu-id="d063a-1111">Die Rückruf Methode sollte die- <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1111">Your callback method should invoke the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method.</span></span> <span data-ttu-id="d063a-1112">Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendTo%2A> , verwendet das System einen separaten Thread zum Ausführen der angegebenen Rückruf Methode und blockiert, <xref:System.Net.Sockets.Socket.EndSendTo%2A> bis der <xref:System.Net.Sockets.Socket> die Anzahl der angeforderten Bytes sendet oder eine Ausnahme auslöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1112">When your application calls <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, the system will use a separate thread to execute the specified callback method, and will block on <xref:System.Net.Sockets.Socket.EndSendTo%2A> until the <xref:System.Net.Sockets.Socket> sends the number of bytes requested or throws an exception.</span></span> <span data-ttu-id="d063a-1113">Wenn der ursprüngliche Thread blockiert werden soll, nachdem Sie die- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode aufgerufen haben, verwenden Sie die- <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-1113">If you want the original thread to block after you call the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method, use the <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="d063a-1114">Rufen Sie die Set-Methode für ein T:System.Threading.ManualResetEvent in der Rückruf Methode auf, wenn der ursprüngliche Thread weiter ausgeführt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1114">Call the Set method on a T:System.Threading.ManualResetEvent in the callback method when you want the original thread to continue executing.</span></span> <span data-ttu-id="d063a-1115">Weitere Informationen zum Schreiben von Rückruf Methoden finden Sie unter Mars Hallen eines Delegaten [als Rückruf Methode](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span><span class="sxs-lookup"><span data-stu-id="d063a-1115">For additional information about writing callback methods see [Marshaling a Delegate as a Callback Method](/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method).</span></span>  
  
 <span data-ttu-id="d063a-1116">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst die-,-,- <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> oder- <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode oder eine-Methode auslösen <xref:System.Net.Sockets.Socket.BeginSendTo%2A> <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1116">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method, or <xref:System.Net.Sockets.Socket.BeginSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1117"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignoriert den `remoteEP` -Parameter und sendet Daten an den <xref:System.Net.EndPoint> , der in der-,-,-oder-Methode festgelegt wird <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1117"><xref:System.Net.Sockets.Socket.BeginSendTo%2A> will ignore the `remoteEP` parameter and send data to the <xref:System.Net.EndPoint> established in the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, or <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1118">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von keinen Standard-Remote Host mit der- <xref:System.Net.Sockets.Socket.Connect%2A> oder- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode einrichten <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1118">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-1119">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode aufzurufen <xref:System.Net.Sockets.Socket.BeginSend%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1119">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method.</span></span> <span data-ttu-id="d063a-1120">Wenn Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> oder- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode vor dem Aufruf von Aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> , überschreibt der- `remoteEP` Parameter nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1120">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.BeginConnect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-1121">Außerdem ist es nicht erforderlich, die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1121">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-1122">In diesem Fall weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1122">In this case, the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-1123">Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port auswählen soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1123">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="d063a-1124">Wenn Sie die zugewiesene Adresse und Portnummer des lokalen Netzwerks identifizieren müssen, können Sie die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft verwenden, nachdem die- <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1124">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d063a-1125">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1125">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-1126">-Sie müssen auch sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1126">-You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-1127">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.EndSendTo%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1127">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.EndSendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-1128">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1128">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1129">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1129">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1130">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1130">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1131">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1131">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1132">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1132">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1133">Der Ausführungs Kontext (der Sicherheitskontext, der Benutzer, dessen Identität angenommen wurde, und der aufrufende Kontext) wird für die asynchronen Methoden zwischengespeichert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1133">The execution context (the security context, the impersonated user, and the calling context) is cached for the asynchronous <xref:System.Net.Sockets.Socket> methods.</span></span> <span data-ttu-id="d063a-1134">Nach der ersten Verwendung eines bestimmten Kontexts (einer bestimmten asynchronen <xref:System.Net.Sockets.Socket> Methode, einer bestimmten <xref:System.Net.Sockets.Socket> Instanz und eines bestimmten Rückrufs) wird bei der nachfolgenden Verwendung dieses Kontexts eine Leistungsverbesserung angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1134">After the first use of a particular context (a specific asynchronous <xref:System.Net.Sockets.Socket> method, a specific <xref:System.Net.Sockets.Socket> instance, and a specific callback), subsequent uses of that context will see a performance improvement.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1135">Im folgenden Codebeispiel werden Daten asynchron an den angegebenen Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1135">The following code example asynchronously sends data to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1136"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1136"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-1137">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1137">-or-</span></span> 
 <span data-ttu-id="d063a-1138"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1138"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1139">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1139">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-1140"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-1140"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-1141">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1141">-or-</span></span> 
 <span data-ttu-id="d063a-1142"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1142"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-1143">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1143">-or-</span></span> 
 <span data-ttu-id="d063a-1144"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-1144"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-1145">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1145">-or-</span></span> 
 <span data-ttu-id="d063a-1146"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" /> -Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-1146"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1147">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1147">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1148">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1148">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="/dotnet/framework/interop/marshaling-a-delegate-as-a-callback-method"><span data-ttu-id="d063a-1149">Marshalling von Delegaten als Rückrufmethode</span><span class="sxs-lookup"><span data-stu-id="d063a-1149">Marshaling a Delegate as a Callback Method</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP"><span data-ttu-id="d063a-1150">Der lokale <see cref="T:System.Net.EndPoint" />, der dem <see cref="T:System.Net.Sockets.Socket" /> zugeordnet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1150">The local <see cref="T:System.Net.EndPoint" /> to associate with the <see cref="T:System.Net.Sockets.Socket" />.</span></span></param>
        <summary><span data-ttu-id="d063a-1151">Ordnet einem <see cref="T:System.Net.Sockets.Socket" /> einen lokalen Endpunkt zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1151">Associates a <see cref="T:System.Net.Sockets.Socket" /> with a local endpoint.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1152">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden müssen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1152">Use the <xref:System.Net.Sockets.Socket.Bind%2A> method if you need to use a specific local endpoint.</span></span> <span data-ttu-id="d063a-1153">Sie müssen aufzurufen, <xref:System.Net.Sockets.Socket.Bind%2A> bevor Sie die-Methode abrufen können <xref:System.Net.Sockets.Socket.Listen%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1153">You must call <xref:System.Net.Sockets.Socket.Bind%2A> before you can call the <xref:System.Net.Sockets.Socket.Listen%2A> method.</span></span> <span data-ttu-id="d063a-1154">Sie müssen nicht <xref:System.Net.Sockets.Socket.Bind%2A> vor der Verwendung der-Methode aufzurufen, <xref:System.Net.Sockets.Socket.Connect%2A> es sei denn, Sie müssen einen bestimmten lokalen Endpunkt verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1154">You do not need to call <xref:System.Net.Sockets.Socket.Bind%2A> before using the <xref:System.Net.Sockets.Socket.Connect%2A> method unless you need to use a specific local endpoint.</span></span> <span data-ttu-id="d063a-1155">Sie können die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode sowohl für verbindungslose als auch für Verbindungs orientierte Protokolle verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1155">You can use the <xref:System.Net.Sockets.Socket.Bind%2A> method on both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d063a-1156">Vor <xref:System.Net.Sockets.Socket.Bind%2A> dem Aufrufen von müssen Sie zuerst das lokale erstellen, <xref:System.Net.IPEndPoint> aus dem Sie Daten übermitteln möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1156">Before calling <xref:System.Net.Sockets.Socket.Bind%2A>, you must first create the local <xref:System.Net.IPEndPoint> from which you intend to communicate data.</span></span> <span data-ttu-id="d063a-1157">Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, können Sie <xref:System.Net.IPEndPoint> mithilfe von <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adress Parameter erstellen, und der zugrunde liegende Dienstanbieter weist die am besten geeignete Netzwerkadresse zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1157">If you do not care which local address is assigned, you can create an <xref:System.Net.IPEndPoint> using <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> as the address parameter, and the underlying service provider will assign the most appropriate network address.</span></span> <span data-ttu-id="d063a-1158">Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1158">This might help simplify your application if you have multiple network interfaces.</span></span> <span data-ttu-id="d063a-1159">Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie einen <xref:System.Net.IPEndPoint> mit 0 für die Portnummer erstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1159">If you do not care which local port is used, you can create an <xref:System.Net.IPEndPoint> using 0 for the port number.</span></span> <span data-ttu-id="d063a-1160">In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000 zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1160">In this case, the service provider will assign an available port number between 1024 and 5000.</span></span>  
  
 <span data-ttu-id="d063a-1161">Wenn Sie den oben genannten Ansatz verwenden, können Sie ermitteln, welche Adresse und Portnummer des lokalen Netzwerks zugewiesen wurden, indem Sie aufrufen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1161">If you use the above approach, you can discover what local network address and port number has been assigned by calling the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>.</span></span> <span data-ttu-id="d063a-1162">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> gibt die lokal zugewiesene Netzwerkadresse erst zurück, nachdem Sie die-Methode oder die-Methode aufgerufen <xref:System.Net.Sockets.Socket.Connect%2A> haben <xref:System.Net.Sockets.Socket.EndConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1162">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> will not return the locally assigned network address until after you have made a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.EndConnect%2A> method.</span></span> <span data-ttu-id="d063a-1163">Wenn Sie ein verbindungsloses Protokoll verwenden, haben Sie erst dann Zugriff auf diese Informationen, wenn Sie einen Sende-oder Empfangsvorgang abgeschlossen haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1163">If you are using a connectionless protocol, you will not have access to this information until you have completed a send or receive.</span></span>  
  
 <span data-ttu-id="d063a-1164">Wenn ein UDP-Socket Schnittstellen Informationen zu empfangenen Paketen empfangen möchte, sollte die- <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode explizit aufgerufen werden, wenn die Socket-Option <xref:System.Net.Sockets.SocketOptionName.PacketInformation> unmittelbar nach dem Aufrufen der-Methode auf festgelegt ist <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1164">If a UDP socket wants to receive interface information on received packets,  the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method should be explicitly called with the socket option set to <xref:System.Net.Sockets.SocketOptionName.PacketInformation> immediately after calling the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1165">Wenn Sie beabsichtigen, Multicast Datagramme zu empfangen, müssen Sie die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode mit einer Multicast Portnummer abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1165">If you intend to receive multicast datagrams, you must call the <xref:System.Net.Sockets.Socket.Bind%2A> method with a multicast port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1166">Sie müssen die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode aufzurufen, wenn Sie verbindungslose Datagramme mithilfe der- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1166">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method if you intend to receive connectionless datagrams using the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1167">Wenn Sie <xref:System.Net.Sockets.SocketException> beim Aufrufen der-Methode einen erhalten <xref:System.Net.Sockets.Socket.Bind%2A> , verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1167">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1168">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1168">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1169">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1169">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1170">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1170">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1171">Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.Socket> mit dem angegebenen lokalen Endpunkt gebunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1171">The following code example binds a <xref:System.Net.Sockets.Socket> using the specified local endpoint.</span></span>  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1172"><paramref name="localEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1172"><paramref name="localEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1173">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1173">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1174">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1174">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1175">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1175">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1176">Ruft einen Wert ab, der angibt, ob sich der <see cref="T:System.Net.Sockets.Socket" /> im blockierenden Modus befindet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1176">Gets or sets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is in blocking mode.</span></span></summary>
        <value><span data-ttu-id="d063a-1177"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> blockiert wird, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1177"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> will block; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-1178">Der Standardwert ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1178">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1179">Die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft gibt an, ob <xref:System.Net.Sockets.Socket> sich ein im Blockierungs Modus befindet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1179">The <xref:System.Net.Sockets.Socket.Blocking%2A> property indicates whether a <xref:System.Net.Sockets.Socket> is in blocking mode.</span></span>  
  
 <span data-ttu-id="d063a-1180">Wenn Sie sich im Blockierungs Modus befinden und einen Methoden aufzurufen, der nicht sofort abgeschlossen wird, blockiert Ihre Anwendung die Ausführung, bis der angeforderte Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1180">If you are in blocking mode, and you make a method call which does not complete immediately, your application will block execution until the requested operation completes.</span></span> <span data-ttu-id="d063a-1181">Wenn die Ausführung fortgesetzt werden soll, obwohl der angeforderte Vorgang nicht vollständig ist, ändern Sie die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft in `false` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1181">If you want execution to continue even though the requested operation is not complete, change the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false`.</span></span> <span data-ttu-id="d063a-1182">Die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft wirkt sich nicht auf asynchrone Methoden aus.</span><span class="sxs-lookup"><span data-stu-id="d063a-1182">The <xref:System.Net.Sockets.Socket.Blocking%2A> property has no effect on asynchronous methods.</span></span> <span data-ttu-id="d063a-1183">Wenn Sie Daten asynchron senden und empfangen und die Ausführung blockieren möchten, verwenden Sie die- <xref:System.Threading.ManualResetEvent> Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-1183">If you are sending and receiving data asynchronously and want to block execution, use the <xref:System.Threading.ManualResetEvent> class.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1184">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1184">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1185">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1185">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1186">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1186">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1187">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1187">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1188">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1188">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1189">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1189">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-1190">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das verwendet wurde, um die Verbindung mit dem Remotehost durch Aufrufen einer der <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />-Methoden anzufordern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1190">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object used to request the connection to the remote host by calling one of the <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" /> methods.</span></span></param>
        <summary><span data-ttu-id="d063a-1191">Bricht eine asynchrone Anforderung einer Remotehostverbindung ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-1191">Cancels an asynchronous request for a remote host connection.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1192">Die <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> -Methode bricht eine asynchrone Anforderung einer Remotehostverbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1192">The <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> method cancels an asynchronous request for a remote host connection.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1193">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1193">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1194">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1194">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1195">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1195">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1196">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1196">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1197">Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1197">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-1198">Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1198">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1199">Die <xref:System.Net.Sockets.Socket.Close%2A> -Methode schließt die Remote Host Verbindung und gibt alle verwalteten und nicht verwalteten Ressourcen frei, die zugeordnet sind <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1199">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1200">Beim Schließen wird die- <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft auf festgelegt `false` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1200">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="d063a-1201">Für Verbindungs orientierte Protokolle empfiehlt es sich, <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufrufen der-Methode aufzurufen <xref:System.Net.Sockets.Socket.Close%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1201">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span> <span data-ttu-id="d063a-1202">Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1202">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d063a-1203">Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Close%2A> , ohne zuerst aufzurufen <xref:System.Net.Sockets.Socket.Shutdown%2A> , können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragungen gesendet werden, indem Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> Option auf festlegen `false` und ein Timeout Intervall angeben, das nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1203">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="d063a-1204"><xref:System.Net.Sockets.Socket.Close%2A> blockiert dann, bis diese Daten gesendet werden oder bis das angegebene Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="d063a-1204"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d063a-1205">Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf festlegen `false` und ein Timeout Intervall von NULL angeben, wird <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung von freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1205">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1206">Um die <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf festzulegen `false` , erstellen Sie eine <xref:System.Net.Sockets.LingerOption> , legen Sie die aktivierte-Eigenschaft auf fest `true` , und legen Sie die- <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft auf den gewünschten Timeout Zeitraum fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1206">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time out period.</span></span> <span data-ttu-id="d063a-1207">Verwenden <xref:System.Net.Sockets.LingerOption> Sie dies zusammen mit der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption, um die-Methode aufzurufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1207">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1208">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1208">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1209">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1209">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1210">Im folgenden Codebeispiel wird ein geschlossen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1210">The following code example closes a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="timeout"><span data-ttu-id="d063a-1211">Warten Sie bis zu <paramref name="timeout" /> Sekunden, damit alle verbleibenden Daten gesendet werden, und schließen Sie dann den Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-1211">Wait up to <paramref name="timeout" /> seconds to send any remaining data, then close the socket.</span></span></param>
        <summary><span data-ttu-id="d063a-1212">Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen mit einem angegebenen Timeout frei, damit in der Warteschlange befindliche Daten gesendet werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-1212">Closes the <see cref="T:System.Net.Sockets.Socket" /> connection and releases all associated resources with a specified timeout to allow queued data to be sent.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1213">Die <xref:System.Net.Sockets.Socket.Close%2A> -Methode schließt die Remote Host Verbindung und gibt alle verwalteten und nicht verwalteten Ressourcen frei, die zugeordnet sind <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1213">The <xref:System.Net.Sockets.Socket.Close%2A> method closes the remote host connection and releases all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1214">Beim Schließen wird die- <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft auf festgelegt `false` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1214">Upon closing, the <xref:System.Net.Sockets.Socket.Connected%2A> property is set to `false`.</span></span>  
  
 <span data-ttu-id="d063a-1215">Für Verbindungs orientierte Protokolle empfiehlt es sich, vor dem Aufruf von aufzurufen <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket.Close%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1215">For connection-oriented protocols, it is recommended that you call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling <xref:System.Net.Sockets.Socket.Close%2A>.</span></span> <span data-ttu-id="d063a-1216">Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1216">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d063a-1217">Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Close%2A> , ohne zuerst aufzurufen <xref:System.Net.Sockets.Socket.Shutdown%2A> , können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragungen gesendet werden, indem Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger> Option auf festlegen `false` und ein Timeout Intervall angeben, das nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1217">If you need to call <xref:System.Net.Sockets.Socket.Close%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can ensure that data queued for outgoing transmission will be sent by setting the <xref:System.Net.Sockets.SocketOptionName.DontLinger> option to `false` and specifying a non-zero time-out interval.</span></span> <span data-ttu-id="d063a-1218"><xref:System.Net.Sockets.Socket.Close%2A> blockiert dann, bis diese Daten gesendet werden oder bis das angegebene Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="d063a-1218"><xref:System.Net.Sockets.Socket.Close%2A> will then block until this data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d063a-1219">Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf festlegen `false` und ein Timeout Intervall von NULL angeben, wird <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung von freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1219">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1220">Um die <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf festzulegen `false` , erstellen Sie eine <xref:System.Net.Sockets.LingerOption> , legen Sie die aktivierte-Eigenschaft auf fest `true` , und legen Sie die- <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft auf den gewünschten Timeout Zeitraum fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1220">To set the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to `false`, create a <xref:System.Net.Sockets.LingerOption>, set the enabled property to `true`, and set the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property to the desired time-out period.</span></span> <span data-ttu-id="d063a-1221">Verwenden <xref:System.Net.Sockets.LingerOption> Sie dies zusammen mit der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption, um die-Methode aufzurufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1221">Use this <xref:System.Net.Sockets.LingerOption> along with the <xref:System.Net.Sockets.SocketOptionName.DontLinger> socket option to call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1222">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1222">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1223">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1223">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1224">Im folgenden Codebeispiel wird veranschaulicht, wie ein geschlossen wird <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1224">The following code example demonstrates how to close a <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1225">Stellt eine Verbindung mit einem Remotehost her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1225">Establishes a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="remoteEP"><span data-ttu-id="d063a-1226">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1226">An <see cref="T:System.Net.EndPoint" /> that represents the remote device.</span></span></param>
        <summary><span data-ttu-id="d063a-1227">Stellt eine Verbindung mit einem Remotehost her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1227">Establishes a connection to a remote host.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1228">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> stellt die Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1228">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d063a-1229">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1229">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d063a-1230">Nachdem Sie aufgerufen <xref:System.Net.Sockets.Socket.Connect%2A> haben, können Sie mit der-Methode Daten an das Remote Gerät senden <xref:System.Net.Sockets.Socket.Send%2A> oder Daten vom Remote Gerät mit der- <xref:System.Net.Sockets.Socket.Receive%2A> Methode empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1230">After you call <xref:System.Net.Sockets.Socket.Connect%2A>, you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1231">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.Connect%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1231">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1232">Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , um synchron mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1232">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d063a-1233">Wenn Sie anrufen <xref:System.Net.Sockets.Socket.Connect%2A> , werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eingehen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1233">If you do call <xref:System.Net.Sockets.Socket.Connect%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1234">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socket-Option auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> . andernfalls <xref:System.Net.Sockets.Socket.Connect%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1234">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1235">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1235">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1236">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1236">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d063a-1237">Die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird blockiert, es sei denn, Sie legen die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft vor dem Aufrufen von ausdrücklich auf fest `false` <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1237">The <xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-1238">Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, löst <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> aus, da es Zeit benötigt, um die Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1238">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d063a-1239">Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1239">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d063a-1240">Sie können verwenden <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1240">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1241">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1241">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-1242">Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben hat, wurde die Remote Host Verbindung von einem Verbindungs orientierten initiiert <xref:System.Net.Sockets.Socket> , aber noch nicht erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1242">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d063a-1243">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> Verbindung von abgeschlossen ist</span><span class="sxs-lookup"><span data-stu-id="d063a-1243">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1244">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufgerufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> wurde, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1244">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d063a-1245">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1245">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d063a-1246">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1246">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1247">Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1247">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d063a-1248">Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1248">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d063a-1249">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-1249">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1250">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1250">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1251">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1251">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1252">Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1252">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1253"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1253"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1254">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1254">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1255">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1255">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1256">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1256">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1257">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1257">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="address"><span data-ttu-id="d063a-1258">Die IP-Adresse des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1258">The IP address of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-1259">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1259">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="d063a-1260">Stellt eine Verbindung mit einem Remotehost her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1260">Establishes a connection to a remote host.</span></span> <span data-ttu-id="d063a-1261">Der Host wird mit einer IP-Adresse und einer Portnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1261">The host is specified by an IP address and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1262">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> stellt die Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1262">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d063a-1263">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1263">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d063a-1264">Nachdem Sie aufgerufen <xref:System.Net.Sockets.Socket.Connect%2A> haben, können Sie mit der-Methode Daten an das Remote Gerät senden <xref:System.Net.Sockets.Socket.Send%2A> oder Daten vom Remote Gerät mit der- <xref:System.Net.Sockets.Socket.Receive%2A> Methode empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1264">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1265">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.Connect%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1265">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1266">Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , um synchron mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1266">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d063a-1267">Wenn Sie Daten abrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die von einer anderen Adresse als der angegebenen Standardadresse eintreffen, werden Sie verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1267">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1268">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socket-Option auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> . andernfalls <xref:System.Net.Sockets.Socket.Connect%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1268">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1269">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1269">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1270">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1270">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d063a-1271"><xref:System.Net.Sockets.Socket.Connect%2A> die Methode wird blockiert, es sei denn, Sie legen die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft vor dem Aufrufen von ausdrücklich auf fest `false` <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1271"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-1272">Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, löst <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> aus, da es Zeit benötigt, um die Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1272">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d063a-1273">Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1273">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d063a-1274">Sie können verwenden <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1274">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1275">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1275">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-1276">Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben hat, wurde die Remote Host Verbindung von einem Verbindungs orientierten initiiert <xref:System.Net.Sockets.Socket> , aber noch nicht erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1276">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d063a-1277">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> Verbindung von abgeschlossen ist</span><span class="sxs-lookup"><span data-stu-id="d063a-1277">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1278">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufgerufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> wurde, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1278">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d063a-1279">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1279">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d063a-1280">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1280">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1281">Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1281">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d063a-1282">Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1282">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d063a-1283">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-1283">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1284">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1284">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1285">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1285">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1286">Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1286">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1287"><paramref name="address" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1287"><paramref name="address" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-1288">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1288">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1289">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1289">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1290">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1290">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1291">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1291">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1292">Die Länge von <paramref name="address" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-1292">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1293">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1293">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="addresses"><span data-ttu-id="d063a-1294">Die IP-Adressen des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1294">The IP addresses of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-1295">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1295">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="d063a-1296">Stellt eine Verbindung mit einem Remotehost her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1296">Establishes a connection to a remote host.</span></span> <span data-ttu-id="d063a-1297">Der Host wird durch ein Array von IP-Adressen und eine Portnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1297">The host is specified by an array of IP addresses and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1298">Diese Methode wird in der Regel unmittelbar nach einem-Rückruf verwendet <xref:System.Net.Dns.GetHostAddresses%2A> , der mehrere IP-Adressen für einen einzelnen Host zurückgeben kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-1298">This method is typically used immediately after a call to <xref:System.Net.Dns.GetHostAddresses%2A>, which can return multiple IP addresses for a single host.</span></span> <span data-ttu-id="d063a-1299">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> stellt die Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Endpunkt her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1299">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote endpoint.</span></span> <span data-ttu-id="d063a-1300">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1300">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d063a-1301">Nachdem Sie aufgerufen <xref:System.Net.Sockets.Socket.Connect%2A> haben, können Sie mit der-Methode Daten an das Remote Gerät senden <xref:System.Net.Sockets.Socket.Send%2A> oder Daten vom Remote Gerät mit der- <xref:System.Net.Sockets.Socket.Receive%2A> Methode empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1301">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1302">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.Connect%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1302">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1303">Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , um synchron mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1303">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d063a-1304">Wenn Sie Daten abrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die von einer anderen Adresse als der angegebenen Standardadresse eintreffen, werden Sie verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1304">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1305">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socket-Option auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> . andernfalls <xref:System.Net.Sockets.Socket.Connect%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1305">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1306">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1306">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1307">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1307">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d063a-1308"><xref:System.Net.Sockets.Socket.Connect%2A> die Methode wird blockiert, es sei denn, Sie legen die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft vor dem Aufrufen von ausdrücklich auf fest `false` <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1308"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-1309">Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, löst <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> aus, da es Zeit benötigt, um die Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1309">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d063a-1310">Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1310">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d063a-1311">Sie können verwenden <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1311">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1312">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1312">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-1313">Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben hat, wurde die Remote Host Verbindung von einem Verbindungs orientierten initiiert <xref:System.Net.Sockets.Socket> , aber noch nicht erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1313">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d063a-1314">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> Verbindung von abgeschlossen ist</span><span class="sxs-lookup"><span data-stu-id="d063a-1314">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1315">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufgerufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> wurde, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1315">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d063a-1316">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1316">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d063a-1317">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1317">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1318">Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1318">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d063a-1319">Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1319">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d063a-1320">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-1320">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1321">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1321">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1322">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1322">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1323">Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1323">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1324"><paramref name="addresses" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1324"><paramref name="addresses" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-1325">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1325">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1326">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1326">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1327">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1327">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1328">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1328">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1329">Die Länge von <paramref name="address" /> ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-1329">The length of <paramref name="address" /> is zero.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1330">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1330">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="host"><span data-ttu-id="d063a-1331">Der Name des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1331">The name of the remote host.</span></span></param>
        <param name="port"><span data-ttu-id="d063a-1332">Die Portnummer des Remotehosts.</span><span class="sxs-lookup"><span data-stu-id="d063a-1332">The port number of the remote host.</span></span></param>
        <summary><span data-ttu-id="d063a-1333">Stellt eine Verbindung mit einem Remotehost her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1333">Establishes a connection to a remote host.</span></span> <span data-ttu-id="d063a-1334">Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1334">The host is specified by a host name and a port number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1335">Wenn Sie ein Verbindungs orientiertes Protokoll wie z. b. TCP verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> stellt die Methode synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remote Host her.</span><span class="sxs-lookup"><span data-stu-id="d063a-1335">If you are using a connection-oriented protocol such as TCP, the <xref:System.Net.Sockets.Socket.Connect%2A> method synchronously establishes a network connection between <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> and the specified remote host.</span></span> <span data-ttu-id="d063a-1336">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1336">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.Connect%2A> establishes a default remote host.</span></span> <span data-ttu-id="d063a-1337">Nachdem Sie aufgerufen <xref:System.Net.Sockets.Socket.Connect%2A> haben, können Sie mit der-Methode Daten an das Remote Gerät senden <xref:System.Net.Sockets.Socket.Send%2A> oder Daten vom Remote Gerät mit der- <xref:System.Net.Sockets.Socket.Receive%2A> Methode empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1337">After you call <xref:System.Net.Sockets.Socket.Connect%2A> you can send data to the remote device with the <xref:System.Net.Sockets.Socket.Send%2A> method, or receive data from the remote device with the <xref:System.Net.Sockets.Socket.Receive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1338">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.Connect%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1338">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.Connect%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1339">Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , um synchron mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1339">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> and <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> to synchronously communicate with a remote host.</span></span> <span data-ttu-id="d063a-1340">Wenn Sie Daten abrufen <xref:System.Net.Sockets.Socket.Connect%2A> , die von einer anderen Adresse als der angegebenen Standardadresse eintreffen, werden Sie verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1340">If you do call <xref:System.Net.Sockets.Socket.Connect%2A> any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1341">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socket-Option auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> . andernfalls <xref:System.Net.Sockets.Socket.Connect%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1341">If you want to set your default remote host to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1342">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1342">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1343">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1343">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d063a-1344"><xref:System.Net.Sockets.Socket.Connect%2A> die Methode wird blockiert, es sei denn, Sie legen die- <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft vor dem Aufrufen von ausdrücklich auf fest `false` <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1344"><xref:System.Net.Sockets.Socket.Connect%2A> method will block, unless you specifically set the <xref:System.Net.Sockets.Socket.Blocking%2A> property to `false` prior to calling <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-1345">Wenn Sie ein Verbindungs orientiertes Protokoll wie TCP verwenden und die Blockierung deaktivieren, löst <xref:System.Net.Sockets.Socket.Connect%2A> eine <xref:System.Net.Sockets.SocketException> aus, da es Zeit benötigt, um die Verbindung herzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1345">If you are using a connection-oriented protocol like TCP and you do disable blocking, <xref:System.Net.Sockets.Socket.Connect%2A> will throw a <xref:System.Net.Sockets.SocketException> because it needs time to make the connection.</span></span> <span data-ttu-id="d063a-1346">Verbindungslose Protokolle lösen keine Ausnahme aus, da Sie einfach einen Standard-Remote Host einrichten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1346">Connectionless protocols will not throw an exception because they simply establish a default remote host.</span></span> <span data-ttu-id="d063a-1347">Sie können verwenden <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> , um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1347">You can use <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1348">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1348">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-1349">Wenn der Fehler "WSAEWOULDBLOCK" zurückgegeben hat, wurde die Remote Host Verbindung von einem Verbindungs orientierten initiiert <xref:System.Net.Sockets.Socket> , aber noch nicht erfolgreich abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1349">If the error returned WSAEWOULDBLOCK, the remote host connection has been initiated by a connection-oriented <xref:System.Net.Sockets.Socket>, but has not yet completed successfully.</span></span> <span data-ttu-id="d063a-1350">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> Verbindung von abgeschlossen ist</span><span class="sxs-lookup"><span data-stu-id="d063a-1350">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method to determine when the <xref:System.Net.Sockets.Socket> is finished connecting.</span></span>  
  
 <span data-ttu-id="d063a-1351">Wenn IPv6 aktiviert ist und die- <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> Methode aufgerufen wird, um eine Verbindung mit einem Host herzustellen, der zu IPv6-und IPv4-Adressen aufgelöst wird, wird die Verbindung mit der IPv6-Adresse zuerst vor der IPv4-Adresse versucht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1351">If IPv6 is enabled and the <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> method is called to connect to a host that resolves to both IPv6 and IPv4 addresses, the connection to the IPv6 address will be attempted first before the IPv4 address.</span></span> <span data-ttu-id="d063a-1352">Dies kann dazu führen, dass sich die Zeit zum Herstellen der Verbindung verzögert, wenn der Host nicht an der IPv6-Adresse lauscht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1352">This may have the effect of delaying the time to establish the connection if the host is not listening on the IPv6 address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1353">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufgerufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.Connect%2A> wurde, weist der zugrunde liegende Dienstanbieter die Adresse und die Portnummer des lokalen Netzwerks zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1353">If you are using a connection-oriented protocol and did not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.Connect%2A>, the underlying service provider will assign the local network address and port number.</span></span> <span data-ttu-id="d063a-1354">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter erst dann eine lokale Netzwerkadresse und eine Portnummer zu, wenn Sie einen Sende-oder Empfangsvorgang ausführen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1354">If you are using a connectionless protocol, the service provider will not assign a local network address and port number until you complete a send or receive operation.</span></span> <span data-ttu-id="d063a-1355">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1355">If you want to change the default remote host, call <xref:System.Net.Sockets.Socket.Connect%2A> again with the desired endpoint.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1356">Wenn der Socket bereits getrennt wurde, können Sie diese Methode nicht verwenden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1356">If the socket has been previously disconnected, then you cannot use this method to restore the connection.</span></span> <span data-ttu-id="d063a-1357">Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden, um die Verbindung wiederherzustellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1357">Use one of the asynchronous <xref:System.Net.Sockets.Socket.BeginConnect%2A> methods to reconnect.</span></span> <span data-ttu-id="d063a-1358">Dies ist eine Einschränkung des zugrunde liegenden Anbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-1358">This is a limitation of the underlying provider.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1359">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1359">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1360">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1360">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1361">Das folgende Codebeispiel stellt eine Verbindung mit einem Remote Endpunkt her und überprüft dann die Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1361">The following code example connects to a remote endpoint and then verifies the connection.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1362"><paramref name="host" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1362"><paramref name="host" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-1363">Die Portnummer ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1363">The port number is not valid.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1364">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1364">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1365">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1365">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1366">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1366">This method is valid for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1367">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1367">The <see cref="T:System.Net.Sockets.Socket" /> has been placed in a listening state by calling <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1368">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1368">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-1369">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1369">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1370">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1370">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="d063a-1371"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1371"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-1372">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1372">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-1373"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1373"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-1374">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1374">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1375">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die- <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode eine asynchrone Anforderung für eine Verbindung mit dem Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-1375">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="d063a-1376">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> richtet einen Standard Remote Host ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1376">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host.</span></span>  
  
 <span data-ttu-id="d063a-1377">Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-Delegaten implementiert, \<SocketAsyncEventArgs> und den Rückruf an das Ereignis anfügen <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1377">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d063a-1378">Der Aufrufer muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft auf den <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, mit dem eine Verbindung hergestellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1378">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="d063a-1379">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-1379">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-1380">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1380">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-1381">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1381">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1382">Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> , um mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1382">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d063a-1383">Wenn Sie anrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> , werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eingehen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1383">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1384">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1384">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d063a-1385">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst aufzurufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf festlegen `true` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1385">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d063a-1386">Wenn dies nicht der Fall ist, löst die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1386">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-1387">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:</span><span class="sxs-lookup"><span data-stu-id="d063a-1387">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-1388">Optional kann ein Puffer bereitgestellt werden, der nach erfolgreichem Abschluss der Methode atomisch an den Socket gesendet wird <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1388">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d063a-1389">In diesem Fall muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> Eigenschaft auf den Puffer festgelegt werden, der die zu sendenden Daten enthält, und die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft muss auf die Anzahl der Daten Bytes festgelegt werden, die aus dem Puffer gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1389">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="d063a-1390">Nachdem eine Verbindung hergestellt wurde, wird dieser Datenpuffer gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1390">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="d063a-1391">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufrufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> , weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1391">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="d063a-1392">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale IP-Adresse und Portnummer für das lokale Netzwerk zu, bis die-Methode oder die-Methode aufgerufen wird <xref:System.Net.Sockets.Socket.SendAsync%2A> <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1392">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="d063a-1393">Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> aus, wenn die Adressfamilie von <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nicht dieselbe Adressfamilie ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1393">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1394">Wenn Sie <xref:System.Net.Sockets.SocketException> beim Aufrufen dieser Methode eine erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1394">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1395">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1395">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1396">Ein Argument ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1396">An argument is not valid.</span></span> <span data-ttu-id="d063a-1397">Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1397">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1398">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1398">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1399">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1399">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1400">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1400">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1401">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1401">Windows XP or later is required for this method.</span></span> <span data-ttu-id="d063a-1402">Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1402">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1403">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1403">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1404">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1404">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ConnectAsync (socketType As SocketType, protocolType As ProtocolType, e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" Index="1" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="2" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="socketType"><span data-ttu-id="d063a-1405">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1405">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></param>
        <param name="protocolType"><span data-ttu-id="d063a-1406">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1406">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></param>
        <param name="e"><span data-ttu-id="d063a-1407">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1407">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1408">Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1408">Begins an asynchronous request for a connection to a remote host.</span></span></summary>
        <returns><span data-ttu-id="d063a-1409"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1409"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-1410">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1410">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-1411"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1411"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-1412">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1412">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1413">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, startet die M:System.net.Sockets.Socket.ConnectAsync (System .net. Sockets. SocketType, System .net. Sockets. ProtocolType, System .net. Sockets. SocketAsyncEventArgs)-Methode eine asynchrone Anforderung für eine Verbindung mit dem Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-1413">If you are using a connection-oriented protocol, the M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs) method starts an asynchronous request for a connection to the remote host.</span></span> <span data-ttu-id="d063a-1414">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> richtet einen Standard Remote Host ein, der durch den `socketType` -Parameter und den-Parameter angegeben wird `protocolType` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1414">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> establishes a default remote host specified by the `socketType` and `protocolType` parameters.</span></span>  
  
 <span data-ttu-id="d063a-1415">Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-Delegaten implementiert, \<SocketAsyncEventArgs> und den Rückruf an das Ereignis anfügen <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1415">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d063a-1416">Der Aufrufer muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft auf den <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, mit dem eine Verbindung hergestellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1416">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host to connect to.</span></span>  
  
 <span data-ttu-id="d063a-1417">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-1417">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-1418">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1418">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-1419">Wenn Sie ein verbindungsloses Protokoll (z. b. UDP) verwenden, müssen Sie vor dem <xref:System.Net.Sockets.Socket.ConnectAsync%2A> senden und empfangen von Daten nicht aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1419">If you are using a connectionless protocol such as UDP, you do not have to call <xref:System.Net.Sockets.Socket.ConnectAsync%2A> before sending and receiving data.</span></span> <span data-ttu-id="d063a-1420">Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und verwenden <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> , um mit einem Remote Host zu kommunizieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1420">You can use <xref:System.Net.Sockets.Socket.SendToAsync%2A> and <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> to communicate with a remote host.</span></span> <span data-ttu-id="d063a-1421">Wenn Sie anrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> , werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eingehen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1421">If you do call <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, any datagrams that arrive from an address other than the specified default will be discarded.</span></span> <span data-ttu-id="d063a-1422">Wenn Sie den Standard-Remote Host ändern möchten, müssen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erneut mit dem gewünschten Endpunkt abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1422">If you want to change the default remote host, call the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method again with the desired endpoint.</span></span>  
  
 <span data-ttu-id="d063a-1423">Wenn Sie den Standard-Remote Host auf eine Broadcast Adresse festlegen möchten, müssen Sie zuerst aufzurufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> und Broadcast auf festlegen `true` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1423">If you wish to set the default remote host to a broadcast address, you must first call <xref:System.Net.Sockets.Socket.SetSocketOption%2A> and set Broadcast to `true`.</span></span> <span data-ttu-id="d063a-1424">Wenn dies nicht der Fall ist, löst die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1424">If this is not done, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-1425">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:</span><span class="sxs-lookup"><span data-stu-id="d063a-1425">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-1426">Optional kann ein Puffer bereitgestellt werden, der nach erfolgreichem Abschluss der Methode atomisch an den Socket gesendet wird <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1426">Optionally, a buffer may be provided which will atomically be sent on the socket after the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method succeeds.</span></span> <span data-ttu-id="d063a-1427">In diesem Fall muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> Eigenschaft auf den Puffer festgelegt werden, der die zu sendenden Daten enthält, und die- <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft muss auf die Anzahl der Daten Bytes festgelegt werden, die aus dem Puffer gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1427">In this case, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> property needs to be set to the buffer containing the data to send and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> property needs to be set to the number of bytes of data to send from the buffer.</span></span> <span data-ttu-id="d063a-1428">Nachdem eine Verbindung hergestellt wurde, wird dieser Datenpuffer gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1428">Once a connection is established, this buffer of data is sent.</span></span>  
  
 <span data-ttu-id="d063a-1429">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden und vor dem Aufruf von nicht aufrufen <xref:System.Net.Sockets.Socket.Bind%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> , weist der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-1429">If you are using a connection-oriented protocol and do not call <xref:System.Net.Sockets.Socket.Bind%2A> before calling <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, the underlying service provider will assign the most appropriate local network address and port number.</span></span>  
  
 <span data-ttu-id="d063a-1430">Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale IP-Adresse und Portnummer für das lokale Netzwerk zu, bis die-Methode oder die-Methode aufgerufen wird <xref:System.Net.Sockets.Socket.SendAsync%2A> <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1430">If you are using a connectionless protocol, the service provider will not assign a local network IP address and port number until you call the <xref:System.Net.Sockets.Socket.SendAsync%2A> or <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> methods.</span></span>  
  
 <span data-ttu-id="d063a-1431">Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> aus, wenn die Adressfamilie von <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> nicht dieselbe Adressfamilie ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1431">The <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method throws <xref:System.NotSupportedException> if the address family of the <xref:System.Net.Sockets.Socket> and the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> are not the same address family.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1432">Wenn Sie <xref:System.Net.Sockets.SocketException> beim Aufrufen dieser Methode eine erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1432">If you receive a <xref:System.Net.Sockets.SocketException> when calling this method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1433">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1433">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1434">Ein Argument ist ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1434">An argument is not valid.</span></span> <span data-ttu-id="d063a-1435">Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1435">This exception occurs if multiple buffers are specified, the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is not null.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1436">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1436">The <paramref name="e" /> parameter cannot be null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1437">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1437">The <see cref="T:System.Net.Sockets.Socket" /> is listening or a socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1438">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1438">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1439">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1439">Windows XP or later is required for this method.</span></span> <span data-ttu-id="d063a-1440">Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1440">This exception also occurs if the local endpoint and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> are not the same address family.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1441">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1441">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1442">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1442">A caller higher in the call stack does not have permission for the requested operation.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1443">Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Net.Sockets.Socket" /> mit dem Remotehost des letzten <see cref="Overload:System.Net.Sockets.Socket.Send" />-Vorgangs oder <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Vorgangs verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1443">Gets a value that indicates whether a <see cref="T:System.Net.Sockets.Socket" /> is connected to a remote host as of the last <see cref="Overload:System.Net.Sockets.Socket.Send" /> or <see cref="Overload:System.Net.Sockets.Socket.Receive" /> operation.</span></span></summary>
        <value><span data-ttu-id="d063a-1444"><see langword="true" />, wenn <see cref="T:System.Net.Sockets.Socket" /> beim letzten Vorgang mit einer Remoteressource verbunden war, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1444"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> was connected to a remote resource as of the most recent operation; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1445">Die- `Connected` Eigenschaft ruft den Verbindungsstatus des <xref:System.Net.Sockets.Socket> ab dem letzten e/a-Vorgang ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-1445">The `Connected` property gets the connection state of the <xref:System.Net.Sockets.Socket> as of the last I/O operation.</span></span> <span data-ttu-id="d063a-1446">Wenn zurückgegeben wird `false` , <xref:System.Net.Sockets.Socket> wurde entweder nie eine Verbindung hergestellt, oder die Verbindung ist nicht mehr hergestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1446">When it returns `false`, the <xref:System.Net.Sockets.Socket> was either never connected, or is no longer connected.</span></span>  
  
 <span data-ttu-id="d063a-1447">Der Wert der- <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft gibt den Status der Verbindung beim letzten Vorgang wieder.</span><span class="sxs-lookup"><span data-stu-id="d063a-1447">The value of the <xref:System.Net.Sockets.Socket.Connected%2A> property reflects the state of the connection as of the most recent operation.</span></span> <span data-ttu-id="d063a-1448">Wenn Sie den aktuellen Status der Verbindung bestimmen müssen, erstellen Sie einen nicht blockierenden, NULL-Byte-Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1448">If you need to determine the current state of the connection, make a nonblocking, zero-byte Send call.</span></span> <span data-ttu-id="d063a-1449">Wenn der-Rückruf erfolgreich zurückgegeben wurde oder einen waewouldblock-Fehlercode (10035) auslöst, ist der Socket weiterhin verbunden. Andernfalls ist der Socket nicht mehr verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1449">If the call returns successfully or throws a WAEWOULDBLOCK error code (10035), then the socket is still connected; otherwise, the socket is no longer connected.</span></span>  
  
 <span data-ttu-id="d063a-1450">Wenn Sie <xref:System.Net.Sockets.Socket.Connect%2A> für einen UDP-Socket (User Datagram Protocol) aufzurufen, gibt die- <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft immer zurück `true` . durch diese Aktion wird jedoch nicht die inhärente verbindungslose Natur von UDP geändert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1450">If you call <xref:System.Net.Sockets.Socket.Connect%2A> on a User Datagram Protocol (UDP) socket, the <xref:System.Net.Sockets.Socket.Connected%2A> property always returns `true`; however, this action does not change the inherent connectionless nature of UDP.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1451">Im folgenden Codebeispiel wird eine Verbindung mit einem Remote Endpunkt hergestellt, die <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft überprüft und der aktuelle Zustand der Verbindung überprüft.</span><span class="sxs-lookup"><span data-stu-id="d063a-1451">The following code example connects to a remote endpoint, checks the <xref:System.Net.Sockets.Socket.Connected%2A> property, and checks the current state of the connection.</span></span>  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><span data-ttu-id="d063a-1452"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die aktuelle Verbindung geschlossen wurde, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1452"><see langword="true" /> if this socket can be reused after the current connection is closed; otherwise, <see langword="false" />.</span></span></param>
        <summary><span data-ttu-id="d063a-1453">Schließt die Socketverbindung und ermöglicht die Wiederverwendung des Sockets.</span><span class="sxs-lookup"><span data-stu-id="d063a-1453">Closes the socket connection and allows reuse of the socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1454">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, können Sie den Socket mit dieser Methode schließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1454">If you are using a connection-oriented protocol, you can use this method to close the socket.</span></span> <span data-ttu-id="d063a-1455">Diese Methode beendet die Verbindung und legt die- <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft auf fest `false` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1455">This method ends the connection and sets the <xref:System.Net.Sockets.Socket.Connected%2A> property to `false`.</span></span> <span data-ttu-id="d063a-1456">Wenn jedoch `reuseSocket` ist `true` , können Sie den Socket wieder verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1456">However, if `reuseSocket` is `true`, you can reuse the socket.</span></span>  
  
 <span data-ttu-id="d063a-1457">Um sicherzustellen, dass alle Daten vor dem Schließen des Sockets gesendet und empfangen werden, sollten Sie aufrufen, <xref:System.Net.Sockets.Socket.Shutdown%2A> bevor Sie die- <xref:System.Net.Sockets.Socket.Disconnect%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1457">To ensure that all data is sent and received before the socket is closed, you should call <xref:System.Net.Sockets.Socket.Shutdown%2A> before calling the <xref:System.Net.Sockets.Socket.Disconnect%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1458">Wenn Sie aufrufen müssen <xref:System.Net.Sockets.Socket.Disconnect%2A> , ohne zuerst aufzurufen <xref:System.Net.Sockets.Socket.Shutdown%2A> , können Sie die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> -Option auf festlegen `false` und ein Timeout Intervall angeben, das nicht NULL ist, um sicherzustellen, dass Daten in der Warteschlange für ausgehende Übertragungen gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1458">If you need to call <xref:System.Net.Sockets.Socket.Disconnect%2A> without first calling <xref:System.Net.Sockets.Socket.Shutdown%2A>, you can set the <xref:System.Net.Sockets.SocketOptionName.DontLinger><xref:System.Net.Sockets.Socket> option to `false` and specify a nonzero time-out interval to ensure that data queued for outgoing transmission is sent.</span></span> <span data-ttu-id="d063a-1459"><xref:System.Net.Sockets.Socket.Disconnect%2A> blockiert dann, bis die Daten gesendet werden oder bis das angegebene Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="d063a-1459"><xref:System.Net.Sockets.Socket.Disconnect%2A> then blocks until the data is sent or until the specified time-out expires.</span></span> <span data-ttu-id="d063a-1460">Wenn Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> auf festlegen `false` und ein Timeout Intervall von NULL angeben, wird <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung von freigegeben, und ausgehende Daten in der Warteschlange werden automatisch verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1460">If you set <xref:System.Net.Sockets.SocketOptionName.DontLinger> to `false` and specify a zero time-out interval, <xref:System.Net.Sockets.Socket.Close%2A> releases the connection and automatically discards outgoing queued data.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1461">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1461">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1462">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1462">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1463">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1463">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1464">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1464">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1465">Das folgende Codebeispiel erstellt einen Socket für die synchrone Kommunikation und sendet einige Daten an einen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-1465">The following code example creates a socket for synchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d063a-1466">Anschließend wird aufgerufen <xref:System.Net.Sockets.Socket.Shutdown%2A> , um die Sende-und Empfangs Aktivität zu beenden, und <xref:System.Net.Sockets.Socket.Disconnect%2A> , um die Socketverbindung zu schließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1466">It then calls <xref:System.Net.Sockets.Socket.Shutdown%2A>, to stop the send and receive activity, and <xref:System.Net.Sockets.Socket.Disconnect%2A>, to close the socket connection.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1467">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1467">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1468">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1468">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-1469">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1469">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1470">Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1470">Begins an asynchronous request to disconnect from a remote endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-1471"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1471"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-1472">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-1472">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-1473"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1473"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-1474">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1474">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1475">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, fordert der Aufruf der- <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> Methode eine Verbindung von einem Remote Endpunkt an.</span><span class="sxs-lookup"><span data-stu-id="d063a-1475">When using a connection-oriented protocol, calling the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> method requests a disconnect from a remote endpoint.</span></span> <span data-ttu-id="d063a-1476">Wenn Sie <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> auf `true` im-Parameter festlegen `e` , kann der Socket wieder verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1476">If you set <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> to `true` in the `e` parameter, the socket can be reused.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1477">Der <paramref name="e" />-Parameter darf nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-1477">The <paramref name="e" /> parameter cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1478">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1478">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1479">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1479">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1480">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1480">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1481">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1481">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1482">Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1482">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-1483">Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1483">Releases all resources used by the current instance of the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1484">Rufen Sie `Dispose` auf, wenn Sie <xref:System.Net.Sockets.Socket> nicht mehr benötigen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1484">Call `Dispose` when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1485">Die `Dispose`-Methode bewirkt, dass <xref:System.Net.Sockets.Socket> nicht mehr verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-1485">The `Dispose` method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="d063a-1486">Nach dem Aufrufen `Dispose` von müssen Sie alle Verweise auf den freigeben, <xref:System.Net.Sockets.Socket> damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.Socket> belegt hat.</span><span class="sxs-lookup"><span data-stu-id="d063a-1486">After calling `Dispose`, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span>  
  
 <span data-ttu-id="d063a-1487">Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-1487">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1488">Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Net.Sockets.Socket> freigeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1488">Always call `Dispose` before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1489">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="d063a-1489">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><span data-ttu-id="d063a-1490"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1490"><see langword="true" /> to release both managed and unmanaged resources; <see langword="false" /> to releases only unmanaged resources.</span></span></param>
        <summary><span data-ttu-id="d063a-1491">Gibt die vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1491">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.Socket" />, and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1492">Diese Methode wird von der öffentlichen `Dispose()` -Methode und der- <xref:System.Object.Finalize%2A> Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1492">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="d063a-1493">`Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der- `disposing` Parameter auf festgelegt ist `true` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1493">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="d063a-1494"><xref:System.Object.Finalize%2A> Ruft `Dispose` `disposing` auf, wobei auf gesetzt ist `false` .</span><span class="sxs-lookup"><span data-stu-id="d063a-1494"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="d063a-1495">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.Socket> verweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1495">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.Socket> references.</span></span> <span data-ttu-id="d063a-1496">Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1496">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1497">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1497">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1498">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1498">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="d063a-1499">
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1499">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="d063a-1500">Beim Überschreiben von <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1500">When overriding <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="d063a-1501">Weitere Informationen zum Implementieren von finden Sie <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> unter [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-1501">For more information about how to implement <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, see [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>  
  
<span data-ttu-id="d063a-1502">Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" /> finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="d063a-1502">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1503">Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> die Fragmentierung von IP (Internet Protocol)-Datagrammen zulässt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1503">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows Internet Protocol (IP) datagrams to be fragmented.</span></span></summary>
        <value><span data-ttu-id="d063a-1504"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> die Datagrammfragmentierung zulässt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1504"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows datagram fragmentation; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-1505">Der Standardwert ist <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1505">The default is <see langword="true" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1506">Datagramme erfordern eine Fragmentierung, wenn ihre Größe die maximale Übertragungseinheit (MTU) des Übertragungsmediums überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1506">Datagrams require fragmentation when their size exceeds the Maximum Transfer Unit (MTU) of the transmission medium.</span></span> <span data-ttu-id="d063a-1507">Datagramme können durch den sendenden Host (alle Internetprotokoll Versionen) oder einen zwischen Router (nur Internetprotokoll Version 4) fragmentiert werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1507">Datagrams may be fragmented by the sending host (all Internet Protocol versions) or an intermediate router (Internet Protocol Version 4 only).</span></span> <span data-ttu-id="d063a-1508">Wenn ein Datagramm fragmentiert werden muss und die- <xref:System.Net.Sockets.Socket.DontFragment%2A> Option festgelegt ist, wird das Datagramm verworfen und eine ICMP (Internet Control Message Protocol)-Fehlermeldung an den Absender des Datagramms zurückgesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1508">If a datagram must be fragmented, and the <xref:System.Net.Sockets.Socket.DontFragment%2A> option is set, the datagram is discarded, and an Internet Control Message Protocol (ICMP) error message is sent back to the sender of the datagram.</span></span>  
  
 <span data-ttu-id="d063a-1509">Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1509">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1510">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.DontFragment%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1510">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.DontFragment%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1511">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1511">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1512">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1512">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1513">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1513">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1514">Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> ein für IPv4 und IPv6 verwendeter Dualmodussocket ist, oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1514">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> is a dual-mode socket used for both IPv4 and IPv6.</span></span></summary>
        <value><span data-ttu-id="d063a-1515"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ein Dualmodussocket ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1515"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is a  dual-mode socket; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-1516">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1516">The default is <see langword="false" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="targetProcessId"><span data-ttu-id="d063a-1517">Die ID des Zielprozesses, in dem ein Duplikat des Socketverweises erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1517">The ID of the target process where a duplicate of the socket reference is created.</span></span></param>
        <summary><span data-ttu-id="d063a-1518">Dupliziert den Socketverweis für den Zielprozess und schließt den Socket für diesen Prozess.</span><span class="sxs-lookup"><span data-stu-id="d063a-1518">Duplicates the socket reference for the target process, and closes the socket for this process.</span></span></summary>
        <returns><span data-ttu-id="d063a-1519">Der Socketverweis, der an den Zielprozess übergeben werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1519">The socket reference to be passed to the target process.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1520">Der Ziel Prozess sollte verwenden <xref:System.Net.Sockets.Socket.%23ctor%2A> , um die doppelte Socketinstanz zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1520">The target process should use <xref:System.Net.Sockets.Socket.%23ctor%2A> to create the duplicate socket instance.</span></span>  
  
 <span data-ttu-id="d063a-1521">Wenn Sie den- <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit dem gleichen Bytearray wie das-Argument für jeden-Befehl aufzurufen, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket> Instanzen mit demselben zugrunde liegenden Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-1521">If you call the <xref:System.Net.Sockets.Socket.%23ctor%2A> constructor multiple times with the same byte array as the argument for each call, you will create multiple managed <xref:System.Net.Sockets.Socket> instances with the same underlying socket.</span></span> <span data-ttu-id="d063a-1522">Diese Vorgehensweise wird dringend davon abgeraten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1522">This practice is strongly discouraged.</span></span>  
  
 <span data-ttu-id="d063a-1523">Wenn der Prozess, der den Socket erstellt, asynchrone Methoden ( <xref:System.Net.Sockets.Socket.BeginReceive%2A> oder <xref:System.Net.Sockets.Socket.BeginSend%2A> ) verwendet, muss der Prozess zuerst die- <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> Eigenschaft auf "true" festlegen. andernfalls ist der Socket an den Abschlussport des Erstellungs Prozesses gebunden, was dazu führen kann, dass eine für <xref:System.ArgumentNullException> den Ziel Prozess ausgelöst wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1523">If the process creating the socket uses asynchronous methods (<xref:System.Net.Sockets.Socket.BeginReceive%2A> or <xref:System.Net.Sockets.Socket.BeginSend%2A>), the process must first set the <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> property to true; otherwise, the socket is bound to the completion port of the creating process, which may cause an <xref:System.ArgumentNullException> to be thrown on the target process.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1524"><paramref name="targetProcessID" /> ist keine gültige Prozess-ID.</span><span class="sxs-lookup"><span data-stu-id="d063a-1524"><paramref name="targetProcessID" /> is not a valid process id.</span></span> 
<span data-ttu-id="d063a-1525">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1525">-or-</span></span> 
<span data-ttu-id="d063a-1526">Die Duplizierung des Socketverweises ist fehlgeschlagen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1526">Duplication of the socket reference failed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1527">Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete senden oder empfangen kann, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1527">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> can send or receive broadcast packets.</span></span></summary>
        <value><span data-ttu-id="d063a-1528"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete zulässt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1528"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows broadcast packets; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-1529">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1529">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1530">Broadcasting ist auf ein bestimmtes Subnetz beschränkt und muss das User Datagram-Protokoll (UDP) verwenden. Für Internet Protocol, Version 4, können Sie in Ihr lokales Subnetz übertragen, indem Sie ein Paket an 255.255.255.255 senden. oder Sie können die gesteuerte Broadcast Adresse verwenden, bei der es sich um den Netzwerk Teil einer IP-Adresse (Internet Protocol) handelt, bei dem alle Bits im Hostteil festgelegt sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1530">Broadcasting is limited to a specific subnet, and must use User Datagram Protocol (UDP.) For Internet Protocol version 4, you can broadcast to your local subnet by sending a packet to 255.255.255.255; or you can use the directed broadcast address, which is the network portion of an Internet Protocol (IP) address with all bits set in the host portion.</span></span> <span data-ttu-id="d063a-1531">Wenn Ihre IP-Adresse beispielsweise 192.168.1.40 (eine Class C-Adresse mit einer Netzwerk Maske von 255.255.255.0 ist, der Netzwerk Teil die ersten drei Oktette und der Hostteil das letzte Oktett ist), lautet die gesteuerte Broadcast Adresse 192.168.1.255.</span><span class="sxs-lookup"><span data-stu-id="d063a-1531">For example, if your IP address is 192.168.1.40 (a Class C address, with a netmask of 255.255.255.0 -- the network portion is the first three octets, and the host portion is the last octet), your directed broadcast address is 192.168.1.255.</span></span>  
  
 <span data-ttu-id="d063a-1532">Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1532">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1533">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.EnableBroadcast%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1533">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.EnableBroadcast%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1534">Diese Option ist nur für Datagrammsockets gültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-1534">This option is valid for a datagram socket only.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1535">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1535">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1536">Nimmt einen eingehenden Verbindungsversuch asynchron an.</span><span class="sxs-lookup"><span data-stu-id="d063a-1536">Asynchronously accepts an incoming connection attempt.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[]? buffer, IAsyncResult asyncResult);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-1537">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1537">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="d063a-1538">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1538">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="d063a-1539">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation.</span><span class="sxs-lookup"><span data-stu-id="d063a-1539">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="d063a-1540">Diese Methode gibt einen Puffer zurück, der die ersten übertragenen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1540">This method returns a buffer that contains the initial data transferred.</span></span></summary>
        <returns><span data-ttu-id="d063a-1541">Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1541">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen-Aufrufvorgang ab <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1542"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d063a-1543">Vor <xref:System.Net.Sockets.Socket.BeginAccept%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die vom Delegaten aufgerufen wird <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1543">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1544">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1544">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span>  
  
 <span data-ttu-id="d063a-1545">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- `asyncResult` Parameters auf, um den zu erhalten, <xref:System.Net.Sockets.Socket> für den der Verbindungsversuch durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1545">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d063a-1546">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndAccept%2A> um den Verbindungsversuch erfolgreich abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1546">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="d063a-1547">Der `buffer` -Parameter dieser Überladung enthält die Daten, die im-Aufrufen von empfangen <xref:System.Net.Sockets.Socket.BeginAccept%2A> wurden, und der- `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im-Befehl übertragen wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1547">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="d063a-1548">Die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1548">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d063a-1549">Die <xref:System.Net.Sockets.Socket.EndAccept%2A> -Methode akzeptiert die eingehende Verbindung und gibt eine neue zurück <xref:System.Net.Sockets.Socket> , die zum Senden von Daten an den Remote Host und zum Empfangen von Daten vom Remote Host verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-1549">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1550">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1550">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1551">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1551">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1552">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1552">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1553">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1553">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1554">Im folgenden Codebeispiel wird verwendet <xref:System.Net.Sockets.Socket.BeginAccept%2A> , um einen Socket zu erstellen und zu verbinden und die anfänglichen 10 Bytes an Daten zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1554">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="d063a-1555">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> auf, um die asynchrone Anforderung zu beenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1555">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d063a-1556">Die Anzahl der übertragenen Bytes, und die Daten werden in den `buffer` -und- `bytesTransferred` Parametern dieser Methode zurückgegeben und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1556">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1557">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1557">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1558">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1558">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1559"><paramref name="asyncResult" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-1559"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1560"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1560"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1561">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1561"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1562">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1562">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" /></span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1563">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1563">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1564">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1564">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="d063a-1565">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Remotehostkommunikation.</span><span class="sxs-lookup"><span data-stu-id="d063a-1565">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</span></span></summary>
        <returns><span data-ttu-id="d063a-1566">Ein <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Kommunikation mit dem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1566">A <see cref="T:System.Net.Sockets.Socket" /> to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen-Aufrufvorgang ab <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1567"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d063a-1568">Vor <xref:System.Net.Sockets.Socket.BeginAccept%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1568">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1569">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1569">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="d063a-1570">Er muss den `asyncResult` von der-Methode zurückgegebenen Parameter akzeptieren <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1570">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1571">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- `asyncResult` Parameters auf, um den zu erhalten, <xref:System.Net.Sockets.Socket> für den der Verbindungsversuch durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1571">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d063a-1572">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndAccept%2A> um den Verbindungsversuch erfolgreich abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1572">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span>  
  
 <span data-ttu-id="d063a-1573">Die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1573">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d063a-1574">Die <xref:System.Net.Sockets.Socket.EndAccept%2A> -Methode akzeptiert die eingehende Verbindung und gibt eine neue zurück <xref:System.Net.Sockets.Socket> , die zum Senden von Daten an den Remote Host und zum Empfangen von Daten vom Remote Host verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-1574">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1575">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1575">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1576">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1576">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1577">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1577">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1578">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1578">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1579">Im folgenden Codebeispiel wird eine asynchrone Anforderung beendet und ein neues erstellt <xref:System.Net.Sockets.Socket> , um eine eingehende Verbindungsanforderung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1579">The following code example ends an asynchronous request and creates a new <xref:System.Net.Sockets.Socket> to accept an incoming connection request.</span></span> <span data-ttu-id="d063a-1580">Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](/dotnet/framework/network-programming/socket-code-examples).</span><span class="sxs-lookup"><span data-stu-id="d063a-1580">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](/dotnet/framework/network-programming/socket-code-examples).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1581"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1581"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1582"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1582"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1583">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1583">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-1584">Weitere Informationen finden Sie im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-1584">See the Remarks section for more information.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1585">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1585">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1586">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1586"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1587">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1587">Windows NT is required for this method.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[]? buffer, out int bytesTransferred, IAsyncResult asyncResult);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept : Byte[] * int * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-1588">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1588">An array of type <see cref="T:System.Byte" /> that contains the bytes transferred.</span></span></param>
        <param name="bytesTransferred"><span data-ttu-id="d063a-1589">Die Anzahl der übertragenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1589">The number of bytes transferred.</span></span></param>
        <param name="asyncResult"><span data-ttu-id="d063a-1590">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1590">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation as well as any user defined data.</span></span></param>
        <summary><span data-ttu-id="d063a-1591">Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation.</span><span class="sxs-lookup"><span data-stu-id="d063a-1591">Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> object to handle remote host communication.</span></span> <span data-ttu-id="d063a-1592">Diese Methode gibt einen Puffer zurück, der die ersten Daten und die Anzahl der übertragenen Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1592">This method returns a buffer that contains the initial data and the number of bytes transferred.</span></span></summary>
        <returns><span data-ttu-id="d063a-1593">Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-1593">A <see cref="T:System.Net.Sockets.Socket" /> object to handle communication with the remote host.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> schließt einen-Aufrufvorgang ab <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1594"><xref:System.Net.Sockets.Socket.EndAccept%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginAccept%2A>.</span></span> <span data-ttu-id="d063a-1595">Vor <xref:System.Net.Sockets.Socket.BeginAccept%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die vom Delegaten aufgerufen wird <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1595">Before calling <xref:System.Net.Sockets.Socket.BeginAccept%2A>, you need to create a callback method that is invoked by the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1596">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem die- <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1596">This callback method executes in a separate thread, and is called by the system after the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method returns.</span></span> <span data-ttu-id="d063a-1597">Er muss den `asyncResult` von der-Methode zurückgegebenen Parameter akzeptieren <xref:System.Net.Sockets.Socket.BeginAccept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1597">It must accept the `asyncResult` parameter returned from the <xref:System.Net.Sockets.Socket.BeginAccept%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1598">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- `asyncResult` Parameters auf, um den zu erhalten, <xref:System.Net.Sockets.Socket> für den der Verbindungsversuch durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1598">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the `asyncResult` parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d063a-1599">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndAccept%2A> um den Verbindungsversuch erfolgreich abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1599">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndAccept%2A> method to successfully complete the connection attempt.</span></span> <span data-ttu-id="d063a-1600">Der `buffer` -Parameter dieser Überladung enthält die Daten, die im-Aufrufen von empfangen <xref:System.Net.Sockets.Socket.BeginAccept%2A> wurden, und der- `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im-Befehl übertragen wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1600">The `buffer` parameter of this overload contains the data that was received in the call to <xref:System.Net.Sockets.Socket.BeginAccept%2A> and the `bytesTransferred` parameter contains the number of bytes that were transferred in the call.</span></span>  
  
 <span data-ttu-id="d063a-1601">Die- <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode wird blockiert, bis eine Verbindung in der Warteschlange für eingehende Verbindungen aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1601">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method blocks until a connection is pending in the incoming connection queue.</span></span> <span data-ttu-id="d063a-1602">Die <xref:System.Net.Sockets.Socket.EndAccept%2A> -Methode akzeptiert die eingehende Verbindung und gibt eine neue zurück <xref:System.Net.Sockets.Socket> , die zum Senden von Daten an den Remote Host und zum Empfangen von Daten vom Remote Host verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-1602">The <xref:System.Net.Sockets.Socket.EndAccept%2A> method accepts the incoming connection and returns a new <xref:System.Net.Sockets.Socket> that can be used to send data to and receive data from the remote host.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1603">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1603">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1604">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1604">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1605">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1605">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1606">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1606">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1607">Im folgenden Codebeispiel wird verwendet <xref:System.Net.Sockets.Socket.BeginAccept%2A> , um einen Socket zu erstellen und zu verbinden und die anfänglichen 10 Bytes an Daten zu übernehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1607">The following code example uses <xref:System.Net.Sockets.Socket.BeginAccept%2A> to create and connect a socket and accept the initial 10 bytes of data.</span></span> <span data-ttu-id="d063a-1608">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> auf, um die asynchrone Anforderung zu beenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1608">The callback delegate calls <xref:System.Net.Sockets.Socket.EndAccept%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d063a-1609">Die Anzahl der übertragenen Bytes, und die Daten werden in den `buffer` -und- `bytesTransferred` Parametern dieser Methode zurückgegeben und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1609">The number of bytes transmitted and the data are returned in the `buffer` and `bytesTransferred` parameters of this method and are displayed on the console.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1610">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1610">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1611">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1611">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1612"><paramref name="asyncResult" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-1612"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1613"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1613"><paramref name="asyncResult" /> was not created by a call to <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1614">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1614"><see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" /> method was previously called.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1615">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1615">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1616">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1616">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1617">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1617">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1618">Beendet eine ausstehende asynchrone Verbindungsanforderung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1618">Ends a pending asynchronous connection request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> ist eine blockierende Methode, die die asynchrone Remote Host-Verbindungsanforderung abschließt, die in der-Methode gestartet wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1619"><xref:System.Net.Sockets.Socket.EndConnect%2A> is a blocking method that completes the asynchronous remote host connection request started in the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1620">Vor <xref:System.Net.Sockets.Socket.BeginConnect%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1620">Before calling <xref:System.Net.Sockets.Socket.BeginConnect%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1621">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginConnect%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1621">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginConnect%2A> returns.</span></span> <span data-ttu-id="d063a-1622">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginConnect%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1622">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginConnect%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1623">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Parameters auf, um den zu erhalten, <xref:System.Net.Sockets.Socket> für den der Verbindungsversuch durchgeführt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1623">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the <xref:System.Net.Sockets.Socket> on which the connection attempt is being made.</span></span> <span data-ttu-id="d063a-1624">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndConnect%2A> um den Verbindungsversuch erfolgreich abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1624">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndConnect%2A> method to successfully complete the connection attempt.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1625">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1625">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1626">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1626">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1627">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1627">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1628">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1628">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1629">Im folgenden Codebeispiel wird der asynchrone Verbindungsversuch beendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1629">The following code example ends the asynchronous connection attempt.</span></span> <span data-ttu-id="d063a-1630">Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](/dotnet/framework/network-programming/socket-code-examples).</span><span class="sxs-lookup"><span data-stu-id="d063a-1630">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](/dotnet/framework/network-programming/socket-code-examples).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1631"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1631"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1632"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1632"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1633"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1634">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1634">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1635">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1635">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1636">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1636">An <see cref="T:System.IAsyncResult" /> object that stores state information and any user-defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1637">Beendet eine ausstehende asynchrone Anforderung zur Trennung der Verbindung.</span><span class="sxs-lookup"><span data-stu-id="d063a-1637">Ends a pending asynchronous disconnect request.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> schließt einen-Aufrufvorgang ab <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1638"><xref:System.Net.Sockets.Socket.EndDisconnect%2A> completes a call to <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>.</span></span> <span data-ttu-id="d063a-1639">Die- <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode wird blockiert, bis die Trennung abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1639">The <xref:System.Net.Sockets.Socket.EndDisconnect%2A> method blocks until the disconnect completes.</span></span> <span data-ttu-id="d063a-1640">Weitere Informationen zu asynchronen Vorgängen finden Sie im Thema "Übersicht über die asynchrone Programmierung" in der MSDN Library.</span><span class="sxs-lookup"><span data-stu-id="d063a-1640">For information about asynchronous operations, see the Asynchronous Programming Overview topic in the MSDN library.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1641">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1641">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1642">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1642">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1643">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1643">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1644">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1644">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1645">Das folgende Codebeispiel erstellt einen Socket für die asynchrone Kommunikation und sendet einige Daten an einen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-1645">The following code example creates a socket for asynchronous communication and sends some data to a remote host.</span></span> <span data-ttu-id="d063a-1646">Wenn die Daten gesendet wurden, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um die Sende-und Empfangs Aktivität anzuhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1646">When the data has been sent, <xref:System.Net.Sockets.Socket.Shutdown%2A> is called to stop the send and receive activity.</span></span> <span data-ttu-id="d063a-1647">Anschließend <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Disconnect-Anforderung zu starten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1647">Then <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> is called to begin a disconnect request.</span></span> <span data-ttu-id="d063a-1648">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndDisconnect%2A> auf, um die asynchrone Anforderung zu beenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1648">The callback delegate calls <xref:System.Net.Sockets.Socket.EndDisconnect%2A> to end the asynchronous request.</span></span> <span data-ttu-id="d063a-1649">Wenn die Anforderung abgeschlossen ist, <xref:System.Net.Sockets.Socket.Connected%2A> wird die-Eigenschaft abgefragt, um zu testen, ob der Socket getrennt ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1649">When the request completes, the <xref:System.Net.Sockets.Socket.Connected%2A> property is queried to test whether the socket is disconnected.</span></span>  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1650">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1650">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1651"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1651"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1652"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1652"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1653"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1653"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> was previously called for the asynchronous connection.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1654">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1654">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.Net.WebException"><span data-ttu-id="d063a-1655">Das Timeout der Anforderung zum Trennen der Verbindung wurde überschritten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1655">The disconnect request has timed out.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1656">Beendet einen ausstehenden asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1656">Ends a pending asynchronous read.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1657">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1657">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1658">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1658">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1659">Beendet einen ausstehenden asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1659">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="d063a-1660">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1660">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1661">Die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode beendet den asynchronen Lesevorgang, der in der-Methode gestartet wurde <xref:System.Net.Sockets.Socket.BeginReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1661">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1662">Vor <xref:System.Net.Sockets.Socket.BeginReceive%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1662">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1663">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1663">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d063a-1664">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginReceive%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1664">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1665">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Objekts auf, um das an die-Methode über gegebene Zustands Objekt abzurufen <xref:System.Net.Sockets.Socket.BeginReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1665">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d063a-1666">Extrahieren Sie den empfangenden <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1666">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d063a-1667">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndReceive%2A> um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1667">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d063a-1668">Die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode wird blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1668">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-1669">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndReceive%2A> liest das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1669">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d063a-1670">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im- `size` Parameter der- <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode angegeben haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1670">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d063a-1671">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1671">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-1672">Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A> -Methode des <xref:System.IAsyncResult> -Objekts auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1672">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
 <span data-ttu-id="d063a-1673">Um einen ausstehenden abzubrechen <xref:System.Net.Sockets.Socket.BeginReceive%2A> , rufen Sie die- <xref:System.Net.Sockets.Socket.Close%2A> Methode auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-1673">To cancel a pending <xref:System.Net.Sockets.Socket.BeginReceive%2A>, call the <xref:System.Net.Sockets.Socket.Close%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1674">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1674">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1675">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1675">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1676">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1676">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-1677">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1677">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1678">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1678">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1679">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1679">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1680">Das folgende Codebeispiel beendet einen ausstehenden asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1680">The following code example ends a pending asynchronous read.</span></span> <span data-ttu-id="d063a-1681">Ein umfassendes Beispiel, in dem die asynchrone Kommunikation mit Sockets veranschaulicht wird, finden Sie unter [Beispiele für Socket-Code](/dotnet/framework/network-programming/socket-code-examples).</span><span class="sxs-lookup"><span data-stu-id="d063a-1681">For a complete example that demonstrates asynchronous communications with sockets, see [Socket Code Examples](/dotnet/framework/network-programming/socket-code-examples).</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1682"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1682"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1683"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1683"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1684"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1684"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1685">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1685">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1686">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1686">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * SocketError -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1687">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1687">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-1688">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1688">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-1689">Beendet einen ausstehenden asynchronen Lesevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1689">Ends a pending asynchronous read.</span></span></summary>
        <returns><span data-ttu-id="d063a-1690">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1690">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1691">Die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode beendet den asynchronen Lesevorgang, der in der-Methode gestartet wurde <xref:System.Net.Sockets.Socket.BeginReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1691">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1692">Vor <xref:System.Net.Sockets.Socket.BeginReceive%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1692">Before calling <xref:System.Net.Sockets.Socket.BeginReceive%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1693">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1693">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d063a-1694">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginReceive%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1694">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1695">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Objekts auf, um das an die-Methode über gegebene Zustands Objekt abzurufen <xref:System.Net.Sockets.Socket.BeginReceive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1695">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d063a-1696">Extrahieren Sie den empfangenden <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1696">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d063a-1697">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndReceive%2A> um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1697">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceive%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d063a-1698">Die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode wird blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1698">The <xref:System.Net.Sockets.Socket.EndReceive%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-1699">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndReceive%2A> liest das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1699">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceive%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d063a-1700">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die- <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im- `size` Parameter der- <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode angegeben haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1700">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceive%2A> method.</span></span> <span data-ttu-id="d063a-1701">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1701">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-1702">Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A> -Methode des <xref:System.IAsyncResult> -Objekts auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1702">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult>, and extract the buffer contained in the resulting state object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1703">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1703">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1704">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1704">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1705">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1705">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-1706">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1706">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1707">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1707">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1708">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1708">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1709"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1709"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1710"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1710"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1711"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1711"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1712">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1712">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1713">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1713">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (asyncResult, endPoint)" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult * EndPoint -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1714">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1714">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1715">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1715">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="endPoint"><span data-ttu-id="d063a-1716">Der Quell-<see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1716">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="end_point"><span data-ttu-id="d063a-1717">Der Quell-<see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1717">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <summary><span data-ttu-id="d063a-1718">Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1718">Ends a pending asynchronous read from a specific endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-1719">Wenn erfolgreich, die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1719">If successful, the number of bytes received.</span></span> <span data-ttu-id="d063a-1720">Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1720">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1721">Die- <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode beendet den asynchronen Lesevorgang, der in der-Methode gestartet wurde <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1721">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method completes the asynchronous read operation started in the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1722">Vor <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1722">Before calling <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1723">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1723">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> returns.</span></span> <span data-ttu-id="d063a-1724">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1724">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1725">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Objekts auf, um das an die-Methode über gegebene Zustands Objekt abzurufen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1725">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> to obtain the state object passed to the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-1726">Extrahieren Sie den empfangenden <xref:System.Net.Sockets.Socket> aus diesem Zustands Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1726">Extract the receiving <xref:System.Net.Sockets.Socket> from this state object.</span></span> <span data-ttu-id="d063a-1727">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> um den Lesevorgang erfolgreich abzuschließen und die Anzahl der gelesenen Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1727">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method to successfully complete the read operation and return the number of bytes read.</span></span>  
  
 <span data-ttu-id="d063a-1728">Die- <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode wird blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1728">The <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-1729">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das im eingehenden Netzwerk Puffer verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1729">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> will read the first enqueued datagram available in the incoming network buffer.</span></span> <span data-ttu-id="d063a-1730">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, liest die- <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode so viele Daten, wie Sie bis zur Anzahl der Bytes verfügbar sind, die Sie im- `size` Parameter der- <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode angegeben haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1730">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will read as much data as is available up to the number of bytes you specified in the `size` parameter of the <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-1731">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1731">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span> <span data-ttu-id="d063a-1732">Rufen Sie zum Abrufen der empfangenen Daten die <xref:System.IAsyncResult.AsyncState%2A> -Methode des <xref:System.IAsyncResult> -Objekts auf, und extrahieren Sie den Puffer, der im resultierenden State-Objekt enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1732">To obtain the received data, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> object, and extract the buffer contained in the resulting state object.</span></span> <span data-ttu-id="d063a-1733">Um den Ursprungs Host zu identifizieren, extrahieren <xref:System.Net.EndPoint> Sie den, und wandeln Sie ihn in einen um <xref:System.Net.IPEndPoint> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1733">To identify the originating host, extract the <xref:System.Net.EndPoint> and cast it to an <xref:System.Net.IPEndPoint>.</span></span> <span data-ttu-id="d063a-1734">Verwenden <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Sie die-Methode, um die IP-Adresse und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode zum Abrufen der Portnummer abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1734">Use the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to obtain the IP address and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to obtain the port number.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1735">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1735">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1736">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1736">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1737">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1737">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1738">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1738">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1739">Das folgende Codebeispiel beendet einen ausstehenden asynchronen Lesevorgang aus einem bestimmten <xref:System.Net.EndPoint> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1739">The following code example ends a pending asynchronous read from a specific <xref:System.Net.EndPoint>.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1740"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1740"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1741"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1741"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1742"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1742"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1743">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1743">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1744">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1744">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1745">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1745">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-1746">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte für das empfangene Paket.</span><span class="sxs-lookup"><span data-stu-id="d063a-1746">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values for the received packet.</span></span></param>
        <param name="endPoint"><span data-ttu-id="d063a-1747">Der Quell-<see cref="T:System.Net.EndPoint" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1747">The source <see cref="T:System.Net.EndPoint" />.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="d063a-1748">Die <see cref="T:System.Net.IPAddress" /> und die Schnittstelle des empfangenen Pakets.</span><span class="sxs-lookup"><span data-stu-id="d063a-1748">The <see cref="T:System.Net.IPAddress" /> and interface of the received packet.</span></span></param>
        <summary><span data-ttu-id="d063a-1749">Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1749">Ends a pending asynchronous read from a specific endpoint.</span></span> <span data-ttu-id="d063a-1750">Diese Methode stellt außerdem mehr Informationen über das Paket als <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> bereit.</span><span class="sxs-lookup"><span data-stu-id="d063a-1750">This method also reveals more information about the packet than <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-1751">Wenn erfolgreich, die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1751">If successful, the number of bytes received.</span></span> <span data-ttu-id="d063a-1752">Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1752">If unsuccessful, returns 0.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1753">Wenn der Vorgang nicht abgeschlossen wurde, wird diese Methode blockiert, bis dies erfolgt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1753">If the operation has not completed, this method blocks until it does.</span></span>  
  
 <span data-ttu-id="d063a-1754">Verwenden Sie die-Methode, um diesen Vorgang synchron auszuführen <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1754">To perform this operation synchronously, use the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-1755">`ipPacketInformation`Überprüfen Sie, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1755">Examine `ipPacketInformation` if you need to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1756"><paramref name="asyncResult" /> ist gleich <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1756"><paramref name="asyncResult" /> is <see langword="null" /></span></span>  
  
<span data-ttu-id="d063a-1757">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1757">-or-</span></span> 
 <span data-ttu-id="d063a-1758"><paramref name="endPoint" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1758"><paramref name="endPoint" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1759"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1759"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1760"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1760"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> was previously called for the asynchronous read.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1761">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1761">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1762">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1762">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1763">Beendet einen ausstehenden asynchronen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1763">Ends a pending asynchronous send.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1764">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1764">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1765">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1765">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1766">Beendet einen ausstehenden asynchronen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1766">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="d063a-1767">Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1767">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1768"><xref:System.Net.Sockets.Socket.EndSend%2A> schließt den asynchronen Sendevorgang ab, der in gestartet wurde <xref:System.Net.Sockets.Socket.BeginSend%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1768"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="d063a-1769">Vor <xref:System.Net.Sockets.Socket.BeginSend%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1769">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1770">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1770">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="d063a-1771">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginSend%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1771">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1772">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Parameters auf, um das Senden zu erhalten <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1772">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1773">Nachdem Sie die <xref:System.Net.Sockets.Socket> -Methode erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSend%2A> -Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1773">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d063a-1774">Wenn Sie ein verbindungsloses Protokoll verwenden, wird von <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1774">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-1775">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndSend%2A> wird von blockiert, bis ein Teil des Puffers gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1775">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="d063a-1776">Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> angibt, dass der Puffer nicht vollständig gesendet wurde, wird die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode erneut aufgerufen, und der Puffer wird so geändert, dass die nicht gesendeten Daten enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1776">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="d063a-1777">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1777">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-1778">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1778">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-1779">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1779">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1780">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1780">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1781">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1781">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1782">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1782">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-1783">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1783">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1784">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1784">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-1785">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1785">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1786">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1786">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1787">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1787">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1788">Das folgende Codebeispiel beendet einen ausstehenden asynchronen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1788">The following code example ends a pending asynchronous send.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1789"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1789"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1790"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1790"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1791"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1791"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1792">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1792">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1793">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1793">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult * SocketError -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1794">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1794">An <see cref="T:System.IAsyncResult" /> that stores state information for this asynchronous operation.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-1795">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1795">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-1796">Beendet einen ausstehenden asynchronen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-1796">Ends a pending asynchronous send.</span></span></summary>
        <returns><span data-ttu-id="d063a-1797">Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1797">If successful, the number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1798"><xref:System.Net.Sockets.Socket.EndSend%2A> schließt den asynchronen Sendevorgang ab, der in gestartet wurde <xref:System.Net.Sockets.Socket.BeginSend%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1798"><xref:System.Net.Sockets.Socket.EndSend%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSend%2A>.</span></span>  
  
 <span data-ttu-id="d063a-1799">Vor <xref:System.Net.Sockets.Socket.BeginSend%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1799">Before calling <xref:System.Net.Sockets.Socket.BeginSend%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1800">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1800">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSend%2A> returns.</span></span> <span data-ttu-id="d063a-1801">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginSend%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1801">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSend%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1802">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Parameters auf, um das Senden zu erhalten <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1802">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1803">Nachdem Sie die <xref:System.Net.Sockets.Socket> -Methode erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSend%2A> -Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1803">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSend%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d063a-1804">Wenn Sie ein verbindungsloses Protokoll verwenden, wird von <xref:System.Net.Sockets.Socket.EndSend%2A> blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1804">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-1805">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndSend%2A> wird von blockiert, bis ein Teil des Puffers gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1805">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSend%2A> will block until some of the buffer was sent.</span></span> <span data-ttu-id="d063a-1806">Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> angibt, dass der Puffer nicht vollständig gesendet wurde, wird die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode erneut aufgerufen, und der Puffer wird so geändert, dass die nicht gesendeten Daten enthalten sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-1806">If the return value from <xref:System.Net.Sockets.Socket.EndSend%2A> indicates that the buffer was not completely sent, call the <xref:System.Net.Sockets.Socket.BeginSend%2A> method again, modifying the buffer to hold the unsent data.</span></span>  
  
 <span data-ttu-id="d063a-1807">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1807">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-1808">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1808">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-1809">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1809">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSend%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1810">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1810">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1811">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1811">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1812">Alle e/a-Vorgänge, die von einem bestimmten Thread initiiert werden, werden beim Beenden des Threads abgebrochen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1812">All I/O initiated by a given thread is canceled when that thread exits.</span></span> <span data-ttu-id="d063a-1813">Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1813">A pending asynchronous operation can fail if the thread exits before the operation completes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1814">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1814">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-1815">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1815">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1816">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1816">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1817">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1817">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1818"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1818"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1819"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1819"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1820"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1820"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1821">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1821">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1822">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1822">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1823">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformation für den asynchronen Vorgang speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1823">An <see cref="T:System.IAsyncResult" /> object that stores state information for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1824">Beendet ein ausstehendes asynchrones Senden einer Datei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1824">Ends a pending asynchronous send of a file.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1825"><xref:System.Net.Sockets.Socket.EndSendFile%2A> schließt den asynchronen Sendevorgang ab, der in gestartet wurde <xref:System.Net.Sockets.Socket.BeginSendFile%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1825"><xref:System.Net.Sockets.Socket.EndSendFile%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.</span></span>  
  
 <span data-ttu-id="d063a-1826">Vor dem Aufrufen von <xref:System.Net.Sockets.Socket.BeginSendFile%2A> müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1826">Before calling <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, you must create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1827">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1827">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginSendFile%2A> returns.</span></span> <span data-ttu-id="d063a-1828">Die Rückruf Methode muss das <xref:System.IAsyncResult> von der-Methode zurückgegebene-Objekt <xref:System.Net.Sockets.Socket.BeginSendFile%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1828">The callback method must accept the <xref:System.IAsyncResult> object returned by the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1829">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Parameters auf, um das Senden zu erhalten <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1829">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1830">Nachdem Sie den erhalten <xref:System.Net.Sockets.Socket> haben, können Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.EndSendFile%2A> um den Sendevorgang erfolgreich abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1830">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendFile%2A> method to successfully complete the send operation.</span></span>  
  
 <span data-ttu-id="d063a-1831">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndSendFile%2A> wird blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1831">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the datagram is sent.</span></span> <span data-ttu-id="d063a-1832">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndSendFile%2A> wird blockiert, bis die gesamte Datei gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1832">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="d063a-1833">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1833">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-1834">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1834">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-1835">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1835">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1836">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1836">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1837">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1837">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1838">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1838">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1839">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1839">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1840">Im folgenden Codebeispiel wird ein Socket für asynchrone Kommunikation erstellt und verknüpft und die Datei "text.txt" asynchron an den Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1840">The following code example creates and connects a socket for asynchronous communication and begins sending the file "text.txt" asynchronously to the remote host.</span></span> <span data-ttu-id="d063a-1841">Der Rückruf Delegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> auf, um die Übertragung abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1841">The callback delegate calls <xref:System.Net.Sockets.Socket.EndSendFile%2A> to complete the transmission.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-1842">Für diese Methode ist Windows NT erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-1842">Windows NT is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1843">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1843">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1844"><paramref name="asyncResult" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-1844"><paramref name="asyncResult" /> is empty.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1845"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1845"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1846"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> wurde bereits für das asynchrone <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1846"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> was previously called for the asynchronous <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1847">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1847">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-1848">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-1848">See remarks section below.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo asyncResult" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult"><span data-ttu-id="d063a-1849">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1849">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <param name="result"><span data-ttu-id="d063a-1850">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1850">An <see cref="T:System.IAsyncResult" /> that stores state information and any user defined data for this asynchronous operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1851">Beendet einen ausstehenden asynchronen Sendevorgang an einen bestimmten Zielort.</span><span class="sxs-lookup"><span data-stu-id="d063a-1851">Ends a pending asynchronous send to a specific location.</span></span></summary>
        <returns><span data-ttu-id="d063a-1852">Wenn erfolgreich, die Anzahl der gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1852">If successful, the number of bytes sent; otherwise, an invalid <see cref="T:System.Net.Sockets.Socket" /> error.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1853"><xref:System.Net.Sockets.Socket.EndSendTo%2A> schließt den asynchronen Sendevorgang ab, der in gestartet wurde <xref:System.Net.Sockets.Socket.BeginSendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1853"><xref:System.Net.Sockets.Socket.EndSendTo%2A> completes the asynchronous send operation started in <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.</span></span>  
  
 <span data-ttu-id="d063a-1854">Vor <xref:System.Net.Sockets.Socket.BeginSendTo%2A> dem Aufrufen von müssen Sie eine Rückruf Methode erstellen, die den-Delegaten implementiert <xref:System.AsyncCallback> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1854">Before calling <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, you need to create a callback method that implements the <xref:System.AsyncCallback> delegate.</span></span> <span data-ttu-id="d063a-1855">Diese Rückruf Methode wird in einem separaten Thread ausgeführt und vom System aufgerufen, nachdem <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-1855">This callback method executes in a separate thread and is called by the system after <xref:System.Net.Sockets.Socket.BeginReceive%2A> returns.</span></span> <span data-ttu-id="d063a-1856">Die Rückruf Methode muss die <xref:System.IAsyncResult> von der-Methode zurückgegebene <xref:System.Net.Sockets.Socket.BeginSendTo%2A> als Parameter akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1856">The callback method must accept the <xref:System.IAsyncResult> returned by the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method as a parameter.</span></span>  
  
 <span data-ttu-id="d063a-1857">Rufen Sie innerhalb der Rückruf Methode die- <xref:System.IAsyncResult.AsyncState%2A> Methode des- <xref:System.IAsyncResult> Parameters auf, um das Senden zu erhalten <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1857">Within the callback method, call the <xref:System.IAsyncResult.AsyncState%2A> method of the <xref:System.IAsyncResult> parameter to obtain the sending <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1858">Nachdem Sie die <xref:System.Net.Sockets.Socket> -Methode erhalten haben, können Sie die <xref:System.Net.Sockets.Socket.EndSendTo%2A> -Methode aufrufen, um den Sendevorgang erfolgreich abzuschließen und die Anzahl der gesendeten Bytes zurückzugeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1858">After obtaining the <xref:System.Net.Sockets.Socket>, you can call the <xref:System.Net.Sockets.Socket.EndSendTo%2A> method to successfully complete the send operation and return the number of bytes sent.</span></span>  
  
 <span data-ttu-id="d063a-1859">Wenn Sie ein verbindungsloses Protokoll verwenden, wird von <xref:System.Net.Sockets.Socket.EndSendTo%2A> blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1859">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-1860">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.EndSendTo%2A> wird von blockiert, bis die angeforderte Anzahl von Bytes gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1860">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.EndSendTo%2A> will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d063a-1861">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1861">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-1862">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1862">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-1863">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1863">A successful completion of the <xref:System.Net.Sockets.Socket.BeginSendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1864">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1864">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1865">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1865">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1866">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1866">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1867">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1867">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1868">Im folgenden Codebeispiel wird ein asynchroner Sendevorgang an eine bestimmte Position beendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-1868">The following code example ends an asynchronous send to a specific location.</span></span>  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-1869"><paramref name="asyncResult" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1869"><paramref name="asyncResult" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-1870"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-1870"><paramref name="asyncResult" /> was not returned by a call to the <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" /> method.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1871"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1871"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> was previously called for the asynchronous send.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1872">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1872">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1873">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1873">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1874">Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Prozesses an einen Anschluss zulässt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1874">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> allows only one process to bind to a port.</span></span></summary>
        <value><span data-ttu-id="d063a-1875"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Sockets an einen bestimmten Anschluss zulässt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1875"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> allows only one socket to bind to a specific port; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-1876">Der Standardwert ist <see langword="true" /> für Windows Server 2003 und Windows XP Service Pack 2 und <see langword="false" /> für alle anderen Versionen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1876">The default is <see langword="true" /> for Windows Server 2003 and Windows XP Service Pack 2, and <see langword="false" /> for all other versions.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1877">Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `false` den Wert hat, können mehrere Sockets die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode verwenden, um eine Bindung an einen bestimmten Port herzustellen. Allerdings kann nur eine der Sockets Vorgänge für den Netzwerk Datenverkehr ausführen, der an den Port gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1877">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `false`, multiple sockets can use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a specific port; however only one of the sockets can perform operations on the network traffic sent to the port.</span></span> <span data-ttu-id="d063a-1878">Wenn mehr als ein Socket versucht, die <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> Methode für die Bindung an einen bestimmten Port zu verwenden, wird der Netzwerkverkehr, der mit der spezifischeren IP-Adresse verbunden ist, mit dem an diesen Port gesendeten Netzwerkverkehr behandelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1878">If more than one socket attempts to use the <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> method to bind to a particular port, then the one with the more specific IP address will handle the network traffic sent to that port.</span></span>  
  
 <span data-ttu-id="d063a-1879">Wenn den Wert <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> `true` hat, wird die erste Verwendung der <xref:System.Net.Sockets.Socket.Bind%2A> -Methode versucht, eine Bindung an einen bestimmten Port herzustellen, unabhängig von der IP-Adresse (Internet Protocol). alle nachfolgenden Verwendungen der-Methode, um eine <xref:System.Net.Sockets.Socket.Bind%2A> Bindung an diesen Port herzustellen, schlagen fehl, bis der ursprüngliche gebundene Socket zerstört wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-1879">If <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> is `true`, the first use of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to a particular port, regardless of Internet Protocol (IP) address, will succeed; all subsequent uses of the <xref:System.Net.Sockets.Socket.Bind%2A> method to attempt to bind to that port will fail until the original bound socket is destroyed.</span></span>  
  
 <span data-ttu-id="d063a-1880">Diese Eigenschaft muss festgelegt werden <xref:System.Net.Sockets.Socket.Bind%2A> , bevor aufgerufen wird. andernfalls wird eine ausgelöst <xref:System.InvalidOperationException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1880">This property must be set before <xref:System.Net.Sockets.Socket.Bind%2A> is called; otherwise an <xref:System.InvalidOperationException> will be thrown.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1881">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1881">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1882">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1882">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1883">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1883">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1884">Für diesen <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> wurde <see cref="T:System.Net.Sockets.Socket" /> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1884"><see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> has been called for this <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-1885">Gibt von der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendete Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-1885">Frees resources used by the <see cref="T:System.Net.Sockets.Socket" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1886">Der <xref:System.Net.Sockets.Socket> Klassen-Finalizer Ruft die <xref:System.Net.Sockets.Socket.Close%2A> -Methode auf, um die <xref:System.Net.Sockets.Socket> -und-Ressourcen, die zugeordnet sind, zu schließen <xref:System.Net.Sockets.Socket></span><span class="sxs-lookup"><span data-stu-id="d063a-1886">The <xref:System.Net.Sockets.Socket> class finalizer calls the <xref:System.Net.Sockets.Socket.Close%2A> method to close the <xref:System.Net.Sockets.Socket> and free resources associated with the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-1887">Gibt einen Hashwert für eine <see cref="T:System.Net.Sockets.Socket" />-Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1887">Returns a hash value for a <see cref="T:System.Net.Sockets.Socket" /> instance.</span></span></summary>
        <returns><span data-ttu-id="d063a-1888">Ein ganzzahliger Hashwert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1888">An integer hash value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="d063a-1889">Die GetHashCode-Methode gibt einen Hashcode für diese Instanz zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1889">The GetHashCode method returns a hash code of this instance.</span></span> <span data-ttu-id="d063a-1890">Dieser Wert kann als Schlüssel in Hash Tabellen verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1890">This value can be used as a key in hash tables.</span></span>

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetRawSocketOption">
      <MemberSignature Language="C#" Value="public int GetRawSocketOption (int optionLevel, int optionName, Span&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.Span`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function GetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetRawSocketOption(int optionLevel, int optionName, Span&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetRawSocketOption : int * int * Span&lt;byte&gt; -&gt; int" Usage="socket.GetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.Span&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-1891">Die von der Plattform definierte Optionsebene.</span><span class="sxs-lookup"><span data-stu-id="d063a-1891">The platform-defined option level.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-1892">Der von der Plattform definierte Optionsname.</span><span class="sxs-lookup"><span data-stu-id="d063a-1892">The platform-defined option name.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-1893">Die Spanne, in der der abgerufene Optionswert gespeichert werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1893">The span into which the retrieved option value should be stored.</span></span></param>
        <summary><span data-ttu-id="d063a-1894">Ruft einen Socketoptionswert unter Verwendung plattformspezifischer Ebenen- und Namensbezeichner ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-1894">Gets a socket option value using platform-specific level and name identifiers.</span></span></summary>
        <returns><span data-ttu-id="d063a-1895">Die Anzahl der in <paramref name="optionValue" /> geschriebenen Bytes für einen erfolgreich abgerufenen Wert.</span><span class="sxs-lookup"><span data-stu-id="d063a-1895">The number of bytes written into <paramref name="optionValue" /> for a successfully retrieved value.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d063a-1896">Im Allgemeinen sollte die- `GetSocketOption` Methode immer dann verwendet werden, wenn eine-Option verwendet wird <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1896">In general, the `GetSocketOption` method should be used whenever getting a <xref:System.Net.Sockets.Socket> option.</span></span>

<span data-ttu-id="d063a-1897"><xref:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})> die-Methode sollte nur verwendet werden, wenn <xref:System.Net.Sockets.SocketOptionLevel> und <xref:System.Net.Sockets.SocketOptionName> die erforderliche Option nicht verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1897"><xref:System.Net.Sockets.Socket.GetRawSocketOption(System.Int32,System.Int32,System.Span{System.Byte})> method should be used only when <xref:System.Net.Sockets.SocketOptionLevel> and <xref:System.Net.Sockets.SocketOptionName> do not expose the required option.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1898">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1898">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1899">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1899">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1900">Gibt den Wert einer <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1900">Returns the value of a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-1901">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1901">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-1902">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1902">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-1903">Gibt den Wert einer angegebenen, als Objekt dargestellten <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1903">Returns the value of a specified <see cref="T:System.Net.Sockets.Socket" /> option, represented as an object.</span></span></summary>
        <returns><span data-ttu-id="d063a-1904">Ein Objekt, das den Wert der Option darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1904">An object that represents the value of the option.</span></span> <span data-ttu-id="d063a-1905">Wenn der <paramref name="optionName" />-Parameter auf <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.LingerOption" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-1905">When the <paramref name="optionName" /> parameter is set to <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> the return value is an instance of the <see cref="T:System.Net.Sockets.LingerOption" /> class.</span></span> <span data-ttu-id="d063a-1906">Wenn <paramref name="optionName" /> auf <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> oder <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.MulticastOption" />-Klasse.</span><span class="sxs-lookup"><span data-stu-id="d063a-1906">When <paramref name="optionName" /> is set to <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> or <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" />, the return value is an instance of the <see cref="T:System.Net.Sockets.MulticastOption" /> class.</span></span> <span data-ttu-id="d063a-1907">Wenn <paramref name="optionName" /> einen anderen Wert hat, ist der Rückgabewert eine ganze Zahl.</span><span class="sxs-lookup"><span data-stu-id="d063a-1907">When <paramref name="optionName" /> is any other value, the return value is an integer.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1908"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1908"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1909">Verwenden Sie diese Überladung, um die <xref:System.Net.Sockets.SocketOptionName.Linger> Optionen, und zu erhalten <xref:System.Net.Sockets.SocketOptionName.AddMembership> <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1909">Use this overload to get the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="d063a-1910">Verwenden Sie für die- <xref:System.Net.Sockets.SocketOptionName.Linger> Option <xref:System.Net.Sockets.Socket> für den- `optionLevel` Parameter.</span><span class="sxs-lookup"><span data-stu-id="d063a-1910">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d063a-1911">Verwenden Sie für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.SocketOptionLevel.IP> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1911">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="d063a-1912">Wenn Sie den Wert einer der oben aufgeführten Optionen festlegen möchten, verwenden Sie die- <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-1912">If you want to set the value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1913">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1913">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1914">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1914">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1915">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1915">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1916">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1916">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1917">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und abgerufen <xref:System.Net.Sockets.Socket.Send%2A> und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1917">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1918">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1918">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="d063a-1919">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1919">-or-</span></span> 
 <span data-ttu-id="d063a-1920"><paramref name="optionName" /> wurde auf den nicht unterstützten Wert <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1920"><paramref name="optionName" /> was set to the unsupported value <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1921">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1921">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-1922">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1922">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-1923">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1923">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-1924">Ein Array vom Typ <see cref="T:System.Byte" />, das die Optionseinstellung erhalten soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1924">An array of type <see cref="T:System.Byte" /> that is to receive the option setting.</span></span></param>
        <summary><span data-ttu-id="d063a-1925">Gibt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Optionseinstellung als Bytearray dargestellt zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1925">Returns the specified <see cref="T:System.Net.Sockets.Socket" /> option setting, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1926"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1926"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-1927">Nach erfolgreichem Abschluss dieser Methode enthält das durch den-Parameter angegebene Array `optionValue` den Wert der angegebenen <xref:System.Net.Sockets.Socket> Option.</span><span class="sxs-lookup"><span data-stu-id="d063a-1927">Upon successful completion of this method, the array specified by the `optionValue` parameter contains the value of the specified <xref:System.Net.Sockets.Socket> option.</span></span>  
  
 <span data-ttu-id="d063a-1928">Wenn die Länge des `optionValue` Arrays kleiner ist als die Anzahl der Bytes, die zum Speichern des Werts der angegebenen <xref:System.Net.Sockets.Socket> Option erforderlich sind, löst eine aus <xref:System.Net.Sockets.Socket.GetSocketOption%2A> <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1928">When the length of the `optionValue` array is smaller than the number of bytes required to store the value of the specified <xref:System.Net.Sockets.Socket> option, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1929">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1929">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1930">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1930">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-1931">Verwenden Sie diese Überladung für alle Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1931">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1932">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1932">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1933">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1933">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1934">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und abgerufen <xref:System.Net.Sockets.Socket.Send%2A> und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1934">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1935">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1935">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="d063a-1936">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1936">-or-</span></span> 
<span data-ttu-id="d063a-1937">In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1937">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="d063a-1938">Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1938">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1939">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1939">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionLength" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-1940">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1940">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-1941">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-1941">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionLength"><span data-ttu-id="d063a-1942">Die Länge des erwarteten Rückgabewerts in Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1942">The length, in bytes, of the expected return value.</span></span></param>
        <summary><span data-ttu-id="d063a-1943">Gibt den Wert der angegebenen <see cref="T:System.Net.Sockets.Socket" />-Option in einem Array zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-1943">Returns the value of the specified <see cref="T:System.Net.Sockets.Socket" /> option in an array.</span></span></summary>
        <returns><span data-ttu-id="d063a-1944">Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Socketoption enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1944">An array of type <see cref="T:System.Byte" /> that contains the value of the socket option.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1945">Der- `optionLength` Parameter legt die maximale Größe des zurückgegebenen Bytearrays fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1945">The `optionLength` parameter sets the maximum size of the returned byte array.</span></span> <span data-ttu-id="d063a-1946">Wenn der Optionswert weniger Bytes erfordert, enthält das Array nur die Anzahl der Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-1946">If the option value requires fewer bytes, the array will contain only that many bytes.</span></span> <span data-ttu-id="d063a-1947">Wenn für den Optionswert mehr Bytes erforderlich sind, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> wird von eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1947">If the option value requires more bytes, <xref:System.Net.Sockets.Socket.GetSocketOption%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-1948">Verwenden Sie diese Überladung für alle Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-1948">Use this overload for any sockets that are represented by Boolean values or integers.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1949">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1949">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1950">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1950">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1951">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1951">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1952">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1952">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1953">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und abgerufen <xref:System.Net.Sockets.Socket.Send%2A> und in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1953">The following code example retrieves the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values and displays them to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1954">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1954">An error occurred when attempting to access the socket.</span></span>  
  
<span data-ttu-id="d063a-1955">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-1955">-or-</span></span> 
<span data-ttu-id="d063a-1956">In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1956">In .NET Compact Framework applications, the Windows CE default buffer space is set to 32768 bytes.</span></span> <span data-ttu-id="d063a-1957">Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1957">You can change the per socket buffer space by calling <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1958">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1958">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1959">Ruft das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-1959">Gets the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-1960">Ein <see cref="T:System.IntPtr" />, der das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1960">An <see cref="T:System.IntPtr" /> that represents the operating system handle for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-1961">Legt Betriebsmodi auf niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1961">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="d063a-1962">Ein <see cref="T:System.Int32" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1962">An <see cref="T:System.Int32" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="d063a-1963">Ein <see cref="T:System.Byte" />-Array, das die für den Vorgang erforderlichen Eingabedaten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1963">A <see cref="T:System.Byte" /> array that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="d063a-1964">Ein <see cref="T:System.Byte" />-Array, das die durch den Vorgang zurückgegebenen Ausgabedaten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1964">A <see cref="T:System.Byte" /> array that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1965">Legt mit numerischen Steuerungscodes die Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1965">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using numerical control codes.</span></span></summary>
        <returns><span data-ttu-id="d063a-1966">Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</span><span class="sxs-lookup"><span data-stu-id="d063a-1966">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1967">Die <xref:System.Net.Sockets.Socket.IOControl%2A> -Methode bietet Zugriff auf niedriger Ebene auf das Betriebssystem, <xref:System.Net.Sockets.Socket> das der aktuellen Instanz der-Klasse zugrunde liegt <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1967">The <xref:System.Net.Sockets.Socket.IOControl%2A> method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="d063a-1968">Weitere Informationen finden Sie in der [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) -Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="d063a-1968">For more information, see the [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1969">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1969">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1970">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1970">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1971">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1971">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1972">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1972">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1973">Im folgenden Codebeispiel werden die Ergebnisse von "fonread" und der verfügbaren Eigenschaft verglichen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1973">The following code example compares the results of FIONREAD and the Available property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1974">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1974">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1975">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1975">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1976">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1976">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-1977">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1977">A caller in the call stack does not have the required permissions.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As IOControlCode, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionInValue" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="ioControlCode"><span data-ttu-id="d063a-1978">Ein <see cref="T:System.Net.Sockets.IOControlCode" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-1978">A <see cref="T:System.Net.Sockets.IOControlCode" /> value that specifies the control code of the operation to perform.</span></span></param>
        <param name="optionInValue"><span data-ttu-id="d063a-1979">Ein Array vom Typ <see cref="T:System.Byte" />, das die für den Vorgang erforderlichen Eingabedaten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1979">An array of type <see cref="T:System.Byte" /> that contains the input data required by the operation.</span></span></param>
        <param name="optionOutValue"><span data-ttu-id="d063a-1980">Ein Array vom Typ <see cref="T:System.Byte" />, das die von dem Vorgang zurückgegebenen Ausgabedaten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-1980">An array of type <see cref="T:System.Byte" /> that contains the output data returned by the operation.</span></span></param>
        <summary><span data-ttu-id="d063a-1981">Legt mithilfe der <see cref="T:System.Net.Sockets.Socket" />-Enumeration zum Angeben von Steuerungscodes Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.IOControlCode" /> fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1981">Sets low-level operating modes for the <see cref="T:System.Net.Sockets.Socket" /> using the <see cref="T:System.Net.Sockets.IOControlCode" /> enumeration to specify control codes.</span></span></summary>
        <returns><span data-ttu-id="d063a-1982">Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</span><span class="sxs-lookup"><span data-stu-id="d063a-1982">The number of bytes in the <paramref name="optionOutValue" /> parameter.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1983">Diese Methode bietet Zugriff auf niedriger Ebene auf das Betriebssystem, <xref:System.Net.Sockets.Socket> das der aktuellen Instanz der-Klasse zugrunde liegt <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-1983">This method provides low-level access to the operating system <xref:System.Net.Sockets.Socket> underlying the current instance of the <xref:System.Net.Sockets.Socket> class.</span></span> <span data-ttu-id="d063a-1984">Weitere Informationen finden Sie in der [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) -Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="d063a-1984">For more, see the [WSAIoctl](/windows/win32/api/winsock2/nf-winsock2-wsaioctl) documentation.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1985">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-1985">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-1986">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-1986">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-1987">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-1987">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-1988">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-1988">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1989">Im folgenden Codebeispiel werden die Ergebnisse des-Anrufs von <xref:System.Net.Sockets.Socket.IOControl%2A> mit <xref:System.Net.Sockets.IOControlCode.DataToRead> und der- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verglichen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1989">The following code example compares the results of calling <xref:System.Net.Sockets.Socket.IOControl%2A> with <xref:System.Net.Sockets.IOControlCode.DataToRead> and the <xref:System.Net.Sockets.Socket.Available%2A> property.</span></span>  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-1990">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1990">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-1991">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-1991">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-1992">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</span><span class="sxs-lookup"><span data-stu-id="d063a-1992">An attempt was made to change the blocking mode without using the <see cref="P:System.Net.Sockets.Socket.Blocking" /> property.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1993">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> an einen bestimmten lokalen Anschluss gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-1993">Gets a value that indicates whether the <see cref="T:System.Net.Sockets.Socket" /> is bound to a specific local port.</span></span></summary>
        <value><span data-ttu-id="d063a-1994"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> an einen lokalen Anschluss gebunden ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-1994"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> is bound to a local port; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1995">Ein Socket wird als gebunden an einen lokalen Port betrachtet, wenn er durch Aufrufen der-Methode explizit gebunden wird <xref:System.Net.Sockets.Socket.Bind%2A> , oder durch Aufrufen von Membern wie, oder implizit gebunden durch Aufrufen von Membern wie <xref:System.Net.Sockets.Socket.Connect%2A> , <xref:System.Net.Sockets.Socket.SendTo%2A> oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> , die einen kurzlebigen lokalen Port verwenden (ein freier Port größer als 1024, der vom Betriebssystem ausgewählt wird). -Server verwenden die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode, um eine Bindung an einen bekannten Port herzustellen, damit Clients eine Verbindung mit Ihnen herstellen können.</span><span class="sxs-lookup"><span data-stu-id="d063a-1995">A socket is considered bound to a local port if it is explicitly bound by calling the <xref:System.Net.Sockets.Socket.Bind%2A> method, or implicitly bound by calling members like <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, which use an ephemeral local port (a free port greater than 1024, selected by the operating system.) Servers use the <xref:System.Net.Sockets.Socket.Bind%2A> method to bind to a well-known port so that clients may connect to them.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-1996">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.IsBound%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-1996">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.IsBound%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption? LingerState { get; set; }" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-1997">Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> bei einem Versuch, alle ausstehenden Daten zu senden, das Schließen eines Sockets verzögert, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-1997">Gets or sets a value that specifies whether the <see cref="T:System.Net.Sockets.Socket" /> will delay closing a socket in an attempt to send all pending data.</span></span></summary>
        <value><span data-ttu-id="d063a-1998">Eine <see cref="T:System.Net.Sockets.LingerOption" />, die angibt, wie der Nachlauf während des Schließens eines Sockets erfolgen soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-1998">A <see cref="T:System.Net.Sockets.LingerOption" /> that specifies how to linger while closing a socket.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-1999">Die- <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft ändert die Art und Weise der <xref:System.Net.Sockets.Socket.Close%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-1999">The <xref:System.Net.Sockets.Socket.LingerState%2A> property changes the way <xref:System.Net.Sockets.Socket.Close%2A> method behaves.</span></span> <span data-ttu-id="d063a-2000">Diese Eigenschaft, wenn Set die Bedingungen ändert, unter denen die Verbindung von Winsock zurückgesetzt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-2000">This property when set modifies the conditions under which the connection can be reset by Winsock.</span></span> <span data-ttu-id="d063a-2001">Verbindungs Aufstellungen können weiterhin basierend auf dem IP-Protokoll Verhalten auftreten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2001">Connection resets can still occur based on the IP protocol behavior.</span></span>  
  
 <span data-ttu-id="d063a-2002">Diese Eigenschaft steuert die Zeitspanne, in der eine Verbindungs orientierte Verbindung nach einem Aufruf von geöffnet bleibt, <xref:System.Net.Sockets.Socket.Close%2A> Wenn die Daten gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2002">This property controls the length of time that a connection-oriented connection will remain open after a call to <xref:System.Net.Sockets.Socket.Close%2A> when data remains to be sent.</span></span>  
  
 <span data-ttu-id="d063a-2003">Wenn Sie Methoden zum Senden von Daten an einen Peer aufzurufen, werden diese Daten im ausgehenden Netzwerk Puffer platziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2003">When you call methods to send data to a peer, this data is placed in the outgoing network buffer.</span></span> <span data-ttu-id="d063a-2004">Diese Eigenschaft kann verwendet werden, um sicherzustellen, dass diese Daten an den Remote Host gesendet werden, bevor die- <xref:System.Net.Sockets.TcpClient.Close%2A> Methode die Verbindung löscht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2004">This property can be used to ensure that this data is sent to the remote host before the <xref:System.Net.Sockets.TcpClient.Close%2A> method drops the connection.</span></span>  
  
 <span data-ttu-id="d063a-2005">Um einen veralteten Wert zu aktivieren, erstellen Sie eine <xref:System.Net.Sockets.LingerOption> -Instanz, die die gewünschten Werte enthält, und legen Sie die- <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft auf diese Instanz fest</span><span class="sxs-lookup"><span data-stu-id="d063a-2005">To enable lingering, create a <xref:System.Net.Sockets.LingerOption> instance containing the desired values, and set the <xref:System.Net.Sockets.Socket.LingerState%2A> property to this instance.</span></span>  
  
 <span data-ttu-id="d063a-2006">In der folgenden Tabelle wird das Verhalten der <xref:System.Net.Sockets.Socket.Close%2A> -Methode für die möglichen Werte der <xref:System.Net.Sockets.LingerOption.Enabled%2A> -Eigenschaft und der-Eigenschaft beschrieben, die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> in der-Eigenschaft gespeichert ist <xref:System.Net.Sockets.Socket.LingerState%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2006">The following table describes the behavior of the <xref:System.Net.Sockets.Socket.Close%2A> method for the possible values of the <xref:System.Net.Sockets.LingerOption.Enabled%2A> property and the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
|<span data-ttu-id="d063a-2007">LingerState. aktiviert</span><span class="sxs-lookup"><span data-stu-id="d063a-2007">LingerState.Enabled</span></span>|<span data-ttu-id="d063a-2008">LingerState. LingerTime</span><span class="sxs-lookup"><span data-stu-id="d063a-2008">LingerState.LingerTime</span></span>|<span data-ttu-id="d063a-2009">Verhalten</span><span class="sxs-lookup"><span data-stu-id="d063a-2009">Behavior</span></span>|  
|-------------------------|----------------------------|--------------|  
|<span data-ttu-id="d063a-2010">`false` (deaktiviert), der Standardwert</span><span class="sxs-lookup"><span data-stu-id="d063a-2010">`false` (disabled), the default value</span></span>|<span data-ttu-id="d063a-2011">Das Timeout ist nicht anwendbar (Standard).</span><span class="sxs-lookup"><span data-stu-id="d063a-2011">The time-out is not applicable, (default).</span></span>|<span data-ttu-id="d063a-2012">Versucht, ausstehende Daten zu senden, bis der Standard-IP-Protokoll Timeout abläuft.</span><span class="sxs-lookup"><span data-stu-id="d063a-2012">Attempts to send pending data until the default IP protocol time-out expires.</span></span>|  
|<span data-ttu-id="d063a-2013">`true` wodurch</span><span class="sxs-lookup"><span data-stu-id="d063a-2013">`true` (enabled)</span></span>|<span data-ttu-id="d063a-2014">Ein Timeout ungleich 0 (null)</span><span class="sxs-lookup"><span data-stu-id="d063a-2014">A nonzero time-out</span></span>|<span data-ttu-id="d063a-2015">Versucht, ausstehende Daten zu senden, bis das angegebene Timeout abläuft. wenn der Versuch fehlschlägt, setzt Winsock die Verbindung zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2015">Attempts to send pending data until the specified time-out expires, and if the attempt fails, then Winsock resets the connection.</span></span>|  
|<span data-ttu-id="d063a-2016">`true` wodurch</span><span class="sxs-lookup"><span data-stu-id="d063a-2016">`true` (enabled)</span></span>|<span data-ttu-id="d063a-2017">Ein Timeout von NULL.</span><span class="sxs-lookup"><span data-stu-id="d063a-2017">A zero timeout.</span></span>|<span data-ttu-id="d063a-2018">Verwirft alle ausstehenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2018">Discards any pending data.</span></span> <span data-ttu-id="d063a-2019">Für Verbindungs orientierten Socket (z. b. TCP) setzt Winsock die Verbindung zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2019">For connection-oriented socket (TCP, for example), Winsock resets the connection.</span></span>|  
  
 <span data-ttu-id="d063a-2020">Der IP-Stapel berechnet den Standard Timeout Zeitraum für das IP-Protokoll, der basierend auf der Roundtripzeit der Verbindung verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-2020">The IP stack computes the default IP protocol time-out period to use based on the round trip time of the connection.</span></span> <span data-ttu-id="d063a-2021">In den meisten Fällen ist der durch den Stapel berechnete Timeout relevanter als der von einer Anwendung definierte Timeout.</span><span class="sxs-lookup"><span data-stu-id="d063a-2021">In most cases, the time-out computed by the stack is more relevant than one defined by an application.</span></span> <span data-ttu-id="d063a-2022">Dies ist das Standardverhalten für einen Socket, wenn die- <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft nicht festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2022">This is the default behavior for a socket when the <xref:System.Net.Sockets.Socket.LingerState%2A> property is not set.</span></span>  
  
 <span data-ttu-id="d063a-2023">Wenn die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft, die in der <xref:System.Net.Sockets.Socket.LingerState%2A> -Eigenschaft gespeichert ist, größer als das Standard Timeout für den IP-Protokoll Wert ist, wird das Standard Timeout für das IP-Protokoll weiterhin angewendet und außer Kraft gesetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2023">When the <xref:System.Net.Sockets.LingerOption.LingerTime%2A> property stored in the <xref:System.Net.Sockets.Socket.LingerState%2A> property is set greater than the default IP protocol time-out, the default IP protocol time-out will still apply and override.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2024">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.LingerState%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2024">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.LingerState%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2025">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2025">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2026">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2026">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen();" />
      <MemberSignature Language="F#" Value="member this.Listen : unit -&gt; unit" Usage="socket.Listen " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-2027">Versetzt einen <see cref="T:System.Net.Sockets.Socket" /> in den Überwachungszustand.</span><span class="sxs-lookup"><span data-stu-id="d063a-2027">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d063a-2028">Die maximale Länge der Warteschlange für ausstehende Verbindungen wird automatisch festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2028">The maximum length of the pending connections queue is determined automatically.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog"><span data-ttu-id="d063a-2029">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2029">The maximum length of the pending connections queue.</span></span></param>
        <summary><span data-ttu-id="d063a-2030">Versetzt einen <see cref="T:System.Net.Sockets.Socket" /> in den Überwachungszustand.</span><span class="sxs-lookup"><span data-stu-id="d063a-2030">Places a <see cref="T:System.Net.Sockets.Socket" /> in a listening state.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2031"><xref:System.Net.Sockets.Socket.Listen%2A> bewirkt, dass ein Verbindungs orientierter <xref:System.Net.Sockets.Socket> auf eingehende Verbindungsversuche lauscht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2031"><xref:System.Net.Sockets.Socket.Listen%2A> causes a connection-oriented <xref:System.Net.Sockets.Socket> to listen for incoming connection attempts.</span></span> <span data-ttu-id="d063a-2032">Der- `backlog` Parameter gibt die Anzahl eingehender Verbindungen an, die zur Annahme in die Warteschlange eingereiht werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2032">The `backlog` parameter specifies the number of incoming connections that can be queued for acceptance.</span></span> <span data-ttu-id="d063a-2033">Um die maximale Anzahl von Verbindungen zu bestimmen, die Sie angeben können, rufen Sie den <xref:System.Net.Sockets.SocketOptionName.MaxConnections> Wert ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-2033">To determine the maximum number of connections you can specify, retrieve the <xref:System.Net.Sockets.SocketOptionName.MaxConnections> value.</span></span> <span data-ttu-id="d063a-2034"><xref:System.Net.Sockets.Socket.Listen%2A> wird nicht blockiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2034"><xref:System.Net.Sockets.Socket.Listen%2A> does not block.</span></span>  
  
 <span data-ttu-id="d063a-2035">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2035">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2036">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2036">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span> <span data-ttu-id="d063a-2037">Verwenden <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> Sie oder, um eine Verbindung aus der Warteschlange zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2037">Use <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.BeginAccept%2A> to accept a connection from the queue.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2038">Sie müssen die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode aufrufen, bevor Sie aufrufen <xref:System.Net.Sockets.Socket.Listen%2A> , oder es <xref:System.Net.Sockets.Socket.Listen%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2038">You must call the <xref:System.Net.Sockets.Socket.Bind%2A> method before calling <xref:System.Net.Sockets.Socket.Listen%2A>, or <xref:System.Net.Sockets.Socket.Listen%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2039">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2039">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2040">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2040">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2041">Der Rückstands Parameter ist abhängig vom Betriebs System auf unterschiedliche Werte beschränkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2041">The backlog parameter is limited to different values depending on the Operating System.</span></span> <span data-ttu-id="d063a-2042">Sie können einen höheren Wert angeben, der Rückstand wird jedoch auf Grundlage des Betriebssystems beschränkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2042">You may specify a higher value, but the backlog will be limited based on the Operating System.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2043">Im folgenden Codebeispiel wird verwendet <xref:System.Net.Sockets.Socket> , um auf eingehende Verbindungen zu lauschen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2043">The following code example uses <xref:System.Net.Sockets.Socket> to listen for incoming connections.</span></span>  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2044">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2044">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2045">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2045">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint? LocalEndPoint { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2046">Ruft den lokalen Endpunkt ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-2046">Gets the local endpoint.</span></span></summary>
        <value><span data-ttu-id="d063a-2047">Der <see cref="T:System.Net.EndPoint" />, den der <see cref="T:System.Net.Sockets.Socket" /> für die Kommunikation verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2047">The <see cref="T:System.Net.EndPoint" /> that the <see cref="T:System.Net.Sockets.Socket" /> is using for communications.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2048">Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft ruft ein-Objekt ab <xref:System.Net.EndPoint> , das die lokale IP-Adresse und die Portnummer enthält, an die Ihr <xref:System.Net.Sockets.Socket> gebunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2048">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property gets an <xref:System.Net.EndPoint> that contains the local IP address and port number to which your <xref:System.Net.Sockets.Socket> is bound.</span></span> <span data-ttu-id="d063a-2049">Sie müssen diesen <xref:System.Net.EndPoint> in einen umwandeln, <xref:System.Net.IPEndPoint> bevor Sie Informationen abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2049">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="d063a-2050">Sie können dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> -Methode aufrufen, um den lokalen abzurufen <xref:System.Net.IPAddress> , und die- <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die lokale Portnummer abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2050">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the local <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the local port number.</span></span>  
  
 <span data-ttu-id="d063a-2051">Die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft wird normalerweise festgelegt, nachdem Sie die-Methode aufgerufen haben <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2051">The <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property is usually set after you make a call to the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-2052">Wenn Sie zulassen, dass das System die lokale IP-Adresse und Portnummer Ihres Sockets zuweist, wird die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach dem ersten e/a-Vorgang festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2052">If you allow the system to assign your socket's local IP address and port number, the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property will be set after the first I/O operation.</span></span> <span data-ttu-id="d063a-2053">Bei Verbindungs orientierten Protokollen wäre der erste e/a-Vorgang ein Rückruf der-oder- <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-2053">For connection-oriented protocols, the first I/O operation would be a call to the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2054">Bei Verbindungs losen Protokollen wäre der erste e/a-Vorgang einer der Sende-oder Empfangs Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="d063a-2054">For connectionless protocols, the first I/O operation would be any of the send or receive calls.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2055">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2055">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2056">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2056">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2057">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2057">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2058">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2058">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2059">Im folgenden Codebeispiel werden die lokalen und Remote Endpunkte abgerufen und angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2059">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2060">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2060">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2061">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2061">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2062">Ruft einen Wert ab, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-2062">Gets or sets a value that specifies whether outgoing multicast packets are delivered to the sending application.</span></span></summary>
        <value><span data-ttu-id="d063a-2063"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ausgehende Multicastpakete empfängt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2063"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> receives outgoing multicast packets; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2064">Multicast ist eine skalierbare Methode für die m:n-Kommunikation im Internet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2064">Multicast is a scalable method for many-to-many communication on the Internet.</span></span> <span data-ttu-id="d063a-2065">Ein Prozess abonniert eine Multicast Adresse. Anschließend werden alle Pakete, die von einem abonnierten Prozess gesendet werden, von jedem anderen Prozess empfangen, der die Multicast Adresse abonniert hat.</span><span class="sxs-lookup"><span data-stu-id="d063a-2065">A process subscribes to a multicast address; then, any packets sent by a subscribed process are received by every other process subscribed to the multicast address.</span></span>  
  
 <span data-ttu-id="d063a-2066">Das Festlegen dieser Eigenschaft auf einen TCP-Socket (Transmission Control Protocol) hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2066">Setting this property on a Transmission Control Protocol (TCP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2067">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.MulticastLoopback%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2067">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.MulticastLoopback%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2068">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2068">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2069">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2069">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2070">Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der Stream-<see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-2070">Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the stream <see cref="T:System.Net.Sockets.Socket" /> is using the Nagle algorithm.</span></span></summary>
        <value><span data-ttu-id="d063a-2071"><see langword="false" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, andernfalls <see langword="true" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2071"><see langword="false" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses the Nagle algorithm; otherwise, <see langword="true" />.</span></span> <span data-ttu-id="d063a-2072">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2072">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2073">Der Nagle-Algorithmus ist darauf ausgelegt, den Netzwerk Datenverkehr zu verringern, indem der Socket kleine Pakete puffert und Sie dann in einem Paket unter bestimmten Umständen kombiniert und sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2073">The Nagle algorithm is designed to reduce network traffic by causing the socket to buffer small packets and then combine and send them in one packet under certain circumstances.</span></span> <span data-ttu-id="d063a-2074">Ein TCP-Paket besteht aus 40 Bytes des Headers und den gesendeten Daten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2074">A TCP packet consists of 40 bytes of header plus the data being sent.</span></span> <span data-ttu-id="d063a-2075">Wenn kleine Datenpakete mit TCP gesendet werden, kann der mehr Aufwand, der sich aus dem TCP-Header ergibt, zu einem erheblichen Teil des Netzwerk Datenverkehrs werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2075">When small packets of data are sent with TCP, the overhead resulting from the TCP header can become a significant part of the network traffic.</span></span> <span data-ttu-id="d063a-2076">Bei stark ausgelasteten Netzwerken kann die Überlastung, die sich aus diesem Aufwand ergibt, zu verlorenen Datagramme und erneuten Übertragungen sowie zu einer übermäßigen propagierungs Zeit führen, die durch eine Überlastung verursacht wird</span><span class="sxs-lookup"><span data-stu-id="d063a-2076">On heavily loaded networks, the congestion resulting from this overhead can result in lost datagrams and retransmissions, as well as excessive propagation time caused by congestion.</span></span> <span data-ttu-id="d063a-2077">Der Nagle-Algorithmus hemmt das Senden neuer TCP-Segmente, wenn neue ausgehende Daten vom Benutzer empfangen werden, wenn zuvor übertragene Daten über die Verbindung nicht bestätigt bleiben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2077">The Nagle algorithm inhibits the sending of new TCP segments when new outgoing data arrives from the user if any previously transmitted data on the connection remains unacknowledged.</span></span>  
  
 <span data-ttu-id="d063a-2078">Die Mehrzahl der Netzwerkanwendungen sollte den Nagle-Algorithmus verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2078">The majority of network applications should use the Nagle algorithm.</span></span>  
  
 <span data-ttu-id="d063a-2079">Das Festlegen dieser Eigenschaft für einen UDP-Socket (User Datagram Protocol) hat keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2079">Setting this property on a User Datagram Protocol (UDP) socket will have no effect.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2080">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.NoDelay%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2080">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.NoDelay%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2081">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2081">An error occurred when attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2082">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2082">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2083">Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv4 (Internet Protocol, Version 4) unterstützen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2083">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 4 (IPv4).</span></span></summary>
        <value><span data-ttu-id="d063a-2084"><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das IPv4-Protokoll unterstützen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2084"><see langword="true" /> if the operating system and network adaptors support the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2085">Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.</span><span class="sxs-lookup"><span data-stu-id="d063a-2085">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2086">Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv6 (Internet Protocol, Version 6) unterstützen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2086">Indicates whether the underlying operating system and network adaptors support Internet Protocol version 6 (IPv6).</span></span></summary>
        <value><span data-ttu-id="d063a-2087"><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das Protokoll IPv6 unterstützen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2087"><see langword="true" /> if the operating system and network adaptors support the IPv6 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2088">Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.</span><span class="sxs-lookup"><span data-stu-id="d063a-2088">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsUnixDomainSockets">
      <MemberSignature Language="C#" Value="public static bool OSSupportsUnixDomainSockets { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsUnixDomainSockets" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsUnixDomainSockets As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsUnixDomainSockets { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsUnixDomainSockets : bool" Usage="System.Net.Sockets.Socket.OSSupportsUnixDomainSockets" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>To be added.</summary>
        <value>To be added.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="microSeconds"><span data-ttu-id="d063a-2089">Die Zeit in Mikrosekunden, die auf eine Antwort gewartet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-2089">The time to wait for a response, in microseconds.</span></span></param>
        <param name="mode"><span data-ttu-id="d063a-2090">Einer der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2090">One of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2091">Bestimmt den Status des <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2091">Determines the status of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2092">Der Status des <see cref="T:System.Net.Sockets.Socket" /> basierend auf dem im <paramref name="mode" />-Parameter übergebenen Abfragemoduswert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2092">The status of the <see cref="T:System.Net.Sockets.Socket" /> based on the polling mode value passed in the <paramref name="mode" /> parameter.</span></span>  
  
 <list type="table"><listheader><term> <span data-ttu-id="d063a-2093">Modus</span><span class="sxs-lookup"><span data-stu-id="d063a-2093">Mode</span></span> 
 </term><description> <span data-ttu-id="d063a-2094">Rückgabewert</span><span class="sxs-lookup"><span data-stu-id="d063a-2094">Return Value</span></span> 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><span data-ttu-id="d063a-2095"><see langword="true" />, wenn <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> aufgerufen wurde und eine Verbindung aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2095"><see langword="true" /> if <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> has been called and a connection is pending;</span></span> 
<span data-ttu-id="d063a-2096">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2096">-or-</span></span> 
 <span data-ttu-id="d063a-2097"><see langword="true" />, wenn Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2097"><see langword="true" /> if data is available for reading;</span></span> 
<span data-ttu-id="d063a-2098">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2098">-or-</span></span> 
 <span data-ttu-id="d063a-2099"><see langword="true" />, wenn die Verbindung geschlossen, zurückgesetzt oder beendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2099"><see langword="true" /> if the connection has been closed, reset, or terminated;</span></span> 
<span data-ttu-id="d063a-2100">Andernfalls wird <see langword="false" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2100">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><span data-ttu-id="d063a-2101"><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> verarbeitet wird und die Verbindung erfolgreich war.</span><span class="sxs-lookup"><span data-stu-id="d063a-2101"><see langword="true" />, if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />, and the connection has succeeded;</span></span> 
<span data-ttu-id="d063a-2102">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2102">-or-</span></span> 
 <span data-ttu-id="d063a-2103"><see langword="true" />, wenn Daten gesendet werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2103"><see langword="true" /> if data can be sent;</span></span> 
<span data-ttu-id="d063a-2104">Andernfalls wird <see langword="false" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2104">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><span data-ttu-id="d063a-2105"><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> ohne Blockierung verarbeitet wird und der Verbindungsaufbau fehlgeschlagen ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2105"><see langword="true" /> if processing a <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> that does not block, and the connection has failed;</span></span> 
<span data-ttu-id="d063a-2106">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2106">-or-</span></span> 
 <span data-ttu-id="d063a-2107"><see langword="true" />, wenn <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nicht festgelegt ist und Out-of-Band-Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2107"><see langword="true" /> if <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> is not set and out-of-band data is available;</span></span> 
<span data-ttu-id="d063a-2108">Andernfalls wird <see langword="false" /> zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2108">otherwise, returns <see langword="false" />.</span></span>  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2109">Die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode überprüft den Zustand von <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2109">The <xref:System.Net.Sockets.Socket.Poll%2A> method will check the state of the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-2110">Geben <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> Sie für den- `selectMode` Parameter an, um zu bestimmen, ob <xref:System.Net.Sockets.Socket> lesbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2110">Specify <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> for the `selectMode` parameter to determine if the <xref:System.Net.Sockets.Socket> is readable.</span></span> <span data-ttu-id="d063a-2111">Geben <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> Sie an, um zu bestimmen, ob <xref:System.Net.Sockets.Socket> beschreibbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2111">Specify <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> to determine if the <xref:System.Net.Sockets.Socket> is writable.</span></span> <span data-ttu-id="d063a-2112">Verwenden <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> Sie, um einen Fehlerzustand zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2112">Use <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> to detect an error condition.</span></span> <span data-ttu-id="d063a-2113"><xref:System.Net.Sockets.Socket.Poll%2A> blockiert die Ausführung bis zum angegebenen Zeitraum, gemessen in `microseconds` , abläuft.</span><span class="sxs-lookup"><span data-stu-id="d063a-2113"><xref:System.Net.Sockets.Socket.Poll%2A> will block execution until the specified time period, measured in `microseconds`, elapses.</span></span> <span data-ttu-id="d063a-2114">Legen Sie den- `microSeconds` Parameter auf eine negative Ganzzahl fest, wenn Sie unbegrenzt auf eine Antwort warten möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2114">Set the `microSeconds` parameter to a negative integer if you would like to wait indefinitely for a response.</span></span> <span data-ttu-id="d063a-2115">Wenn Sie den Status mehrerer Sockets überprüfen möchten, empfiehlt es sich, die-Methode zu verwenden <xref:System.Net.Sockets.Socket.Select%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2115">If you want to check the status of multiple sockets, you might prefer to use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2116">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2116">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2117">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2117">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2118">Diese Methode kann bestimmte Arten von Verbindungsproblemen, wie z. b. ein fehlerhaftes Netzwerkkabel, nicht erkennen, oder der Remote Host wurde nicht ordnungsgemäß heruntergefahren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2118">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="d063a-2119">Sie müssen versuchen, Daten zu senden oder zu empfangen, um diese Arten von Fehlern zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2119">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2120">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2120">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2121">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2121">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2122">Im folgenden Codebeispiel wird ein Socket erstellt, eine Verbindung mit einem Server hergestellt und <xref:System.Net.Sockets.Socket.Poll%2A> zum Überprüfen des Socketstatus verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2122">The following code example creates a socket, connects to a server, and uses <xref:System.Net.Sockets.Socket.Poll%2A> to check the status of the socket.</span></span>  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-2123">Der <paramref name="mode" />-Parameter ist keiner der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2123">The <paramref name="mode" /> parameter is not one of the <see cref="T:System.Net.Sockets.SelectMode" /> values.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2124">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2124">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-2125">Weitere Informationen finden Sie weiter unten im Abschnitt "Hinweise".</span><span class="sxs-lookup"><span data-stu-id="d063a-2125">See remarks below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2126">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2126">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2127">Ruft den Protokolltyp des <see cref="T:System.Net.Sockets.Socket" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-2127">Gets the protocol type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-2128">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2128">One of the <see cref="T:System.Net.Sockets.ProtocolType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2129">Die <xref:System.Net.Sockets.Socket.ProtocolType%2A> -Eigenschaft wird festgelegt <xref:System.Net.Sockets.Socket> , wenn der erstellt wird, und gibt das von diesem verwendete Protokoll an <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2129">The <xref:System.Net.Sockets.Socket.ProtocolType%2A> property is set when the <xref:System.Net.Sockets.Socket> is created, and specifies the protocol used by that <xref:System.Net.Sockets.Socket>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2130">Im folgenden Codebeispiel <xref:System.Net.Sockets.AddressFamily> werden, <xref:System.Net.Sockets.SocketType> und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2130">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-2131">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2131">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2132">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2132">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="d063a-2133">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2133">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="d063a-2134">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2134">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2135">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2135">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2136"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2136">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2137">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2137">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="d063a-2138">Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt. die Größe ist standardmäßig auf die Länge des Puffer Parameters und der <xref:System.Net.Sockets.SocketFlags> Standardwert auf <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2138">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d063a-2139">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2139">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2140">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2140">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2141">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2141">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2142"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2142"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2143">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2143">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2144">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2144">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2145">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2145">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2146">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2146">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2147">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2147">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2148">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2148">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2149">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2149">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2150">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2150">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2151">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2151">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2152">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2152">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2153">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2153">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2154">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2154">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2155">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2155">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2156">Im folgenden Codebeispiel werden Daten zu einem verbundenen empfangen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2156">The following code example receives data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2157"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2157"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2158">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2158">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2159">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2159">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2160">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2160">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-2161">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2161">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <summary><span data-ttu-id="d063a-2162">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> und fügt sie in die Liste der Empfangspuffer ein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2162">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers.</span></span></summary>
        <returns><span data-ttu-id="d063a-2163">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2163">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2164">Diese Methode liest Daten in den Puffer Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2164">This method reads data into the buffers parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2165">Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2165">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2166">Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2166">This overload requires you to provide one or more receive buffers.</span></span>  
  
 <span data-ttu-id="d063a-2167">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2167">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2168">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2168">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2169">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2169">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2170"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2170"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2171">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2171">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2172">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2172">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2173">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2173">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2174">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2174">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2175">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2175">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2176">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2176">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2177">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2177">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2178">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2178">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2179">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers` Parameters ist, `buffers` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2179">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2180">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2180">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2181">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2181">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
 <span data-ttu-id="d063a-2182">**Hinweis** Dieser Member gibt Ablauf Verfolgungs Informationen aus, wenn Sie die Netzwerk Ablauf Verfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2182">**Note** This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2183">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2183">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2184">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2184">The <paramref name="buffer" /> parameter is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2185">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2185">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2186">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2186">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2187">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2187">A span of bytes that is the storage location for the received data.</span></span></param>
        <summary><span data-ttu-id="d063a-2188">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2188">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer.</span></span></summary>
        <returns><span data-ttu-id="d063a-2189">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2189">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d063a-2190">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2190">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2191"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2191">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="d063a-2192">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2192">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="d063a-2193">Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt. die Größe ist standardmäßig auf die Länge des Puffer Parameters und der <xref:System.Net.Sockets.SocketFlags> Standardwert auf <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2193">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="d063a-2194">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> eine eingehende Verbindung akzeptieren, bevor aufgerufen wird <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2194">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection before calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2195">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2195">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2196">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2196">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2197"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="d063a-2198">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2198">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2199">Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2199">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2200">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2200">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2201">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2201">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2202">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2202">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="d063a-2203">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2203">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2204">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2204">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="d063a-2205">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2205">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2206">Wenn das Datagramm, das Sie empfangen, größer ist als die Größe des `buffer` Parameters, wird `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und eine <xref:System.Net.Sockets.SocketException> wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2206">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="d063a-2207">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2207">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2208">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2208">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="d063a-2209">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2209">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2210">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2210">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2211">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2211">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2212">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2212">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2213">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2213">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2214">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2214">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2215">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2215">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2216">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2216">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2217">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2217">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2218">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2218">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2219"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2219">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2220">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer und die erforderliche bereitstellen <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2220">This overload only requires you to provide a receive buffer and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d063a-2221">Der Puffer Offset ist standardmäßig 0, und die Größe ist standardmäßig auf die Länge des Byte-Parameters eingestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2221">The buffer offset defaults to 0, and the size defaults to the length of the byte parameter.</span></span>  
  
 <span data-ttu-id="d063a-2222">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2222">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2223">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2223">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2224">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2224">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2225"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2225"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2226">Wenn keine Daten zum Lesen verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die Methode blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2226">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-2227">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2227">If you are in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2228">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2228">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2229">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2229">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2230">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest die Methode so viele Daten, wie Sie bis zur Größe des Puffers verfügbar ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2230">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2231">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2231">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2232">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2232">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2233">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2233">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2234">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2234">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2235">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2235">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2236">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2236">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2237">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2237">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2238">Im folgenden Codebeispiel wird ein Datenpuffer und <xref:System.Net.Sockets.SocketFlags> zum Empfangen von Daten auf einem verbundenen angegeben <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2238">The following code example specifies a data buffer, and <xref:System.Net.Sockets.SocketFlags> for receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2239"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2239"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2240">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2240">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2241">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2241">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2242">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2242">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-2243">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2243">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2244">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2244">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2245">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2245">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2246">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2246">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2247">Diese Methode liest Daten in den `buffers` -Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2247">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2248">Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2248">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2249">Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2249">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="d063a-2250">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2250">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d063a-2251">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2251">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2252">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2252">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2253">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2253">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2254"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2255">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2255">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2256">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2256">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2257">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2257">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2258">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2258">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2259">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2259">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2260">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2260">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2261">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2261">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2262">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2262">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first enqueued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2263">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers` Parameters ist, `buffers` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2263">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2264">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2264">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2265">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2265">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2266">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2266">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2267">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2267">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2268">Im folgenden Codebeispiel wird veranschaulicht, wie Daten für einen verbundenen empfangen werden <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2268">The following code example demonstrates how to receive data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2269"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2269"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2270">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2270">-or-</span></span> 
 <span data-ttu-id="d063a-2271"><paramref name="buffers" />.Count ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-2271"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2272">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2272">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2273">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2273">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2274">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2274">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2275">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2275">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="d063a-2276">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2276">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2277">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2277">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks

<span data-ttu-id="d063a-2278">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2278">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2279"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2279">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>

<span data-ttu-id="d063a-2280">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2280">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="d063a-2281">Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt. die Größe ist standardmäßig auf die Länge des Puffer Parameters und der <xref:System.Net.Sockets.SocketFlags> Standardwert auf <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2281">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>

<span data-ttu-id="d063a-2282">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2282">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2283">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2283">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2284">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2284">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2285"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2285"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>

<span data-ttu-id="d063a-2286">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2286">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2287">Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2287">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2288">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2288">If you're in non-blocking mode, and there is no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2289">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2289">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2290">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2290">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>

<span data-ttu-id="d063a-2291">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2291">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2292">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2292">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>

<span data-ttu-id="d063a-2293">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2293">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2294">Wenn das Datagramm, das Sie empfangen, größer ist als die Größe des `buffer` Parameters, wird `buffer` mit dem ersten Teil der Nachricht aufgefüllt, die überzähligen Daten gehen verloren, und eine <xref:System.Net.Sockets.SocketException> wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2294">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost, and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>

> [!NOTE]
> <span data-ttu-id="d063a-2295">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2295">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2296">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2296">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="d063a-2297">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2297">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2298">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2298">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2299">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2299">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2300">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2300">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2301">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2301">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2302">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2302">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2303">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2303">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2304">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2304">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2305">Empfängt die angegebene Anzahl von Datenbytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2305">Receives the specified number of bytes of data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2306">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2306">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2307">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den `buffer` -Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2307">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the `buffer` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2308"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2308">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2309">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, die Anzahl der zu empfangenden Bytes und die erforderliche angeben <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2309">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, and the necessary <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 <span data-ttu-id="d063a-2310">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2310">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2311">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2311">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2312">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2312">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2313"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2313"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2314">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2314">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2315">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2315">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2316">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2316">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, The <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2317">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2317">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2318">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2318">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry your receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2319">Wenn Sie ein Verbindungs orientiertes verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten wie verfügbar, bis zur Anzahl der vom-Parameter angegebenen Bytes `size` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2319">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d063a-2320">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2320">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2321">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2321">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2322">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2322">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2323">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2323">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2324">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2324">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2325">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2325">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2326">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2326">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2327">Folgendes empfängt die Daten, die in gefunden `buffer` wurden, und gibt <xref:System.Net.Sockets.SocketFlags.None> für an <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2327">The following receives the data found into `buffer`, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>  
  
 [!code-cpp[Socket_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2328"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2328"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2329"><paramref name="size" /> ist größer als <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2329"><paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2330">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2330">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2331">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2331">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2332">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2332">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-2333">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2333">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2334">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2334">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-2335">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2335">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-2336">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2336">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into the list of receive buffers, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2337">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2337">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2338">Diese Methode liest Daten in den `buffers` -Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2338">This method reads data into the `buffers` parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2339">Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2339">You can call from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2340">Diese Überladung erfordert, dass Sie einen oder mehrere Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2340">This overload requires you to provide one or more receive buffers.</span></span> <span data-ttu-id="d063a-2341">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2341">The <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
 <span data-ttu-id="d063a-2342">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2342">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2343">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remote Host Verbindung empfangen werden, die in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2343">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host connection established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2344">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2344">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2345"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2345"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2346">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2346">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2347">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2347">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2348">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2348">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2349">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2349">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2350">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2350">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2351">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2351">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2352">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2352">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2353">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2353">If you are using a connectionless <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2354">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffers` Parameters ist, `buffers` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2354">If the datagram you receive is larger than the size of the `buffers` parameter, `buffers` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2355">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2355">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2356">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2356">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2357">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2357">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2358">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2358">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2359"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2359"><paramref name="buffers" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2360">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2360">-or-</span></span> 
 <span data-ttu-id="d063a-2361"><paramref name="buffers" />.Count ist 0 (null).</span><span class="sxs-lookup"><span data-stu-id="d063a-2361"><paramref name="buffers" />.Count is zero.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2362">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2362">An error occurred while attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2363">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2363">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2364">Eine Spanne von Bytes, die der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2364">A span of bytes that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2365">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2365">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-2366">Diese Methode gibt einen der Enumerationswerte zurück, der Fehlercodes für den Socket definiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2366">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="d063a-2367">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2367">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2368">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2368">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="d063a-2369">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2369">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2370"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2370">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  

<span data-ttu-id="d063a-2371">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer bereitstellen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2371">This overload only requires you to provide a receive buffer.</span></span> <span data-ttu-id="d063a-2372">Der Puffer Offset ist standardmäßig auf 0 (null) eingestellt. die Größe ist standardmäßig auf die Länge des Puffer Parameters und der <xref:System.Net.Sockets.SocketFlags> Standardwert auf <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2372">The buffer offset defaults to 0, the size defaults to the length of the buffer parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  

<span data-ttu-id="d063a-2373">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2373">If you're using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2374">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2374">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2375">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2375">If you're using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2376"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2376"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  

<span data-ttu-id="d063a-2377">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2377">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2378">Wenn der Timeout Wert überschritten wird, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2378">When the time-out value is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2379">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2379">If you're in non-blocking mode, and there's no data available in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2380">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2380">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2381">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2381">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  

<span data-ttu-id="d063a-2382">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten, wie Sie verfügbar sind, bis zur Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2382">If you're using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the size of the buffer.</span></span> <span data-ttu-id="d063a-2383">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2383">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  

<span data-ttu-id="d063a-2384">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2384">If you're using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2385">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2385">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  

> [!NOTE]
>  <span data-ttu-id="d063a-2386">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2386">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2387">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2387">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  

> [!NOTE]
>  <span data-ttu-id="d063a-2388">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2388">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2389">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2389">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2390">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2390">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2391">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2391">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2392">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2392">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2393">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2393">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-2394">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2394">The location in <paramref name="buffer" /> to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2395">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2395">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2396">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2396">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2397">Empfängt die angegebene Anzahl von Bytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> an der angegebenen Offsetposition des Empfangspuffers, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2397">Receives the specified number of bytes from a bound <see cref="T:System.Net.Sockets.Socket" /> into the specified offset position of the receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2398">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2398">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2399">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2399">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2400"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2400">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2401">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2401">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2402">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2402">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2403">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2403">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2404"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2404"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2405">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2405">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2406">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2406">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2407">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2407">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2408">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2408">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-2409">Siehe folgende Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-2409">See Remarks below.</span></span> <span data-ttu-id="d063a-2410">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2410">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2411">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2411">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2412">Wenn Sie ein Verbindungs orientiertes verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten wie verfügbar, bis zur Anzahl der Bytes, die durch den size-Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2412">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="d063a-2413">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2413">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2414">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2414">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2415">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2415">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2416">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2416">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2417">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2417">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2418">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2418">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2419">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2419">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2420">Im folgenden Codebeispiel werden ein Datenpuffer, ein Offset, eine Größe und ein Socketflag angegeben, bevor Daten für einen verbundenen empfangen werden <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2420">The following code example specifies a data buffer, an offset, a size, and a socket flag before receiving data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2421"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2421"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2422"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2422"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2423">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2423">-or-</span></span> 
 <span data-ttu-id="d063a-2424"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2424"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-2425">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2425">-or-</span></span> 
 <span data-ttu-id="d063a-2426"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2426"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2427">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2427">-or-</span></span> 
 <span data-ttu-id="d063a-2428"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-2428"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2429"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2429"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-2430">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2430">-or-</span></span> 
<span data-ttu-id="d063a-2431">Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2431">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="d063a-2432">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2432">-or-</span></span> 
<span data-ttu-id="d063a-2433">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-2433">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2434">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2434">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2435">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2435">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2436">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2436">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-2437">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2437">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2438">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2438">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2439">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2439">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-2440">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2440">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-2441">Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2441">Receives data from a bound <see cref="T:System.Net.Sockets.Socket" /> into a receive buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2442">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2442">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2443">Die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode liest Daten in den buffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2443">The <xref:System.Net.Sockets.Socket.Receive%2A> method reads data into the buffer parameter and returns the number of bytes successfully read.</span></span> <span data-ttu-id="d063a-2444"><xref:System.Net.Sockets.Socket.Receive%2A>Aus Verbindungs orientierten und Verbindungs losen Sockets kann aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2444">You can call <xref:System.Net.Sockets.Socket.Receive%2A> from both connection-oriented and connectionless sockets.</span></span>  
  
 <span data-ttu-id="d063a-2445">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder <xref:System.Net.Sockets.Socket.Accept%2A> vor dem Aufrufen von eine eingehende Verbindung akzeptieren <xref:System.Net.Sockets.Socket.Receive%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2445">If you are using a connection-oriented protocol, you must either call <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection prior to calling <xref:System.Net.Sockets.Socket.Receive%2A>.</span></span> <span data-ttu-id="d063a-2446">Die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die vom Remote Host empfangen werden, der in der-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2446">The <xref:System.Net.Sockets.Socket.Receive%2A> method will only read data that arrives from the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2447">Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die-Methode verwenden <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2447">If you are using a connectionless protocol, you can also use the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2448"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ermöglicht das Empfangen von Daten, die von einem beliebigen Host empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2448"><xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will allow you to receive data arriving from any host.</span></span>  
  
 <span data-ttu-id="d063a-2449">Wenn keine Daten zum Lesen verfügbar sind, wird die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis Daten verfügbar sind, es sei denn, ein Timeout Wert wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2449">If no data is available for reading, the <xref:System.Net.Sockets.Socket.Receive%2A> method will block until data is available, unless a time-out value was set by using <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2450">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Receive%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2450">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2451">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.Receive%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2451">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2452">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2452">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-2453">Siehe folgende Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-2453">See Remarks below.</span></span> <span data-ttu-id="d063a-2454">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2454">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2455">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2455">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2456">Wenn Sie ein Verbindungs orientiertes verwenden <xref:System.Net.Sockets.Socket> , liest die- <xref:System.Net.Sockets.Socket.Receive%2A> Methode so viele Daten wie verfügbar, bis zur Anzahl der Bytes, die durch den size-Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2456">If you are using a connection-oriented <xref:System.Net.Sockets.Socket>, the <xref:System.Net.Sockets.Socket.Receive%2A> method will read as much data as is available, up to the number of bytes specified by the size parameter.</span></span> <span data-ttu-id="d063a-2457">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.Receive%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2457">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.Receive%2A> method will complete immediately and return zero bytes.</span></span>  
  
 <span data-ttu-id="d063a-2458">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm in der Warteschlange von der Zieladresse, die Sie in der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2458">If you are using a connectionless <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> will read the first queued datagram from the destination address you specify in the <xref:System.Net.Sockets.Socket.Connect%2A> method.</span></span> <span data-ttu-id="d063a-2459">Wenn das Datagramm, das Sie empfangen, größer als die Größe des `buffer` Parameters ist, `buffer` mit dem ersten Teil der Nachricht gefüllt wird, gehen die Daten verloren, und <xref:System.Net.Sockets.SocketException> es wird eine ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2459">If the datagram you receive is larger than the size of the `buffer` parameter, `buffer` gets filled with the first part of the message, the excess data is lost and a <xref:System.Net.Sockets.SocketException> is thrown.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2460">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2460">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2461">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2461">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2462">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2462">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2463">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2463">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2464"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2464"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2465"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2465"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2466">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2466">-or-</span></span> 
 <span data-ttu-id="d063a-2467"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2467"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-2468">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2468">-or-</span></span> 
 <span data-ttu-id="d063a-2469"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2469"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2470">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2470">-or-</span></span> 
 <span data-ttu-id="d063a-2471"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-2471"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2472"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2472"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-2473">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2473">-or-</span></span> 
<span data-ttu-id="d063a-2474">Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft ist nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2474">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property is not set.</span></span>  
  
<span data-ttu-id="d063a-2475">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2475">-or-</span></span> 
<span data-ttu-id="d063a-2476">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-2476">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2477">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2477">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2478">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2478">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-2479">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-2479">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-2480">Startet eine asynchrone Anforderung, um Daten von einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2480">Begins an asynchronous request to receive data from a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="d063a-2481"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2481"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-2482">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2482">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-2483"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2483"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-2484">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2484">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2485">Die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> -Methode wird für verbundene Sockets oder gebundene verbindungslose Sockets verwendet und zum Lesen eingehender Daten verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2485">The <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method is used on connected sockets or bound connectionless sockets and is used to read incoming data.</span></span> <span data-ttu-id="d063a-2486">Die lokale Adresse des Sockets muss bekannt sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2486">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="d063a-2487">Für gebundene verbindungslose Sockets schränkt diese Funktion die Adressen ein, von denen empfangene Nachrichten akzeptiert werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2487">For bound connectionless sockets, this function restricts the addresses from which received messages are accepted.</span></span> <span data-ttu-id="d063a-2488">Die-Funktion gibt nur Nachrichten von der in der Verbindung angegebenen Remote Adresse zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2488">The function only returns messages from the remote address specified in the connection.</span></span> <span data-ttu-id="d063a-2489">Nachrichten von anderen Adressen werden automatisch verworfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2489">Messages from other addresses are silently discarded.</span></span>  
  
 <span data-ttu-id="d063a-2490">Die-Eigenschaft des- <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> `e` Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Lese Anforderung bereit.</span><span class="sxs-lookup"><span data-stu-id="d063a-2490">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="d063a-2491">Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d063a-2491">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d063a-2492">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-2492">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="d063a-2493"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d063a-2493"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="d063a-2494"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist</span><span class="sxs-lookup"><span data-stu-id="d063a-2494"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="d063a-2495"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist</span><span class="sxs-lookup"><span data-stu-id="d063a-2495"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-2496">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2496">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-2497">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2497">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-2498">Bei Bytes im Bytestream werden eingehende Daten in den Puffer eingefügt, bis der Puffer gefüllt wird, die Verbindung geschlossen wird oder die intern gepufferten Daten aufgebraucht sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2498">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span>  
  
 <span data-ttu-id="d063a-2499">Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers, der dem Parameter zugeordnet ist, in den Puffer eingefügt `e` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2499">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer associated with the `e` parameter.</span></span> <span data-ttu-id="d063a-2500">Wenn die Nachricht größer als der Puffer ist, wird der Puffer mit dem ersten Teil der Nachricht gefüllt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2500">If the message is larger than the buffer, the buffer is filled with the first part of the message.</span></span>  
  
 <span data-ttu-id="d063a-2501">Bei Verbindungs orientierten Sockets kann die- <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methode die ordnungsgemäße Beendigung der virtuellen Verbindung auf eine von zwei Arten angeben, die davon abhängen, ob der Socket ein Bytestream oder eine Nachrichten orientierte ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2501">For connection-oriented sockets, the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> method can indicate the graceful termination of the virtual circuit in one of two ways that depend on whether the socket is byte stream or message oriented.</span></span> <span data-ttu-id="d063a-2502">Bei Bytestreams geben NULL Bytes, die gelesen wurden, eine ordnungsgemäße Sperre an, und es werden nie mehr Bytes gelesen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2502">For byte streams, zero bytes having been read indicates graceful closure and that no more bytes will ever be read.</span></span> <span data-ttu-id="d063a-2503">Bei Nachrichten orientierten Sockets, bei denen eine Meldung mit dem Wert 0 (null) häufig zulässig ist, wird ein-Wert, <xref:System.Net.Sockets.SocketException> der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den nativen Winsock-wsaediscon-Fehlercode (10101) festgelegt ist, zum ordnungsgemäßen schließen verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2503">For message-oriented sockets, where a zero byte message is often allowable, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEDISCON error code (10101) is used to indicate graceful closure.</span></span> <span data-ttu-id="d063a-2504">In jedem Fall weist ein-Element, <xref:System.Net.Sockets.SocketException> das <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den systemeigenen Winsock-WSAECONNRESET-Fehlercode (10054) festgelegt ist, darauf hin, dass ein Abbruch aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2504">In any case, a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAECONNRESET error code (10054) indicates an abortive close has occurred.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-2505">Ein Argument war ungültig.</span><span class="sxs-lookup"><span data-stu-id="d063a-2505">An argument was invalid.</span></span> <span data-ttu-id="d063a-2506">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2506">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="d063a-2507">Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="d063a-2507">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-2508">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2508">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-2509">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-2509">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2510">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2510">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2511">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2511">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2512">Ruft einen Wert ab, der die Größe des Empfangspuffers des <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-2512">Gets or sets a value that specifies the size of the receive buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-2513">Ein <see cref="T:System.Int32" />, das die Größe des Empfangspuffer in Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2513">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the receive buffer.</span></span> <span data-ttu-id="d063a-2514">Der Standard ist 8192.</span><span class="sxs-lookup"><span data-stu-id="d063a-2514">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2515">Eine größere Puffergröße reduziert möglicherweise die Anzahl der leeren Bestätigungen (TCP-Pakete ohne Daten Anteil), kann aber auch die Erkennung von Verbindungsproblemen verzögern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2515">A larger buffer size potentially reduces the number of empty acknowledgements (TCP packets with no data portion), but might also delay the recognition of connection difficulties.</span></span> <span data-ttu-id="d063a-2516">Erhöhen Sie ggf. die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine Verbindung mit hoher Bandbreite und hoher Latenz (z. b. einem Satelliten-Breitbandanbieter).</span><span class="sxs-lookup"><span data-stu-id="d063a-2516">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2517">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2517">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2518">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2518">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2519">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2519">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2520">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2520">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-2521">Empfängt ein Datagramm und speichert den Endpunkt der Quelle.</span><span class="sxs-lookup"><span data-stu-id="d063a-2521">Receives a datagram and stores the source endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2522">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2522">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-2523">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2523">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="d063a-2524">Empfängt ein Datagramm im Datenpuffer und speichert den Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2524">Receives a datagram into the data buffer and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-2525">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2525">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2526">Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den- `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2526">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d063a-2527">Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2527">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d063a-2528">Diese Überladung erfordert nur, dass Sie einen Empfangs `buffer` -und einen-Wert bereitstellen, <xref:System.Net.EndPoint> der den Remote Host darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2528">This overload only requires you to provide a receive `buffer`, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d063a-2529">Der Puffer Offset ist standardmäßig 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2529">The buffer offset defaults to 0.</span></span> <span data-ttu-id="d063a-2530">Der Standardwert ist die Länge des `buffer` -Parameters, und der- `socketFlags` Wert ist standardmäßig <xref:System.Net.Sockets.SocketFlags.None> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2530">The size defaults to the length of the `buffer` parameter and the `socketFlags` value defaults to <xref:System.Net.Sockets.SocketFlags.None>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2531">Vor dem Aufrufen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> von müssen Sie das <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2531">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-2532">Andernfalls löst <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2532">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-2533">Bei Verbindungs losen Protokollen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2533">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d063a-2534">Wenn das Datagramm, das Sie empfangen, größer als die Größe von ist `buffer` , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode so `buffer` viel wie möglich mit der Nachricht aufgefüllt und löst eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2534">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2535">Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2535">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d063a-2536">Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einem ausreichend großen Puffer aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2536">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d063a-2537">Wenn keine Daten zum Lesen verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die Methode blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2537">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-2538">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2538">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2539">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2539">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2540">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2540">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2541">Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle bestimmt ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2541">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d063a-2542">Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Remote Host Verbindung übernehmen, indem Sie die- <xref:System.Net.Sockets.Socket.Accept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2542">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2543">Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2543">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2544">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2544">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2545">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ignoriert die-Methode den `remoteEP` -Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-2545">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-2546">Mit Verbindungs orientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten, wie bis zur Größe von verfügbar sind `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2546">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="d063a-2547">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2547">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2548">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2548">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2549">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2549">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2550">Der <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> verwendeten in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss mit dem <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> in der verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A> identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2550">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2551">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2551">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2552">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2552">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2553">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2553">The following code example receives a connectionless datagram from a remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2554"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2554"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2555">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2555">-or-</span></span> 
 <span data-ttu-id="d063a-2556"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2556"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2557">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2557">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2558">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2558">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2559">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2559">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2560">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2560">An array of type <see cref="T:System.Byte" /> that is the storage location for the received data.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2561">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2561">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-2562">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2562">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="d063a-2563">Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> ein Datagramm im Datenpuffer und speichert den Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2563">Receives a datagram into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-2564">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2564">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2565">Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den- `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2565">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d063a-2566">Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2566">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d063a-2567">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, den erforderlichen und einen-Wert bereitstellen, der <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> den Remote Host darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2567">This overload only requires you to provide a receive buffer, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d063a-2568">Der Offset ist standardmäßig 0, und die Größe ist standardmäßig auf die Länge des Puffer Parameters eingestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2568">The offset defaults to 0 and the size defaults to the length of the buffer parameter.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2569">Vor dem Aufrufen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> von müssen Sie das <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2569">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-2570">Andernfalls löst <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2570">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-2571">Bei Verbindungs losen Protokollen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2571">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d063a-2572">Wenn das Datagramm, das Sie empfangen, größer als die Größe von ist `buffer` , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode so `buffer` viel wie möglich mit der Nachricht aufgefüllt und löst eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2572">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2573">Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2573">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d063a-2574">Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einem ausreichend großen Puffer aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2574">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d063a-2575">Wenn keine Daten zum Lesen verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die Methode blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2575">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-2576">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2576">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2577">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2577">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2578">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2578">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2579">Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle bestimmt ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2579">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d063a-2580">Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Remote Host Verbindung übernehmen, indem Sie die- <xref:System.Net.Sockets.Socket.Accept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2580">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2581">Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2581">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2582">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2582">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2583">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ignoriert die-Methode den `remoteEP` -Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-2583">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-2584">Mit Verbindungs orientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten, wie bis zur Größe von verfügbar sind `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2584">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the size of `buffer`.</span></span> <span data-ttu-id="d063a-2585">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2585">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2586">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2586">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2587">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2587">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2588">Der <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> verwendeten in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss mit dem <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> in der verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A> identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2588">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2589">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2589">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2590">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2590">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2591">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2591">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d063a-2592"><xref:System.Net.Sockets.SocketFlags> werden an die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2592"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2593"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2593"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2594">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2594">-or-</span></span> 
 <span data-ttu-id="d063a-2595"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2595"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2596">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2596">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2597">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2597">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2598">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2598">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2599">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2599">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2600">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2600">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2601">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2601">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-2602">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2602">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="d063a-2603">Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> die angegebene Anzahl von Bytes im Datenpuffer und speichert den Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2603">Receives the specified number of bytes into the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-2604">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2604">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2605">Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den- `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2605">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d063a-2606">Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2606">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d063a-2607">Diese Überladung erfordert nur, dass Sie einen Empfangs Puffer, die Anzahl der zu empfangenden Bytes, die erforderliche und eine bereitstellen, die <xref:System.Net.Sockets.SocketFlags> <xref:System.Net.EndPoint> den Remote Host darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2607">This overload only requires you to provide a receive buffer, the number of bytes you want to receive, the necessary <xref:System.Net.Sockets.SocketFlags>, and an <xref:System.Net.EndPoint> that represents the remote host.</span></span> <span data-ttu-id="d063a-2608">Der Puffer Offset ist standardmäßig 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2608">The buffer offset defaults to 0.</span></span>  
  
 <span data-ttu-id="d063a-2609">Bei Verbindungs losen Protokollen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2609">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d063a-2610">Wenn das Datagramm, das Sie empfangen, größer als die Größe von ist `buffer` , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode so `buffer` viel wie möglich mit der Nachricht aufgefüllt und löst eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2610">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2611">Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2611">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d063a-2612">Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einem ausreichend großen Puffer aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2612">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d063a-2613">Wenn keine Daten zum Lesen verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die Methode blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2613">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-2614">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2614">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2615">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2615">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2616">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2616">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2617">Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle bestimmt ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2617">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d063a-2618">Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Remote Host Verbindung übernehmen, indem Sie die- <xref:System.Net.Sockets.Socket.Accept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2618">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2619">Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2619">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2620">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2620">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2621">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ignoriert die-Methode den `remoteEP` -Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-2621">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-2622">Mit Verbindungs orientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten wie verfügbar, die bis zu der Anzahl der Bytes verfügbar sind, die durch den-Parameter angegeben werden `size` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2622">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the number of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d063a-2623">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2623">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2624">Vor dem Aufrufen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> von müssen Sie das <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2624">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-2625">Andernfalls löst <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2625">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2626">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2626">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2627">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2627">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2628">Der <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> verwendeten in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss mit dem <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> in der verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A> identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2628">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2629">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2629">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2630">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2630">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2631">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2631">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d063a-2632">Die Puffergröße und <xref:System.Net.Sockets.SocketFlags> werden an die-Methode übermittelt <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2632">The buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2633"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2633"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2634">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2634">-or-</span></span> 
 <span data-ttu-id="d063a-2635"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2635"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2636"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2636"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2637">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2637">-or-</span></span> 
 <span data-ttu-id="d063a-2638"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2638"><paramref name="size" /> is greater than the length of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2639"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2639"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-2640">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2640">-or-</span></span> 
<span data-ttu-id="d063a-2641">Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2641">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="d063a-2642">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2642">-or-</span></span> 
<span data-ttu-id="d063a-2643">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-2643">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2644">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2644">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-2645">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2645">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags * EndPoint -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2646">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2646">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-2647">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2647">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2648">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2648">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2649">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2649">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-2650">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2650">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <summary><span data-ttu-id="d063a-2651">Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert den Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2651">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-2652">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2652">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2653">Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode liest Daten in den- `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2653">The <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent.</span></span> <span data-ttu-id="d063a-2654">Diese Methode ist nützlich, wenn Sie verbindungslose Datagramme von einem unbekannten Host oder mehreren Hosts empfangen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2654">This method is useful if you intend to receive connectionless datagrams from an unknown host or multiple hosts.</span></span>  
  
 <span data-ttu-id="d063a-2655">Bei Verbindungs losen Protokollen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste in die Warteschlange eingereihte Datagramm, das in den Puffer des lokalen Netzwerks empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2655">With connectionless protocols, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read the first enqueued datagram received into the local network buffer.</span></span> <span data-ttu-id="d063a-2656">Wenn das Datagramm, das Sie empfangen, größer als die Größe von ist `buffer` , <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode so `buffer` viel wie möglich mit der Nachricht aufgefüllt und löst eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2656">If the datagram you receive is larger than the size of `buffer`, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will fill `buffer` with as much of the message as is possible, and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2657">Wenn Sie ein unzuverlässiges Protokoll verwenden, gehen die Daten verloren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2657">If you are using an unreliable protocol, the excess data will be lost.</span></span> <span data-ttu-id="d063a-2658">Wenn Sie ein zuverlässiges Protokoll verwenden, werden die überzähligen Daten vom Dienstanbieter aufbewahrt, und Sie können Sie abrufen, indem Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode mit einem ausreichend großen Puffer aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2658">If you are using a reliable protocol, the excess data will be retained by the service provider and you can retrieve it by calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method with a large enough buffer.</span></span>  
  
 <span data-ttu-id="d063a-2659">Wenn keine Daten zum Lesen verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die Methode blockiert, bis die Daten verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2659">If no data is available for reading, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will block until data is available.</span></span> <span data-ttu-id="d063a-2660">Wenn Sie sich im nicht blockierenden Modus befinden und im Protokollstapel Puffer keine Daten verfügbar sind, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> wird die-Methode sofort beendet, und es wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2660">If you are in non-blocking mode, and there is no data available in the in the protocol stack buffer, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2661">Sie können die- <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft verwenden, um zu bestimmen, ob Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2661">You can use the <xref:System.Net.Sockets.Socket.Available%2A> property to determine if data is available for reading.</span></span> <span data-ttu-id="d063a-2662">Wenn ungleich <xref:System.Net.Sockets.Socket.Available%2A> NULL ist, wiederholen Sie den Empfangsvorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-2662">When <xref:System.Net.Sockets.Socket.Available%2A> is non-zero, retry the receive operation.</span></span>  
  
 <span data-ttu-id="d063a-2663">Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> für verbindungslose Protokolle bestimmt ist, können Sie auch ein Verbindungs orientiertes Protokoll verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2663">Although <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> is intended for connectionless protocols, you can use a connection-oriented protocol as well.</span></span> <span data-ttu-id="d063a-2664">Wenn Sie sich dafür entscheiden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Remote Host Verbindung übernehmen, indem Sie die- <xref:System.Net.Sockets.Socket.Accept%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2664">If you choose to do so, you must first either establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming remote host connection by calling the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-2665">Wenn Sie keine Verbindung einrichten oder akzeptieren, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen, erhalten Sie eine <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2665">If you do not establish or accept a connection before calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method, you will get a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2666">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2666">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span> <span data-ttu-id="d063a-2667">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> ignoriert die-Methode den `remoteEP` -Parameter und empfängt nur Daten vom verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-2667">In either of these cases, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will ignore the `remoteEP` parameter and only receive data from the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-2668">Mit Verbindungs orientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten wie verfügbar, die bis zu dem vom-Parameter angegebenen Byte Umfang verfügbar sind `size` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2668">With connection-oriented sockets, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will read as much data as is available up to the amount of bytes specified by the `size` parameter.</span></span> <span data-ttu-id="d063a-2669">Wenn der Remote Host die <xref:System.Net.Sockets.Socket> Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode herunterfährt und alle verfügbaren Daten empfangen wurden, wird die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode sofort abgeschlossen und gibt NULL Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2669">If the remote host shuts down the <xref:System.Net.Sockets.Socket> connection with the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, and all available data has been Received, the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method will complete immediately and return zero bytes.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2670">Vor dem Aufrufen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> von müssen Sie das <xref:System.Net.Sockets.Socket> mithilfe der-Methode explizit an einen lokalen Endpunkt binden <xref:System.Net.Sockets.Socket.Bind%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2670">Before calling <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, you must explicitly bind the <xref:System.Net.Sockets.Socket> to a local endpoint using the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-2671">Andernfalls löst <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2671">If you do not, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2672">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2672">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2673">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2673">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2674">Der <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> verwendeten in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss mit dem <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> in der verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A> identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2674">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2675">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2675">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2676">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2676">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2677">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remote Host empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2677">The following code example receives a connectionless datagram from a remote host.</span></span> <span data-ttu-id="d063a-2678">Der Offset, die Puffergröße und <xref:System.Net.Sockets.SocketFlags> werden an die- <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2678">The offset, buffer size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2679"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2679"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2680">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2680">-or-</span></span> 
 <span data-ttu-id="d063a-2681"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2681"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2682"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2682"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2683">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2683">-or-</span></span> 
 <span data-ttu-id="d063a-2684"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2684"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-2685">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2685">-or-</span></span> 
 <span data-ttu-id="d063a-2686"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2686"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2687">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2687">-or-</span></span> 
 <span data-ttu-id="d063a-2688"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-2688"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2689"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2689"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-2690">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2690">-or-</span></span> 
<span data-ttu-id="d063a-2691">Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2691">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="d063a-2692">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2692">-or-</span></span> 
<span data-ttu-id="d063a-2693">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2693">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2694">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2694">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-2695">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-2695">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-2696">Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</span><span class="sxs-lookup"><span data-stu-id="d063a-2696">Begins to asynchronously receive data from a specified network device.</span></span></summary>
        <returns><span data-ttu-id="d063a-2697"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2697"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-2698">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2698">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-2699"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2699"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-2700">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2700">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2701">Die- <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Methode wird hauptsächlich verwendet, um Daten auf einem Verbindungs losen Socket zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2701">The <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method is used primarily to receive data on a connectionless socket.</span></span> <span data-ttu-id="d063a-2702">Die lokale Adresse des Sockets muss bekannt sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2702">The socket's local address must be known.</span></span>  
  
 <span data-ttu-id="d063a-2703">Der Aufrufer muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft auf den <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, von dem die Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2703">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="d063a-2704">Die-Eigenschaft des- <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> `e` Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Lese Anforderung bereit.</span><span class="sxs-lookup"><span data-stu-id="d063a-2704">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the read request.</span></span> <span data-ttu-id="d063a-2705">Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="d063a-2705">For more information about how to use this parameter, see <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="d063a-2706">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-2706">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-2707">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2707">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-2708">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2708">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-2709">Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers in den Puffer eingefügt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2709">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="d063a-2710">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.</span><span class="sxs-lookup"><span data-stu-id="d063a-2710">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="d063a-2711">Bei Bytes im Bytestream werden eingehende Daten in den Puffer eingefügt, bis der Puffer gefüllt wird, die Verbindung geschlossen wird oder die intern gepufferten Daten aufgebraucht sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2711">For byte stream-style sockets, incoming data is placed into the buffer until the buffer is filled, the connection is closed, or the internally buffered data is exhausted.</span></span> <span data-ttu-id="d063a-2712">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.</span><span class="sxs-lookup"><span data-stu-id="d063a-2712">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2713"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2713">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-2714">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2714">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-2715">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-2715">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2716">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2716">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2717">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2717">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int * SocketFlags * EndPoint * IPPacketInformation -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" Index="5" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2718">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2718">An array of type <see cref="T:System.Byte" /> that is the storage location for received data.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-2719">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2719">The position in the <paramref name="buffer" /> parameter to store the received data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-2720">Die Anzahl der zu empfangenden Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2720">The number of bytes to receive.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2721">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2721">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-2722">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2722">An <see cref="T:System.Net.EndPoint" />, passed by reference, that represents the remote server.</span></span></param>
        <param name="ipPacketInformation"><span data-ttu-id="d063a-2723">Ein <see cref="T:System.Net.Sockets.IPPacketInformation" />-Objekt, das Adress- und Schnittstelleninformationen enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2723">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> holding address and interface information.</span></span></param>
        <summary><span data-ttu-id="d063a-2724">Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert die Endpunkt- und Paketinformationen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2724">Receives the specified number of bytes of data into the specified location of the data buffer, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="d063a-2725">Die Anzahl der empfangenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2725">The number of bytes received.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2726">Die- <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode liest Daten in den- `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes zurück und erfasst den Remote Host Endpunkt, von dem die Daten gesendet wurden, sowie Informationen über das empfangene Paket.</span><span class="sxs-lookup"><span data-stu-id="d063a-2726">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method reads data into the `buffer` parameter, returns the number of bytes successfully read, and captures the remote host endpoint from which the data was sent, as well as information about the received packet.</span></span>  
  
 <span data-ttu-id="d063a-2727">Die- <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode wird hauptsächlich verwendet, um Nachrichten Daten in einem Verbindungs losen Socket zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2727">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="d063a-2728">Die lokale Adresse des Sockets muss bekannt sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2728">The socket's local address must be known.</span></span> <span data-ttu-id="d063a-2729">Diese Methode kann nur mit Datagramm-und RAW-Sockets verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2729">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="d063a-2730">Der Socket muss mit dem auf oder festgelegten Sockettyp initialisiert werden, <xref:System.Net.Sockets.SocketType.Dgram> <xref:System.Net.Sockets.SocketType.Raw> bevor diese Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2730">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="d063a-2731">Dies kann geschehen, wenn der Socket mithilfe von erstellt wird <xref:System.Net.Sockets.Socket.%23ctor%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2731">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2732">Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht `buffer` bis zur Gesamtgröße, die im-Parameter angegeben ist, in den-Parameter eingefügt `size` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2732">For message-oriented sockets, an incoming message is placed into the `buffer` parameter up to the total size specified in the `size` parameter.</span></span> <span data-ttu-id="d063a-2733">Der- `offset` Parameter bestimmt, wo die `buffer` Daten abgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2733">The `offset` parameter determines where in the `buffer` the data is placed.</span></span> <span data-ttu-id="d063a-2734">Die tatsächliche Datenmenge, die in der eingefügt `buffer` wird, wird von der-Methode zurückgegeben <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2734">The actual amount of data placed into the `buffer` is returned by the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-2735">Die Methode <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> legt die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption beim `true` ersten Aufrufen für einen angegebenen auf die automatische Methode fest <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2735">The <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method automatically method sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-2736">Das zurückgegebene Objekt ist jedoch <xref:System.Net.Sockets.IPPacketInformation> nur für Pakete gültig, die auf dem lokalen Computer eintreffen, nachdem die Socketoption festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2736">However, the returned <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="d063a-2737">Wenn ein Socket Pakete sendet, die zwischen dem Binden an einen lokalen Endpunkt (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine der <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methoden,, <xref:System.Net.Sockets.Socket.SendTo%2A> oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) und dem ersten Aufruf der-Methode gesendet werden <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> , geben Aufrufe der- <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode <xref:System.Net.Sockets.IPPacketInformation> für diese Pakete Ungültige Objekte zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2737">If a socket is sent packets between when it is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and its first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> method will return invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="d063a-2738">Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, sollte eine Anwendung die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf festlegen, `true` bevor Sie mithilfe der-Methode an einen lokalen Endpunkt gebunden wird <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2738">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="d063a-2739">Eine Anwendung kann den Parameter untersuchen, `ipPacketInformation` Wenn Sie wissen muss, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2739">An application can examine the `ipPacketInformation` parameter if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2740">Der <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> verwendeten in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> muss mit dem <xref:System.Net.Sockets.AddressFamily> des <xref:System.Net.EndPoint> in der verwendeten <xref:System.Net.Sockets.Socket.SendTo%2A> identisch sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2740">The <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> needs to match the <xref:System.Net.Sockets.AddressFamily> of the <xref:System.Net.EndPoint> used in <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2741">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2741">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2742">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2742">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2743"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2743"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-2744">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2744">-or-</span></span> 
 <span data-ttu-id="d063a-2745"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2745"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2746"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2746"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2747">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2747">-or-</span></span> 
 <span data-ttu-id="d063a-2748"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2748"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-2749">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2749">-or-</span></span> 
 <span data-ttu-id="d063a-2750"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2750"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-2751">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2751">-or-</span></span> 
 <span data-ttu-id="d063a-2752"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-2752"><paramref name="size" /> is greater than the length of the <paramref name="buffer" /> minus the value of the offset parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2753"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2753"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-2754">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2754">-or-</span></span> 
<span data-ttu-id="d063a-2755">Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2755">The <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" /> property was not set.</span></span>  
  
<span data-ttu-id="d063a-2756">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2756">-or-</span></span> 
<span data-ttu-id="d063a-2757">.NET Framework wird mit einem AMD 64 Bit-Prozessor ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2757">The .NET Framework is running on an AMD 64-bit processor.</span></span>  
  
<span data-ttu-id="d063a-2758">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-2758">-or-</span></span> 
<span data-ttu-id="d063a-2759">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2759">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2760">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2760">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-2761">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-2761">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-2762">Beginnt unter Verwendung der angegebenen <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2762">Begins to asynchronously receive the specified number of bytes of data into the specified location in the data buffer, using the specified <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />, and stores the endpoint and packet information.</span></span></summary>
        <returns><span data-ttu-id="d063a-2763"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2763"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-2764">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-2764">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-2765"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2765"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-2766">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2766">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2767">Die- <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode wird hauptsächlich verwendet, um Nachrichten Daten in einem Verbindungs losen Socket zu empfangen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2767">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method is used primarily to receive message data on a connectionless socket.</span></span> <span data-ttu-id="d063a-2768">Die lokale Adresse des Sockets muss bekannt sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2768">The socket's local address must be known.</span></span> <span data-ttu-id="d063a-2769">Diese Methode kann nur mit Datagramm-und RAW-Sockets verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2769">This method can only be used with datagram and raw sockets.</span></span> <span data-ttu-id="d063a-2770">Der Socket muss mit dem auf oder festgelegten Sockettyp initialisiert werden, <xref:System.Net.Sockets.SocketType.Dgram> <xref:System.Net.Sockets.SocketType.Raw> bevor diese Methode aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2770">The socket must be initialized with the socket type set to <xref:System.Net.Sockets.SocketType.Dgram> or <xref:System.Net.Sockets.SocketType.Raw> before calling this method.</span></span> <span data-ttu-id="d063a-2771">Dies kann geschehen, wenn der Socket mithilfe von erstellt wird <xref:System.Net.Sockets.Socket.%23ctor%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2771">This can be done when the socket is constructed using <xref:System.Net.Sockets.Socket.%23ctor%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2772">Der Aufrufer muss die- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft auf den <xref:System.Net.IPEndPoint> des Remote Hosts festlegen, von dem die Daten empfangen werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2772">The caller must set the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property to the <xref:System.Net.IPEndPoint> of the remote host from which the data is to be received.</span></span>  
  
 <span data-ttu-id="d063a-2773">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-2773">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-2774">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2774">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-2775">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2775">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-2776">Bei Nachrichten orientierten Sockets wird eine eingehende Nachricht bis zur Gesamtgröße des Puffers in den Puffer eingefügt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2776">For message-oriented sockets, an incoming message is placed into the buffer up to the total size of the buffer.</span></span> <span data-ttu-id="d063a-2777">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft und die-Eigenschaft <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> bestimmen, wo die Daten im Puffer abgelegt werden, und die Datenmenge.</span><span class="sxs-lookup"><span data-stu-id="d063a-2777">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> properties determine where in the buffer the data is placed and the amount of data.</span></span>  
  
 <span data-ttu-id="d063a-2778">Die- <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode legt die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption automatisch auf fest, wenn `true` Sie zum ersten Mal für eine bestimmte aufgerufen wird <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2778">The <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method automatically sets the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to `true` the first time it is called for a given <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-2779">Das-Objekt ist jedoch <xref:System.Net.Sockets.IPPacketInformation> nur für Pakete gültig, die auf dem lokalen Computer eintreffen, nachdem die Socketoption festgelegt wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2779">However, the <xref:System.Net.Sockets.IPPacketInformation> object will only be valid for packets which arrive at the local computer after the socket option has been set.</span></span> <span data-ttu-id="d063a-2780">Wenn ein Socket Pakete zwischen dem Zeitpunkt, an dem der Socket an einen lokalen Endpunkt gebunden ist (explizit durch die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine der <xref:System.Net.Sockets.Socket.Connect%2A> Methoden,, <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendTo%2A> oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> ) und dem ersten Aufruf der-Methode gesendet wird <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> , führen Aufrufe der-Methode zu <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> ungültigen <xref:System.Net.Sockets.IPPacketInformation> Objekten für diese Pakete.</span><span class="sxs-lookup"><span data-stu-id="d063a-2780">If a socket is sent packets between when the socket is bound to a local endpoint (explicitly by the <xref:System.Net.Sockets.Socket.Bind%2A> method or implicitly by one of the <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A> methods) and the first call to the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method, calls to <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> method will result in invalid <xref:System.Net.Sockets.IPPacketInformation> objects for these packets.</span></span>  
  
 <span data-ttu-id="d063a-2781">Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, sollte eine Anwendung die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf festlegen, `true` bevor Sie mithilfe der-Methode an einen lokalen Endpunkt gebunden wird <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2781">To ensure that all <xref:System.Net.Sockets.IPPacketInformation> objects are valid, an application should set the <xref:System.Net.Sockets.SocketOptionName.PacketInformation> socket option to`true` before it is bound to a local endpoint using the <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> method.</span></span>  
  
 <span data-ttu-id="d063a-2782">Eine Anwendung kann die resultierenden Objekte untersuchen, <xref:System.Net.Sockets.IPPacketInformation> Wenn Sie wissen muss, ob das Datagramm mithilfe einer Unicast-, Multicast-oder Broadcast Adresse gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-2782">An application can examine the resulting <xref:System.Net.Sockets.IPPacketInformation> objects if it needs to know if the datagram was sent using a unicast, multicast, or broadcast address.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2783"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-2783">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-2784">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-2784">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2785">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2785">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2786">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2786">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2787">Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Aufrufs angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-2787">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Receive" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="d063a-2788">Der Timeoutwert in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2788">The time-out value, in milliseconds.</span></span> <span data-ttu-id="d063a-2789">Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an.</span><span class="sxs-lookup"><span data-stu-id="d063a-2789">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="d063a-2790">Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2790">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2791">Diese Option gilt nur für synchrone <xref:System.Net.Sockets.Socket.Receive%2A> Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="d063a-2791">This option applies to synchronous <xref:System.Net.Sockets.Socket.Receive%2A> calls only.</span></span> <span data-ttu-id="d063a-2792">Wenn der Timeout Zeitraum überschritten wird, löst die <xref:System.Net.Sockets.Socket.Receive%2A> Methode eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2792">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Receive%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2793">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-2793">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2794">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2794">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2795">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2795">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-2796">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="d063a-2796">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="C#" Value="public System.Net.EndPoint? RemoteEndPoint { get; }" FrameworkAlternate="net-5.0" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2797">Ruft den Remoteendpunkt ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-2797">Gets the remote endpoint.</span></span></summary>
        <value><span data-ttu-id="d063a-2798">Der <see cref="T:System.Net.EndPoint" />, mit dem der <see cref="T:System.Net.Sockets.Socket" /> kommuniziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2798">The <see cref="T:System.Net.EndPoint" /> with which the <see cref="T:System.Net.Sockets.Socket" /> is communicating.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2799">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, ruft die- <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Eigenschaft den ab, der <xref:System.Net.EndPoint> die Remote-IP-Adresse und die Portnummer enthält, mit der die <xref:System.Net.Sockets.Socket> verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-2799">If you are using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> property gets the <xref:System.Net.EndPoint> that contains the remote IP address and port number to which the <xref:System.Net.Sockets.Socket> is connected.</span></span> <span data-ttu-id="d063a-2800">Wenn Sie ein verbindungsloses Protokoll verwenden, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> enthält die Standard-Remote-IP-Adresse und die Portnummer, mit der <xref:System.Net.Sockets.Socket> kommuniziert.</span><span class="sxs-lookup"><span data-stu-id="d063a-2800">If you are using a connectionless protocol, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> contains the default remote IP address and port number with which the <xref:System.Net.Sockets.Socket> will communicate.</span></span> <span data-ttu-id="d063a-2801">Sie müssen diesen <xref:System.Net.EndPoint> in einen umwandeln, <xref:System.Net.IPEndPoint> bevor Sie Informationen abrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2801">You must cast this <xref:System.Net.EndPoint> to an <xref:System.Net.IPEndPoint> before retrieving any information.</span></span> <span data-ttu-id="d063a-2802">Sie können dann die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> -Methode aufrufen, um die Remote <xref:System.Net.IPAddress> -Portnummer abzurufen, und die- <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode zum Abrufen der Remote Portnummer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2802">You can then call the <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> method to retrieve the remote <xref:System.Net.IPAddress>, and the <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> method to retrieve the remote port number.</span></span>  
  
 <span data-ttu-id="d063a-2803">Der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> wird nach einem-oder-Aufrufsatz festgelegt <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2803">The <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> is set after a call to either <xref:System.Net.Sockets.Socket.Accept%2A> or <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2804">Wenn Sie zuvor versuchen, auf diese Eigenschaft zuzugreifen, löst <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2804">If you try to access this property earlier, <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2805">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2805">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2806">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2806">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2807">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2807">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2808">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2808">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2809">Im folgenden Codebeispiel werden die lokalen und Remote Endpunkte abgerufen und angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2809">The following code example retrieves and displays the local and remote endpoints.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2810">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2810">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2811">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2811">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="SafeHandle">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SafeSocketHandle SafeHandle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SafeSocketHandle SafeHandle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SafeHandle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SafeHandle As SafeSocketHandle" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SafeSocketHandle ^ SafeHandle { System::Net::Sockets::SafeSocketHandle ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.SafeHandle : System.Net.Sockets.SafeSocketHandle" Usage="System.Net.Sockets.Socket.SafeHandle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SafeSocketHandle</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-2812">Ruft ein <see cref="T:System.Net.Sockets.SafeSocketHandle" /> ab, das den Sockethandle darstellt, der vom aktuellen <see cref="T:System.Net.Sockets.Socket" />-Objekt gekapselt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2812">Gets a <see cref="T:System.Net.Sockets.SafeSocketHandle" /> that represents the socket handle that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></summary>
        <value><span data-ttu-id="d063a-2813">Ein Sockethandle, das auf sichere Weise für den Socket verfügbar gemacht wird, den das aktuelle- <see cref="T:System.Net.Sockets.Socket" /> Objekt kapselt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2813">A socket handle exposed in a safe manner for the socket that the current <see cref="T:System.Net.Sockets.Socket" /> object encapsulates.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  

> [!IMPORTANT]
> <span data-ttu-id="d063a-2814">Das <xref:System.Net.Sockets.SafeSocketHandle> direkte Arbeiten mit dem Socket kann zu einem nicht dokumentierten Status führen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2814">Using the <xref:System.Net.Sockets.SafeSocketHandle> to operate on the socket directly may result in an undocumented state.</span></span> 

         ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="checkError" Type="System.Collections.IList" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="microSeconds" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="checkRead"><span data-ttu-id="d063a-2815">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob sie gelesen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2815">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for readability.</span></span></param>
        <param name="checkWrite"><span data-ttu-id="d063a-2816">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob in sie geschrieben werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-2816">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for writability.</span></span></param>
        <param name="checkError"><span data-ttu-id="d063a-2817">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, die auf Fehler überprüft werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2817">An <see cref="T:System.Collections.IList" /> of <see cref="T:System.Net.Sockets.Socket" /> instances to check for errors.</span></span></param>
        <param name="microSeconds"><span data-ttu-id="d063a-2818">Der Timeoutwert in Mikrosekunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2818">The time-out value, in microseconds.</span></span> <span data-ttu-id="d063a-2819">Ein Wert von -1 gibt ein unendliches Timeout an.</span><span class="sxs-lookup"><span data-stu-id="d063a-2819">A -1 value indicates an infinite time-out.</span></span></param>
        <summary><span data-ttu-id="d063a-2820">Bestimmt den Status von einem oder mehreren Sockets.</span><span class="sxs-lookup"><span data-stu-id="d063a-2820">Determines the status of one or more sockets.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2821"><xref:System.Net.Sockets.Socket.Select%2A> ist eine statische Methode, die den Status von mindestens einer <xref:System.Net.Sockets.Socket> Instanz bestimmt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2821"><xref:System.Net.Sockets.Socket.Select%2A> is a static method that determines the status of one or more <xref:System.Net.Sockets.Socket> instances.</span></span> <span data-ttu-id="d063a-2822">Sie müssen eine oder mehrere Sockets in einen platzieren, <xref:System.Collections.IList> bevor Sie die- <xref:System.Net.Sockets.Socket.Select%2A> Methode verwenden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-2822">You must place one or more sockets into an <xref:System.Collections.IList> before you can use the <xref:System.Net.Sockets.Socket.Select%2A> method.</span></span> <span data-ttu-id="d063a-2823">Überprüfen Sie die Lesbarkeit, indem Sie <xref:System.Net.Sockets.Socket.Select%2A> mit <xref:System.Collections.IList> als-Parameter aufrufen `checkRead` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2823">Check for readability by calling <xref:System.Net.Sockets.Socket.Select%2A> with the <xref:System.Collections.IList> as the `checkRead` parameter.</span></span> <span data-ttu-id="d063a-2824">Verwenden Sie den-Parameter, um die Sockets auf die Schreib barkeit zu überprüfen `checkWrite` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2824">To check your sockets for writability, use the `checkWrite` parameter.</span></span> <span data-ttu-id="d063a-2825">Verwenden Sie zum Erkennen von Fehlerbedingungen `checkError` .</span><span class="sxs-lookup"><span data-stu-id="d063a-2825">For detecting error conditions, use `checkError`.</span></span> <span data-ttu-id="d063a-2826">Nachdem aufgerufen <xref:System.Net.Sockets.Socket.Select%2A> wurde, <xref:System.Collections.IList> wird der mit nur den Sockets aufgefüllt, die die Bedingungen erfüllen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2826">After calling <xref:System.Net.Sockets.Socket.Select%2A>, the <xref:System.Collections.IList> will be filled with only those sockets that satisfy the conditions.</span></span>  
  
 <span data-ttu-id="d063a-2827">Wenn Sie sich im Zustand "lauschen" befinden, bedeutet die Lesbarkeit, dass ein-Rückruf <xref:System.Net.Sockets.Socket.Accept%2A> ohne Blockierung erfolgreich ausgeführt werden kann.</span><span class="sxs-lookup"><span data-stu-id="d063a-2827">If you are in a listening state, readability means that a call to <xref:System.Net.Sockets.Socket.Accept%2A> will succeed without blocking.</span></span> <span data-ttu-id="d063a-2828">Wenn Sie die Verbindung bereits angenommen haben, bedeutet die Lesbarkeit, dass Daten zum Lesen verfügbar sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-2828">If you have already accepted the connection, readability means that data is available for reading.</span></span> <span data-ttu-id="d063a-2829">In diesen Fällen werden alle Empfangs Vorgänge ohne Blockierung erfolgreich ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2829">In these cases, all receive operations will succeed without blocking.</span></span> <span data-ttu-id="d063a-2830">Die Lesbarkeit kann auch angeben, ob die Remote <xref:System.Net.Sockets.Socket> Verbindung von der Remote Verbindung beendet wurde. in diesem Fall wird ein-Rückruf <xref:System.Net.Sockets.Socket.Receive%2A> sofort zurückgegeben, wobei null Bytes zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2830">Readability can also indicate whether the remote <xref:System.Net.Sockets.Socket> has shut down the connection; in that case a call to <xref:System.Net.Sockets.Socket.Receive%2A> will return immediately, with zero bytes returned.</span></span>  
  
 <span data-ttu-id="d063a-2831"><xref:System.Net.Sockets.Socket.Select%2A> Gibt zurück, wenn mindestens eine der zu berücksichtigenden Sockets (die Sockets in den `checkRead` `checkWrite` Listen, und `checkError` ) den angegebenen Kriterien entsprechen oder der `microSeconds` Parameter überschritten wird, je nachdem, welcher Wert zuerst eintritt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2831"><xref:System.Net.Sockets.Socket.Select%2A> returns when at least one of the sockets of interest (the sockets in the `checkRead`, `checkWrite`, and `checkError` lists) meets its specified criteria, or the `microSeconds` parameter is exceeded, whichever comes first.</span></span> <span data-ttu-id="d063a-2832">`microSeconds`Wenn Sie auf-1 festlegen, wird ein unendliches Timeout angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2832">Setting `microSeconds` to -1 specifies an infinite time-out.</span></span>  
  
 <span data-ttu-id="d063a-2833">Wenn Sie einen nicht blockierenden-aufrufmachen <xref:System.Net.Sockets.Socket.Connect%2A> , bedeutet Schreibbarkeit, dass Sie erfolgreich eine Verbindung hergestellt haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-2833">If you make a nonblocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, writability means that you have connected successfully.</span></span> <span data-ttu-id="d063a-2834">Wenn Sie bereits eine Verbindung hergestellt haben, bedeutet die Schreib barkeit, dass alle Sende Vorgänge ohne Blockierung erfolgreich ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2834">If you already have a connection established, writability means that all send operations will succeed without blocking.</span></span>  
  
 <span data-ttu-id="d063a-2835">Wenn Sie einen nicht blockierenden-Aufrufe von vorgenommen haben <xref:System.Net.Sockets.Socket.Connect%2A> , `checkerror` identifiziert der-Parameter Sockets, die nicht erfolgreich verbunden wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2835">If you have made a non-blocking call to <xref:System.Net.Sockets.Socket.Connect%2A>, the `checkerror` parameter identifies sockets that have not connected successfully.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2836">Verwenden Sie die- <xref:System.Net.Sockets.Socket.Poll%2A> Methode, wenn Sie nur den Status eines einzelnen bestimmen möchten <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2836">Use the <xref:System.Net.Sockets.Socket.Poll%2A> method if you only want to determine the status of a single <xref:System.Net.Sockets.Socket>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2837">Diese Methode kann bestimmte Arten von Verbindungsproblemen, wie z. b. ein fehlerhaftes Netzwerkkabel, nicht erkennen, oder der Remote Host wurde nicht ordnungsgemäß heruntergefahren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2837">This method cannot detect certain kinds of connection problems, such as a broken network cable, or that the remote host was shut down ungracefully.</span></span> <span data-ttu-id="d063a-2838">Sie müssen versuchen, Daten zu senden oder zu empfangen, um diese Arten von Fehlern zu erkennen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2838">You must attempt to send or receive data to detect these kinds of errors.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2839">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2839">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2840">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2840">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2841">Im folgenden Codebeispiel wird verwendet <xref:System.Net.Sockets.Socket.Select%2A> , um zu bestimmen, welche Abhör Sockets eine Verbindungsanforderung aufweisen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2841">The following code example uses <xref:System.Net.Sockets.Socket.Select%2A> to determine which listening sockets have a connection request.</span></span>  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2842">Der <paramref name="checkRead" />-Parameter ist <see langword="null" /> oder leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2842">The <paramref name="checkRead" /> parameter is <see langword="null" /> or empty.</span></span>  
  
<span data-ttu-id="d063a-2843">- und -</span><span class="sxs-lookup"><span data-stu-id="d063a-2843">-and-</span></span> 
<span data-ttu-id="d063a-2844">Der <paramref name="checkWrite" />-Parameter ist <see langword="null" /> oder leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2844">The <paramref name="checkWrite" /> parameter is <see langword="null" /> or empty</span></span> 
<span data-ttu-id="d063a-2845">- und -</span><span class="sxs-lookup"><span data-stu-id="d063a-2845">-and-</span></span> 
<span data-ttu-id="d063a-2846">Der <paramref name="checkError" />-Parameter ist <see langword="null" /> oder leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2846">The <paramref name="checkError" /> parameter is <see langword="null" /> or empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2847">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2847">An error occurred when attempting to access the socket.</span></span></exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-2848">Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2848">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2849">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2849">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="d063a-2850">Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2850">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2851">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2851">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2852"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode angegeben ist, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2852"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-2853"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2853"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-2854">Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2854">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="d063a-2855">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist 0, der Puffer Offset standardmäßig 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2855">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>  
  
 <span data-ttu-id="d063a-2856">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2856">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2857">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2857">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-2858">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2858">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-2859">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie vor jedem-Befehl aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2859">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-2860">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2860">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2861">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2861">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2862">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2862">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2863">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2863">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2864">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn der Wert weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2864">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-2865">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2865">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-2866">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2866">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-2867">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2867">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-2868">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2868">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2869">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2869">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2870">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2870">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2871">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2871">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-2872">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2872">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2873">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2873">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2874">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2874">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2875">Im folgenden Codebeispiel wird das Senden von Daten auf einem verbundenen veranschaulicht <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2875">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2876"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2876"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2877">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2877">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2878">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2878">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-2879">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2879">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="d063a-2880">Sendet den Satz der Puffer in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2880">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2881">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2881">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2882"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2882"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-2883">Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2883">This overload requires at least one buffer that contains the data you want to send.</span></span>  
  
 <span data-ttu-id="d063a-2884">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2884">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2885">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2885">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-2886">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2886">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-2887">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie vor jedem-Befehl aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2887">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-2888">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2888">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2889">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2889">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2890">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2890">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2891">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2891">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2892">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn der Wert weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2892">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-2893">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2893">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-2894">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2894">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-2895">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2895">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-2896">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2896">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2897">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2897">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2898">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2898">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2899">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2899">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-2900">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2900">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2901">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2901">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2902">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2902">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2903"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2903"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-2904"><paramref name="buffers" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2904"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2905">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2905">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-2906">Weitere Informationen finden Sie unten im Abschnitt Hinweise.</span><span class="sxs-lookup"><span data-stu-id="d063a-2906">See remarks section below.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2907">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2907">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2908">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2908">A span of bytes that contains the data to be sent.</span></span></param>
        <summary><span data-ttu-id="d063a-2909">Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2909">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2910">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2910">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="d063a-2911"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode angegeben ist, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2911"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-2912"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2912"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="d063a-2913">Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2913">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="d063a-2914">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist 0, der Puffer Offset standardmäßig 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2914">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="d063a-2915">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2915">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2916">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2916">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="d063a-2917">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2917">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-2918">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-Rückruf aufgerufen werden <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2918">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-2919">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2919">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2920">Sie können den Standard-Remote Host auch vor Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von durchführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2920">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="d063a-2921">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2921">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2922">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2922">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2923">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn der Wert weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2923">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-2924">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2924">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-2925">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2925">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-2926">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2926">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-2927">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2927">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="d063a-2928">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2928">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2929">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2929">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="d063a-2930">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2930">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2931">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2931">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>

> [!IMPORTANT]
><span data-ttu-id="d063a-2932">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2932">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-2933">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2933">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2934">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2934">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2935">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2935">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-2936">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-2936">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2937">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2937">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2938">Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2938">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2939">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2939">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2940"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode eingerichtet wurde, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-2940"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-2941">Die <xref:System.Net.Sockets.Socket.Send%2A> -Methode kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2941">The <xref:System.Net.Sockets.Socket.Send%2A> method can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-2942">Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten, und eine bitweise Kombination von <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2942">This overload requires a buffer that contains the data you want to send and a bitwise combination of <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d063a-2943">Der Puffer Offset ist standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers eingestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2943">The buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span> <span data-ttu-id="d063a-2944">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameterwert angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2944">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter value, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-2945">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2945">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2946">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2946">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-2947">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2947">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-2948">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-Aufrufvorgang die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2948">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-2949">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2949">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2950">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2950">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2951">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2951">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2952">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2952">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2953">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn der Wert weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2953">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-2954">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2954">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-2955">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2955">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-2956">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2956">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-2957">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2957">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2958">Sie müssen sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2958">You must ensure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-2959">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2959">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2960">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2960">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2961">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2961">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2962">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2962">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-2963">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2963">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2964">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2964">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2965">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2965">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-2966">Im folgenden Codebeispiel wird das Senden von Daten auf einem verbundenen veranschaulicht <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2966">The following code example demonstrates sending data on a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2967"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2967"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2968">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2968">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2969">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2969">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-2970">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2970">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-2971">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-2971">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-2972">Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2972">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-2973">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-2973">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-2974">Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2974">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="d063a-2975">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-2975">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="d063a-2976">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketFlags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2976">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-2977">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2977">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2978">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2978">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-2979">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2979">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-2980">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie vor jedem-Befehl aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2980">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-2981">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2981">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-2982">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2982">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-2983">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2983">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-2984">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-2984">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-2985">Im Modus, der nicht blockiert wird, wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2985">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-2986">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-2986">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-2987">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2987">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-2988">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-2988">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-2989">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-2989">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2990">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-2990">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-2991">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-2991">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2992">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-2992">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-2993">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-2993">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-2994">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-2994">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-2995">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-2995">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-2996"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-2996"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-2997"><paramref name="buffers" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-2997"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-2998">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2998">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-2999">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-2999">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3000">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3000">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3001">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3001">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <summary><span data-ttu-id="d063a-3002">Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3002">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3003">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3003">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  

  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3004">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3004">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3005">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3005">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3006">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3006">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-3007">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3007">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3008">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3008">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-3009">Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3009">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3010">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3010">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="d063a-3011"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode eingerichtet wurde, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-3011"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host established in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-3012"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3012"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="d063a-3013">Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten, die Anzahl der zu sendenden Bytes und eine bitweise Kombination von Any <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3013">This overload requires a buffer that contains the data you want to send, the number of bytes you want to send, and a bitwise combination of any <xref:System.Net.Sockets.SocketFlags>.</span></span> <span data-ttu-id="d063a-3014">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3014">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you're sending won't be routed.</span></span>

<span data-ttu-id="d063a-3015">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3015">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3016">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3016">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="d063a-3017">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3017">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3018">Wenn Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode für die Methode nicht benötigen, müssen Sie die-Methode aufrufen, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie die- <xref:System.Net.Sockets.Socket.Send%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3018">If you don'tuse the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call the <xref:System.Net.Sockets.Socket.Connect%2A> method before each call to the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d063a-3019">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3019">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-3020">Sie können den Standard-Remote Host auch vor Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von durchführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3020">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="d063a-3021">Mit einem Verbindungs orientierten Protokoll blockiert, <xref:System.Net.Sockets.Socket.Send%2A> bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3021">With a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3022">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3022">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3023">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn die Anzahl der von Ihnen angeforderten Bytes kleiner ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3023">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d063a-3024">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3024">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-3025">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3025">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3026">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3026">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3027">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3027">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
> <span data-ttu-id="d063a-3028">Sie müssen sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3028">You must ensure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3029">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3029">If it does, the datagram won't be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3030">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3030">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3031">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3031">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="d063a-3032">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3032">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3033">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3033">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>

> [!IMPORTANT]
><span data-ttu-id="d063a-3034">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3034">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-3035">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3035">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

## Examples

<span data-ttu-id="d063a-3036">Das folgende Codebeispiel sendet die Daten, die im Puffer gefunden werden, und gibt <xref:System.Net.Sockets.SocketFlags.None> für an <xref:System.Net.Sockets.SocketFlags> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3036">The following code example sends the data found in buffer, and specifies <xref:System.Net.Sockets.SocketFlags.None> for <xref:System.Net.Sockets.SocketFlags>.</span></span>

[!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
[!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
[!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3037"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3037"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3038"><paramref name="size" /> ist größer als 0 oder übersteigt die Puffergröße.</span><span class="sxs-lookup"><span data-stu-id="d063a-3038"><paramref name="size" /> is less than 0 or exceeds the size of the buffer.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3039"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3039"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-3040">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3040">-or-</span></span> 
<span data-ttu-id="d063a-3041">Beim Zugriff auf den Socket ist ein Fehler auf Betriebssystemebene aufgetreten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3041">An operating system error occurs while accessing the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3042">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3042">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt;? buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte)), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.CLSCompliant(false)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.CLSCompliant(false)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffers"><span data-ttu-id="d063a-3043">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3043">A list of <see cref="T:System.ArraySegment`1" />s of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3044">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3044">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-3045">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3045">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-3046">Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3046">Sends the set of buffers in the list to a connected <see cref="T:System.Net.Sockets.Socket" />, using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3047">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3047">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3048">Diese Überladung erfordert mindestens einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3048">This overload requires at least one buffer that contains the data you want to send.</span></span> <span data-ttu-id="d063a-3049">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3049">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span> <span data-ttu-id="d063a-3050">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketFlags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3050">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketFlags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3051">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3051">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3052">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3052">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-3053">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3053">If you are using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3054">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie vor jedem-Befehl aufruft <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3054">If you do not use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-3055">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3055">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-3056">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3056">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-3057">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3057">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3058">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3058">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3059">Im Modus, der nicht blockiert wird, wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3059">In non-blocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-3060">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3060">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-3061">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3061">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3062">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3062">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3063">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3063">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3064">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3064">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3065">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3065">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3066">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3066">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-3067">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3067">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3068">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3068">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3069">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3069">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3070"><paramref name="buffers" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3070"><paramref name="buffers" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-3071"><paramref name="buffers" /> ist leer.</span><span class="sxs-lookup"><span data-stu-id="d063a-3071"><paramref name="buffers" /> is empty.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3072">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3072">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3073">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3073">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte), socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3074">Eins Spanne von Bytes, die die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3074">A span of bytes that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3075">Eine bitweise Kombination der Enumerationswerte, die das Sende- und Empfangsverhalten angeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3075">A bitwise combination of the enumeration values that specifies send and receive behaviors.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-3076">Diese Methode gibt einen der Enumerationswerte zurück, der Fehlercodes für den Socket definiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3076">When this method returns, contains one of the enumeration values that defines error codes for the socket.</span></span></param>
        <summary><span data-ttu-id="d063a-3077">Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3077">Sends data to a connected <see cref="T:System.Net.Sockets.Socket" /> using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3078">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3078">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="d063a-3079"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode angegeben ist, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-3079"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-3080"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3080"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>

<span data-ttu-id="d063a-3081">Diese Überladung erfordert einen Puffer, der die Daten enthält, die Sie senden möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3081">This overload requires a buffer that contains the data you want to send.</span></span> <span data-ttu-id="d063a-3082">Der <xref:System.Net.Sockets.SocketFlags> Standardwert ist 0, der Puffer Offset standardmäßig 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des Puffers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3082">The <xref:System.Net.Sockets.SocketFlags> value defaults to 0, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the buffer.</span></span>

<span data-ttu-id="d063a-3083">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3083">If you're using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3084">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3084">If you're using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>

<span data-ttu-id="d063a-3085">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3085">If you're using a connectionless protocol and plan to send data to several different hosts, you should use the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3086">Wenn Sie die-Methode nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-Rückruf aufgerufen werden <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3086">If you don't use the <xref:System.Net.Sockets.Socket.SendTo%2A> method, you'll have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-3087">Sie können auch dann verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3087">You can use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you've established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-3088">Sie können den Standard-Remote Host auch vor Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von durchführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3088">You can also change the default remote host before calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>

<span data-ttu-id="d063a-3089">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3089">If you're using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until all of the bytes in the buffer are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3090">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3090">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3091">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn der Wert weniger als die Anzahl der Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3091">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes in the buffer.</span></span> <span data-ttu-id="d063a-3092">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3092">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the bytes in the buffer.</span></span> <span data-ttu-id="d063a-3093">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3093">There's also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3094">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3094">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3095">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3095">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>

> [!NOTE]
><span data-ttu-id="d063a-3096">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3096">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3097">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation für Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3097">After you've obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>

<span data-ttu-id="d063a-3098">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3098">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3099">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3099">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>

> [!IMPORTANT]
><span data-ttu-id="d063a-3100">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3100">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-3101">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3101">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>

 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3102">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3102">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3103">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3103">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3104">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3104">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-3105">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3105">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-3106">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3106">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3107">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3107">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-3108">Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, beginnend bei einem angegebenen Offset und unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3108">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3109">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3109">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3110"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode angegeben ist, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-3110"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-3111"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3111"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-3112">Wenn Sie in dieser Überladung das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3112">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3113">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3113">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3114">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3114">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-3115">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3115">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3116">Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-Aufrufvorgang aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3116">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-3117">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3117">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-3118">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3118">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-3119">Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3119">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3120">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3120">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-3121">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3121">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3122">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3122">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3123">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn die Anzahl der von Ihnen angeforderten Bytes kleiner ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3123">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d063a-3124">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3124">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-3125">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3125">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3126">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3126">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3127">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3127">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3128">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3128">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3129">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3129">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3130">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3130">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-3131">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3131">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3132">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3132">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3133">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3133">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3134">Im folgenden Codebeispiel wird der Datenpuffer, ein Offset, eine Größe und das <xref:System.Net.Sockets.SocketFlags> Senden von Daten an einen verbundenen angegeben <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3134">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3135"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3135"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3136"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3136"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3137">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3137">-or-</span></span> 
 <span data-ttu-id="d063a-3138"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3138"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-3139">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3139">-or-</span></span> 
 <span data-ttu-id="d063a-3140"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3140"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3141">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3141">-or-</span></span> 
 <span data-ttu-id="d063a-3142"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-3142"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3143"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3143"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-3144">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3144">-or-</span></span> 
<span data-ttu-id="d063a-3145">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-3145">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3146">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3146">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags * SocketError -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3147">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3147">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-3148">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3148">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-3149">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3149">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3150">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3150">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="errorCode"><span data-ttu-id="d063a-3151">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3151">A <see cref="T:System.Net.Sockets.SocketError" /> object that stores the socket error.</span></span></param>
        <summary><span data-ttu-id="d063a-3152">Sendet unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />, beginnend beim angegebenen Offset.</span><span class="sxs-lookup"><span data-stu-id="d063a-3152">Sends the specified number of bytes of data to a connected <see cref="T:System.Net.Sockets.Socket" />, starting at the specified offset, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" /></span></span></summary>
        <returns><span data-ttu-id="d063a-3153">Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3153">The number of bytes sent to the <see cref="T:System.Net.Sockets.Socket" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3154"><xref:System.Net.Sockets.Socket.Send%2A> Sendet synchron Daten an den Remote Host, der in der- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode angegeben ist, <xref:System.Net.Sockets.Socket.Accept%2A> und gibt die Anzahl der erfolgreich gesendeten Bytes zurück.</span><span class="sxs-lookup"><span data-stu-id="d063a-3154"><xref:System.Net.Sockets.Socket.Send%2A> synchronously sends data to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method and returns the number of bytes successfully sent.</span></span> <span data-ttu-id="d063a-3155"><xref:System.Net.Sockets.Socket.Send%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3155"><xref:System.Net.Sockets.Socket.Send%2A> can be used for both connection-oriented and connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-3156">Wenn Sie in dieser Überladung das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3156">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3157">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode aufrufen, oder es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3157">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method or <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3158">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3158">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-3159">Wenn Sie ein verbindungsloses Protokoll verwenden und planen, Daten an mehrere verschiedene Hosts zu senden, sollten Sie verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3159">If you are using a connectionless protocol and plan to send data to several different hosts, you should use <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3160">Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> , müssen Sie <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem-Aufrufvorgang aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3160">If you do not use <xref:System.Net.Sockets.Socket.SendTo%2A>, you will have to call <xref:System.Net.Sockets.Socket.Connect%2A> before each call to <xref:System.Net.Sockets.Socket.Send%2A>.</span></span> <span data-ttu-id="d063a-3161">Es ist in Ordnung, auch dann zu verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> Wenn Sie einen Standard-Remote Host mit erstellt haben <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3161">It is okay to use <xref:System.Net.Sockets.Socket.SendTo%2A> even after you have established a default remote host with <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span> <span data-ttu-id="d063a-3162">Sie können den Standard-Remote Host auch vor dem Aufrufen <xref:System.Net.Sockets.Socket.Send%2A> von ändern, indem Sie einen weiteren Aufruf von ausführen <xref:System.Net.Sockets.Socket.Connect%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3162">You can also change the default remote host prior to calling <xref:System.Net.Sockets.Socket.Send%2A> by making another call to <xref:System.Net.Sockets.Socket.Connect%2A>.</span></span>  
  
 <span data-ttu-id="d063a-3163">Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3163">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3164">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.Send%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3164">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.Send%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-3165">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.Send%2A> wird von blockiert, bis die angeforderte Anzahl von Bytes gesendet wird, es sei denn, ein Timeout wurde mithilfe von festgelegt <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3165">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.Send%2A> will block until the requested number of bytes are sent, unless a time-out was set by using <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3166">Wenn der Timeout Wert überschritten wurde, löst der <xref:System.Net.Sockets.Socket.Send%2A> Aufruf einen aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3166">If the time-out value was exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> call will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3167">Im nicht blockierenden Modus wird <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise auch dann erfolgreich abgeschlossen, wenn die Anzahl der von Ihnen angeforderten Bytes kleiner ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3167">In nonblocking mode, <xref:System.Net.Sockets.Socket.Send%2A> may complete successfully even if it sends less than the number of bytes you request.</span></span> <span data-ttu-id="d063a-3168">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3168">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-3169">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3169">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3170">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3170">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3171">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3171">A successful completion of the <xref:System.Net.Sockets.Socket.Send%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3172">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3172">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3173">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3173">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3174">Der erfolgreiche Abschluss eines Sendevorgang weist nicht darauf hin, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3174">The successful completion of a send does not indicate that the data was successfully delivered.</span></span> <span data-ttu-id="d063a-3175">Wenn innerhalb des Transport Systems kein Pufferspeicher verfügbar ist, um die zu übertragenden Daten aufzunehmen, wird der Sendevorgang blockiert, es sei denn, der Socket wurde in den nicht blockierenden Modus versetzt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3175">If no buffer space is available within the transport system to hold the data to be transmitted, send will block unless the socket has been placed in nonblocking mode.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3176">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3176">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3177">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3177">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3178">Im folgenden Codebeispiel wird der Datenpuffer, ein Offset, eine Größe und das <xref:System.Net.Sockets.SocketFlags> Senden von Daten an einen verbundenen angegeben <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3178">The following code example specifies the data buffer, an offset, a size, and <xref:System.Net.Sockets.SocketFlags> for sending data to a connected <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3179"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3179"><paramref name="buffer" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3180"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3180"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3181">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3181">-or-</span></span> 
 <span data-ttu-id="d063a-3182"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3182"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-3183">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3183">-or-</span></span> 
 <span data-ttu-id="d063a-3184"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3184"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3185">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3185">-or-</span></span> 
 <span data-ttu-id="d063a-3186"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-3186"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3187"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3187"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-3188">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3188">-or-</span></span> 
<span data-ttu-id="d063a-3189">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-3189">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3190">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3190">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-3191">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3191">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-3192">Sendet Daten asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3192">Sends data asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="d063a-3193"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3193"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-3194">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-3194">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-3195"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3195"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-3196">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3196">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3197">Die- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode wird verwendet, um ausgehende Daten von einem oder mehreren Puffern in einem Verbindungs orientierten Socket zu schreiben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3197">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method is used to write outgoing data from one or more buffers on a connection-oriented socket.</span></span> <span data-ttu-id="d063a-3198">Diese Methode kann jedoch auch für verbindungslose Sockets verwendet werden, die einen Remote Host für einen Verbindungsvorgang angegeben haben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3198">This method can also be used, however, on connectionless sockets that have specified a remote host on a connect operation.</span></span>  
  
 <span data-ttu-id="d063a-3199">Die- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode startet einen asynchronen Sendevorgang für den Remote Host, der in der-,-,-,-,-oder-Methode eingerichtet wurde <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3199">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method starts an asynchronous send operation to the remote host established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-3200">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-3200">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <span data-ttu-id="d063a-3201"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="d063a-3201"><xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType></span></span>  
  
-   <span data-ttu-id="d063a-3202"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist</span><span class="sxs-lookup"><span data-stu-id="d063a-3202"><xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <span data-ttu-id="d063a-3203"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist</span><span class="sxs-lookup"><span data-stu-id="d063a-3203"><xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> if <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> is set</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-3204">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3204">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-3205">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3205">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-3206">Die- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode löst eine Ausnahme aus, wenn Sie nicht zuerst <xref:System.Net.Sockets.Socket.Accept%2A> , <xref:System.Net.Sockets.Socket.AcceptAsync%2A> , <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> , <xref:System.Net.Sockets.Socket.Connect%2A> oder aufruft <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3206">The <xref:System.Net.Sockets.Socket.SendAsync%2A> method will throw an exception if you do not first call <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A><xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.</span></span>  
  
 <span data-ttu-id="d063a-3207">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3207">Calling the <xref:System.Net.Sockets.Socket.SendAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span>  
  
 <span data-ttu-id="d063a-3208">Überschreiten Sie für Nachrichten orientierte Sockets nicht die maximale Nachrichtengröße des zugrunde liegenden Windows Sockets-Dienstanbieters.</span><span class="sxs-lookup"><span data-stu-id="d063a-3208">For message-oriented sockets, do not exceed the maximum message size of the underlying Windows sockets service provider.</span></span> <span data-ttu-id="d063a-3209">Wenn die Daten zu lang sind, um atomisch über den zugrunde liegenden Dienstanbieter zu übergeben, werden keine Daten übertragen, und die Methode löst eine aus, <xref:System.Net.Sockets.Socket.SendAsync%2A> <xref:System.Net.Sockets.SocketException> bei der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den nativen Winsock-wsaemsgsize-Fehlercode (10040) festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3209">If the data is too long to pass atomically through the underlying service provider, no data is transmitted and the <xref:System.Net.Sockets.Socket.SendAsync%2A> method throws a <xref:System.Net.Sockets.SocketException> with the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> set to the native Winsock WSAEMSGSIZE error code (10040).</span></span>  
  
 <span data-ttu-id="d063a-3210">Beachten Sie, dass der erfolgreiche Abschluss der- <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode nicht anzeigt, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3210">Note that the successful completion of the <xref:System.Net.Sockets.Socket.SendAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-3211">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3211">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> or <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> properties on the <paramref name="e" /> parameter must reference valid buffers.</span></span> <span data-ttu-id="d063a-3212">Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</span><span class="sxs-lookup"><span data-stu-id="d063a-3212">One or the other of these properties may be set, but not both at the same time.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3213">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3213">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3214">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-3214">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3215">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3215">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3216">Der <see cref="T:System.Net.Sockets.Socket" /> ist noch nicht verbunden oder wurde nicht über eine <see cref="M:System.Net.Sockets.Socket.Accept" />-<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />- oder <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />-Methode abgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3216">The <see cref="T:System.Net.Sockets.Socket" /> is not yet connected or was not obtained via an <see cref="M:System.Net.Sockets.Socket.Accept" />, <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />,or <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />, method.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3217">Ruft einen Wert ab, der die Größe des Sendepuffers für den <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3217">Gets or sets a value that specifies the size of the send buffer of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-3218">Ein <see cref="T:System.Int32" />, das die Größe des Sendepuffer in Bytes enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3218">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the send buffer.</span></span> <span data-ttu-id="d063a-3219">Der Standard ist 8192.</span><span class="sxs-lookup"><span data-stu-id="d063a-3219">The default is 8192.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3220">Eine größere Puffergröße kann das Erkennen von Verbindungsproblemen verzögern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3220">A larger buffer size might delay the recognition of connection difficulties.</span></span> <span data-ttu-id="d063a-3221">Erhöhen Sie ggf. die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine Verbindung mit hoher Bandbreite und hoher Latenz (z. b. einem Satelliten-Breitbandanbieter).</span><span class="sxs-lookup"><span data-stu-id="d063a-3221">Consider increasing the buffer size if you are transferring large files, or you are using a high bandwidth, high latency connection (such as a satellite broadband provider.)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3222">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendBufferSize%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3222">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendBufferSize%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3223">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3223">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3224">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3224">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3225">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3225">The value specified for a set operation is less than 0.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-3226">Sendet eine Datei und optionale Daten synchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3226">Sends a file and optional data synchronously to a connected <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="d063a-3227">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3227">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="d063a-3228">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3228">This parameter can be <see langword="null" />.</span></span></param>
        <summary><span data-ttu-id="d063a-3229">Sendet die Datei <paramref name="fileName" /> mit dem <see cref="T:System.Net.Sockets.Socket" />-Übertragungsflag an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3229">Sends the file <paramref name="fileName" /> to a connected <see cref="T:System.Net.Sockets.Socket" /> object with the <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" /> transmit flag.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3230">Diese Überladung sendet die Datei `fileName` an den verbundenen Socket.</span><span class="sxs-lookup"><span data-stu-id="d063a-3230">This overload sends the file `fileName` to the connected socket.</span></span> <span data-ttu-id="d063a-3231">Der `flags` -Parameter hat den Standardwert <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), und der `preBuffer` -Parameter und der- `postBuffer` Parameter sind standardmäßig `null`</span><span class="sxs-lookup"><span data-stu-id="d063a-3231">The `flags` parameter defaults to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), and the `preBuffer` and `postBuffer` parameters default to `null`.</span></span> <span data-ttu-id="d063a-3232">Wenn `fileName` sich im lokalen Verzeichnis befindet, kann es mit nur dem Namen der Datei identifiziert werden. andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3232">If `fileName` is in the local directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d063a-3233">Platzhalter (".. \\\myfile.txt ") und UNC-Freigabe Namen (" \\ \\ \\ \Shared Directory \\\myfile.txt ") werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3233">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span> <span data-ttu-id="d063a-3234">Wenn die Datei nicht gefunden wird, wird die Ausnahme ausgelöst <xref:System.IO.FileNotFoundException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3234">If the file is not found, the exception <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d063a-3235">Diese Methode verwendet die-Funktion, die `TransmitFile` in der Windows Sockets 2-API enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3235">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d063a-3236">Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="d063a-3236">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="d063a-3237"><xref:System.Net.Sockets.Socket.SendFile%2A> Sendet synchron eine Datei an den Remote Host, der in der-Methode oder der-Methode angegeben ist <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3237"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3238"><xref:System.Net.Sockets.Socket.SendFile%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3238"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-3239">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> , bevor Sie diese Methode aufrufen; andernfalls wird <xref:System.Net.Sockets.Socket.SendFile%2A> eine-Ausnahme ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3239">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method, otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span> <span data-ttu-id="d063a-3240">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden, <xref:System.Net.Sockets.Socket.Connect%2A> um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3240">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-3241">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die Datei gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3241">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the file is sent.</span></span> <span data-ttu-id="d063a-3242">Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> kann erfolgreich abgeschlossen werden, bevor die gesamte Datei gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3242">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="d063a-3243">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3243">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3244">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3244">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3245">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3245">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3246">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3246">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3247">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3247">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3248">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3248">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3249">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3249">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3250">Im folgenden Codebeispiel wird ein Socket erstellt und verbunden, und anschließend wird eine Datei an den Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3250">The following code example creates and connects a socket and then sends a file to the remote host.</span></span> <span data-ttu-id="d063a-3251">Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3251">The file "test.txt" is located in the root directory of the local machine.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3252">Der Socket ist nicht mit einem Remotehost verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3252">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3253">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3253">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3254">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3254">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d063a-3255">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3255">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3256">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3256">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="preBuffer" Type="System.Byte[]" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="postBuffer" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="fileName"><span data-ttu-id="d063a-3257">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3257">A <see cref="T:System.String" /> that contains the path and name of the file to be sent.</span></span> <span data-ttu-id="d063a-3258">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3258">This parameter can be <see langword="null" />.</span></span></param>
        <param name="preBuffer"><span data-ttu-id="d063a-3259">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3259">A <see cref="T:System.Byte" /> array that contains data to be sent before the file is sent.</span></span> <span data-ttu-id="d063a-3260">Dieser Parameter kann <see langword="null" />sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3260">This parameter can be <see langword="null" />.</span></span></param>
        <param name="postBuffer"><span data-ttu-id="d063a-3261">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3261">A <see cref="T:System.Byte" /> array that contains data to be sent after the file is sent.</span></span> <span data-ttu-id="d063a-3262">Dieser Parameter kann <see langword="null" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3262">This parameter can be <see langword="null" />.</span></span></param>
        <param name="flags"><span data-ttu-id="d063a-3263">Mindestens ein <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3263">One or more of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values.</span></span></param>
        <summary><span data-ttu-id="d063a-3264">Sendet die Datei <paramref name="fileName" /> und puffert Daten mit dem angegebenen <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert in einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3264">Sends the file <paramref name="fileName" /> and buffers of data to a connected <see cref="T:System.Net.Sockets.Socket" /> object using the specified <see cref="T:System.Net.Sockets.TransmitFileOptions" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3265">Diese Überladung erfordert den Namen der Datei, die Sie senden möchten, und eine bitweise Kombination von- <xref:System.Net.Sockets.TransmitFileOptions> Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3265">This overload requires the name of the file you want to send and a bitwise combination of <xref:System.Net.Sockets.TransmitFileOptions> values.</span></span> <span data-ttu-id="d063a-3266">Der- `preBuffer` Parameter enthält alle Daten, die Sie der Datei vorausgehen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3266">The `preBuffer` parameter contains any data you want to precede the file.</span></span> <span data-ttu-id="d063a-3267">`postBuffer` enthält Daten, die Sie der Datei folgen möchten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3267">`postBuffer` contains data you want to follow the file.</span></span> <span data-ttu-id="d063a-3268">Wenn `fileName` sich im aktuellen Arbeitsverzeichnis befindet, kann es mit nur dem Namen der Datei identifiziert werden. andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3268">If `fileName` is in the current working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d063a-3269">Platzhalter (".. \\\myfile.txt ") und UNC-Freigabe Namen (" \\ \\ \\ \Shared Directory \\\myfile.txt ") werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3269">Wildcards ("..\\\myfile.txt") and UNC share names ("\\\\\\\shared directory\\\myfile.txt") are supported.</span></span>  
  
 <span data-ttu-id="d063a-3270">Der- `flags` Parameter stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="d063a-3270">The `flags` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d063a-3271">Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d063a-3271">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d063a-3272">Diese Methode verwendet die-Funktion, die `TransmitFile` in der Windows Sockets 2-API enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3272">This method uses the `TransmitFile` function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d063a-3273">Weitere Informationen zur `TransmitFile` Funktion und ihren Flags finden Sie in der Dokumentation zu [Windows Sockets](/windows/desktop/WinSock/) .</span><span class="sxs-lookup"><span data-stu-id="d063a-3273">For more information about the `TransmitFile` function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="d063a-3274"><xref:System.Net.Sockets.Socket.SendFile%2A> Sendet synchron eine Datei an den Remote Host, der in der-Methode oder der-Methode angegeben ist <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.Accept%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3274"><xref:System.Net.Sockets.Socket.SendFile%2A> synchronously sends a file to the remote host specified in the <xref:System.Net.Sockets.Socket.Connect%2A> or <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3275"><xref:System.Net.Sockets.Socket.SendFile%2A> kann sowohl für Verbindungs orientierte als auch für verbindungslose Protokolle verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3275"><xref:System.Net.Sockets.Socket.SendFile%2A> can be used for both connection-oriented and for connectionless protocols.</span></span>  
  
 <span data-ttu-id="d063a-3276">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie diese Methode aufrufen; andernfalls wird <xref:System.Net.Sockets.Socket.SendFile%2A> eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3276">If you are using a connectionless protocol, you must call <xref:System.Net.Sockets.Socket.Connect%2A> before calling this method; otherwise <xref:System.Net.Sockets.Socket.SendFile%2A> throws a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3277">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie entweder verwenden <xref:System.Net.Sockets.Socket.Connect%2A> , um eine Remote Host Verbindung herzustellen, oder verwenden, <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung zu akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3277">If you are using a connection-oriented protocol, you must either use <xref:System.Net.Sockets.Socket.Connect%2A> to establish a remote host connection, or use <xref:System.Net.Sockets.Socket.Accept%2A> to accept an incoming connection.</span></span>  
  
 <span data-ttu-id="d063a-3278">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, <xref:System.Net.Sockets.Socket.SendFile%2A> wird blockiert, bis die gesamte Datei gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3278">If you are using a connection-oriented protocol, <xref:System.Net.Sockets.Socket.SendFile%2A> blocks until the entire file is sent.</span></span> <span data-ttu-id="d063a-3279">Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> kann erfolgreich abgeschlossen werden, bevor die gesamte Datei gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3279">In nonblocking mode, <xref:System.Net.Sockets.Socket.SendFile%2A> may complete successfully before the entire file has been sent.</span></span> <span data-ttu-id="d063a-3280">Es gibt keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3280">There is no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3281">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3281">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3282">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3282">A successful completion of the <xref:System.Net.Sockets.Socket.SendFile%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3283">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3283">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3284">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3284">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3285">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3285">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3286">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3286">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3287">Im folgenden Codebeispiel wird ein Socket erstellt und verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3287">The following code example creates and connects a socket.</span></span> <span data-ttu-id="d063a-3288">Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3288">The file "test.txt" is located in the root directory of the local machine.</span></span> <span data-ttu-id="d063a-3289">In diesem Beispiel erstellen wir einen vorab Puffer und einen postBuffer von Daten und senden diese mit der Datei an den Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-3289">In this example, we create a prebuffer and postbuffer of data and send them to the remote host with the file.</span></span> <span data-ttu-id="d063a-3290">Der Standardwert <xref:System.Net.Sockets.TransmitFileOptions> wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3290">The default <xref:System.Net.Sockets.TransmitFileOptions> are used.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3291">Das Betriebssystem ist nicht Windows NT oder höher.</span><span class="sxs-lookup"><span data-stu-id="d063a-3291">The operating system is not Windows NT or later.</span></span>  
  
<span data-ttu-id="d063a-3292">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3292">-or-</span></span>
  
 <span data-ttu-id="d063a-3293">Der Socket ist nicht mit einem Remotehost verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3293">The socket is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3294">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3294">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3295">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3295">The <see cref="T:System.Net.Sockets.Socket" /> object is not in blocking mode and cannot accept this synchronous call.</span></span></exception>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d063a-3296">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3296">The file <paramref name="fileName" /> was not found.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3297">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3297">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("Not implemented")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("Not implemented")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-3298">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3298">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-3299">Sendet eine Auflistung von Dateien oder Datenpuffern im Speicher asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3299">Sends a collection of files or in memory data buffers asynchronously to a connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></summary>
        <returns><span data-ttu-id="d063a-3300"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3300"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-3301">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-3301">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-3302"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3302"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-3303">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3303">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3304">Die- <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode wird verwendet, um eine Auflistung von Dateien oder in Arbeitsspeicher-Daten Puffern an den Remote Host zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3304">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is used to send a collection of files or in memory data buffers to remote host.</span></span> <span data-ttu-id="d063a-3305"><xref:System.Net.Sockets.Socket>Muss bereits mit dem Remote Host verbunden sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3305">The <xref:System.Net.Sockets.Socket> must already be connected to the remote host.</span></span>  
  
 <span data-ttu-id="d063a-3306">Wenn eine <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> auf eine Datei im Arbeitsverzeichnis verweist, kann Sie nur mit dem Namen der Datei identifiziert werden. andernfalls müssen der vollständige Pfad und der Name der Datei angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3306">If a <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> references a file in the working directory, it may be identified with just the name of the file; otherwise, the full path and name of the file must be specified.</span></span> <span data-ttu-id="d063a-3307">Platzhalter und UNC-Freigabe Namen werden unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3307">Wildcards and UNC share names are supported.</span></span> <span data-ttu-id="d063a-3308">Wenn die Datei nicht gefunden wird, <xref:System.IO.FileNotFoundException> wird ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-3308">If the file is not found, <xref:System.IO.FileNotFoundException> is thrown.</span></span>  
  
 <span data-ttu-id="d063a-3309">Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-Delegaten implementiert, \<SocketAsyncEventArgs> und den Rückruf an das Ereignis anfügen <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3309">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d063a-3310">Die-Eigenschaft des- <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> `e` Parameters stellt dem Window Sockets-Dienstanbieter zusätzliche Informationen über die Dateiübertragung zur Verfügung.</span><span class="sxs-lookup"><span data-stu-id="d063a-3310">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter provides the Window Sockets service provider with additional information about the file transfer.</span></span> <span data-ttu-id="d063a-3311">Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.</span><span class="sxs-lookup"><span data-stu-id="d063a-3311">For more information about how to use this parameter, see <xref:System.Net.Sockets.TransmitFileOptions>.</span></span>  
  
 <span data-ttu-id="d063a-3312">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-3312">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-3313">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3313">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-3314">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3314">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-3315">Diese Methode verwendet die transmitpaketen-Funktion, die in der Windows Sockets 2-API enthalten ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3315">This method uses the TransmitPackets function found in the Windows Sockets 2 API.</span></span> <span data-ttu-id="d063a-3316">Weitere Informationen zur transmitpaketen-Funktion und ihren Flags finden Sie in der [Windows Sockets](/windows/desktop/WinSock/) -Dokumentation.</span><span class="sxs-lookup"><span data-stu-id="d063a-3316">For more information about the TransmitPackets function and its flags, see the [Windows Sockets](/windows/desktop/WinSock/) documentation.</span></span>  
  
 <span data-ttu-id="d063a-3317">Obwohl die-Methode für Verbindungs orientierte Protokolle vorgesehen ist, kann die- <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode auch für verbindungslose Protokolle verwendet werden, vorausgesetzt, dass Sie zuerst die- <xref:System.Net.Sockets.Socket.BeginConnect%2A> ,-oder- <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode zum Einrichten eines Standard Remote Hosts aufruft.</span><span class="sxs-lookup"><span data-stu-id="d063a-3317">Although intended for connection-oriented protocols, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method also works for connectionless protocols, provided that you first call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method to establish a default remote host.</span></span> <span data-ttu-id="d063a-3318">Bei Verbindungs losen Protokollen müssen Sie auch sicherstellen, dass die Größe der Datei nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3318">With connectionless protocols, you must also be sure that the size of your file does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3319">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es wird <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> eine- <xref:System.Net.Sockets.SocketException> Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-3319">If it does, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> throws a <xref:System.Net.Sockets.SocketException> exception.</span></span>  
  
 <span data-ttu-id="d063a-3320">Die- <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode wird entsprechend dem Betriebssystem optimiert, in dem Sie verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3320">The <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized according to the operating system on which it is used.</span></span> <span data-ttu-id="d063a-3321">Bei Windows Server-Editionen ist die- <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode für eine hohe Leistung optimiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3321">On Windows server editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for high performance.</span></span>  
  
 <span data-ttu-id="d063a-3322">Bei den Windows-Client Editionen <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> ist die-Methode für die minimale Arbeitsspeicher-und Ressourcenauslastung optimiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3322">On Windows client editions, the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method is optimized for minimum memory and resource utilization.</span></span>  
  
 <span data-ttu-id="d063a-3323">Die Verwendung des- <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> Flags in der-Eigenschaft des- <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> `e` Parameters kann zu erheblichen Leistungsvorteilen führen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3323">Use of the <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> property on the `e` parameter can deliver significant performance benefits.</span></span> <span data-ttu-id="d063a-3324">Wenn der Thread, der den <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methoden aufzurufen initiiert, für hohe Berechnungen verwendet wird, ist es möglich, dass die APCs nicht gestartet werden können, obwohl dies unwahrscheinlich ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3324">If the thread initiating the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> method call is being used for heavy computations, it is possible, though unlikely, that APCs could be prevented from launching.</span></span> <span data-ttu-id="d063a-3325">Beachten Sie, dass es einen Unterschied zwischen Kernel-und benutzermodusapcs gibt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3325">Note that there is a difference between kernel and user-mode APCs.</span></span> <span data-ttu-id="d063a-3326">Kernel-APCs werden gestartet, wenn sich ein Thread in einem Wartezustand befindet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3326">Kernel APCs launch when a thread is in a wait state.</span></span> <span data-ttu-id="d063a-3327">Benutzermodusapcs wird gestartet, wenn sich ein Thread in einem wartewarnbaren Wartestatus befindet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3327">User-mode APCs launch when a thread is in an alertable wait state</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException"><span data-ttu-id="d063a-3328">Die in der <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />-Eigenschaft angegebene Datei wurde nicht gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3328">The file specified in the <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" /> property was not found.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3329">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3329">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3330">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-3330">Windows XP or later is required for this method.</span></span> <span data-ttu-id="d063a-3331">Diese Ausnahme tritt auch auf, wenn <see cref="T:System.Net.Sockets.Socket" /> nicht mit einem Remotehost verbunden ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3331">This exception also occurs if the <see cref="T:System.Net.Sockets.Socket" /> is not connected to a remote host.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3332">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3332">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3333">Ein verbindungsloser <see cref="T:System.Net.Sockets.Socket" /> wird verwendet, und die verwendete Datei überschreitet die maximale Paketgröße des zugrunde liegenden Transports.</span><span class="sxs-lookup"><span data-stu-id="d063a-3333">A connectionless <see cref="T:System.Net.Sockets.Socket" /> is being used and the file being sent exceeds the maximum packet size of the underlying transport.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3334">Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Send" />-Aufrufs angibt, oder legt diesen fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3334">Gets or sets a value that specifies the amount of time after which a synchronous <see cref="Overload:System.Net.Sockets.Socket.Send" /> call will time out.</span></span></summary>
        <value><span data-ttu-id="d063a-3335">Der Timeoutwert in Millisekunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3335">The time-out value, in milliseconds.</span></span> <span data-ttu-id="d063a-3336">Wenn Sie die Eigenschaft auf einen Wert zwischen 1 und 499 festlegen, wird der Wert in 500 geändert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3336">If you set the property with a value between 1 and 499, the value will be changed to 500.</span></span> <span data-ttu-id="d063a-3337">Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an.</span><span class="sxs-lookup"><span data-stu-id="d063a-3337">The default value is 0, which indicates an infinite time-out period.</span></span> <span data-ttu-id="d063a-3338">Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3338">Specifying -1 also indicates an infinite time-out period.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3339">Diese Option gilt nur für synchrone <xref:System.Net.Sockets.Socket.Send%2A> Aufrufe.</span><span class="sxs-lookup"><span data-stu-id="d063a-3339">This option applies to synchronous <xref:System.Net.Sockets.Socket.Send%2A> calls only.</span></span> <span data-ttu-id="d063a-3340">Wenn der Timeout Zeitraum überschritten wird, löst die <xref:System.Net.Sockets.Socket.Send%2A> Methode eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3340">If the time-out period is exceeded, the <xref:System.Net.Sockets.Socket.Send%2A> method will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3341">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendTimeout%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3341">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.SendTimeout%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3342">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3342">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3343">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3343">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3344">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</span><span class="sxs-lookup"><span data-stu-id="d063a-3344">The value specified for a set operation is less than -1.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-3345">Sendet Daten an einen bestimmten Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3345">Sends data to a specific endpoint.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3346">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3346">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-3347">Der <see cref="T:System.Net.EndPoint" />, der das Ziel der Daten darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3347">The <see cref="T:System.Net.EndPoint" /> that represents the destination for the data.</span></span></param>
        <summary><span data-ttu-id="d063a-3348">Sendet Daten an den angegebenen Endpunkt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3348">Sends data to the specified endpoint.</span></span></summary>
        <returns><span data-ttu-id="d063a-3349">Die Anzahl der gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3349">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3350">In dieser Überladung ist der Puffer Offset standardmäßig auf 0, die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des `buffer` Parameters und der <xref:System.Net.Sockets.SocketFlags> Wert standardmäßig auf 0 (null) eingestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3350">In this overload, the buffer offset defaults to 0, the number of bytes to send defaults to the size of the `buffer` parameter, and the <xref:System.Net.Sockets.SocketFlags> value defaults to 0.</span></span>  
  
 <span data-ttu-id="d063a-3351">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie keinen Standard-Remote Host mit der-Methode einrichten, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3351">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3352">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3352">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d063a-3353">Wenn Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufrufen von Aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> , überschreibt der- `remoteEP` Parameter nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-3353">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-3354">Sie müssen die-Methode auch nicht aufzurufen <xref:System.Net.Sockets.Socket.Bind%2A> , da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3354">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-3355">Wenn Sie die zugewiesene Adresse und Portnummer des lokalen Netzwerks identifizieren müssen, können Sie die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft verwenden, nachdem die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3355">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d063a-3356">Obwohl für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3356">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d063a-3357">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Verbindungsanforderung mithilfe der- <xref:System.Net.Sockets.Socket.Accept%2A> Methode akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3357">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3358">Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, löst <xref:System.Net.Sockets.Socket.SendTo%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3358">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3359">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3359">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3360">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert den `remoteEP` -Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-3360">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-3361">Blockierende Sockets werden blockiert, bis alle Bytes im Puffer gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3361">Blocking sockets will block until the all of the bytes in the buffer are sent.</span></span> <span data-ttu-id="d063a-3362">Da eine nicht Blockierung <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, sendet Sie möglicherweise nicht alle Bytes in `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3362">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d063a-3363">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in der sendet `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3363">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d063a-3364">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3364">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3365">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3365">To increase network efficiency, the underlying system may delay transmission until a significant amount of outgoing data is collected.</span></span> <span data-ttu-id="d063a-3366">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3366">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d063a-3367">Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> wird von blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3367">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-3368">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3368">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3369">Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3369">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3370">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendTo%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3370">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3371">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3371">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3372">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3372">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3373">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3373">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3374">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3374">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3375">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3375">The following code example sends a connectionless datagram to the specified remote host.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3376"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3376"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-3377">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3377">-or-</span></span> 
 <span data-ttu-id="d063a-3378"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3378"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3379">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3379">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3380">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3380">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3381">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3381">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3382">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3382">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-3383">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3383">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="d063a-3384">Sendet Daten an einen bestimmten Endpunkt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3384">Sends data to a specific endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3385">Die Anzahl der gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3385">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3386">In dieser Überladung wird der Puffer Offset standardmäßig auf 0 und die Anzahl der zu sendenden Bytes standardmäßig auf die Größe des gesendet `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3386">In this overload, the buffer offset defaults to 0, and the number of bytes to send defaults to the size of the `buffer`.</span></span> <span data-ttu-id="d063a-3387">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3387">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3388">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie keinen Standard-Remote Host mit der-Methode einrichten, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3388">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3389">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3389">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d063a-3390">Wenn Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufrufen von Aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> , überschreibt der- `remoteEP` Parameter nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-3390">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-3391">Sie müssen die-Methode auch nicht aufzurufen <xref:System.Net.Sockets.Socket.Bind%2A> , da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3391">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-3392">Wenn Sie die zugewiesene Adresse und Portnummer des lokalen Netzwerks identifizieren müssen, können Sie die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft verwenden, nachdem die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3392">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d063a-3393">Obwohl für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3393">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d063a-3394">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Verbindungsanforderung mithilfe der- <xref:System.Net.Sockets.Socket.Accept%2A> Methode akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3394">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3395">Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, löst <xref:System.Net.Sockets.Socket.SendTo%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3395">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3396">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3396">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3397">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert den `remoteEP` -Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-3397">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-3398">Blockierende Sockets werden blockiert, bis die angeforderten alle Bytes in der `buffer` gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3398">Blocking sockets will block until the requested all of the bytes in the `buffer` are sent.</span></span> <span data-ttu-id="d063a-3399">Da eine nicht Blockierung <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, sendet Sie möglicherweise nicht alle Bytes in `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3399">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d063a-3400">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung alle Bytes in der sendet `buffer` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3400">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends all of the bytes in the `buffer`.</span></span> <span data-ttu-id="d063a-3401">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3401">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3402">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3402">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d063a-3403">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3403">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d063a-3404">Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> wird von blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3404">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-3405">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3405">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3406">Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3406">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3407">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendTo%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3407">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3408">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3408">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3409">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3409">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3410">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3410">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3411">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3411">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3412">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3412">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d063a-3413"><xref:System.Net.Sockets.SocketFlags> werden an die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3413"><xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3414"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3414"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-3415">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3415">-or-</span></span> 
 <span data-ttu-id="d063a-3416"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3416"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3417">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3417">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3418">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3418">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3419">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3419">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-3420">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3420">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3421">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3421">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-3422">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3422">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="d063a-3423">Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3423">Sends the specified number of bytes of data to the specified endpoint using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3424">Die Anzahl der gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3424">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3425">In dieser Überladung wird der Puffer Offset standardmäßig auf 0 eingestellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3425">In this overload, the buffer offset defaults to 0.</span></span> <span data-ttu-id="d063a-3426">Wenn Sie das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3426">If you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3427">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie keinen Standard-Remote Host mit der-Methode einrichten, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3427">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3428">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3428">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d063a-3429">Wenn Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufrufen von Aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> , überschreibt der- `remoteEP` Parameter nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-3429">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-3430">Sie müssen die-Methode auch nicht aufzurufen <xref:System.Net.Sockets.Socket.Bind%2A> , da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3430">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-3431">Wenn Sie die zugewiesene Adresse und Portnummer des lokalen Netzwerks identifizieren müssen, können Sie die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft verwenden, nachdem die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3431">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d063a-3432">Obwohl für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3432">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d063a-3433">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Verbindungsanforderung mithilfe der- <xref:System.Net.Sockets.Socket.Accept%2A> Methode akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3433">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3434">Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, löst <xref:System.Net.Sockets.Socket.SendTo%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3434">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3435">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3435">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3436">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert den `remoteEP` -Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-3436">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-3437">Blockierende Sockets werden blockiert, bis die angeforderte Anzahl von Bytes gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3437">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d063a-3438">Da eine nicht Blockierung <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, werden möglicherweise nicht alle in einem einzelnen Vorgang angeforderten Bytes gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3438">Since a nonblocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="d063a-3439">Es ist Aufgabe Ihrer Anwendung, die Anzahl der gesendeten Bytes nachzuverfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3439">It is your application's responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-3440">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3440">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3441">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3441">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d063a-3442">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3442">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d063a-3443">Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> wird von blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3443">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-3444">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3444">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3445">Außerdem müssen Sie sicherstellen, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3445">You must also be sure that the number of bytes sent does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3446">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendTo%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3446">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3447">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3447">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3448">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3448">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3449">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3449">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3450">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3450">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3451">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3451">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d063a-3452">Die Größe und <xref:System.Net.Sockets.SocketFlags> werden an die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode übermittelt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3452">The size and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3453"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3453"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-3454">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3454">-or-</span></span> 
 <span data-ttu-id="d063a-3455"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3455"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3456">Die angegebene <paramref name="size" /> ist größer als <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3456">The specified <paramref name="size" /> exceeds the size of <paramref name="buffer" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3457">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3457">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3458">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3458">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), offset As Integer, size As Integer, socketFlags As SocketFlags, remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="size" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="d063a-3459">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3459">An array of type <see cref="T:System.Byte" /> that contains the data to be sent.</span></span></param>
        <param name="offset"><span data-ttu-id="d063a-3460">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3460">The position in the data buffer at which to begin sending data.</span></span></param>
        <param name="size"><span data-ttu-id="d063a-3461">Die Anzahl von Bytes, die gesendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3461">The number of bytes to send.</span></span></param>
        <param name="socketFlags"><span data-ttu-id="d063a-3462">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3462">A bitwise combination of the <see cref="T:System.Net.Sockets.SocketFlags" /> values.</span></span></param>
        <param name="remoteEP"><span data-ttu-id="d063a-3463">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3463">The <see cref="T:System.Net.EndPoint" /> that represents the destination location for the data.</span></span></param>
        <summary><span data-ttu-id="d063a-3464">Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt und beginnt dabei an der angegebenen Position im Puffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3464">Sends the specified number of bytes of data to the specified endpoint, starting at the specified location in the buffer, and using the specified <see cref="T:System.Net.Sockets.SocketFlags" />.</span></span></summary>
        <returns><span data-ttu-id="d063a-3465">Die Anzahl der gesendeten Bytes.</span><span class="sxs-lookup"><span data-stu-id="d063a-3465">The number of bytes sent.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3466">Wenn Sie in dieser Überladung das- <xref:System.Net.Sockets.SocketFlags.DontRoute> Flag als `socketflags` Parameter angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3466">In this overload, if you specify the <xref:System.Net.Sockets.SocketFlags.DontRoute> flag as the `socketflags` parameter, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3467">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie keinen Standard-Remote Host mit der-Methode einrichten, <xref:System.Net.Sockets.Socket.Connect%2A> bevor Sie aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3467">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>.</span></span> <span data-ttu-id="d063a-3468">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3468">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.Send%2A> method.</span></span> <span data-ttu-id="d063a-3469">Wenn Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode vor dem Aufrufen von Aufrufen <xref:System.Net.Sockets.Socket.SendTo%2A> , überschreibt der- `remoteEP` Parameter nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-3469">If you do call the <xref:System.Net.Sockets.Socket.Connect%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendTo%2A>, the `remoteEP` parameter will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-3470">Sie müssen die-Methode auch nicht aufzurufen <xref:System.Net.Sockets.Socket.Bind%2A> , da der zugrunde liegende Dienstanbieter die am besten geeignete Adresse und Portnummer für das lokale Netzwerk zuweist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3470">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method, because the underlying service provider will assign the most appropriate local network address and port number.</span></span> <span data-ttu-id="d063a-3471">Wenn Sie die zugewiesene Adresse und Portnummer des lokalen Netzwerks identifizieren müssen, können Sie die- <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft verwenden, nachdem die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3471">If you need to identify the assigned local network address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.Socket.SendTo%2A> method successfully completes.</span></span>  
  
 <span data-ttu-id="d063a-3472">Obwohl für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3472">Although intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendTo%2A> also works with connection-oriented protocols.</span></span> <span data-ttu-id="d063a-3473">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst eine Remote Host Verbindung herstellen, indem Sie die- <xref:System.Net.Sockets.Socket.Connect%2A> Methode aufrufen oder eine eingehende Verbindungsanforderung mithilfe der- <xref:System.Net.Sockets.Socket.Accept%2A> Methode akzeptieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3473">If you are using a connection-oriented protocol, you must first establish a remote host connection by calling the <xref:System.Net.Sockets.Socket.Connect%2A> method or accept an incoming connection request using the <xref:System.Net.Sockets.Socket.Accept%2A> method.</span></span> <span data-ttu-id="d063a-3474">Wenn Sie keine Remote Host Verbindung einrichten oder akzeptieren, löst <xref:System.Net.Sockets.Socket.SendTo%2A> eine aus <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3474">If you do not establish or accept a remote host connection, <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3475">Sie können auch einen Standard-Remote Host für ein verbindungsloses Protokoll einrichten, bevor Sie die- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3475">You can also establish a default remote host for a connectionless protocol prior to calling the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span> <span data-ttu-id="d063a-3476">In jedem dieser Fälle <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert den `remoteEP` -Parameter und sendet nur Daten an den verbundenen oder standardmäßigen Remote Host.</span><span class="sxs-lookup"><span data-stu-id="d063a-3476">In either of these cases, <xref:System.Net.Sockets.Socket.SendTo%2A> will ignore the `remoteEP` parameter and only send data to the connected or default remote host.</span></span>  
  
 <span data-ttu-id="d063a-3477">Blockierende Sockets werden blockiert, bis die angeforderte Anzahl von Bytes gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3477">Blocking sockets will block until the requested number of bytes are sent.</span></span> <span data-ttu-id="d063a-3478">Da eine nicht blockierende <xref:System.Net.Sockets.Socket> sofort abgeschlossen wird, werden möglicherweise nicht alle in einem einzelnen Vorgang angeforderten Bytes gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3478">Since a non-blocking <xref:System.Net.Sockets.Socket> completes immediately, it might not send all of the bytes requested in a single operation.</span></span> <span data-ttu-id="d063a-3479">Ihre Anwendungen sind dafür verantwortlich, die Anzahl der gesendeten Bytes zu verfolgen und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes sendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3479">It is your applications responsibility to keep track of the number of bytes sent and to retry the operation until the application sends the requested number of bytes.</span></span> <span data-ttu-id="d063a-3480">Außerdem gibt es keine Garantie dafür, dass die gesendeten Daten sofort im Netzwerk angezeigt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3480">There is also no guarantee that the data you send will appear on the network immediately.</span></span> <span data-ttu-id="d063a-3481">Um die Netzwerkeffizienz zu erhöhen, kann das zugrunde liegende System die Übertragung verzögern, bis eine beträchtliche Menge an ausgehenden Daten gesammelt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3481">To increase network efficiency, the underlying system may delay transmission until a significant amount of out-going data is collected.</span></span> <span data-ttu-id="d063a-3482">Ein erfolgreicher Abschluss der- <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System über Platz verfügt, um die Daten für ein Netzwerk Sendevorgang zu puffern.</span><span class="sxs-lookup"><span data-stu-id="d063a-3482">A successful completion of the <xref:System.Net.Sockets.Socket.SendTo%2A> method means that the underlying system has had room to buffer your data for a network send.</span></span>  
  
 <span data-ttu-id="d063a-3483">Wenn Sie ein verbindungsloses Protokoll im Blockierungs Modus verwenden, <xref:System.Net.Sockets.Socket.SendTo%2A> wird von blockiert, bis das Datagramm gesendet wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3483">If you are using a connectionless protocol in blocking mode, <xref:System.Net.Sockets.Socket.SendTo%2A> will block until the datagram is sent.</span></span> <span data-ttu-id="d063a-3484">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socketoption auf festlegen <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3484">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option to <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>.</span></span> <span data-ttu-id="d063a-3485">Außerdem müssen Sie sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Dienstanbieters nicht überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3485">You must also be sure that the size does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3486">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendTo%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3486">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendTo%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3487">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3487">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3488">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3488">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3489">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3489">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3490">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3490">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3491">Im folgenden Codebeispiel wird ein verbindungsloses Datagramm an den angegebenen Remote Host gesendet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3491">The following code example sends a connectionless datagram to the specified remote host.</span></span> <span data-ttu-id="d063a-3492">Offset, Größe und <xref:System.Net.Sockets.SocketFlags> werden an die-Methode übermittelt <xref:System.Net.Sockets.Socket.SendTo%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3492">The offset, size, and <xref:System.Net.Sockets.SocketFlags> are passed to the <xref:System.Net.Sockets.Socket.SendTo%2A> method.</span></span>  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3493"><paramref name="buffer" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3493"><paramref name="buffer" /> is <see langword="null" />.</span></span>  
  
<span data-ttu-id="d063a-3494">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3494">-or-</span></span> 
 <span data-ttu-id="d063a-3495"><paramref name="remoteEP" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3495"><paramref name="remoteEP" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3496"><paramref name="offset" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3496"><paramref name="offset" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3497">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3497">-or-</span></span> 
 <span data-ttu-id="d063a-3498"><paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3498"><paramref name="offset" /> is greater than the length of <paramref name="buffer" />.</span></span>  
  
<span data-ttu-id="d063a-3499">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3499">-or-</span></span> 
 <span data-ttu-id="d063a-3500"><paramref name="size" /> ist kleiner als 0.</span><span class="sxs-lookup"><span data-stu-id="d063a-3500"><paramref name="size" /> is less than 0.</span></span>  
  
<span data-ttu-id="d063a-3501">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3501">-or-</span></span> 
 <span data-ttu-id="d063a-3502"><paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="d063a-3502"><paramref name="size" /> is greater than the length of <paramref name="buffer" /> minus the value of the <paramref name="offset" /> parameter.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3503"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3503"><paramref name="socketFlags" /> is not a valid combination of values.</span></span>  
  
<span data-ttu-id="d063a-3504">- oder -</span><span class="sxs-lookup"><span data-stu-id="d063a-3504">-or-</span></span> 
<span data-ttu-id="d063a-3505">Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</span><span class="sxs-lookup"><span data-stu-id="d063a-3505">An operating system error occurs while accessing the <see cref="T:System.Net.Sockets.Socket" />.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3506">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3506">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Security.SecurityException"><span data-ttu-id="d063a-3507">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3507">A caller in the call stack does not have the required permissions.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" Index="0" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="d063a-3508">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3508">The <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object to use for this asynchronous socket operation.</span></span></param>
        <summary><span data-ttu-id="d063a-3509">Sendet asynchron Daten an einen angegebenen Remotehost.</span><span class="sxs-lookup"><span data-stu-id="d063a-3509">Sends data asynchronously to a specific remote host.</span></span></summary>
        <returns><span data-ttu-id="d063a-3510"><see langword="true" />, wenn der E/A-Vorgang aussteht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3510"><see langword="true" /> if the I/O operation is pending.</span></span> <span data-ttu-id="d063a-3511">Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="d063a-3511">The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will be raised upon completion of the operation.</span></span>  
  
 <span data-ttu-id="d063a-3512"><see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3512"><see langword="false" /> if the I/O operation completed synchronously.</span></span> <span data-ttu-id="d063a-3513">In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3513">In this case, The <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" /> event on the <paramref name="e" /> parameter will not be raised and the <paramref name="e" /> object passed as a parameter may be examined immediately after the method call returns to retrieve the result of the operation.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3514">Die- <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode startet einen asynchronen Sendevorgang an den Remote Host, der in der- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft des- `e` Parameters angegeben ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3514">The <xref:System.Net.Sockets.Socket.SendToAsync%2A> method starts an asynchronous send operation to the remote host specified in the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property of the `e` parameter.</span></span> <span data-ttu-id="d063a-3515">Durch Aufrufen der- <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode haben Sie die Möglichkeit, Daten in einem separaten Ausführungs Thread zu senden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3515">Calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method gives you the ability to send data within a separate execution thread.</span></span> <span data-ttu-id="d063a-3516">Obwohl diese Methode für verbindungslose Protokolle vorgesehen ist, <xref:System.Net.Sockets.Socket.SendToAsync%2A> funktioniert sowohl mit Verbindungs orientierten Protokollen als auch mit Verbindungs orientierten Protokollen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3516">Although this method is intended for connectionless protocols, <xref:System.Net.Sockets.Socket.SendToAsync%2A> works with both connectionless and connection-oriented protocols.</span></span>  
  
 <span data-ttu-id="d063a-3517">Damit Sie über den Abschluss benachrichtigt werden können, müssen Sie eine Rückruf Methode erstellen, die den EventHandler-Delegaten implementiert, \<SocketAsyncEventArgs> und den Rückruf an das Ereignis anfügen <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3517">To be notified of completion, you must create a callback method that implements the EventHandler\<SocketAsyncEventArgs> delegate and attach the callback to the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event.</span></span>  
  
 <span data-ttu-id="d063a-3518">Die folgenden Eigenschaften und Ereignisse für das- <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:</span><span class="sxs-lookup"><span data-stu-id="d063a-3518">The following properties and events on the <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> object are required to successfully call this method:</span></span>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 <span data-ttu-id="d063a-3519">Der Aufrufer kann die- <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft auf ein beliebiges Benutzer Zustands Objekt festlegen, das vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode erwünscht ist, damit die Informationen in der Rückruf Methode abgerufen werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3519">The caller may set the <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> property to any user state object desired before calling the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method, so that the information will be retrievable in the callback method.</span></span> <span data-ttu-id="d063a-3520">Wenn der Rückruf mehr Informationen benötigt als ein einzelnes Objekt, kann eine kleine Klasse erstellt werden, die die anderen erforderlichen Zustandsinformationen als Member enthält.</span><span class="sxs-lookup"><span data-stu-id="d063a-3520">If the callback needs more information than a single object, a small class can be created to hold the other required state information as members.</span></span>  
  
 <span data-ttu-id="d063a-3521">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, müssen Sie zuerst die-,-,-,-,-oder-Methode aufzurufen <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3521">If you are using a connection-oriented protocol, you must first call the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span> <span data-ttu-id="d063a-3522">Andernfalls <xref:System.Net.Sockets.Socket.SendToAsync%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3522">Otherwise <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3523">Bei Verwendung eines Verbindungs orientierten Protokolls <xref:System.Net.Sockets.Socket.SendToAsync%2A> ignoriert die-Methode die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> -Eigenschaft und sendet Daten an den, der in der-,-,-,-,- <xref:System.Net.EndPoint?displayProperty=nameWithType> oder-Methode festgelegt wird <xref:System.Net.Sockets.Socket.Accept%2A> <xref:System.Net.Sockets.Socket.AcceptAsync%2A> <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A> <xref:System.Net.Sockets.Socket.Connect%2A> <xref:System.Net.Sockets.Socket.ConnectAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3523">When using a connection-oriented protocol, the <xref:System.Net.Sockets.Socket.SendToAsync%2A> method will ignore the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property and send data to the <xref:System.Net.EndPoint?displayProperty=nameWithType> established in the <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-3524">Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie vor dem Aufrufen von keinen Standard-Remote Host mit der- <xref:System.Net.Sockets.Socket.BeginConnect%2A> ,- <xref:System.Net.Sockets.Socket.Connect%2A> oder-Methode erstellen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3524">If you are using a connectionless protocol, you do not need to establish a default remote host with the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>.</span></span> <span data-ttu-id="d063a-3525">Dies ist nur erforderlich, wenn Sie beabsichtigen, die-Methode oder die-Methode aufzurufen <xref:System.Net.Sockets.Socket.BeginSend%2A> <xref:System.Net.Sockets.Socket.SendAsync%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3525">You only need to do this if you intend to call the <xref:System.Net.Sockets.Socket.BeginSend%2A> or <xref:System.Net.Sockets.Socket.SendAsync%2A> methods.</span></span> <span data-ttu-id="d063a-3526">Wenn Sie vor dem Aufrufen der- <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, der- <xref:System.Net.Sockets.Socket.Connect%2A> Methode oder der-Methode aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> <xref:System.Net.Sockets.Socket.SendToAsync%2A> , überschreibt die- <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft nur den angegebenen Standard Remote Host für diesen Sendevorgang.</span><span class="sxs-lookup"><span data-stu-id="d063a-3526">If you do call the <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, or <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method prior to calling <xref:System.Net.Sockets.Socket.SendToAsync%2A>, the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> property will override the specified default remote host for that send operation only.</span></span> <span data-ttu-id="d063a-3527">Außerdem ist es nicht erforderlich, die- <xref:System.Net.Sockets.Socket.Bind%2A> Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3527">You are also not required to call the <xref:System.Net.Sockets.Socket.Bind%2A> method.</span></span> <span data-ttu-id="d063a-3528">In diesem Fall weist der zugrunde liegende Dienstanbieter die am besten geeignete IP-Adresse und Portnummer für das lokale Netzwerk zu.</span><span class="sxs-lookup"><span data-stu-id="d063a-3528">In this case, the underlying service provider will assign the most appropriate local network IP address and port number.</span></span> <span data-ttu-id="d063a-3529">Verwenden Sie die Portnummer 0 (null), wenn der zugrunde liegende Dienstanbieter einen freien Port auswählen soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3529">Use a port number of zero if you want the underlying service provider to select a free port.</span></span> <span data-ttu-id="d063a-3530">Wenn Sie die IP-Adresse und Portnummer des zugewiesenen lokalen Netzwerks identifizieren müssen, können Sie die-Eigenschaft verwenden, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> nachdem das- <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis signalisiert und die zugehörigen Delegaten aufgerufen wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3530">If you need to identify the assigned local network IP address and port number, you can use the <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> property after the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> event is signaled and the associated delegates are called.</span></span>  
  
 <span data-ttu-id="d063a-3531">Wenn Sie Daten an eine Broadcast Adresse senden möchten, müssen Sie zuerst die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode und die Socket-Option für <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> auf true festlegen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3531">If you want to send data to a broadcast address, you must first call the <xref:System.Net.Sockets.Socket.SetSocketOption%2A> method and set the socket option for <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> to true.</span></span> <span data-ttu-id="d063a-3532">Außerdem müssen Sie sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3532">You must also be sure that the size of your buffer does not exceed the maximum packet size of the underlying service provider.</span></span> <span data-ttu-id="d063a-3533">Wenn dies der Fall ist, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendToAsync%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3533">If it does, the datagram will not be sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span>  
  
 <span data-ttu-id="d063a-3534">Wenn Sie das DontRoute-Flag in der- <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Eigenschaft angeben, werden die Daten, die Sie senden, nicht weitergeleitet.</span><span class="sxs-lookup"><span data-stu-id="d063a-3534">If you specify the DontRoute flag in the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> property, the data you are sending will not be routed.</span></span>  
  
 <span data-ttu-id="d063a-3535">Bei Nachrichten orientierten Sockets muss darauf geachtet werden, dass die maximale Nachrichtengröße des zugrunde liegenden Transports nicht überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3535">For message-oriented sockets, care must be taken not to exceed the maximum message size of the underlying transport.</span></span> <span data-ttu-id="d063a-3536">Wenn die Größe des Puffers die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet, wird das Datagramm nicht gesendet, und es <xref:System.Net.Sockets.Socket.SendToAsync%2A> wird eine ausgelöst <xref:System.Net.Sockets.SocketException> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3536">If the size of the buffer exceeds the maximum packet size of the underlying service provider, the datagram is not sent and <xref:System.Net.Sockets.Socket.SendToAsync%2A> will throw a <xref:System.Net.Sockets.SocketException>.</span></span> <span data-ttu-id="d063a-3537">Der erfolgreiche Abschluss einer <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode zeigt nicht an, dass die Daten erfolgreich übermittelt wurden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3537">The successful completion of a <xref:System.Net.Sockets.Socket.SendToAsync%2A> method does not indicate that the data was successfully delivered.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3538"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3538">The <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> cannot be null.</span></span></exception>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3539">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3539">A socket operation was already in progress using the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> object specified in the <paramref name="e" /> parameter.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3540">Für diese Methode ist Windows XP oder höher erforderlich.</span><span class="sxs-lookup"><span data-stu-id="d063a-3540">Windows XP or later is required for this method.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3541">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3541">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3542">Das angegebene Protokoll ist verbindungsorientiert, aber der <see cref="T:System.Net.Sockets.Socket" /> wurde noch nicht verbunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3542">The protocol specified is connection-oriented, but the <see cref="T:System.Net.Sockets.Socket" /> is not yet connected.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="level"><span data-ttu-id="d063a-3543">Die für diesen Socket festzulegende IP-Schutzebene.</span><span class="sxs-lookup"><span data-stu-id="d063a-3543">The IP protection level to set on this socket.</span></span></param>
        <summary><span data-ttu-id="d063a-3544">Legt die IP-Schutzebene für einen Socket fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3544">Set the IP protection level on a socket.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3545">Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> -Methode ermöglicht das Einschränken eines IPv6-oder IP-Sockets zum lauschen an einem bestimmten Bereich, z. b. Adressen mit demselben Link lokalen oder Standort lokalen Präfix.</span><span class="sxs-lookup"><span data-stu-id="d063a-3545">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method enables restricting an a IPv6 or IP socket to listen on a specified scope, such as addresses with the same link local or site local prefix.</span></span> <span data-ttu-id="d063a-3546">Mit dieser Socketoption können Anwendungen Zugriffs Einschränkungen für IPv6 oder IP-Sockets platzieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3546">This socket option enables applications to place access restrictions on IPv6 or IP sockets.</span></span> <span data-ttu-id="d063a-3547">Mit solchen Einschränkungen kann sich eine im privaten LAN ausgeführte Anwendung selbst einfach und stabil vor externen Angriffen schützen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3547">Such restrictions enable an application running on a private LAN to simply and robustly harden itself against external attacks.</span></span> <span data-ttu-id="d063a-3548">Diese Socketoption kann auch verwendet werden, um Zugriffs Einschränkungen zu entfernen, wenn der- `level` Parameter auf festgelegt ist <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3548">This socket option can also be used to remove access restrictions if the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>.</span></span> <span data-ttu-id="d063a-3549">Diese Socketoption erweitert oder beschränkt den Bereich eines empfangsbereiten Sockets und ermöglicht so bei Bedarf den uneingeschränkten Zugriff von öffentlichen und privaten Benutzern oder beschränkt den Zugriff nur auf denselben Standort.</span><span class="sxs-lookup"><span data-stu-id="d063a-3549">This socket option widens or narrows the scope of a listening socket, enabling unrestricted access from public and private users when appropriate, or restricting access only to the same site, as required.</span></span>  
  
 <span data-ttu-id="d063a-3550">Für diese Socketoption sind in der <xref:System.Net.Sockets.IPProtectionLevel>-Enumeration angegebene Schutzebenen definiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3550">This socket option has defined protection levels specified in the <xref:System.Net.Sockets.IPProtectionLevel> enumeration.</span></span>  
  
 <span data-ttu-id="d063a-3551">Die- <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Methode wird verwendet, um Network Address Traversal (NAT) für eine-Instanz zu aktivieren oder zu deaktivieren <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3551">The <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> method is used to enable or disable Network Address Traversal (NAT) for a <xref:System.Net.Sockets.Socket> instance.</span></span> <span data-ttu-id="d063a-3552">NAT-Durchlauf kann mithilfe von Teredo, IPv6-zu-IPv4 oder einem ISATAP-Tunnel bereitgestellt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3552">NAT traversal may be provided using Teredo, 6to4, or an ISATAP tunnel.</span></span>  
  
 <span data-ttu-id="d063a-3553">Wenn der- `level` Parameter auf oder festgelegt ist, wird der <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> NAT- <xref:System.Net.Sockets.IPProtectionLevel.Restricted> Durchlauf für eine- <xref:System.Net.Sockets.Socket> Instanz explizit deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3553">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, or <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, this explicitly disables NAT traversal for a <xref:System.Net.Sockets.Socket> instance.</span></span>  
  
 <span data-ttu-id="d063a-3554">Wenn der- `level` Parameter auf festgelegt ist <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> , kann die NAT-Durchquerung für eine <xref:System.Net.Sockets.Socket> abhängig von Firewallregeln im System zulassen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3554">When the `level` parameter is set to <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, this may allow NAT traversal for a <xref:System.Net.Sockets.Socket> depending on firewall rules in place on the system.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="d063a-3555">Der <paramref name="level" />-Parameter darf nicht <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3555">The <paramref name="level" /> parameter cannot be <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" />.</span></span> <span data-ttu-id="d063a-3556">Die IP-Schutzebene kann nicht auf nicht angegeben festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3556">The IP protection level cannot be set to unspecified.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3557">Die <see cref="T:System.Net.Sockets.AddressFamily" /> des Sockets muss <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> sein.</span><span class="sxs-lookup"><span data-stu-id="d063a-3557">The <see cref="T:System.Net.Sockets.AddressFamily" /> of the socket must be either <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />.</span></span></exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="SetRawSocketOption">
      <MemberSignature Language="C#" Value="public void SetRawSocketOption (int optionLevel, int optionName, ReadOnlySpan&lt;byte&gt; optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetRawSocketOption(int32 optionLevel, int32 optionName, valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetRawSocketOption (optionLevel As Integer, optionName As Integer, optionValue As ReadOnlySpan(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetRawSocketOption(int optionLevel, int optionName, ReadOnlySpan&lt;System::Byte&gt; optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetRawSocketOption : int * int * ReadOnlySpan&lt;byte&gt; -&gt; unit" Usage="socket.SetRawSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionName" Type="System.Int32" Index="1" FrameworkAlternate="net-5.0" />
        <Parameter Name="optionValue" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="2" FrameworkAlternate="net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-3558">Die von der Plattform definierte Optionsebene.</span><span class="sxs-lookup"><span data-stu-id="d063a-3558">The platform-defined option level.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-3559">Der von der Plattform definierte Optionsname.</span><span class="sxs-lookup"><span data-stu-id="d063a-3559">The platform-defined option name.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-3560">Der Wert, auf den die Option festgelegt werden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3560">The value to which the option should be set.</span></span></param>
        <summary><span data-ttu-id="d063a-3561">Legt einen Socketoptionswert unter Verwendung plattformspezifischer Ebenen- und Namensbezeichner fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3561">Sets a socket option value using platform-specific level and name identifiers.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="d063a-3562">Im Allgemeinen sollte die- `SetSocketOption` Methode immer dann verwendet werden, wenn eine-Option festgelegt wird <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3562">In general, the `SetSocketOption` method should be used whenever setting a <xref:System.Net.Sockets.Socket> option.</span></span>

<span data-ttu-id="d063a-3563">Die <xref:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})> -Methode sollte nur verwendet werden, wenn <xref:System.Net.Sockets.SocketOptionLevel> und <xref:System.Net.Sockets.SocketOptionName> die erforderliche Option nicht verfügbar machen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3563">The <xref:System.Net.Sockets.Socket.SetRawSocketOption(System.Int32,System.Int32,System.ReadOnlySpan{System.Byte})> method should be used only when <xref:System.Net.Sockets.SocketOptionLevel> and <xref:System.Net.Sockets.SocketOptionName> do not expose the required option.</span></span>

          ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3564">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3564">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3565">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3565">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="d063a-3566">Legt eine <see cref="T:System.Net.Sockets.Socket" />-Option fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3566">Sets a <see cref="T:System.Net.Sockets.Socket" /> option.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-3567">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3567">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-3568">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3568">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-3569">Der als <see cref="T:System.Boolean" />-Wert dargestellte Wert der Option.</span><span class="sxs-lookup"><span data-stu-id="d063a-3569">The value of the option, represented as a <see cref="T:System.Boolean" />.</span></span></param>
        <summary><span data-ttu-id="d063a-3570">Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen <see cref="T:System.Boolean" />-Wert fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3570">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified <see cref="T:System.Boolean" /> value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3571"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3571"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3572">Legen `optionValue` Sie auf fest `true` , um die Option zu aktivieren, oder auf, `false` um die Option zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3572">Set `optionValue` to `true` to enable the option, or to `false` to disable the option.</span></span>  
  
 <span data-ttu-id="d063a-3573"><xref:System.Net.Sockets.Socket> Optionen werden nach Ebene der Protokoll Unterstützung gruppiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3573"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="d063a-3574">Im folgenden sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen aufgeführt, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3574">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="d063a-3575">Diese Optionen werden nach dem entsprechenden <xref:System.Net.Sockets.SocketOptionLevel> Wert gruppiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3575">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value.</span></span> <span data-ttu-id="d063a-3576">Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, dass Sie den entsprechenden <xref:System.Net.Sockets.SocketOptionLevel> Wert für den `optionLevel` Parameter verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3576">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> value for the `optionLevel` parameter.</span></span> <span data-ttu-id="d063a-3577">Die Option, die Sie festlegen möchten, muss im- `optionName` Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3577">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="d063a-3578">Wenn Sie den aktuellen Wert einer der aufgelisteten Optionen erhalten möchten, verwenden Sie die- <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-3578">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-3579"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3579"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <span data-ttu-id="d063a-3580"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3580"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="d063a-3581"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3581"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="d063a-3582"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3582"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="d063a-3583">Weitere Informationen zu diesen Optionen finden Sie in der- <xref:System.Net.Sockets.SocketOptionName> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d063a-3583">For more information on these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3584">Wenn Sie eine- <xref:System.Net.Sockets.SocketException> Ausnahme erhalten, verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3584">If you receive a <xref:System.Net.Sockets.SocketException> exception, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3585">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3585">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3586">Im folgenden Codebeispiel wird ein Socket geöffnet, und die `DontLinger` `OutOfBandInline` Socketoptionen und werden aktiviert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3586">The following code example opens a socket and enables the `DontLinger` and the `OutOfBandInline` socket options.</span></span>  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3587">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3587">The <see cref="T:System.Net.Sockets.Socket" /> object has been closed.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3588">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3588">An error occurred when attempting to access the socket.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Byte[]" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-3589">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3589">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-3590">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3590">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-3591">Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Option darstellt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3591">An array of type <see cref="T:System.Byte" /> that represents the value of the option.</span></span></param>
        <summary><span data-ttu-id="d063a-3592">Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Bytearray dargestellten Wert fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3592">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as a byte array.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3593"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3593"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3594">Verwenden Sie diese Überladung, um diese Optionen festzulegen <xref:System.Net.Sockets.Socket> , die ein Bytearray als Optionswert benötigen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3594">Use this overload to set those <xref:System.Net.Sockets.Socket> options that require a byte array as an option value.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3595">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3595">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3596">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3596">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3597">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3597">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3598">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3598">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3599">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und festgelegt <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3599">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3600">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3600">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3601">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3601">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Int32" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-3602">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3602">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-3603">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3603">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-3604">Ein Wert der Option.</span><span class="sxs-lookup"><span data-stu-id="d063a-3604">A value of the option.</span></span></param>
        <summary><span data-ttu-id="d063a-3605">Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen ganzzahligen Wert fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3605">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified integer value.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3606"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3606"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3607">Für eine Option mit einem- <xref:System.Boolean> Datentyp geben Sie einen Wert ungleich 0 (null) an, um die Option zu aktivieren, und einen Nullwert, um die Option zu deaktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3607">For an option with a <xref:System.Boolean> data type, specify a nonzero value to enable the option, and a zero value to disable the option.</span></span> <span data-ttu-id="d063a-3608">Geben Sie für eine Option mit einem Integer-Datentyp den entsprechenden Wert an.</span><span class="sxs-lookup"><span data-stu-id="d063a-3608">For an option with an integer data type, specify the appropriate value.</span></span> <span data-ttu-id="d063a-3609"><xref:System.Net.Sockets.Socket> Optionen werden nach Ebene der Protokoll Unterstützung gruppiert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3609"><xref:System.Net.Sockets.Socket> options are grouped by level of protocol support.</span></span>  
  
 <span data-ttu-id="d063a-3610">Im folgenden sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen aufgeführt, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3610">Listed below are the various <xref:System.Net.Sockets.Socket> options that can be set using this overload.</span></span> <span data-ttu-id="d063a-3611">Diese Optionen werden nach dem entsprechenden gruppiert <xref:System.Net.Sockets.SocketOptionLevel> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3611">These options are grouped by the appropriate <xref:System.Net.Sockets.SocketOptionLevel>.</span></span> <span data-ttu-id="d063a-3612">Wenn Sie eine dieser Optionen festlegen möchten, achten Sie darauf, dass Sie die entsprechende <xref:System.Net.Sockets.SocketOptionLevel> für den `optionLevel` Parameter verwenden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3612">If you intend to set any of these options, be sure to use the appropriate <xref:System.Net.Sockets.SocketOptionLevel> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d063a-3613">Die Option, die Sie festlegen möchten, muss im- `optionName` Parameter angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3613">The option you choose to set must be specified in the `optionName` parameter.</span></span> <span data-ttu-id="d063a-3614">Wenn Sie den aktuellen Wert einer der aufgelisteten Optionen erhalten möchten, verwenden Sie die- <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-3614">If you want to get the current value of any of the options listed, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
 <span data-ttu-id="d063a-3615"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3615"><xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <span data-ttu-id="d063a-3616"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3616"><xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <span data-ttu-id="d063a-3617"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3617"><xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <span data-ttu-id="d063a-3618"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3618"><xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <span data-ttu-id="d063a-3619"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.</span><span class="sxs-lookup"><span data-stu-id="d063a-3619"><xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> options that can be set using this overload.</span></span>  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 <span data-ttu-id="d063a-3620">Weitere Informationen zu diesen Optionen finden Sie in der- <xref:System.Net.Sockets.SocketOptionName> Enumeration.</span><span class="sxs-lookup"><span data-stu-id="d063a-3620">For more information about these options, refer to the <xref:System.Net.Sockets.SocketOptionName> enumeration.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3621">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3621">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3622">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3622">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3623">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3623">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3624">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3624">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3625">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und festgelegt <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3625">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time-out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3626">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3626">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3627">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3627">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="optionValue" Type="System.Object" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="optionLevel"><span data-ttu-id="d063a-3628">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3628">One of the <see cref="T:System.Net.Sockets.SocketOptionLevel" /> values.</span></span></param>
        <param name="optionName"><span data-ttu-id="d063a-3629">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3629">One of the <see cref="T:System.Net.Sockets.SocketOptionName" /> values.</span></span></param>
        <param name="optionValue"><span data-ttu-id="d063a-3630">Eine <see cref="T:System.Net.Sockets.LingerOption" /> oder <see cref="T:System.Net.Sockets.MulticastOption" /> mit dem Wert der Option.</span><span class="sxs-lookup"><span data-stu-id="d063a-3630">A <see cref="T:System.Net.Sockets.LingerOption" /> or <see cref="T:System.Net.Sockets.MulticastOption" /> that contains the value of the option.</span></span></param>
        <summary><span data-ttu-id="d063a-3631">Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Objekt dargestellten Wert fest.</span><span class="sxs-lookup"><span data-stu-id="d063a-3631">Sets the specified <see cref="T:System.Net.Sockets.Socket" /> option to the specified value, represented as an object.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3632"><xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten der aktuellen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3632"><xref:System.Net.Sockets.Socket> options determine the behavior of the current <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3633">Verwenden Sie diese Überladung, um die <xref:System.Net.Sockets.SocketOptionName.Linger> Optionen, und festzulegen <xref:System.Net.Sockets.SocketOptionName.AddMembership> <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3633">Use this overload to set the <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, and <xref:System.Net.Sockets.SocketOptionName.DropMembership><xref:System.Net.Sockets.Socket> options.</span></span> <span data-ttu-id="d063a-3634">Verwenden Sie für die- <xref:System.Net.Sockets.SocketOptionName.Linger> Option <xref:System.Net.Sockets.Socket> für den- `optionLevel` Parameter.</span><span class="sxs-lookup"><span data-stu-id="d063a-3634">For the <xref:System.Net.Sockets.SocketOptionName.Linger> option, use <xref:System.Net.Sockets.Socket> for the `optionLevel` parameter.</span></span> <span data-ttu-id="d063a-3635">Verwenden Sie für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.SocketOptionLevel.IP> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3635">For <xref:System.Net.Sockets.SocketOptionName.AddMembership> and <xref:System.Net.Sockets.SocketOptionName.DropMembership>, use <xref:System.Net.Sockets.SocketOptionLevel.IP>.</span></span> <span data-ttu-id="d063a-3636">Wenn Sie den aktuellen Wert einer der oben aufgeführten Optionen erhalten möchten, verwenden Sie die- <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-3636">If you want to get the current value of any of the options listed above, use the <xref:System.Net.Sockets.Socket.GetSocketOption%2A> method.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3637">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3637">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3638">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3638">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3639">Im folgenden Codebeispiel werden die Timeout <xref:System.Net.Sockets.LingerOption> Werte und festgelegt <xref:System.Net.Sockets.Socket.Send%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3639">The following code example sets the <xref:System.Net.Sockets.LingerOption> and <xref:System.Net.Sockets.Socket.Send%2A> time out values.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><span data-ttu-id="d063a-3640"><paramref name="optionValue" /> ist <see langword="null" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3640"><paramref name="optionValue" /> is <see langword="null" />.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3641">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3641">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3642">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3642">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how"><span data-ttu-id="d063a-3643">Einer der <see cref="T:System.Net.Sockets.SocketShutdown" />-Werte, der den Vorgang angibt, der nicht mehr zulässig ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3643">One of the <see cref="T:System.Net.Sockets.SocketShutdown" /> values that specifies the operation that will no longer be allowed.</span></span></param>
        <summary><span data-ttu-id="d063a-3644">Deaktiviert Senden und Empfangen für einen <see cref="T:System.Net.Sockets.Socket" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3644">Disables sends and receives on a <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3645">Wenn Sie einen Verbindungs orientierten verwenden <xref:System.Net.Sockets.Socket> , sollten Sie vor dem Schließen von immer die-Methode aufzurufen <xref:System.Net.Sockets.Socket.Shutdown%2A> <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3645">When using a connection-oriented <xref:System.Net.Sockets.Socket>, always call the <xref:System.Net.Sockets.Socket.Shutdown%2A> method before closing the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3646">Dadurch wird sichergestellt, dass alle Daten vor dem Schließen des verbundenen Sockets gesendet und empfangen werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3646">This ensures that all data is sent and received on the connected socket before it is closed.</span></span>  
  
 <span data-ttu-id="d063a-3647">Ruft die <xref:System.Net.Sockets.Socket.Close%2A> -Methode auf, um alle verwalteten und nicht verwalteten Ressourcen freizugeben, die zugeordnet sind <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3647">Call the <xref:System.Net.Sockets.Socket.Close%2A> method to free all managed and unmanaged resources associated with the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3648">Versuchen Sie nicht, das nach dem Schließen wiederzuverwenden <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3648">Do not attempt to reuse the <xref:System.Net.Sockets.Socket> after closing.</span></span>  
  
 <span data-ttu-id="d063a-3649">Die folgende Tabelle zeigt die <xref:System.Net.Sockets.SocketShutdown> Enumerationswerte, die für den-Parameter gültig sind `how` .</span><span class="sxs-lookup"><span data-stu-id="d063a-3649">The following table shows the <xref:System.Net.Sockets.SocketShutdown> enumeration values that are valid for the `how` parameter.</span></span>  
  
|<span data-ttu-id="d063a-3650">Wert</span><span class="sxs-lookup"><span data-stu-id="d063a-3650">Value</span></span>|<span data-ttu-id="d063a-3651">Beschreibung</span><span class="sxs-lookup"><span data-stu-id="d063a-3651">Description</span></span>|  
|-----------|-----------------|  
|<span data-ttu-id="d063a-3652">Senden</span><span class="sxs-lookup"><span data-stu-id="d063a-3652">Send</span></span>|<span data-ttu-id="d063a-3653">Hiermit wird das Senden für dieses deaktiviert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3653">Disable sending on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="d063a-3654">Empfangen</span><span class="sxs-lookup"><span data-stu-id="d063a-3654">Receive</span></span>|<span data-ttu-id="d063a-3655">Deaktiviert den Empfang für diesen <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3655">Disable receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
|<span data-ttu-id="d063a-3656">Beides</span><span class="sxs-lookup"><span data-stu-id="d063a-3656">Both</span></span>|<span data-ttu-id="d063a-3657">Hiermit wird das Senden und empfangen von für dieses deaktiviert <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3657">Disable both sending and receiving on this <xref:System.Net.Sockets.Socket>.</span></span>|  
  
 <span data-ttu-id="d063a-3658">Durch Festlegen `how` von auf <xref:System.Net.Sockets.SocketShutdown.Send> wird angegeben, dass nachfolgende Aufrufe von <xref:System.Net.Sockets.Socket.Send%2A> nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-3658">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Send> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Send%2A> are not allowed.</span></span> <span data-ttu-id="d063a-3659">Wenn Sie einen Verbindungs losen verwenden <xref:System.Net.Sockets.Socket> , hat die Angabe von <xref:System.Net.Sockets.SocketShutdown.Send> keine Auswirkungen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3659">If you are using a connectionless <xref:System.Net.Sockets.Socket>, specifying <xref:System.Net.Sockets.SocketShutdown.Send> will have no effect.</span></span>  
  
 <span data-ttu-id="d063a-3660">Durch Festlegen `how` von auf <xref:System.Net.Sockets.SocketShutdown.Receive> wird angegeben, dass nachfolgende Aufrufe von <xref:System.Net.Sockets.Socket.Receive%2A> nicht zulässig sind.</span><span class="sxs-lookup"><span data-stu-id="d063a-3660">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Receive> specifies that subsequent calls to <xref:System.Net.Sockets.Socket.Receive%2A> are not allowed.</span></span> <span data-ttu-id="d063a-3661">Dies hat keine Auswirkung auf niedrigere Protokoll Ebenen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3661">This has no effect on lower protocol layers.</span></span> <span data-ttu-id="d063a-3662">Wenn Sie ein Verbindungs orientiertes Protokoll verwenden, wird die Verbindung beendet, wenn eine der folgenden Bedingungen nach einem-Rückruf vorhanden ist <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span><span class="sxs-lookup"><span data-stu-id="d063a-3662">If you are using a connection-oriented protocol, the connection is terminated if either of the following conditions exist after a call to <xref:System.Net.Sockets.Socket.Shutdown%2A> :</span></span>  
  
-   <span data-ttu-id="d063a-3663">Die Daten befinden sich im eingehenden Netzwerk Puffer, der darauf wartet, empfangen zu werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3663">Data is in the incoming network buffer waiting to be received.</span></span>  
  
-   <span data-ttu-id="d063a-3664">Es wurden weitere Daten gefunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3664">More data has arrived.</span></span>  
  
 <span data-ttu-id="d063a-3665">Wenn Sie ein verbindungsloses Protokoll verwenden, werden Datagramme akzeptiert und in die Warteschlange eingereiht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3665">If you are using a connectionless protocol, datagrams are accepted and queued.</span></span> <span data-ttu-id="d063a-3666">Wenn jedoch kein Pufferspeicher für zusätzliche Eingehende Datagramme verfügbar ist, werden Sie verworfen, und es wird kein Fehler an den Absender zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="d063a-3666">However, if no buffer space is available for additional incoming datagrams, they will be discarded and no error will be returned to the sender.</span></span> <span data-ttu-id="d063a-3667">Die Verwendung <xref:System.Net.Sockets.Socket.Shutdown%2A> von für einen Verbindungs losen Wert <xref:System.Net.Sockets.Socket> ist nicht empfehlenswert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3667">Using <xref:System.Net.Sockets.Socket.Shutdown%2A> on a connectionless <xref:System.Net.Sockets.Socket> is not recommended.</span></span>  
  
 <span data-ttu-id="d063a-3668">`how`Wenn Sie auf festlegen, werden <xref:System.Net.Sockets.SocketShutdown.Both> beide Sendungen und Empfangs Vorgänge wie oben beschrieben deaktiviert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3668">Setting `how` to <xref:System.Net.Sockets.SocketShutdown.Both> disables both sends and receives as described above.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3669">Wenn Sie <xref:System.Net.Sockets.SocketException> beim Aufrufen der-Methode einen erhalten <xref:System.Net.Sockets.Socket.Shutdown%2A> , verwenden Sie die- <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3669">If you receive a <xref:System.Net.Sockets.SocketException> when calling the <xref:System.Net.Sockets.Socket.Shutdown%2A> method, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3670">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3670">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="d063a-3671">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="d063a-3671">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="d063a-3672">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).</span><span class="sxs-lookup"><span data-stu-id="d063a-3672">For more information, see [Network Tracing in the .NET Framework](/dotnet/framework/network-programming/network-tracing).</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3673">Im folgenden Codebeispiel wird verwendet <xref:System.Net.Sockets.Socket.Shutdown%2A> , um zu deaktivieren <xref:System.Net.Sockets.Socket> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3673">The following code example uses <xref:System.Net.Sockets.Socket.Shutdown%2A> to disable the <xref:System.Net.Sockets.Socket>.</span></span>  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3674">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3674">An error occurred when attempting to access the socket.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3675">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3675">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3676">Ruft den Typ des <see cref="T:System.Net.Sockets.Socket" /> ab.</span><span class="sxs-lookup"><span data-stu-id="d063a-3676">Gets the type of the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-3677">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</span><span class="sxs-lookup"><span data-stu-id="d063a-3677">One of the <see cref="T:System.Net.Sockets.SocketType" /> values.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3678"><xref:System.Net.Sockets.Socket.SocketType%2A> ist schreibgeschützt und wird festgelegt, wenn das <xref:System.Net.Sockets.Socket> erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3678"><xref:System.Net.Sockets.Socket.SocketType%2A> is read-only and is set when the <xref:System.Net.Sockets.Socket> is created.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3679">Im folgenden Codebeispiel <xref:System.Net.Sockets.AddressFamily> werden, <xref:System.Net.Sockets.SocketType> und <xref:System.Net.Sockets.ProtocolType> in der Konsole angezeigt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3679">The following code example displays the <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, and <xref:System.Net.Sockets.ProtocolType> to the console.</span></span>  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use OSSupportsIPv4 instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use OSSupportsIPv4 instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3680">Ruft einen Wert ab, der angibt, ob IPv4-Unterstützung verfügbar und auf dem aktuellen Host aktiviert ist.</span><span class="sxs-lookup"><span data-stu-id="d063a-3680">Gets a value indicating whether IPv4 support is available and enabled on the current host.</span></span></summary>
        <value><span data-ttu-id="d063a-3681"><see langword="true" />, wenn der aktuelle Host das Protokoll IPv4 unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3681"><see langword="true" /> if the current host supports the IPv4 protocol; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3682">Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.</span><span class="sxs-lookup"><span data-stu-id="d063a-3682">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use OSSupportsIPv6 instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use OSSupportsIPv6 instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3683">Ruft einen Wert ab, der angibt, ob das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Member unterstützt.</span><span class="sxs-lookup"><span data-stu-id="d063a-3683">Gets a value that indicates whether the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> members.</span></span></summary>
        <value><span data-ttu-id="d063a-3684"><see langword="true" />, wenn das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Methoden unterstützt, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3684"><see langword="true" /> if the Framework supports IPv6 for certain obsolete <see cref="T:System.Net.Dns" /> methods; otherwise, <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3685">Das Betriebssystem unterstützt möglicherweise sowohl IPv4-als auch IPv6-Protokolle.</span><span class="sxs-lookup"><span data-stu-id="d063a-3685">The operating system may support both IPv4 and IPv6 protocols.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberSignature Language="F#" Value="abstract member System.IDisposable.Dispose : unit -&gt; unit&#xA;override this.System.IDisposable.Dispose : unit -&gt; unit" Usage="socket.System.IDisposable.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="d063a-3686">Gibt alle vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="d063a-3686">Releases all resources used by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
<span data-ttu-id="d063a-3687">Wenn Sie die Verwendung von abgeschlossen haben, nennen Sie iverwerf. <xref:System.Net.Sockets.Socket> verwerfen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3687">Call IDisposable.Dispose when you are finished using the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3688">Die iverwerf. verwerfen-Methode verbleibt in einem nicht verwendbaren <xref:System.Net.Sockets.Socket> Zustand.</span><span class="sxs-lookup"><span data-stu-id="d063a-3688">The IDisposable.Dispose method leaves the <xref:System.Net.Sockets.Socket> in an unusable state.</span></span> <span data-ttu-id="d063a-3689">Nach dem Aufrufen von "iverwerf. verwerfen" müssen Sie alle Verweise auf freigeben, <xref:System.Net.Sockets.Socket> damit das Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.Socket> belegt hat.</span><span class="sxs-lookup"><span data-stu-id="d063a-3689">After calling IDisposable.Dispose, you must release all references to the <xref:System.Net.Sockets.Socket> so the garbage collector can reclaim the memory that the <xref:System.Net.Sockets.Socket> was occupying.</span></span> <span data-ttu-id="d063a-3690">Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](/dotnet/standard/garbage-collection/unmanaged) und [Implementieren einer](/dotnet/standard/garbage-collection/implementing-dispose)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="d063a-3690">For more information, see [Cleaning Up Unmanaged Resources](/dotnet/standard/garbage-collection/unmanaged) and [Implementing a Dispose Method](/dotnet/standard/garbage-collection/implementing-dispose).</span></span>

> [!NOTE] 
> <span data-ttu-id="d063a-3691">Vor dem Freigeben des letzten Verweises auf wird immer "iverwerf. verwerfen" <xref:System.Net.Sockets.Socket> aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3691">Always call IDisposable.Dispose before you release your last reference to the <xref:System.Net.Sockets.Socket>.</span></span> <span data-ttu-id="d063a-3692">Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.</span><span class="sxs-lookup"><span data-stu-id="d063a-3692">Otherwise, the resources it is using will not be freed until the garbage collector calls the <xref:System.Net.Sockets.Socket> object's `Finalize` method.</span></span>

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3693">Ruft einen Wert ab, der die Gültigkeitsdauer (TTL) von IP (Internet Protocol)-Paketen angibt, die vom <see cref="T:System.Net.Sockets.Socket" /> gesendet werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3693">Gets or sets a value that specifies the Time To Live (TTL) value of Internet Protocol (IP) packets sent by the <see cref="T:System.Net.Sockets.Socket" />.</span></span></summary>
        <value><span data-ttu-id="d063a-3694">Der TTL-Wert.</span><span class="sxs-lookup"><span data-stu-id="d063a-3694">The TTL value.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3695">Der TTL-Wert gibt die maximale Anzahl von Routern an, die das Paket durchlaufen kann, bevor der Router das Paket verwirft und eine ICMP-Fehlermeldung (Internet Control Message Protocol), die an den Absender überschritten wird.</span><span class="sxs-lookup"><span data-stu-id="d063a-3695">The TTL value indicates the maximum number of routers the packet can traverse before the router discards the packet and an Internet Control Message Protocol (ICMP) "TTL exceeded" error message is returned to the sender.</span></span>  
  
 <span data-ttu-id="d063a-3696">Der TTL-Wert kann auf einen Wert zwischen 0 und 255 festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3696">The TTL value may be set to a value from 0 to 255.</span></span> <span data-ttu-id="d063a-3697">Wenn diese Eigenschaft nicht festgelegt ist, ist der standardmäßige TTL-Wert für einen Socket 32.</span><span class="sxs-lookup"><span data-stu-id="d063a-3697">When this property is not set, the default TTL value for a socket is 32.</span></span>  
  
 <span data-ttu-id="d063a-3698">Das Festlegen dieser Eigenschaft für einen TCP-Socket (Transmission Control Protocol) wird vom TCP/IP-Stapel ignoriert, wenn eine erfolgreiche Verbindung mithilfe des Sockets hergestellt wurde.</span><span class="sxs-lookup"><span data-stu-id="d063a-3698">Setting this property on a Transmission Control Protocol (TCP) socket is ignored by the TCP/IP stack if a successful connection has been established using the socket.</span></span>  
  
 <span data-ttu-id="d063a-3699">Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten.</span><span class="sxs-lookup"><span data-stu-id="d063a-3699">If you receive a <xref:System.Net.Sockets.SocketException>, use the <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> property to obtain the specific error code.</span></span> <span data-ttu-id="d063a-3700">Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.</span><span class="sxs-lookup"><span data-stu-id="d063a-3700">After you have obtained this code, refer to the [Windows Sockets version 2 API error code](/windows/desktop/winsock/windows-sockets-error-codes-2) documentation for a detailed description of the error.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="d063a-3701">Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.Ttl%2A>-Attributs veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="d063a-3701">The following code example demonstrates the use of the <xref:System.Net.Sockets.Socket.Ttl%2A> property.</span></span>  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="d063a-3702">Für den TTL-Wert kann keine negative Zahl festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3702">The TTL value can't be set to a negative number.</span></span></exception>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="d063a-3703">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3703">This property can be set only for sockets in the <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> or <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> families.</span></span></exception>
        <exception cref="T:System.Net.Sockets.SocketException"><span data-ttu-id="d063a-3704">Fehler beim Versuch, auf den Socket zuzugreifen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3704">An error occurred when attempting to access the socket.</span></span> <span data-ttu-id="d063a-3705">Dieser Fehler wird auch zurückgegeben, wenn versucht wird, TTL auf einen höheren Wert als 255 festzulegen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3705">This error is also returned when an attempt was made to set TTL to a value higher than 255.</span></span></exception>
        <exception cref="T:System.ObjectDisposedException"><span data-ttu-id="d063a-3706">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</span><span class="sxs-lookup"><span data-stu-id="d063a-3706">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.MonoTODO("This doesn't do anything on Mono yet")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.MonoTODO("This doesn't do anything on Mono yet")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="d063a-3707">Gibt an, ob der Socket nur den Modus für überlappende E/A-Vorgänge verwenden soll.</span><span class="sxs-lookup"><span data-stu-id="d063a-3707">Specifies whether the socket should only use Overlapped I/O mode.</span></span></summary>
        <value><span data-ttu-id="d063a-3708"><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> nur überlappende E/A-Vorgänge verwendet, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3708"><see langword="true" /> if the <see cref="T:System.Net.Sockets.Socket" /> uses only overlapped I/O; otherwise, <see langword="false" />.</span></span> <span data-ttu-id="d063a-3709">Der Standardwert ist <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="d063a-3709">The default is <see langword="false" />.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="d063a-3710">Legen Sie diese Eigenschaft für ein fest, das aufgerufen werden soll `true` <xref:System.Net.Sockets.Socket> <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3710">Set this property to `true` for a <xref:System.Net.Sockets.Socket> you intend to call <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span> <span data-ttu-id="d063a-3711">Andernfalls weist das Framework möglicherweise dem Socket einen Abschlussport zu, was die Verwendung von untersagt <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A> .</span><span class="sxs-lookup"><span data-stu-id="d063a-3711">Otherwise, the Framework may assign a completion port to the socket, which would prohibit the use of <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException"><span data-ttu-id="d063a-3712">Der Socket wurde an einen Abschlussanschluss gebunden.</span><span class="sxs-lookup"><span data-stu-id="d063a-3712">The socket has been bound to a completion port.</span></span></exception>
      </Docs>
    </Member>
  </Members>
</Type>
