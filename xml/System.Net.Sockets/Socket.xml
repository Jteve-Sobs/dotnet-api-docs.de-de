<Type Name="Socket" FullName="System.Net.Sockets.Socket">
  <Metadata><Meta Name="ms.openlocfilehash" Value="528c249ecf9ee5530e3c595f4ceee28d34332910" /><Meta Name="ms.sourcegitcommit" Value="9e3550fb2088d4faf2043f0acb29da4555519937" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/12/2018" /><Meta Name="ms.locfileid" Value="53301167" /></Metadata><TypeSignature Language="C#" Value="public class Socket : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Socket extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.Socket" />
  <TypeSignature Language="VB.NET" Value="Public Class Socket&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Socket : IDisposable" />
  <TypeSignature Language="F#" Value="type Socket = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Implementiert die Berkeley-Sockets-Schnittstelle.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket> Klasse bietet einen umfangreichen Satz von Methoden und Eigenschaften für die Netzwerkkommunikation. Die <xref:System.Net.Sockets.Socket> Klasse können Sie sowohl synchrone und asynchrone Datenübertragung mit einer der Protokolle für die Kommunikation in der <xref:System.Net.Sockets.ProtocolType> Enumeration.  
  
 Die <xref:System.Net.Sockets.Socket> Klasse folgt das Benennungsmuster von .NET Framework für asynchrone Methoden. Beispielsweise ist die synchrone <xref:System.Net.Sockets.Socket.Receive%2A> Methode entspricht, auf den asynchronen <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A> Methoden.  
  
 Wenn Ihre Anwendung nur ein Thread während der Ausführung erforderlich ist, verwenden Sie die folgenden Methoden, die für den synchronen Betriebsmodus ausgelegt sind.  
  
-   Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, Ihrem Server kann nicht auf Verbindungen Lauschen mithilfe der <xref:System.Net.Sockets.Socket.Listen%2A> Methode. Die <xref:System.Net.Sockets.Socket.Accept%2A> Methode Prozesse eingehende Verbindung anfordert, und gibt eine <xref:System.Net.Sockets.Socket> , Sie verwenden können, um Daten mit dem Remotehost zu kommunizieren. Verwenden Sie diese zurückgegebenen <xref:System.Net.Sockets.Socket> zum Aufrufen der <xref:System.Net.Sockets.Socket.Send%2A> oder <xref:System.Net.Sockets.Socket.Receive%2A> Methode. Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> aufrufen, bevor die <xref:System.Net.Sockets.Socket.Listen%2A> Methode, wenn Sie die lokale IP-Adresse und den Port angeben möchten. Verwenden Sie die Portnummer 0 (null), wenn Sie den zugrunde liegenden Dienstanbieter einen Free-Port für die Sie zuweisen möchten. Wenn Sie einem überwachenden Host eine Verbindung herstellen möchten, rufen Sie die <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Um Daten zu kommunizieren, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> oder <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
-   Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht alle zum Lauschen auf Verbindungen. Rufen Sie die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode, um eingehende Datagramme zu akzeptieren. Verwenden der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode, um Datagramme zu senden, mit einem Remotehost.  
  
 Verwenden Sie zum Verarbeiten von Kommunikation mithilfe von separaten Threads während der Ausführung der folgenden Methoden, die entwickelt wurden, für den asynchronen Betriebsmodus.  
  
-   Wenn Sie ein verbindungsorientiertes Protokoll wie TCP verwenden, verwenden Sie die <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, und <xref:System.Net.Sockets.Socket.EndConnect%2A> Methoden für die Verbindung mit einem überwachenden Host. Verwenden der <xref:System.Net.Sockets.Socket.BeginSend%2A> und <xref:System.Net.Sockets.Socket.EndSend%2A> oder <xref:System.Net.Sockets.Socket.BeginReceive%2A> und <xref:System.Net.Sockets.Socket.EndReceive%2A> Methoden, um die Daten asynchron kommunizieren. Eingehende verbindungsanforderungen können verarbeitet werden, mithilfe von <xref:System.Net.Sockets.Socket.BeginAccept%2A> und <xref:System.Net.Sockets.Socket.EndAccept%2A>.  
  
-   Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, können Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.EndSendTo%2A> Datagramme senden und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> und <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> um Datagramme zu empfangen.  
  
 Wenn Sie mehrere asynchrone Vorgänge für einen Socket durchführen, führen sie nicht unbedingt in der Reihenfolge Sie in denen sie gestartet werden.  
  
 Wenn Sie fertig ist, senden und Empfangen von Daten sind, verwenden Sie die <xref:System.Net.Sockets.Socket.Shutdown%2A> Methode zum Deaktivieren der <xref:System.Net.Sockets.Socket>. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Shutdown%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode, um alle zugeordneten Ressourcen freizugeben. die <xref:System.Net.Sockets.Socket>.  
  
 Die <xref:System.Net.Sockets.Socket> Klasse können Sie konfigurieren Ihr <xref:System.Net.Sockets.Socket> mithilfe der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode. Rufen Sie diese Einstellungen mithilfe der <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie eine relativ einfache Anwendung schreiben und nicht die maximale Leistung benötigen, erwägen Sie die Verwendung <xref:System.Net.Sockets.TcpClient>, <xref:System.Net.Sockets.TcpListener>, und <xref:System.Net.Sockets.UdpClient>. Diese Klassen bieten eine einfachere und benutzerfreundlichere Benutzeroberfläche zur <xref:System.Net.Sockets.Socket> Kommunikation.  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die <xref:System.Net.Sockets.Socket> Klasse kann verwendet werden, zum Senden von Daten an einem HTTP-Server und die Antwort zu empfangen. In diesem Beispiel wird blockiert, bis die gesamte Seite empfangen wird.  
  
 [!code-cpp[System.Net.Sockets.Socket#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CPP/socket.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket/CS/socket.cs#1)]
 [!code-vb[System.Net.Sockets.Socket#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.Socket/VB/socket.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Um eine ausgehende Verbindung herzustellen, oder übernehmen Sie eine eingehende Anforderung.</permission>
    <threadsafe>Instanzen dieser Klasse sind threadsicher.</threadsafe>
    <altmember cref="N:System.Net" />
    <altmember cref="N:System.Net.Cache" />
    <altmember cref="N:System.Net.Security" />
    <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
    <related type="Article" href="~/docs/framework/network-programming/index.md">Netzwerkprogrammierung in .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/best-practices-for-system-net-classes.md">Bewährte Methoden für System.Net-Klassen</related>
    <related type="Article" href="~/docs/framework/network-programming/cache-management-for-network-applications.md">Cacheverwaltung für Netzwerkanwendungen</related>
    <related type="Article" href="~/docs/framework/network-programming/internet-protocol-version-6.md">Internetprotokoll Version 6</related>
    <related type="Article" href="~/docs/framework/network-programming/network-programming-samples.md">Beispiele zur Netzwerkprogrammierung</related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md">Netzwerkablaufverfolgung in .NET Framework</related>
    <related type="Article" href="~/docs/framework/network-programming/security-in-network-programming.md">Sicherheit in der Netzwerkprogrammierung</related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md">Erweiterungen der Socketleistung in Version 3.5</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketInformation socketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketInformation socketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketInformation)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketInformation socketInformation);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketInformation -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket socketInformation" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketInformation" Type="System.Net.Sockets.SocketInformation" />
      </Parameters>
      <Docs>
        <param name="socketInformation">Die von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegebenen Socketinformationen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse mit dem angegebenen Wert, der von <see cref="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" /> zurückgegeben wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Aufrufen der <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket>mit dem gleichen zugrunde liegenden Socket. Dieses Vorgehen wird dringend abgeraten.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Sockettyps und Protokolls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `socketType` Parameter gibt den Typ des der <xref:System.Net.Sockets.Socket> Klasse und die `protocolType` Parameter gibt an, das von verwendete Protokoll <xref:System.Net.Sockets.Socket>. Die beiden Parameter sind nicht voneinander unabhängig. Häufig die <xref:System.Net.Sockets.Socket> Typ ist implizit in das Protokoll. Wenn die Kombination von <xref:System.Net.Sockets.Socket> Typ und das Protokoll, geben Ergebnisse in einen ungültigen <xref:System.Net.Sockets.Socket>, löst der Konstruktor eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn dieser Konstruktor löst eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Socket (System.Net.Sockets.AddressFamily addressFamily, System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily addressFamily, valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.#ctor(System.Net.Sockets.AddressFamily,System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Socket(System::Net::Sockets::AddressFamily addressFamily, System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.Socket : System.Net.Sockets.AddressFamily * System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType -&gt; System.Net.Sockets.Socket" Usage="new System.Net.Sockets.Socket (addressFamily, socketType, protocolType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="addressFamily" Type="System.Net.Sockets.AddressFamily" />
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
      </Parameters>
      <Docs>
        <param name="addressFamily">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</param>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse unter Verwendung der angegebenen Adressfamilie sowie des angegebenen Sockettyps und Protokolls.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `addressFamily` Parameter gibt das Adressierschema an, die die <xref:System.Net.Sockets.Socket> -Klasse verwendet, die `socketType` Parameter gibt den Typ des der <xref:System.Net.Sockets.Socket> -Klasse, und die `protocolType` Parameter gibt an, das von verwendete Protokoll <xref:System.Net.Sockets.Socket>. Die drei Parameter sind nicht voneinander unabhängig. Adressfamilien einschränken, welche Protokolle verwendet werden können, und häufig die <xref:System.Net.Sockets.Socket> Typ ist implizit in das Protokoll. Wenn die Kombination der Adressfamilie, <xref:System.Net.Sockets.Socket> Typ, und geben Sie die Ergebnisse in ein ungültiges Protokoll <xref:System.Net.Sockets.Socket>, löst der Konstruktor eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn dieser Konstruktor löst eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Erstellen einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse.  
  
 [!code-cpp[Socket_Send_Recieve#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#1)]
 [!code-csharp[Socket_Send_Recieve#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#1)]
 [!code-vb[Socket_Send_Recieve#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Die Kombination von <paramref name="addressFamily" />, <paramref name="socketType" /> und <paramref name="protocolType" /> führt zu einem ungültigen Socket.</exception>
        <altmember cref="T:System.Net.Sockets.SocketException" />
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
        <altmember cref="T:System.Net.Sockets.ProtocolType" />
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="Accept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Accept ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket Accept() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Accept" />
      <MemberSignature Language="VB.NET" Value="Public Function Accept () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ Accept();" />
      <MemberSignature Language="F#" Value="member this.Accept : unit -&gt; System.Net.Sockets.Socket" Usage="socket.Accept " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> für eine neu erstellte Verbindung.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Accept%2A> synchron die erste ausstehende verbindungsanforderung extrahiert, in der Warteschlange von der empfangsbereiten Sockets und Verbindung erstellt und gibt ein neues <xref:System.Net.Sockets.Socket>. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Allerdings rufen Sie die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Methode der zurückgegebenen <xref:System.Net.Sockets.Socket> den Hostnamen des Remotehosts Adresse und den Port identifizieren.  
  
 In den blockierenden Modus <xref:System.Net.Sockets.Socket.Accept%2A> blockiert, bis Sie ein eingehenden Verbindungsversuch in der Warteschlange befindet. Sobald eine Verbindung akzeptiert wird, die ursprüngliche <xref:System.Net.Sockets.Socket> weiterhin queuing eingehende verbindungsanforderungen bis schließen sie.  
  
 Wenn Sie diese Methode mit einem nicht blockierenden Aufrufen <xref:System.Net.Sockets.Socket>, und daher keine Verbindung mit dem Anforderungen werden in der Warteschlange, <xref:System.Net.Sockets.Socket.Accept%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Vor dem Aufruf der <xref:System.Net.Sockets.Socket.Accept%2A> -Methode, Sie müssen zuerst Aufrufen der <xref:System.Net.Sockets.Socket.Listen%2A> Methode zum Überwachen und in die Warteschlange eingehende verbindungsanforderungen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird akzeptiert, eine einfache <xref:System.Net.Sockets.Socket> Verbindung.  
  
 [!code-cpp[Classic Socket.Accept Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Accept Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Accept Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Accept Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Accept Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Accept Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.Accept" /> aufrufen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="AcceptAsync">
      <MemberSignature Language="C#" Value="public bool AcceptAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool AcceptAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool AcceptAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.AcceptAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.AcceptAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Asynchron, Verbindungen zu akzeptieren, bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Vor dem Aufruf der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> Methode zum Überwachen und in die Warteschlange eingehende verbindungsanforderungen.  
  
 Zum Abschluss benachrichtigt werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs > delegieren und verknüpfen Sie ihn auf die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann optional angeben, ein vorhandenes <xref:System.Net.Sockets.Socket> für die Verwendung der eingehenden Verbindung durch Angabe der <xref:System.Net.Sockets.Socket> für die Verwendung mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> -Eigenschaft ist null, ein neues <xref:System.Net.Sockets.Socket> wird erstellt, mit dem gleichen <xref:System.Net.Sockets.Socket.AddressFamily%2A>, <xref:System.Net.Sockets.Socket.SocketType%2A>, und <xref:System.Net.Sockets.Socket.ProtocolType%2A> wie die aktuelle <xref:System.Net.Sockets.Socket> und legen Sie als die <xref:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket%2A?displayProperty=nameWithType> Eigenschaft.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Optional kann ein Puffer angegeben werden, in dem der erste Block von Daten auf dem Socket nach dem Empfangen der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss auf den Puffer mit den Daten festgelegt werden, empfangen und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die maximale Anzahl von Bytes der Daten festgelegt werden, um in den Puffer zu erhalten. Diese Eigenschaften können festgelegt werden, mithilfe der <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A?displayProperty=nameWithType> Methode. Teil des übergebenen Puffers wird intern für die Verwendung durch den zugrunde liegenden Winsock AcceptEx-Aufruf genutzt werden. Dies bedeutet, dass die Menge der zurückgegebenen Daten immer kleiner als der Wert, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Eigenschaft für die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> bereitgestellten Instanz. Die Menge des Puffers wird intern verwendet, ist die Adressfamilie des Sockets abhängig. Die minimale erforderliche Puffergröße ist 288 Byte. Wenn Sie ein größeren Puffer angegeben wird, und klicken Sie dann die <xref:System.Net.Sockets.Socket> erwarten, dass zusätzlichen Daten als die Adressdaten, die durch den Aufruf Winsock AcceptEx empfangen und wartet, bis diese zusätzlichen Daten empfangen werden. Wenn ein Timeout auftritt, wird die Verbindung zurückgesetzt. Also wenn zusätzliche Daten für eine bestimmte Menge erwartet werden, sollte dann die Größe des Puffers, der minimalen Puffergröße und diesen Betrag festgelegt werden.  
  
 Die Vervollständigung Callback-Methode sollte überprüfen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Vorgang war erfolgreich.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis kann in einigen Fällen auftreten, wenn keine Verbindung akzeptiert wurde und dazu führen, dass die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> Eigenschaft festgelegt werden, um <xref:System.Net.Sockets.SocketError.ConnectionReset>. Dies kann auftreten, als Ergebnis der portüberwachung mithilfe eines halb geöffneten SYN-Typ-Scans (eine SYN -> SYN-ACK-RST-Sequenz ->). Anwendungen, die mit der <xref:System.Net.Sockets.Socket.AcceptAsync%2A> Methode sollten darauf vorbereitet sein, diese Konstellation behandeln.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn der bereitgestellte Puffer nicht groß genug ist. Der Puffer muss wenigstens 2 * (sizeof(SOCKADDR_STORAGE + 16) Bytes betragen.  
  
Diese Ausnahme tritt auch auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Ein Argument liegt außerhalb des gültigen Bereichs. Die Ausnahme tritt auf, wenn <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" /> kleiner als 0 ist.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde eine ungültige Operation angefordert. Diese Ausnahme tritt auf, wenn der annehmende <see cref="T:System.Net.Sockets.Socket" /> keine Verbindungen überwacht oder der angenommene Socket gebunden ist.  
  
Sie müssen die <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />-Methode und die <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />-Methode aufrufen, bevor Sie die <see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode aufrufen.  
  
Diese Ausnahme tritt auch auf, wenn der Socket bereits verbunden ist oder bereits ein Socketvorgang mit dem angegebenen <paramref name="e" />-Parameter ausgeführt wird.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="AddressFamily">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.AddressFamily AddressFamily { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.AddressFamily AddressFamily" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.AddressFamily" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property AddressFamily As AddressFamily" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::AddressFamily AddressFamily { System::Net::Sockets::AddressFamily get(); };" />
      <MemberSignature Language="F#" Value="member this.AddressFamily : System.Net.Sockets.AddressFamily" Usage="System.Net.Sockets.Socket.AddressFamily" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.AddressFamily</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Adressfamilie des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.AddressFamily> gibt an, die Adressierung von Schemas, die einer Instanz von der <xref:System.Net.Sockets.Socket> Klasse verwenden kann. Diese Eigenschaft ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.AddressFamily" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.Socket.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Datenmenge ab, die über das Netzwerk empfangen wurde und gelesen werden kann.</summary>
        <value>Die Anzahl der Datenbytes, die vom Netzwerk empfangen wurden und zum Lesen zur Verfügung stehen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie einen nicht blockierenden verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Available%2A> ist eine gute Möglichkeit, um festzustellen, ob die Daten für das Lesen, vor dem Aufruf in der Warteschlange ist <xref:System.Net.Sockets.Socket.Receive%2A>. Die verfügbaren Daten ist, dass die Gesamtmenge der Daten im Netzwerkpuffer zum Lesen in die Warteschlange eingereiht. Wenn keine Daten im Netzwerkpuffer, in der Warteschlange ist <xref:System.Net.Sockets.Socket.Available%2A> gibt 0 zurück.  
  
 Wenn der remote-Host beendet wird oder die Verbindung schließt, <xref:System.Net.Sockets.Socket.Available%2A> Auslösen einer <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird, vergleicht die Ergebnisse des Aufrufs von IOControl mit FIONREAD und der Eigenschaft zur Verfügung.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="T:System.IO.Stream" />
        <altmember cref="F:System.Net.Sockets.SocketType.Dgram" />
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Asynchron, Verbindungen zu akzeptieren, bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> Methode zum Überwachen und in die Warteschlange eingehende verbindungsanforderungen.  
  
 Sie müssen eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Zumindest dazu, müssen Sie übergeben, das Lauschen <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird. <xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt ein neues <xref:System.Net.Sockets.Socket> Objekt, das Sie verwenden können, zum Senden und Empfangen von Daten mit dem Remotehost. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode ist, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, die Callback-Methode aufrufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> wird festgelegt werden, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Können Sie die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> den Hostnamen des Remotehosts Adresse und den Port identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [Windows Sockets-Version 2-API-Fehlercode](/windows/desktop/winsock/windows-sockets-error-codes-2) Dokumentation für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird versucht, eine eingehende Verbindung asynchron zu empfangen.  
  
 [!code-cpp[Socket_Async_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Async_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Async_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder -  
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="receiveSize">Die Anzahl der Bytes vom Absender, die angenommen werden sollen.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Erstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Asynchron, Verbindungen zu akzeptieren, können Sie Daten in einem separaten Ausführungsthread senden und empfangen. Mit dieser Überladung können Sie angeben, die Anzahl der Bytes, die in der ersten Übertragung akzeptiert die `receiveSize` Parameter.  
  
 Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> Methode zum Überwachen und in die Warteschlange eingehende verbindungsanforderungen.  
  
 Sie müssen eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Zumindest dazu, müssen Sie übergeben, das Lauschen <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt eine neue <xref:System.Net.Sockets.Socket> , Sie verwenden können, zum Senden und Empfangen von Daten mit dem Remotehost. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode ist, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, die Callback-Methode aufrufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> wird festgelegt werden, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>.  Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Rufen Sie mithilfe der <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> Objekt, das den Hostnamen des Remotehosts Adresse und Anschluss identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel nimmt der Socket für die ersten 10 Bytes der Daten. Die Anzahl der empfangenen Bytes und die Daten werden von den Callback-Delegaten in der Konsole angezeigt. Finden Sie unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> eine Beschreibung, wie die übrigen Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder -  
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginAccept">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAccept (System.Net.Sockets.Socket acceptSocket, int receiveSize, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAccept(class System.Net.Sockets.Socket acceptSocket, int32 receiveSize, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginAccept(System.Net.Sockets.Socket,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAccept (acceptSocket As Socket, receiveSize As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAccept(System::Net::Sockets::Socket ^ acceptSocket, int receiveSize, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAccept : System.Net.Sockets.Socket * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginAccept (acceptSocket, receiveSize, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="acceptSocket" Type="System.Net.Sockets.Socket" />
        <Parameter Name="receiveSize" Type="System.Int32" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="acceptSocket">Das angenommene <see cref="T:System.Net.Sockets.Socket" />-Objekt. Dieser Wert kann <see langword="null" /> sein.</param>
        <param name="receiveSize">Die maximale Anzahl der zu empfangenden Bytes.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung von einem angegebenen Socket anzunehmen, und empfängt den ersten von der Clientanwendung gesendeten Datenblock.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone <see cref="T:System.Net.Sockets.Socket" />-Objekterstellung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verbindungsorientierte Protokolle können die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode zum asynchronen Verarbeiten von eingehenden Verbindung versucht. Asynchron, Verbindungen zu akzeptieren, bietet Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread. Mit dieser Überladung können Sie angeben, den angenommene Socket in den `acceptSocket` Parameter. Wenn dieser Parameter ist `null`, wird der angenommene Socket erstellt, indem die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Sie können angeben, die Anzahl der Bytes, die in der ersten Übertragung akzeptiert die `receiveSize` Parameter.  
  
 Vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, die Sie aufrufen müssen die <xref:System.Net.Sockets.Socket.Listen%2A> Methode zum Überwachen und in die Warteschlange eingehende verbindungsanforderungen.  
  
 Sie müssen eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Zumindest dazu, müssen Sie übergeben, das Lauschen <xref:System.Net.Sockets.Socket> -Objekt <xref:System.Net.Sockets.Socket.BeginAccept%2A> über die `state` Parameter. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginAccept%2A>, das System in der Regel verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndAccept%2A> bis eine ausstehende Verbindung abgerufen wird.  
  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Gibt eine neue <xref:System.Net.Sockets.Socket> Objekt, das Sie verwenden können, zum Senden und Empfangen von Daten mit dem Remotehost. Können keine diesem zurückgegebenen <xref:System.Net.Sockets.Socket> aller zusätzlichen Verbindungen aus der Verbindungswarteschlange akzeptieren. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode ist, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll.  
  
 Das System kann auch den aufrufenden Thread verwenden, die Callback-Methode aufrufen. In diesem Fall die <xref:System.IAsyncResult.CompletedSynchronously%2A> Eigenschaft für das zurückgegebene <xref:System.IAsyncResult> wird festgelegt werden, um anzugeben, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode synchron abgeschlossen wurde.  
  
 Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> Objekt, das den Hostnamen des Remotehosts Adresse und Anschluss identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und eine asynchrone Verbindung akzeptiert. In diesem Beispiel der Socket akzeptiert die ersten 10 Bytes der Daten und die `acceptSocket` Parameter `null`, die erzwingt, dass die <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode, um der angenommene Socket zu erstellen. Die Anzahl der empfangenen Bytes und die Daten werden von den Callback-Delegaten in der Konsole angezeigt. Finden Sie unter <xref:System.Net.Sockets.Socket.BeginReceive%2A> eine Beschreibung, wie die übrigen Daten empfangen werden.  
  
 [!code-cpp[NCLSocketEnhancements#7](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#7)]
 [!code-csharp[NCLSocketEnhancements#7](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.InvalidOperationException">Der annehmende Socket überwacht keine Verbindungen. Vor dem Aufruf von <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> müssen Sie <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> und <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> aufrufen.  
  
- oder -  
Der angenommene Socket ist gebunden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="receiveSize" /> ist kleiner als 0.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="P:System.Net.Sockets.Socket.RemoteEndPoint" />
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginConnect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (remoteEP As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.EndPoint end_point, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.EndPoint end_point, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (end_point As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::EndPoint ^ end_point, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (end_point, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="1" />
        <Parameter Name="state" Type="System.Object" Index="2" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</param>
        <param name="end_point">Ein <see cref="T:System.Net.EndPoint" />, der den Remotehost darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll, verwenden die <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode startet eine asynchrone Anforderung für eine Verbindung mit der `remoteEP` Parameter. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.BeginConnect%2A> richtet einen Standardremotehost ein. Herstellen einer Verbindung oder die Standard-Remotehost asynchron festlegen wird Ihnen die Möglichkeit zum Senden und Empfangen von Daten in einem separaten Ausführungsthread.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode. Zumindest, müssen Sie übergeben die <xref:System.Net.Sockets.Socket> zu <xref:System.Net.Sockets.Socket.BeginConnect%2A> über die `state` Parameter. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket>, und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginConnect%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndConnect%2A> erst die <xref:System.Net.Sockets.Socket> eine Verbindung hergestellt oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode ist, <xref:System.Threading.WaitHandle.WaitOne%2A>. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.BeginConnect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.BeginSendTo%2A> und <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.BeginConnect%2A>, alle Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie Ihre Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , und legen Sie auf Broadcast `true`. Wenn Sie keine Möglichkeit, <xref:System.Net.Sockets.Socket.BeginConnect%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, und Sie keine rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginConnect%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, der Dienstanbieter nicht weist eine LAN-Adresse und Portnummer Zahl bis zum Aufruf der <xref:System.Net.Sockets.Socket.BeginSend%2A> oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode mit den gewünschten Endpunkt.  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[Socket_Async_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Async_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Async_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress address, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress address, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (address As IPAddress, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::Net::IPAddress ^ address, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (address, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="address">Die <see cref="T:System.Net.IPAddress" /> des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch eine <see cref="T:System.Net.IPAddress" /> und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> -methodenüberladungen, oder <xref:System.Net.Sockets.Socket.EndConnect%2A>.  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> , verwendet, müssen unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#7)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der <see cref="T:System.Net.Sockets.Socket" /> ist nicht in der Socketfamilie enthalten.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.Net.IPAddress[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (System.Net.IPAddress[] addresses, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(class System.Net.IPAddress[] addresses, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (addresses As IPAddress(), port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : System.Net.IPAddress[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (addresses, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="addresses">Mindestens eine <see cref="T:System.Net.IPAddress" />, die den Remotehost angibt.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch ein <see cref="T:System.Net.IPAddress" />-Array und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchronen Verbindungen verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> Überladungen der Methode.  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> , verwendet, müssen unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets, die <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> verwenden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginConnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback requestCallback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginConnect(System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginConnect (string host, int port, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginConnect(string host, int32 port, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginConnect (host As String, port As Integer, callback As AsyncCallback, state As Object) As IAsyncResult" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginConnect(System::String ^ host, int port, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginConnect : string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginConnect (host, port, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" Index="0" />
        <Parameter Name="port" Type="System.Int32" Index="1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="3" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Verbindungsvorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Verbindungsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Remotehostverbindung. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Verbindung verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginConnect%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `requestCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Connect%2A> Überladungen der Methode.  
  
 Zum Abbrechen eines anstehenden Aufrufs der <xref:System.Net.Sockets.Socket.BeginConnect%2A> -Methode, schließen die <xref:System.Net.Sockets.Socket>. Bei der <xref:System.Net.Sockets.Socket.Close%2A> des Rückrufs-Methode aufgerufen wird, während ein asynchroner Vorgang ausgeführt wird, bereitgestellt werden, um die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode wird aufgerufen.  Ein nachfolgender Aufruf von der <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode löst eine <xref:System.ObjectDisposedException> um anzugeben, dass der Vorgang abgebrochen wurde.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn dieser Socket zuvor, klicken Sie dann getrennt wurde <xref:System.Net.Sockets.Socket.BeginConnect%2A> muss aufgerufen werden, auf einen Thread, der nicht beendet wird, bis der Vorgang abgeschlossen ist. Dies ist eine Einschränkung des zugrunde liegenden Anbieter. Auch die <xref:System.Net.EndPoint> , verwendet, müssen unterschiedlich sein.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird initiiert einen asynchronen Verbindungsversuch.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#1)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#1)]  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#3)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert, oder ein asynchroner Vorgang wird bereits ausgeführt.</exception>
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginDisconnect">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginDisconnect (bool reuseSocket, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginDisconnect(bool reuseSocket, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginDisconnect (reuseSocket As Boolean, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginDisconnect(bool reuseSocket, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginDisconnect : bool * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginDisconnect (reuseSocket, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die Verbindung geschlossen wurde, andernfalls <see langword="false" />.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das auf den asynchronen Vorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie rufen die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Methode, um die Trennung der Verbindung mit einem Remoteendpunkt anzufordern. Wenn `reuseSocket` ist `true`, können Sie den Socket wiederverwenden.  
  
 Die <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> Methode verwendet einen separaten Thread, um die angegebene Rückrufmethode aufgerufen. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode blockiert, bis der ausstehende Trennung der Verbindung abgeschlossen ist. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> Ausnahme verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet Daten an einen Remotehost. Wenn die Daten gesendet wurde, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um das Beenden der Send und receive-Aktivität. Klicken Sie dann <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Anforderung zum Trennen zu beginnen. Wenn die Anforderung abgeschlossen ist, die <xref:System.Net.Sockets.Socket.Connected%2A> abgefragt wird, um festzustellen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel beginnt den asynchronen Datenempfang aus einem verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Async_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Async_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Async_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#11)]  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags flags, out System.Net.Sockets.SocketError error, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags flags, [out] valuetype System.Net.Sockets.SocketError&amp; error, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (buffer As Byte(), offset As Integer, size As Integer, flags As SocketFlags, ByRef error As SocketError, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags flags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % error, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceive (buffer, offset, size, flags, error, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="error" Type="System.Net.Sockets.SocketError" RefType="out" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="error">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />-Delegaten übergeben.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.Socket.BeginReceive%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Zum Blockieren, bis der Vorgang abgeschlossen ist, gehen die <xref:System.Net.Sockets.Socket.Receive%2A> Überladungen der Methode.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException"><see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, ref System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint&amp; remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceiveFrom (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, ByRef remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ % remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveFrom (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" RefType="ref" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="remote_end">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode startet verbindungslose Datagramme asynchron von einem Remotehost zu lesen. Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu erhalten.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> erst die <xref:System.Net.Sockets.Socket> Daten liest, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode ist, <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType>. Rufen Sie die Set-Methode für einen: System.Threading.ManualResetEvent in der Rückrufmethode ein, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, müssen Sie explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode oder <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Diese Methode liest die Daten in die `buffer` -Parameter und zeichnet den Remotehost Endpunkt aus dem die Daten werden gesendet. Informationen zum Abrufen von diesem Endpunkt finden Sie in <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode ist besonders hilfreich, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts zu empfangen. In diesen Fällen <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest das erste Datagramm, die im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm, Sie erhalten, größer als die Größe des `buffer`, <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich ist, und lösen wird mit der Meldung eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein-unzuverlässigen Protokoll verwenden, werden überschüssigen Daten in die verloren gehen. Wenn Sie ein zuverlässiges Protokoll verwenden, überschüssigen Daten in die vom Dienstanbieter beibehalten werden werden und zum Abrufen dieses durch Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> -Methode mit einem ausreichend großen Puffer.  
  
 Um sicherzustellen, dass der remote-Host-Endpunkt wird immer zurückgegeben, die eine Anwendung sollten explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, und rufen Sie dann die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode mit der `optionLevel` Parametersatz zu <xref:System.Net.Sockets.SocketOptionLevel.IP>oder <xref:System.Net.Sockets.SocketOptionLevel.IPv6> nach Bedarf die `optionName` Parametersatz zu <xref:System.Net.Sockets.SocketOptionName.PacketInformation>, und die `optionValue` Parameter zum Aktivieren dieser Option vor dem Aufruf der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Andernfalls ist es möglich, dass der remote-Host-Endpunkt nicht zurückgegeben werden, wenn der Absender eine Reihe von Datagrammen gesendet hat, bevor der Empfänger aufgerufen hat die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode.  
  
 Obwohl <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie dazu entscheiden, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A>  /  <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, oder übernehmen Sie eine eingehende verbindungsanforderung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. Aufrufen der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode vor eine Verbindung hergestellt oder angenommen, Sie erhalten eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. In beiden Fällen die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode ignoriert die `remoteEP` Parameter und nur Daten aus dem verbundenen oder Standard-Remotehost empfangen.  
  
 Bei einem verbindungsorientierten Sockets <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> liest so viele Daten wie verfügbar bis zur Anzahl von Bytes, die angegeben ist die `size` Parameter.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die verbindungslose Datagramme asynchron von einem Remotehost empfangen.  
  
 [!code-cpp[Socket_Async_Send_Receive#41](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#41)]
 [!code-csharp[Socket_Async_Send_Receive#41](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#41)]
 [!code-vb[Socket_Async_Send_Receive#41](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#41)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
      </Docs>
    </Member>
    <Member MemberName="BeginReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceiveMessageFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceiveMessageFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der die Daten gespeichert werden.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der die Datenquelle darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Beginnt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />-Klassen den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Lesevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchronen Empfangsvorgang abgeschlossen werden muss, durch den Aufruf der <xref:System.Net.Sockets.Socket.EndReceiveMessageFrom%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `asyncCallback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceiveMessageFrom%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md)  
  
 Diese Methode liest die Daten in die `buffer` -Parameter, und zeichnet den Remotehost Endpunkt aus dem die Daten gesendet werden, sowie Informationen über das empfangene Paket. Informationen zum Abrufen von diesem Endpunkt finden Sie in <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A>. Diese Methode ist besonders hilfreich, wenn Sie beabsichtigen, verbindungslose Datagramme asynchron von einem unbekannten Host oder mehreren Hosts zu empfangen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine Ausnahme ausgelöst, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> erst die <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für einen: System.Threading.ManualResetEvent in der Rückrufmethode ein, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSend%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffers, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffers">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine Ausnahme ausgelöst, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> erst die <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für eine <xref:System.Threading.ManualResetEvent> in die Callback-Methode, wenn den ursprünglichen Thread weiterhin ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSend%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags *  * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socketFlags, errorCode, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine Ausnahme ausgelöst, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> erst die <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für einen: System.Threading.ManualResetEvent in der Rückrufmethode ein, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSend%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * int * System.Net.Sockets.SocketFlags * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSend (buffer, offset, size, socket_flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="4" />
        <Parameter Name="state" Type="System.Object" Index="5" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />-Parameter, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet Daten asynchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode. <xref:System.Net.Sockets.Socket.BeginSend%2A> wird eine Ausnahme ausgelöst, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine kleine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSend%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSend%2A> erst die <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für einen: System.Threading.ManualResetEvent in der Rückrufmethode ein, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSend%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.BeginSendTo%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.BeginSendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.BeginSend%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.BeginSend%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  `state` ist eine Instanziierung einer benutzerdefinierten Klasse.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird startet das asynchrone Senden von Daten mit einem Remotehost.  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist kleiner als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-client-socket-example.md">Asynchrone Clientsockets - Beispiel</related>
        <related type="Article" href="~/docs/framework/network-programming/asynchronous-server-socket-example.md">Asynchroner Serversocket, Beispiel</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet eine Datei asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> unter Verwendung des <see cref="T:System.Net.Sockets.Socket" />-Flags an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Sendevorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an die verbundenen Socket. Wenn `fileName` ist im lokalen Verzeichnis befindet, kann es mit nur den Namen der Datei bezeichnet werden, andernfalls den vollständigen Pfad und Name der Datei angegeben werden müssen. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Diese Methode verwendet die `TransmitFile` Funktion gefunden wird, in der Windows Sockets-API-2. Weitere Informationen zu den `TransmitFile` -Funktion und die Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>,<xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methoden. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode können Sie eine Datei in einem separaten Ausführungsthread zu senden.  
  
 Um den Vorgang abzuschließen, können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <xref:System.AsyncCallback> Delegatparameter. Dazu äußerstes Minimum, das `state` Parameter muss enthalten der <xref:System.Net.Sockets.Socket> Objekt für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert für <xref:System.Net.Sockets.Socket.EndSendFile%2A> erst die <xref:System.Net.Sockets.Socket> sendet die gesamte Datei oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Mit verbindungslose Protokolle müssen Sie Sie sicher, dass sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Service Providers nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> Ausnahme verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation. Zunächst wird die Datei "text.txt" asynchron an den Remotehost gesendet. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> die Übertragung abgeschlossen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendFile">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags, AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags, class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags, AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendFile (fileName, preBuffer, postBuffer, flags, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="fileName">Eine Zeichenfolge, die den Pfad und Namen der zu sendenden Datei enthält. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Eine bitweise Kombination von <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Werten.</param>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der nach Abschluss dieses Vorgangs aufgerufen werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="state">Ein benutzerdefiniertes Objekt mit Zustandsinformationen für diese Anforderung. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet eine Datei und Datenpuffer asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss der Name der zu sendenden Datei und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions> Werte. Die `preBuffer` Parameter enthält alle Daten, die vor der Datei gesendet werden sollen. `postBuffer` enthält Daten, die auf die Datei folgen soll. Wenn `fileName` ist im lokalen Verzeichnis befindet, kann es mit nur den Namen der Datei bezeichnet werden, andernfalls den vollständigen Pfad und Name der Datei angegeben werden müssen. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Die `flags` Parameter stellt den Dienstanbieter für Fenster-Sockets mit zusätzlichen Informationen über die Dateiübertragung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile` Funktion gefunden wird, in der Windows Sockets-API-2. Weitere Informationen zu den `TransmitFile` -Funktion und die Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 Die <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methoden. <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.BeginConnect%2A>. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode bietet Ihnen die Möglichkeit, eine Datei in einem separaten Ausführungsthread zu senden.  
  
 Um den Vorgang abzuschließen, können Sie eine Rückrufmethode, die aufgerufen wird, indem Sie erstellen die <xref:System.AsyncCallback> Delegatparameter. Dazu äußerstes Minimum, das `state` Parameter muss enthalten der <xref:System.Net.Sockets.Socket> Objekt für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen, eine Klasse oder Struktur zum Speichern der <xref:System.Net.Sockets.Socket> und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieses benutzerdefinierten Objekts in der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen muss die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, das System verwendet einen eigenen Thread zum Ausführen der angegebenen Rückrufmethode und blockiert für <xref:System.Net.Sockets.Socket.EndSendFile%2A> erst die <xref:System.Net.Sockets.Socket> sendet die gesamte Datei oder eine Ausnahme auslöst. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt <xref:System.Net.Sockets.Socket.BeginSendFile%2A> funktioniert auch für verbindungslose Protokolle, vorausgesetzt, Sie rufen Sie zuerst die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode, um einen Standardremotehost herzustellen. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Service Providers nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.BeginSendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> Ausnahme verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost. In diesem Beispiel eine `preBuffer` und `postBuffer` Daten erstellt, die mit der Datei und der Standardwert gesendet <xref:System.Net.Sockets.TransmitFileOptions> Wert wird verwendet. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> die Übertragung abgeschlossen.  
  
 [!code-cpp[NCLSocketEnhancements#10](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#10)]
 [!code-csharp[NCLSocketEnhancements#10](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
\- oder – 
Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginSendTo">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP, AsyncCallback callback, object state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socket_flags, System.Net.EndPoint remote_end, AsyncCallback callback, object state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socket_flags, class System.Net.EndPoint remote_end, class System.AsyncCallback callback, object state) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSendTo (buffer As Byte(), offset As Integer, size As Integer, socket_flags As SocketFlags, remote_end As EndPoint, callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socket_flags, System::Net::EndPoint ^ remote_end, AsyncCallback ^ callback, System::Object ^ state);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.BeginSendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="socket.BeginSendTo (buffer, offset, size, socket_flags, remote_end, callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" Index="0" />
        <Parameter Name="offset" Type="System.Int32" Index="1" />
        <Parameter Name="size" Type="System.Int32" Index="2" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="socket_flags" Type="System.Net.Sockets.SocketFlags" Index="3" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="remote_end" Type="System.Net.EndPoint" Index="4" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="callback" Type="System.AsyncCallback" Index="5" />
        <Parameter Name="state" Type="System.Object" Index="6" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die nullbasierte Position im <paramref name="buffer" />, an der mit dem Senden der Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="socket_flags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <param name="remote_end">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <param name="callback">Der <see cref="T:System.AsyncCallback" />-Delegat.</param>
        <param name="state">Ein Objekt mit Zustandsinformationen für diese Anforderung.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, angegeben der `remoteEP` Parameter. Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden. Obwohl für die verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.BeginSendTo%2A> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.  
  
 Sie können eine Rückrufmethode, die implementiert erstellen die <xref:System.AsyncCallback> delegieren und übergeben Sie seinen Namen der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode. Hierzu äußerstes Minimum, Ihre `state` Parameter muss der verbundenen enthalten oder default <xref:System.Net.Sockets.Socket> für die Kommunikation verwendet wird. Wenn Ihr Rückruf Informationen benötigt werden, können Sie erstellen eine kleine Klasse zum Speichern der <xref:System.Net.Sockets.Socket>, und die weiteren erforderlichen Informationen. Übergeben Sie eine Instanz dieser Klasse, die <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode über die `state` Parameter.  
  
 Die Rückrufmethode aufrufen sollten die <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode. Wenn die Anwendung aufruft <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, das System verwendet einen separaten Thread zum Ausführen der angegebenen Rückrufmethode und blockiert <xref:System.Net.Sockets.Socket.EndSendTo%2A> erst die <xref:System.Net.Sockets.Socket> sendet die Anzahl der angeforderten Bytes, oder löst eine Ausnahme aus. Wenn Sie möchten, dass den ursprüngliche Thread blockiert wird, nach dem Aufrufen der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> -Methode, mit der <xref:System.Threading.WaitHandle.WaitOne%2A?displayProperty=nameWithType> Methode. Rufen Sie die Set-Methode für einen: System.Threading.ManualResetEvent in der Rückrufmethode ein, wenn der ursprüngliche Thread weiter ausgeführt werden soll. Weitere Informationen zum Schreiben von Rückrufmethoden finden Sie unter [Marshalling von Delegaten als Rückrufmethode](~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md).  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> -Methode oder <xref:System.Net.Sockets.Socket.BeginSendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. <xref:System.Net.Sockets.Socket.BeginSendTo%2A> ignoriert die `remoteEP` Parameter und sendet Daten an die <xref:System.Net.EndPoint> hergestellt, der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Accept%2A>, oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.BeginConnect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` Parameter überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie werden außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. In diesem Fall wird der zugrunde liegenden Dienstanbieter, die am besten geeignete Anzahl von LAN-Adresse und Port zuweisen. Verwenden Sie die Portnummer 0 (null), wenn Sie den zugrunde liegenden Dienstanbieter, um einen Free-Port auswählen möchten. Wenn Sie die zugeordnete lokale Adresse und den Port identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft nach der <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. – Sie müssen auch darauf achten, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.EndSendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Ausführungskontext (den Sicherheitskontext, den imitierten Benutzer und dem aufrufenden Kontext) werden zwischengespeichert, für das asynchrone <xref:System.Net.Sockets.Socket> Methoden. Nach der ersten Verwendung eines bestimmten Kontexts (eine bestimmte asynchrone <xref:System.Net.Sockets.Socket> Methode, eine bestimmte <xref:System.Net.Sockets.Socket> -Instanz und ein bestimmter Rückruf), nachfolgende Verwendungen von diesem Kontext werden eine leistungsverbesserung angezeigt.  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet Daten asynchron an den angegebenen Remotehost.  
  
 [!code-cpp[Socket_Async_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Async_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Async_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <related type="Article" href="~/docs/framework/interop/marshaling-a-delegate-as-a-callback-method.md">Marshalling von Delegaten als Rückrufmethode</related>
      </Docs>
    </Member>
    <Member MemberName="Bind">
      <MemberSignature Language="C#" Value="public void Bind (System.Net.EndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Bind(class System.Net.EndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Bind (localEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Bind(System::Net::EndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="member this.Bind : System.Net.EndPoint -&gt; unit" Usage="socket.Bind localEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Der lokale <see cref="T:System.Net.EndPoint" />, der dem <see cref="T:System.Net.Sockets.Socket" /> zugeordnet werden soll.</param>
        <summary>Ordnet einem <see cref="T:System.Net.Sockets.Socket" /> einen lokalen Endpunkt zu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, wenn Sie einen bestimmten lokalen Endpunkt verwenden möchten. Rufen Sie <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf kann die <xref:System.Net.Sockets.Socket.Listen%2A> Methode. Sie müssen nicht aufrufen <xref:System.Net.Sockets.Socket.Bind%2A> vor der Verwendung der <xref:System.Net.Sockets.Socket.Connect%2A> Methode es sei denn, Sie einen bestimmten lokalen Endpunkt zu verwenden müssen. Sie können die <xref:System.Net.Sockets.Socket.Bind%2A> Methode Verbindungs- und verbindungsorientierte Protokolle.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.Bind%2A>, müssen Sie zunächst die lokale erstellen <xref:System.Net.IPEndPoint> aus dem Sie Daten kommuniziert werden soll. Wenn Sie sich nicht wichtig ist, welche lokalen Adresse zugewiesen ist, können Sie erstellen eine <xref:System.Net.IPEndPoint> mit <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adressenparameter und den zugrunde liegenden Dienst weist Anbieter die am besten geeignete Netzwerkadresse. Das kann hilfreich sein, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht wichtig ist der lokaler Port verwendet wird, können Sie erstellen eine <xref:System.Net.IPEndPoint> verwenden 0 für die Nummer des Ports. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000.  
  
 Wenn Sie die oben beschriebene Ansatz verwenden, können Sie ermitteln, welche LAN-Adresse und Portnummer Anzahl durch den Aufruf zugewiesen wurde die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A>. Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> gibt nicht die lokal zugewiesene Netzwerkadresse erst zurück, nachdem Sie einen Aufruf von vorgenommen haben die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, werden Sie keinen Zugriff auf diese Informationen, bis Sie ein senden haben oder empfangen.  
  
 Wenn ein UDP-Socket Schnittstelleninformationen auf empfangene Pakete empfangen werden sollen die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> -Methode muss explizit aufgerufen werden, mit der Socketoption auf <xref:System.Net.Sockets.SocketOptionName.PacketInformation> unmittelbar nach dem Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie beabsichtigen, multicast Datagramme zu empfangen, müssen Sie Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> Methode mit einer multicast-Portnummer.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, wenn Sie beabsichtigen, verbindungslose Datagramme mit empfangen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> beim Aufrufen der <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, mit der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel bindet ein <xref:System.Net.Sockets.Socket> mit dem angegebenen lokalen Endpunkt.  
  
 [!code-cpp[Classic Socket.Bind Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Bind Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Bind Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Bind Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Bind Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Bind Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen aus dem Host durch definiert <paramref name="localEP" />. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Blocking">
      <MemberSignature Language="C#" Value="public bool Blocking { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Blocking" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Blocking" />
      <MemberSignature Language="VB.NET" Value="Public Property Blocking As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Blocking { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Blocking : bool with get, set" Usage="System.Net.Sockets.Socket.Blocking" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob sich der <see cref="T:System.Net.Sockets.Socket" /> im blockierenden Modus befindet.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> blockiert wird, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft gibt an, ob eine <xref:System.Net.Sockets.Socket> im blockierenden Modus befindet.  
  
 Wenn Sie in den blockierenden Modus, und Sie stellen eine Methode aufrufen, die nicht sofort abgeschlossen wird, blockiert Ihre Anwendung die Ausführung bis zum Abschluss des angeforderten Vorgangs. Wenn Sie möchten die Ausführung fortgesetzt werden, obwohl der angeforderte Vorgang nicht abgeschlossen ist, ändern Sie die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false`. Die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft hat keine Auswirkungen auf asynchrone Methoden. Wenn Sie senden und Empfangen von Daten asynchron und die Ausführung blockieren möchten, verwenden Sie die <xref:System.Threading.ManualResetEvent> Klasse.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="CancelConnectAsync">
      <MemberSignature Language="C#" Value="public static void CancelConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void CancelConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.CancelConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub CancelConnectAsync (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void CancelConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member CancelConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="System.Net.Sockets.Socket.CancelConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das verwendet wurde, um die Verbindung mit dem Remotehost durch Aufrufen einer der <see cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />-Methoden anzufordern.</param>
        <summary>Bricht eine asynchrone Anforderung einer Remotehostverbindung ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.CancelConnectAsync%2A> -Methode bricht eine asynchrone Anforderung einer Remotehostverbindung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Close">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="socket.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A> Methode schließt die Verbindung des remote-Host und Versionen alle verwalteten und nicht verwaltete Ressourcen im Zusammenhang mit der <xref:System.Net.Sockets.Socket>. Beim Beenden der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaftensatz auf `false`.  
  
 Für verbindungsorientierte Protokolle, wird empfohlen, die Sie aufrufen <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf der <xref:System.Net.Sockets.Socket.Close%2A> Methode. Dadurch wird sichergestellt, dass alle Daten gesendet und auf dem verbundenen Socket empfangen wird, bevor diese geschlossen wird.  
  
 Wenn Sie aufrufen möchten <xref:System.Net.Sockets.Socket.Close%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> die Möglichkeit, `false` und ein Timeoutintervall von ungleich NULL angeben. <xref:System.Net.Sockets.Socket.Close%2A> wird dann blockiert, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Setzen Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> zu `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Festlegen der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`, erstellen eine <xref:System.Net.Sockets.LingerOption>, legen Sie die enabled-Eigenschaft auf `true`, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft, um das gewünschte Zeitlimit. Verwenden Sie diese Option <xref:System.Net.Sockets.LingerOption> zusammen mit den <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption zum Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel Beispiel schließt eine <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close (int timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close(int32 timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Close(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close (timeout As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close(int timeout);" />
      <MemberSignature Language="F#" Value="member this.Close : int -&gt; unit" Usage="socket.Close timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="timeout">Warten Sie bis zu <paramref name="timeout" /> Sekunden, damit alle verbleibenden Daten gesendet werden, und schließen Sie dann den Socket.</param>
        <summary>Schließt die <see cref="T:System.Net.Sockets.Socket" />-Verbindung und gibt alle zugeordneten Ressourcen mit einem angegebenen Timeout frei, damit in der Warteschlange befindliche Daten gesendet werden können.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Close%2A> Methode schließt die Verbindung des remote-Host und Versionen alle verwalteten und nicht verwaltete Ressourcen im Zusammenhang mit der <xref:System.Net.Sockets.Socket>. Beim Beenden der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaftensatz auf `false`.  
  
 Für verbindungsorientierte Protokolle, wird empfohlen, die Sie aufrufen <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Close%2A>. Dadurch wird sichergestellt, dass alle Daten gesendet und auf dem verbundenen Socket empfangen wird, bevor diese geschlossen wird.  
  
 Wenn Sie aufrufen möchten <xref:System.Net.Sockets.Socket.Close%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, können Sie sicherstellen, dass die Daten in der Warteschlange für ausgehende Übertragung festlegen, indem gesendet werden die <xref:System.Net.Sockets.SocketOptionName.DontLinger> die Möglichkeit, `false` und ein Timeoutintervall von ungleich NULL angeben. <xref:System.Net.Sockets.Socket.Close%2A> wird dann blockiert, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Setzen Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> zu `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Festlegen der <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption auf `false`, erstellen eine <xref:System.Net.Sockets.LingerOption>, legen Sie die enabled-Eigenschaft auf `true`, und legen Sie die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft, um das gewünschte Timeoutintervall. Verwenden Sie diese Option <xref:System.Net.Sockets.LingerOption> zusammen mit den <xref:System.Net.Sockets.SocketOptionName.DontLinger> Socketoption zum Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Schließen einer <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.DontLinger" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Stellt eine Verbindung mit einem Remotehost her.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (remoteEP As EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.EndPoint -&gt; unit" Usage="socket.Connect remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.EndPoint" />, der das Remotegerät darstellt.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebene Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standardremotehost ein. Nach dem Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A>, können Sie Daten senden, mit dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit dem <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A>, alle Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie Ihre Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 Die <xref:System.Net.Sockets.Socket.Connect%2A> Methode blockiert, es sei denn, Sie insbesondere die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP beim Deaktivieren des blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden eine Ausnahme nicht ausgelöst, da sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die remote-Host-Verbindung durch ein verbindungsorientiertes initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> beendet ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie nicht aufgerufen haben, und ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale Adresse und Portnummer Netzwerknummer, bis Sie einen Sendeport abgeschlossen oder receive-Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden eine Verbindung herzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt her, und anschließend überprüft die Verbindung.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
        <permission cref="T:System.Net.SocketPermission">für die Verbindung mit dem Remotehost. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Connect" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.Blocking" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress address, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress address, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (address As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ address, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="socket.Connect (address, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="address" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="address">Die IP-Adresse des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird mit einer IP-Adresse und einer Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebene Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standardremotehost ein. Nach dem Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> können Sie Daten senden, mit dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit dem <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie Ihre Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode blockiert, es sei denn, Sie insbesondere die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP beim Deaktivieren des blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden eine Ausnahme nicht ausgelöst, da sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die remote-Host-Verbindung durch ein verbindungsorientiertes initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> beendet ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie nicht aufgerufen haben, und ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale Adresse und Portnummer Netzwerknummer, bis Sie einen Sendeport abgeschlossen oder receive-Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden eine Verbindung herzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt her, und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#4)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="address" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress[] addresses, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress[] addresses, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.Net.IPAddress[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addresses As IPAddress(), port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(cli::array &lt;System::Net::IPAddress ^&gt; ^ addresses, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress[] * int -&gt; unit" Usage="socket.Connect (addresses, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addresses" Type="System.Net.IPAddress[]" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="addresses">Die IP-Adressen des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch ein Array von IP-Adressen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird in der Regel verwendet, sofort nach einem Aufruf von <xref:System.Net.Dns.GetHostAddresses%2A>, die können mehrere IP-Adressen für einen einzigen Host zurückgeben. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und der angegebene Remoteendpunkt. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standardremotehost ein. Nach dem Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> können Sie Daten senden, mit dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit dem <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie Ihre Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode blockiert, es sei denn, Sie insbesondere die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP beim Deaktivieren des blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden eine Ausnahme nicht ausgelöst, da sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die remote-Host-Verbindung durch ein verbindungsorientiertes initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> beendet ist eine Verbindung herstellen.  
  
> [!NOTE]
>  Wenn Sie nicht aufgerufen haben, und ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale Adresse und Portnummer Netzwerknummer, bis Sie einen Sendeport abgeschlossen oder receive-Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden eine Verbindung herzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt her, und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#5)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="addresses" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentException">Die Länge von <paramref name="address" /> ist 0 (null).</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string host, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string host, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (host As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ host, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="socket.Connect (host, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="host" Type="System.String" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="host">Der Name des Remotehosts.</param>
        <param name="port">Die Portnummer des Remotehosts.</param>
        <summary>Stellt eine Verbindung mit einem Remotehost her. Der Host wird durch einen Hostnamen und eine Portnummer angegeben.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll wie TCP, verwenden die <xref:System.Net.Sockets.Socket.Connect%2A> Methode wird synchron eine Netzwerkverbindung zwischen <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> und dem angegebenen Remotehost. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.Connect%2A> richtet einen Standardremotehost ein. Nach dem Aufruf von <xref:System.Net.Sockets.Socket.Connect%2A> können Sie Daten senden, mit dem Remotegerät mit der <xref:System.Net.Sockets.Socket.Send%2A> -Methode, oder Empfangen von Daten aus dem Remotegerät mit dem <xref:System.Net.Sockets.Socket.Receive%2A> Methode.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> und <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> synchron mit einem Remotehost kommunizieren. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie Ihre Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>, oder <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 <xref:System.Net.Sockets.Socket.Connect%2A> Methode blockiert, es sei denn, Sie insbesondere die <xref:System.Net.Sockets.Socket.Blocking%2A> Eigenschaft `false` vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie ein verbindungsorientiertes Protokoll wie TCP beim Deaktivieren des blockieren, <xref:System.Net.Sockets.Socket.Connect%2A> löst eine <xref:System.Net.Sockets.SocketException> da Zeit zum Herstellen die Verbindung benötigt. Verbindungslose Protokolle werden eine Ausnahme nicht ausgelöst, da sie einfach einen Standard-Remotehost herstellen. Sie können <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Wenn der Fehler WSAEWOULDBLOCK zurückgegeben wird, wurde die remote-Host-Verbindung durch ein verbindungsorientiertes initiiert <xref:System.Net.Sockets.Socket>, aber noch nicht erfolgreich abgeschlossen wurde. Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, um zu bestimmen, wann die <xref:System.Net.Sockets.Socket> beendet ist eine Verbindung herstellen.  
  
 Wenn IPv6 aktiviert ist und die <xref:System.Net.Sockets.Socket.Connect%28System.String%2CSystem.Int32%29> Methode wird aufgerufen, um eine Verbindung zu einem Host herzustellen, die sowohl in IPv6 aufgelöst wird und IPv4-Adressen, die Verbindung mit der IPv6-Adresse versucht zuerst, bevor Sie die IPv4-Adresse. Dies möglicherweise die Auswirkungen der verzögern der Zeit zum Herstellen der Verbindung, wenn der Host nicht an die IPv6-Adresse lauscht.  
  
> [!NOTE]
>  Wenn Sie nicht aufgerufen haben, und ein verbindungsorientiertes Protokoll verwenden <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>, der zugrunde liegenden Dienstanbieter weist die LAN-Adresse und Port. Wenn Sie ein verbindungsloses Protokoll verwenden, weist der Dienstanbieter keine lokale Adresse und Portnummer Netzwerknummer, bis Sie einen Sendeport abgeschlossen oder receive-Methode. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie <xref:System.Net.Sockets.Socket.Connect%2A> erneut mit den gewünschten Endpunkt.  
  
> [!NOTE]
>  Wenn der Socket bereits getrennt wurde, können nicht Sie diese Methode verwenden, um die Verbindung wiederherzustellen. Verwenden Sie eine der asynchronen <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methoden eine Verbindung herzustellen. Dies ist eine Einschränkung des zugrunde liegenden Anbieter.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung mit einem Remoteendpunkt her, und anschließend überprüft die Verbindung.  
  
 [!code-cpp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CPP/beginconnect.cpp#6)]
 [!code-csharp[System.Net.Sockets.Socket.BeginConnect#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socket.BeginConnect/CS/beginconnect.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="host" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die Portnummer ist ungültig.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Diese Methode gilt für Sockets der Familie <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde durch den Aufruf von <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> in einem Wartezustand platziert.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ConnectAsync">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public bool ConnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ConnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ConnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ConnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ConnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ConnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll, verwenden die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode startet eine asynchrone Anforderung für eine Verbindung mit dem Remotehost. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.ConnectAsync%2A> richtet einen Standardremotehost ein.  
  
 Zum Abschluss benachrichtigt werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs >-Delegaten, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, für die Verbindung.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, alle Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode mit den gewünschten Endpunkt.  
  
 Wenn Sie die Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , und legen Sie auf Broadcast `true`. Wenn dies nicht erfolgt, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional ein Puffer kann angegeben werden die automatisch über den Socket gesendet wird, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss auf den Puffer mit den Daten festgelegt werden, zum Senden und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden. Sobald eine Verbindung hergestellt wurde, wird diesen Puffer mit Daten gesendet.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, und Sie keine rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, der Dienstanbieter nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl bis zum Aufruf der <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methoden.  
  
 Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> Wenn die Adressfamilie des der <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> sind nicht die gleiche Adressfamilie.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> beim Aufrufen dieser Methode verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ConnectAsync">
      <MemberSignature Language="C#" Value="public static bool ConnectAsync (System.Net.Sockets.SocketType socketType, System.Net.Sockets.ProtocolType protocolType, System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ConnectAsync(valuetype System.Net.Sockets.SocketType socketType, valuetype System.Net.Sockets.ProtocolType protocolType, class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketType,System.Net.Sockets.ProtocolType,System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ConnectAsync(System::Net::Sockets::SocketType socketType, System::Net::Sockets::ProtocolType protocolType, System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="static member ConnectAsync : System.Net.Sockets.SocketType * System.Net.Sockets.ProtocolType * System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="System.Net.Sockets.Socket.ConnectAsync (socketType, protocolType, e)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="socketType" Type="System.Net.Sockets.SocketType" />
        <Parameter Name="protocolType" Type="System.Net.Sockets.ProtocolType" />
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="socketType">Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</param>
        <param name="protocolType">Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</param>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung einer Verbindung mit einem Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wird die m:System.NET.Sockets.Socket.ConnectAsync(System.NET.Sockets.SocketType,System.NET.Sockets.ProtocolType,System.NET.Sockets.SocketAsyncEventArgs)-Methode startet eine asynchrone Anforderung für eine Verbindung mit dem Remotehost. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.ConnectAsync%2A> richtet einen Standardremotehost gemäß der `socketType` und `protocolType` Parameter.  
  
 Zum Abschluss benachrichtigt werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs >-Delegaten, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, für die Verbindung.  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie z. B. UDP ein verbindungsloses Protokoll verwenden, müssen Sie nicht aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A> vor dem Senden und Empfangen von Daten. Sie können <xref:System.Net.Sockets.Socket.SendToAsync%2A> und <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> für die Kommunikation mit einem Remotehost. Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, alle Datagramme, die über eine andere Adresse als der angegebene Standardwert eingehen werden verworfen. Wenn Sie die Standard-Remotehost ändern möchten, rufen Sie die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode mit den gewünschten Endpunkt.  
  
 Wenn Sie die Standard-Remotehost auf eine Broadcastadresse festlegen möchten, müssen Sie zuerst Aufrufen <xref:System.Net.Sockets.Socket.SetSocketOption%2A> , und legen Sie auf Broadcast `true`. Wenn dies nicht erfolgt, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
 Optional ein Puffer kann angegeben werden die automatisch über den Socket gesendet wird, die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode erfolgreich ausgeführt wird. In diesem Fall die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> -Eigenschaft muss auf den Puffer mit den Daten festgelegt werden, zum Senden und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> -Eigenschaft muss auf die Anzahl der Bytes der Daten festgelegt werden, um aus dem Puffer zu senden. Sobald eine Verbindung hergestellt wurde, wird diesen Puffer mit Daten gesendet.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, und Sie keine rufen <xref:System.Net.Sockets.Socket.Bind%2A> vor dem Aufruf <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, der zugrunde liegenden Dienstanbieter weist die am besten geeigneten LAN-Adresse und Port.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, der Dienstanbieter nicht weist eine LAN-IP-Adresse und Anschlussnummer Zahl bis zum Aufruf der <xref:System.Net.Sockets.Socket.SendAsync%2A> oder <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methoden.  
  
 Die <xref:System.Net.Sockets.Socket.ConnectAsync%2A> -Methode löst <xref:System.NotSupportedException> Wenn die Adressfamilie des der <xref:System.Net.Sockets.Socket> und <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> sind nicht die gleiche Adressfamilie.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> beim Aufrufen dieser Methode verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument ist ungültig. Diese Ausnahme tritt auf, wenn mehrere Puffer angegeben werden und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft nicht NULL ist.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter kann nicht NULL und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> kann nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.Socket" /> führt eine Überwachung durch, oder ein Socketvorgang wird bereits mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn der lokale Endpunkt und der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> nicht die gleiche Adressfamilie aufweisen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein höher in der Aufrufliste befindlicher Aufrufer verfügt nicht über die Berechtigung für den angeforderten Vorgang.</exception>
      </Docs>
    </Member>
    <Member MemberName="Connected">
      <MemberSignature Language="C#" Value="public bool Connected { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Connected" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Connected" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Connected As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool Connected { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Connected : bool" Usage="System.Net.Sockets.Socket.Connected" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein <see cref="T:System.Net.Sockets.Socket" /> mit dem Remotehost des letzten <see cref="Overload:System.Net.Sockets.Socket.Send" />-Vorgangs oder <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Vorgangs verbunden ist.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Net.Sockets.Socket" /> beim letzten Vorgang mit einer Remoteressource verbunden war, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `Connected` Eigenschaft ruft den Verbindungsstatus der ab der <xref:System.Net.Sockets.Socket> beim letzten e/a-Vorgang. Wenn gibt `false`, <xref:System.Net.Sockets.Socket> wurde entweder nie verbunden oder nicht mehr verbunden ist.  
  
 Der Wert des der <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft gibt den Zustand der Verbindung seit dem letzten Vorgang. Wenn Sie den aktuellen Zustand der Verbindung ermitteln müssen, stellen Sie einen nicht blockierenden, 0-Byte-Sendeport aufrufen. Wenn der Aufruf erfolgreich zurückgegeben, oder einen Fehlercode WAEWOULDBLOCK (10035 aufgeführt löst), klicken Sie dann der Socket immer noch verbunden; Andernfalls wird der Socket nicht mehr verbunden.  
  
 Wenn Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> für einen Socket User Datagram Protocol (UDP) die <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft gibt immer `true`, aber dadurch ändert sich nicht auf der verbindungslosen Natur nach der UDP.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Verbindung herstellt, zu einem Remoteendpunkt überprüft die <xref:System.Net.Sockets.Socket.Connected%2A> -Eigenschaft, und überprüft den aktuellen Zustand der Verbindung.  
  
 [!code-cpp[Classic Socket.Connect Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Connect Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Connect Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Connect Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Connect Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Connect Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Disconnect">
      <MemberSignature Language="C#" Value="public void Disconnect (bool reuseSocket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Disconnect(bool reuseSocket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Disconnect(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Disconnect (reuseSocket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Disconnect(bool reuseSocket);" />
      <MemberSignature Language="F#" Value="member this.Disconnect : bool -&gt; unit" Usage="socket.Disconnect reuseSocket" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="reuseSocket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="reuseSocket"><see langword="true" />, wenn dieser Socket wiederverwendet werden kann, nachdem die aktuelle Verbindung geschlossen wurde, andernfalls <see langword="false" />.</param>
        <summary>Schließt die Socketverbindung und ermöglicht die Wiederverwendung des Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, können Sie diese Methode, auf den Socket schließen. Diese Methode beendet die Verbindung und legt die <xref:System.Net.Sockets.Socket.Connected%2A> Eigenschaft `false`. Aber wenn `reuseSocket` ist `true`, können Sie den Socket wiederverwenden.  
  
 Um sicherzustellen, dass alle Daten gesendet und empfangen, bevor der Socket geschlossen wird, rufen Sie <xref:System.Net.Sockets.Socket.Shutdown%2A> vor dem Aufruf der <xref:System.Net.Sockets.Socket.Disconnect%2A> Methode.  
  
 Wenn Sie aufrufen möchten <xref:System.Net.Sockets.Socket.Disconnect%2A> erst nach Aufrufen von <xref:System.Net.Sockets.Socket.Shutdown%2A>, Sie können festlegen, die <xref:System.Net.Sockets.SocketOptionName.DontLinger> <xref:System.Net.Sockets.Socket> die Möglichkeit, `false` , und geben Sie ein ungleich NULL Timeoutintervall, um sicherzustellen, dass die Daten in der Warteschlange für ausgehende Übertragung gesendet wird. <xref:System.Net.Sockets.Socket.Disconnect%2A> Klicken Sie dann blockiert, bis die Daten gesendet werden oder das angegebene Timeout abläuft. Setzen Sie <xref:System.Net.Sockets.SocketOptionName.DontLinger> zu `false` , und geben Sie ein Timeoutintervall NULL <xref:System.Net.Sockets.Socket.Close%2A> die Verbindung frei und verwirft automatisch die ausgehenden Daten in der Warteschlange.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die synchrone Kommunikation erstellt und sendet Daten an einen Remotehost. Es ruft dann <xref:System.Net.Sockets.Socket.Shutdown%2A>Beenden der Send und receive-Aktivität, und <xref:System.Net.Sockets.Socket.Disconnect%2A>, um die Socket-Verbindung zu schließen.  
  
 [!code-cpp[Nclsocketenhancements#12](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#12)]
 [!code-csharp[Nclsocketenhancements#12](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.PlatformNotSupportedException">Für diese Methode wird Windows 2000 oder früher benötigt, andernfalls wird eine Ausnahme ausgelöst.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DisconnectAsync">
      <MemberSignature Language="C#" Value="public bool DisconnectAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool DisconnectAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function DisconnectAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool DisconnectAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.DisconnectAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.DisconnectAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt eine asynchrone Anforderung zum Trennen der Verbindung mit einem Remoteendunkt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden zu können, Aufrufen der <xref:System.Net.Sockets.Socket.DisconnectAsync%2A> -Methode fordert eine Trennung der Verbindung mit einem Remoteendpunkt. Setzen Sie <xref:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket%2A?displayProperty=nameWithType> zu `true` in die `e` -Parameter der Socket wiederverwendet werden kann.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="e" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socket.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Rufen Sie `Dispose` auf, wenn Sie <xref:System.Net.Sockets.Socket> nicht mehr benötigen. Die `Dispose`-Methode bewirkt, dass <xref:System.Net.Sockets.Socket> nicht mehr verwendet werden kann. Nach dem Aufruf `Dispose`, Sie müssen alle Verweise auf Freigeben der <xref:System.Net.Sockets.Socket> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Net.Sockets.Socket> belegt wurde.  
  
 Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
> [!NOTE]
>  Rufen Sie immer `Dispose` auf, bevor Sie den letzten Verweis auf das <xref:System.Net.Sockets.Socket> freigeben. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="socket.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben. <see langword="false" />, wenn ausschließlich nicht verwaltete Ressourcen freigegeben werden sollen.</param>
        <summary>Gibt die vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten, nicht verwalteten Ressourcen frei und verwirft optional auch die verwalteten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird aufgerufen, von der öffentlichen `Dispose()` Methode und die <xref:System.Object.Finalize%2A> Methode. `Dispose()` Ruft die geschützte `Dispose(Boolean)` -Methode mit dem `disposing` Parametersatz zu `true`. <xref:System.Object.Finalize%2A> Ruft `Dispose` mit `disposing` festgelegt `false`.  
  
 Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.Socket> verweist. Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben von <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden. Weitere Informationen zur Implementierung <see cref="M:System.Net.Sockets.Socket.Dispose(System.Boolean)" />, finden Sie unter [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />, finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Überschreiben der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.Socket.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> die Fragmentierung von IP (Internet Protocol)-Datagrammen zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> die Datagrammfragmentierung zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramme erfordern Fragmentierung aus, wenn die Größe der Einheit MTU (Maximum Transfer) des Übertragungsmediums überschreitet. Datagramme kann fragmentiert werden, vom sendenden Host (alle Versionen für Internet Protocol) oder einen Zwischenrouter (nur Internet Protocol Version 4). Wenn ein Datagramm fragmentiert werden muss, und die <xref:System.Net.Sockets.Socket.DontFragment%2A> Option wird festgelegt, das Datagramm verworfen und Internet Control Message Protocol (ICMP) folgende Fehlermeldung zurück an den Absender der das Datagramm gesendet wird.  
  
 Durch Festlegen dieser Eigenschaft auf einen Socket (TCP, Transmission Control Protocol) haben keine Wirkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.DontFragment%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="DualMode">
      <MemberSignature Language="C#" Value="public bool DualMode { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DualMode" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.DualMode" />
      <MemberSignature Language="VB.NET" Value="Public Property DualMode As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DualMode { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DualMode : bool with get, set" Usage="System.Net.Sockets.Socket.DualMode" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> ein für IPv4 und IPv6 verwendeter Dualmodussocket ist, oder legt ihn fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ein Dualmodussocket ist; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="DuplicateAndClose">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketInformation DuplicateAndClose (int targetProcessId);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Net.Sockets.SocketInformation DuplicateAndClose(int32 targetProcessId) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.DuplicateAndClose(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function DuplicateAndClose (targetProcessId As Integer) As SocketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::SocketInformation DuplicateAndClose(int targetProcessId);" />
      <MemberSignature Language="F#" Value="member this.DuplicateAndClose : int -&gt; System.Net.Sockets.SocketInformation" Usage="socket.DuplicateAndClose targetProcessId" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoLimitation("We do not support passing sockets across processes, we merely allow this API to pass the socket across AppDomains")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketInformation</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="targetProcessId" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="targetProcessId">Die ID des Zielprozesses, in dem ein Duplikat des Socketverweises erstellt wird.</param>
        <summary>Dupliziert den Socketverweis für den Zielprozess und schließt den Socket für diesen Prozess.</summary>
        <returns>Der Socketverweis, der an den Zielprozess übergeben werden soll.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sollte der Zielprozess verwenden <xref:System.Net.Sockets.Socket.%23ctor%2A> die doppelte Socketinstanz erstellt.  
  
 Wenn Sie aufrufen, die <xref:System.Net.Sockets.Socket.%23ctor%2A> Konstruktor mehrmals mit demselben Bytearray als Argument für jeden Aufruf, erstellen Sie mehrere verwaltete <xref:System.Net.Sockets.Socket> -Instanzen mit dem gleichen zugrunde liegenden Socket. Dieses Vorgehen wird dringend abgeraten.  
  
 Wenn der Prozess zum Erstellen des Sockets, asynchrone Methoden verwendet (<xref:System.Net.Sockets.Socket.BeginReceive%2A> oder <xref:System.Net.Sockets.Socket.BeginSend%2A>), muss zunächst Festlegen der <xref:System.Net.Sockets.Socket.UseOnlyOverlappedIO%2A> Eigenschaft auf "true" ist, andernfalls wird der Socket gebunden, an den Completion Port des erstellen-Prozesses, der eine könnte<xref:System.ArgumentNullException> für den Zielprozess ausgelöst wird.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="targetProcessID" /> ist keine gültige Prozess-ID. 
- oder -  
Die Duplizierung des Socketverweises ist fehlgeschlagen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.Socket.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete senden oder empfangen kann, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> Broadcastpakete zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Übertragung muss auf ein bestimmtes Subnetz beschränkt, und User Datagram-Protokoll (UDP). Internetprotokoll Version 4 können Sie zum lokalen Subnetz durch Senden eines Pakets 255.255.255.255 übertragen. Sie können auch die gesteuerte Broadcastadresse, die den Netzwerkteil des eine IP (Internet Protocol)-Adresse mit allen Bits, die in den Hostteil festgelegt ist. Wenn Ihre IP-Adresse 192.168.1.40 ist z. B. (eine Adresse Klasse C mit eine Netzmaske 255.255.255.0 – der Netzwerkteil gibt die ersten drei Oktette und der Hostteil ist das letzte Oktett) Broadcastadresse ist 192.168.1.255.  
  
 Durch Festlegen dieser Eigenschaft auf einen Socket (TCP, Transmission Control Protocol) haben keine Wirkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.EnableBroadcast%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Diese Option ist nur für Datagrammsockets gültig.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndAccept">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Nimmt einen eingehenden Verbindungsversuch asynchron an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation. Diese Methode gibt einen Puffer zurück, der die ersten übertragenen Daten enthält.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, durch die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methodenrückgabe.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf dem der Verbindungsversuch erfolgt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen. Die `buffer` Parameter dieser Überladung enthält die Daten, die im Aufruf empfangen wurde <xref:System.Net.Sockets.Socket.BeginAccept%2A> und `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung vorhanden ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung und gibt ein neues <xref:System.Net.Sockets.Socket> , die verwendet werden können, um Daten zu senden und Empfangen von Daten über den Remotehost.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.Socket.BeginAccept%2A> erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> beendet die asynchrone Anforderung. Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der `buffer` und `bytesTransferred` Parameter dieser Methode, und klicken Sie auf der Konsole angezeigt werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (asyncResult As IAsyncResult) As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (result As IAsyncResult) As Socket" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndAccept : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methodenrückgabe. Akzeptieren sie die `asyncResult` Parameter zurückgegeben, die von der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf dem der Verbindungsversuch erfolgt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung vorhanden ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung und gibt ein neues <xref:System.Net.Sockets.Socket> , die verwendet werden können, um Daten zu senden und Empfangen von Daten über den Remotehost.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet eine asynchrone Anforderung und erstellt ein neues <xref:System.Net.Sockets.Socket> eine eingehende verbindungsanforderung akzeptiert. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Async_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Async_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndAccept">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAccept (out byte[] buffer, out int bytesTransferred, IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAccept([out] unsigned int8[]&amp; buffer, [out] int32&amp; bytesTransferred, class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndAccept(System.Byte[]@,System.Int32@,System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAccept (ByRef buffer As Byte(), ByRef bytesTransferred As Integer, asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAccept([Runtime::InteropServices::Out] cli::array &lt;System::Byte&gt; ^ % buffer, [Runtime::InteropServices::Out] int % bytesTransferred, IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAccept :  *  * IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="socket.EndAccept (buffer, bytesTransferred, asyncResult)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" RefType="out" />
        <Parameter Name="bytesTransferred" Type="System.Int32" RefType="out" />
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die übertragenen Bytes enthält.</param>
        <param name="bytesTransferred">Die Anzahl der übertragenen Bytes.</param>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt ein neues <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Remotehostkommunikation. Diese Methode gibt einen Puffer zurück, der die ersten Daten und die Anzahl der übertragenen Bytes enthält.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />-Objekt zum Behandeln der Kommunikation mit dem Remotehost.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndAccept%2A> Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginAccept%2A>. Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginAccept%2A>, müssen Sie eine Rückrufmethode erstellen, die aufgerufen wird, durch die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach dem <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methodenrückgabe. Akzeptieren sie die `asyncResult` Parameter zurückgegeben, die von der <xref:System.Net.Sockets.Socket.BeginAccept%2A> Methode.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> Methode der `asyncResult` Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf dem der Verbindungsversuch erfolgt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen. Die `buffer` Parameter dieser Überladung enthält die Daten, die im Aufruf empfangen wurde <xref:System.Net.Sockets.Socket.BeginAccept%2A> und `bytesTransferred` Parameter enthält die Anzahl der Bytes, die im Aufruf übertragen wurden.  
  
 Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode blockiert, bis eine Verbindung vorhanden ist in der Warteschlange für eingehende Verbindungen. Die <xref:System.Net.Sockets.Socket.EndAccept%2A> Methode akzeptiert die eingehende Verbindung und gibt ein neues <xref:System.Net.Sockets.Socket> , die verwendet werden können, um Daten zu senden und Empfangen von Daten über den Remotehost.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.Socket.BeginAccept%2A> erstellen und Verbinden eines Sockets und akzeptieren die ersten 10 Bytes der Daten. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndAccept%2A> beendet die asynchrone Anforderung. Die Anzahl der übertragenen Bytes und die Daten werden zurückgegeben, der `buffer` und `bytesTransferred` Parameter dieser Methode, und klicken Sie auf der Konsole angezeigt werden.  
  
 [!code-cpp[NCLSocketEnhancements#6](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#6)]
 [!code-csharp[NCLSocketEnhancements#6](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf von <see cref="M:System.Net.Sockets.Socket.BeginAccept(System.AsyncCallback,System.Object)" /> erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.Socket.EndAccept(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndConnect">
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (asyncResult As IAsyncResult)" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public void EndConnect (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndConnect(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndConnect (result As IAsyncResult)" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndConnect(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndConnect : IAsyncResult -&gt; unit" Usage="socket.EndConnect result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet eine ausstehende asynchrone Verbindungsanforderung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndConnect%2A> eine blockierende Methode, die die verbindungsanforderung asynchrone Remotehost abgeschlossen wird im gestartet wird die <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginConnect%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginConnect%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginConnect%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> Methode der <xref:System.IAsyncResult> Parameter zum Abrufen der <xref:System.Net.Sockets.Socket> auf dem der Verbindungsversuch erfolgt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndConnect%2A> Methode den Verbindungsversuch erfolgreich abgeschlossen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet den asynchronen Verbindungsversuch. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Async_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Async_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndConnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginConnect(System.Net.EndPoint,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
      </Docs>
    </Member>
    <Member MemberName="EndDisconnect">
      <MemberSignature Language="C#" Value="public void EndDisconnect (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndDisconnect(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndDisconnect (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndDisconnect(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndDisconnect : IAsyncResult -&gt; unit" Usage="socket.EndDisconnect asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet eine ausstehende asynchrone Anforderung zur Trennung der Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Schließt einen Aufruf von <xref:System.Net.Sockets.Socket.BeginDisconnect%2A>. Die <xref:System.Net.Sockets.Socket.EndDisconnect%2A> Methode blockiert, bis der Vorgang abgeschlossen ist. Informationen zu asynchronen Vorgängen finden Sie im Thema "Asynchronous Programming Overview" in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket für die asynchrone Kommunikation erstellt und sendet Daten an einen Remotehost. Wenn die Daten gesendet wurde, <xref:System.Net.Sockets.Socket.Shutdown%2A> wird aufgerufen, um das Beenden der Send und receive-Aktivität. Klicken Sie dann <xref:System.Net.Sockets.Socket.BeginDisconnect%2A> wird aufgerufen, um eine Anforderung zum Trennen zu beginnen. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndDisconnect%2A> beendet die asynchrone Anforderung. Wenn die Anforderung abgeschlossen ist, die <xref:System.Net.Sockets.Socket.Connected%2A> abgefragt wird, um festzustellen, ob der Socket getrennt ist.  
  
 [!code-cpp[Nclsocketenhancements#11](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#11)]
 [!code-csharp[Nclsocketenhancements#11](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginDisconnect(System.Boolean,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndDisconnect(System.IAsyncResult)" /> wurde bereits für die asynchrone Verbindung aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.Net.WebException">Das Timeout der Anforderung zum Trennen der Verbindung wurde überschritten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndReceive">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult -&gt; int" Usage="socket.EndReceive result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode schließt den asynchronen Lesevorgang, die Schritte in der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceive%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode als Parameter.  
  
 Rufen Sie in die Callback-Methode, die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> abgerufen, die an das Zustandsobjekt, das die <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus diesem Zustandsobjekt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode für die erfolgreiche Abschluss des Lesevorgangs und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndReceive%2A> liest die erste in die Warteschlange eingereihte Datagramm in der eingehenden Netzwerkpuffer. Bei Verwendung einer verbindungsorientiertes Protokoll, das <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode liest so viele Daten wie die Anzahl von Bytes verfügbar ist, in angegebenen, die `size` Parameter der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Um die empfangenen Daten zu erhalten, rufen Sie die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult>, und extrahieren Sie den Puffer in das resultierende Statusobjekt enthalten.  
  
 Abbrechen einer ausstehenden <xref:System.Net.Sockets.Socket.BeginReceive%2A>, rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet einen ausstehenden asynchronen Lesevorgang. Ein vollständiges Beispiel, die asynchrone Kommunikation mit Sockets veranschaulicht, finden Sie unter [Socket-Codebeispiele](~/docs/framework/network-programming/socket-code-examples.md).  
  
 [!code-cpp[Socket_Async_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Async_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Async_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public int EndReceive (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceive(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceive(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult *  -&gt; int" Usage="socket.EndReceive (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode schließt den asynchronen Lesevorgang, die Schritte in der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceive%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode als Parameter.  
  
 Rufen Sie in die Callback-Methode, die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> abgerufen, die an das Zustandsobjekt, das die <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus diesem Zustandsobjekt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode für die erfolgreiche Abschluss des Lesevorgangs und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndReceive%2A> liest die erste in die Warteschlange eingereihte Datagramm in der eingehenden Netzwerkpuffer. Bei Verwendung einer verbindungsorientiertes Protokoll, das <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode liest so viele Daten wie die Anzahl von Bytes verfügbar ist, in angegebenen, die `size` Parameter der <xref:System.Net.Sockets.Socket.BeginReceive%2A> Methode. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Um die empfangenen Daten zu erhalten, rufen Sie die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult>, und extrahieren Sie den Puffer in das resultierende Statusobjekt enthalten.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceive(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginReceive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="T:System.IAsyncResult" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      </Docs>
    </Member>
    <Member MemberName="EndReceiveFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult asyncResult, ref System.Net.EndPoint endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult asyncResult, class System.Net.EndPoint&amp; endPoint) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (asyncResult As IAsyncResult, ByRef endPoint As EndPoint) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ asyncResult, System::Net::EndPoint ^ % endPoint);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndReceiveFrom (IAsyncResult result, ref System.Net.EndPoint end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveFrom(class System.IAsyncResult result, class System.Net.EndPoint&amp; end_point) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveFrom (result As IAsyncResult, ByRef end_point As EndPoint) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveFrom(IAsyncResult ^ result, System::Net::EndPoint ^ % end_point);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndReceiveFrom : IAsyncResult *  -&gt; int" Usage="socket.EndReceiveFrom (result, end_point)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="end_point" Type="System.Net.EndPoint" RefType="ref" Index="1" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="endPoint">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <param name="end_point">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt.</summary>
        <returns>Wenn erfolgreich, die Anzahl der empfangenen Bytes. Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode schließt den asynchronen Lesevorgang, die Schritte in der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode als Parameter.  
  
 Rufen Sie in die Callback-Methode, die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> abgerufen, die an das Zustandsobjekt, das die <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Extrahieren Sie den Empfang <xref:System.Net.Sockets.Socket> aus diesem Zustandsobjekt. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode für die erfolgreiche Abschluss des Lesevorgangs und die Anzahl der gelesenen Bytes zurück.  
  
 Die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> liest die erste in die Warteschlange eingereihte Datagramm in der eingehenden Netzwerkpuffer. Bei Verwendung einer verbindungsorientiertes Protokoll, das <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode liest so viele Daten wie die Anzahl von Bytes verfügbar ist, in angegebenen, die `size` Parameter der <xref:System.Net.Sockets.Socket.BeginReceiveFrom%2A> Methode. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.EndReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück. Um die empfangenen Daten zu erhalten, rufen Sie die <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> Objekt aus, und extrahieren Sie den Puffer in das resultierende Statusobjekt enthalten. Um den Ausgangshost zu identifizieren, extrahieren die <xref:System.Net.EndPoint> und wandeln Sie sie in einem <xref:System.Net.IPEndPoint>. Verwenden der <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode zum Abrufen der IP-Adresse und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die Portnummer abzurufen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet einen ausstehenden asynchronen Lesevorgang von einer bestimmten <xref:System.Net.EndPoint>.  
  
 [!code-cpp[Socket_Async_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Async_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Async_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int EndReceiveMessageFrom (IAsyncResult asyncResult, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint endPoint, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndReceiveMessageFrom(class System.IAsyncResult asyncResult, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; endPoint, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceiveMessageFrom (asyncResult As IAsyncResult, ByRef socketFlags As SocketFlags, ByRef endPoint As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndReceiveMessageFrom(IAsyncResult ^ asyncResult, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % endPoint, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.EndReceiveMessageFrom : IAsyncResult *  *  *  -&gt; int" Usage="socket.EndReceiveMessageFrom (asyncResult, socketFlags, endPoint, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="endPoint" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte für das empfangene Paket.</param>
        <param name="endPoint">Der Quell-<see cref="T:System.Net.EndPoint" />.</param>
        <param name="ipPacketInformation">Die <see cref="T:System.Net.IPAddress" /> und die Schnittstelle des empfangenen Pakets.</param>
        <summary>Beendet einen ausstehenden asynchronen Lesevorgang von einem bestimmten Endpunkt. Diese Methode stellt außerdem mehr Informationen über das Paket als <see cref="M:System.Net.Sockets.Socket.EndReceiveFrom(System.IAsyncResult,System.Net.EndPoint@)" /> bereit.</summary>
        <returns>Wenn erfolgreich, die Anzahl der empfangenen Bytes. Wenn die Ausführung nicht erfolgreich ist, wird 0 zurückgegeben.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Vorgang nicht, wird diese Methode blockiert abgeschlossen wurde, bis dies der Fall ist.  
  
 Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Untersuchen Sie `ipPacketInformation` , wenn das Datagramm gesendet wurde mit einer Unicast, multicast und broadcast werden sollen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist gleich <see langword="null" />.  
  
- oder -  
 <paramref name="endPoint" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndReceiveMessageFrom(System.IAsyncResult,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="EndSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="socket.EndSend result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
        <returns>Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> Schließt den asynchronen Sendevorgang ab, die Schritte im <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSend%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> Parameter, um das Senden abrufen <xref:System.Net.Sockets.Socket>. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode für die erfolgreiche Abschluss des Sendevorgangs und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> wird blockiert, bis das Datagramm gesendet wurde. Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.EndSend%2A> wird blockiert, bis der Teil des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erneut auf, den Puffer zum Speichern der nicht gesendeten Daten zu ändern.  
  
 Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet einen ausstehenden asynchronen Sendevorgang.  
  
 [!code-cpp[Socket_Async_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Async_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Async_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult, ByRef errorCode As SocketError) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult *  -&gt; int" Usage="socket.EndSend (asyncResult, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
        <returns>Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSend%2A> Schließt den asynchronen Sendevorgang ab, die Schritte im <xref:System.Net.Sockets.Socket.BeginSend%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSend%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSend%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> Parameter, um das Senden abrufen <xref:System.Net.Sockets.Socket>. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndSend%2A> Methode für die erfolgreiche Abschluss des Sendevorgangs und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndSend%2A> wird blockiert, bis das Datagramm gesendet wurde. Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.EndSend%2A> wird blockiert, bis der Teil des Puffers gesendet wurde. Wenn der Rückgabewert von <xref:System.Net.Sockets.Socket.EndSend%2A> gibt an, dass der Puffer nicht vollständig gesendet wurde, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> -Methode erneut auf, den Puffer zum Speichern der nicht gesendeten Daten zu ändern.  
  
 Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.BeginSend%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Alle e/as, die von einem bestimmten Thread initiiert wird abgebrochen, beim Beenden des Threads. Ein ausstehender asynchroner Vorgang kann fehlschlagen, wenn der Thread beendet wird, bevor der Vorgang abgeschlossen ist.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />
        <altmember cref="T:System.AsyncCallback" />
        <altmember cref="P:System.IAsyncResult.AsyncState" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.NoDelay" />
      </Docs>
    </Member>
    <Member MemberName="EndSendFile">
      <MemberSignature Language="C#" Value="public void EndSendFile (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void EndSendFile(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Sub EndSendFile (asyncResult As IAsyncResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void EndSendFile(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSendFile : IAsyncResult -&gt; unit" Usage="socket.EndSendFile asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das Zustandsinformation für den asynchronen Vorgang speichert.</param>
        <summary>Beendet ein ausstehendes asynchrones Senden einer Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendFile%2A> Schließt den asynchronen Sendevorgang ab, die Schritte im <xref:System.Net.Sockets.Socket.BeginSendFile%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSendFile%2A>, müssen Sie eine Rückrufmethode, die implementiert, erstellen die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginSendFile%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes Objekt der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> Parameter, um das Senden abrufen <xref:System.Net.Sockets.Socket>. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndSendFile%2A> Methode, um den Sendevorgang erfolgreich abgeschlossen.  
  
 Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis das Datagramm gesendet wurde. Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.EndSendFile%2A> blockiert, bis die gesamte Datei gesendet wird. Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.BeginSendFile%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket für die asynchrone Kommunikation und beginnt damit, senden die Datei "text.txt" asynchron mit dem Remotehost. Der Rückrufdelegat ruft <xref:System.Net.Sockets.Socket.EndSendFile%2A> die Übertragung abgeschlossen.  
  
 [!code-cpp[NCLSocketEnhancements#9](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#9)]
 [!code-csharp[NCLSocketEnhancements#9](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows NT erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist leer.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendFile(System.IAsyncResult)" /> wurde bereits für das asynchrone <see cref="M:System.Net.Sockets.Socket.BeginSendFile(System.String,System.AsyncCallback,System.Object)" /> aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSendTo">
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult asyncResult) cil managed" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (asyncResult As IAsyncResult) As Integer" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ asyncResult);" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
      <MemberSignature Language="C#" Value="public int EndSendTo (IAsyncResult result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSendTo(class System.IAsyncResult result) cil managed" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSendTo (result As IAsyncResult) As Integer" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSendTo(IAsyncResult ^ result);" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.EndSendTo : IAsyncResult -&gt; int" Usage="socket.EndSendTo result" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netcore-2.1;netframework-4.7.2;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.8;netcore-2.2" />
        <Parameter Name="result" Type="System.IAsyncResult" Index="0" FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <param name="result">Ein <see cref="T:System.IAsyncResult" />, das Zustandsinformationen über diesen asynchronen Vorgang sowie ggf. vorhandene benutzerdefinierte Daten speichert.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang an einen bestimmten Zielort.</summary>
        <returns>Wenn erfolgreich, die Anzahl der gesendeten Bytes, andernfalls ein Fehler aufgrund eines ungültigen <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.EndSendTo%2A> Schließt den asynchronen Sendevorgang ab, die Schritte im <xref:System.Net.Sockets.Socket.BeginSendTo%2A>.  
  
 Vor dem Aufruf <xref:System.Net.Sockets.Socket.BeginSendTo%2A>, müssen Sie eine Rückrufmethode erstellen, die implementiert die <xref:System.AsyncCallback> delegieren. Diese Callback-Methode in einem separaten Thread ausgeführt wird, und wird aufgerufen, durch das System nach <xref:System.Net.Sockets.Socket.BeginReceive%2A> zurückgibt. Die Rückrufmethode muss akzeptieren die <xref:System.IAsyncResult> zurückgegebenes der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode als Parameter.  
  
 Rufen Sie in der Rückrufmethode der <xref:System.IAsyncResult.AsyncState%2A> -Methode der der <xref:System.IAsyncResult> Parameter, um das Senden abrufen <xref:System.Net.Sockets.Socket>. Nach dem Abrufen der <xref:System.Net.Sockets.Socket>, rufen Sie die <xref:System.Net.Sockets.Socket.EndSendTo%2A> Methode für die erfolgreiche Abschluss des Sendevorgangs und die Anzahl der gesendeten Bytes zurück.  
  
 Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.EndSendTo%2A> wird blockiert, bis das Datagramm gesendet wurde. Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.EndSendTo%2A> wird blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.BeginSendTo%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird beendet einen asynchronen Sendevorgang an einem bestimmten Speicherort.  
  
 [!code-cpp[Socket_Async_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Async_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Async_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Async_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Async_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSendTo(System.IAsyncResult)" /> wurde bereits für den asynchronen Sendevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.Socket.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Prozesses an einen Anschluss zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> das Binden nur eines einzigen Sockets an einen bestimmten Anschluss zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" /> für Windows Server 2003 und Windows XP Service Pack 2 und <see langword="false" /> für alle anderen Versionen.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> ist `false`, mehrere Sockets können die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode zum Binden an einen bestimmten Port; jedoch nur eine der Sockets Vorgänge für den Netzwerkdatenverkehr an den Port gesendete ausführen kann. Wenn mehr als ein Socket versucht, verwenden die <xref:System.Net.Sockets.Socket.Bind%28System.Net.EndPoint%29> Methode für einen bestimmten Port, gebunden werden soll, und klicken Sie dann die Woche mit die spezifischere IP-Adresse den Netzwerkdatenverkehr an diesen Port behandelt.  
  
 Wenn <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> ist `true`, der ersten Verwendung der <xref:System.Net.Sockets.Socket.Bind%2A> Methode, um zu versuchen, die für einen bestimmten Port, unabhängig von IP (Internet Protocol)-Adresse, Bindung ist erfolgreich, alle nachfolgenden Verwendungen von der <xref:System.Net.Sockets.Socket.Bind%2A> wird versucht, die an diesen Port binden fehl, bis der ursprüngliche gebundene Socket zerstört wird.  
  
 Diese Eigenschaft muss festgelegt werden, bevor <xref:System.Net.Sockets.Socket.Bind%2A> aufgerufen wird; andernfalls ein <xref:System.InvalidOperationException> ausgelöst.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Für diesen <see cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" /> wurde <see cref="T:System.Net.Sockets.Socket" /> aufgerufen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~Socket ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!Socket ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socket.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt von der <see cref="T:System.Net.Sockets.Socket" />-Klasse verwendete Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket> -Klasse Finalizer ruft der <xref:System.Net.Sockets.Socket.Close%2A> Methode zum Schließen der <xref:System.Net.Sockets.Socket> zugeordneten Ressourcen frei, und der <xref:System.Net.Sockets.Socket>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="socket.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt einen Hashwert für eine <see cref="T:System.Net.Sockets.Socket" />-Instanz zurück.</summary>
        <returns>Ein ganzzahliger Hashwert.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Die GetHashCode-Methode gibt einen Hashcode dieser Instanz zurück. Dieser Wert kann als Schlüssel für Hashtabellen verwendet werden.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Wert einer <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public object GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Object ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName -&gt; obj" Usage="socket.GetSocketOption (optionLevel, optionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <summary>Gibt den Wert einer angegebenen, als Objekt dargestellten <see cref="T:System.Net.Sockets.Socket" />-Option zurück.</summary>
        <returns>Ein Objekt, das den Wert der Option darstellt. Wenn der <paramref name="optionName" />-Parameter auf <see cref="F:System.Net.Sockets.SocketOptionName.Linger" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.LingerOption" />-Klasse. Wenn <paramref name="optionName" /> auf <see cref="F:System.Net.Sockets.SocketOptionName.AddMembership" /> oder <see cref="F:System.Net.Sockets.SocketOptionName.DropMembership" /> festgelegt ist, ist der Rückgabewert eine Instanz der <see cref="T:System.Net.Sockets.MulticastOption" />-Klasse. Wenn <paramref name="optionName" /> einen anderen Wert hat, ist der Rückgabewert eine ganze Zahl.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Verwenden Sie diese Überladung zum Abrufen der <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> Optionen. Für die <xref:System.Net.Sockets.SocketOptionName.Linger> option können Sie <xref:System.Net.Sockets.Socket> für die `optionLevel` Parameter. Für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership>, verwenden Sie <xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie verwenden möchten, legen Sie den Wert eines der oben aufgeführten Optionen, verwenden Sie die <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
- oder -  
 <paramref name="optionName" /> wurde auf den nicht unterstützten Wert <see cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" /> festgelegt.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public void GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.GetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die Optionseinstellung erhalten soll.</param>
        <summary>Gibt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Optionseinstellung als Bytearray dargestellt zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Nach erfolgreichem Abschluss dieser Methode das Array, das vom angegebenen die `optionValue` -Parameter enthält den Wert des angegebenen <xref:System.Net.Sockets.Socket> Option.  
  
 Wenn die Länge des der `optionValue` Array ist kleiner als die Anzahl von Bytes zum Speichern des Werts des angegebenen benötigt <xref:System.Net.Sockets.Socket> Option <xref:System.Net.Sockets.Socket.GetSocketOption%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
\- oder – 
In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt. Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="GetSocketOption">
      <MemberSignature Language="C#" Value="public byte[] GetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] GetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionLength) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionLength As Integer) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ GetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionLength);" />
      <MemberSignature Language="F#" Value="member this.GetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; byte[]" Usage="socket.GetSocketOption (optionLevel, optionName, optionLength)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionLength" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionLength">Die Länge des erwarteten Rückgabewerts in Bytes.</param>
        <summary>Gibt den Wert der angegebenen <see cref="T:System.Net.Sockets.Socket" />-Option in einem Array zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Socketoption enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `optionLength` Parameter legt die maximale Größe des zurückgegebenen Bytearray fest. Wenn der Optionswert weniger Bytes erforderlich ist, wird das Array enthalten, die Anzahl an Bytes. Wenn Sie den Wert der Option mehr Bytes erforderlich <xref:System.Net.Sockets.Socket.GetSocketOption%2A> löst eine <xref:System.Net.Sockets.SocketException>. Verwenden Sie diese Überladung für Sockets, die durch boolesche Werte oder ganze Zahlen dargestellt werden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Der folgende code Beispiel ruft die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeout Werte und zeigt sie an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#2)]
 [!code-csharp[Socket_Socket_Options#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#2)]
 [!code-vb[Socket_Socket_Options#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.  
  
\- oder – 
In .NET Compact Framework-Anwendungen ist der Standardpufferspeicher für Windows CE auf 32768 Bytes festgelegt. Sie können den Pufferspeicher pro Socket durch den Aufruf von <see cref="Overload:System.Net.Sockets.Socket.SetSocketOption" /> ändern.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
      </Docs>
    </Member>
    <Member MemberName="Handle">
      <MemberSignature Language="C#" Value="public IntPtr Handle { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance native int Handle" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Handle" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Handle As IntPtr" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property IntPtr Handle { IntPtr get(); };" />
      <MemberSignature Language="F#" Value="member this.Handle : nativeint" Usage="System.Net.Sockets.Socket.Handle" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IntPtr</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Ein <see cref="T:System.IntPtr" />, der das Betriebssystemhandle für den <see cref="T:System.Net.Sockets.Socket" /> darstellt.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="IOControl">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt Betriebsmodi auf niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (int ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(int32 ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Int32,System.Byte[],System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function IOControl (ioControlCode As Integer, optionInValue As Byte(), optionOutValue As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(int ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : int * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Int32" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Int32" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein <see cref="T:System.Byte" />-Array, das die für den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein <see cref="T:System.Byte" />-Array, das die durch den Vorgang zurückgegebenen Ausgabedaten enthält.</param>
        <summary>Legt mit numerischen Steuerungscodes die Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.Socket" /> fest.</summary>
        <returns>Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.IOControl%2A> -Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <xref:System.Net.Sockets.Socket> zugrunde liegende der aktuellen Instanz von der <xref:System.Net.Sockets.Socket> Klasse. Weitere Informationen finden Sie unter der WSAIoctl-Dokumentation in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird vergleicht die Ergebnisse der FIONREAD und die Eigenschaft zur Verfügung.  
  
 [!code-cpp[NCLSocketIoControl#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl/CPP/iocontrolserver.cpp#1)]
 [!code-csharp[NCLSocketIoControl#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl/CS/iocontrolserver.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IOControl">
      <MemberSignature Language="C#" Value="public int IOControl (System.Net.Sockets.IOControlCode ioControlCode, byte[] optionInValue, byte[] optionOutValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 IOControl(valuetype System.Net.Sockets.IOControlCode ioControlCode, unsigned int8[] optionInValue, unsigned int8[] optionOutValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.IOControl(System.Net.Sockets.IOControlCode,System.Byte[],System.Byte[])" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int IOControl(System::Net::Sockets::IOControlCode ioControlCode, cli::array &lt;System::Byte&gt; ^ optionInValue, cli::array &lt;System::Byte&gt; ^ optionOutValue);" />
      <MemberSignature Language="F#" Value="member this.IOControl : System.Net.Sockets.IOControlCode * byte[] * byte[] -&gt; int" Usage="socket.IOControl (ioControlCode, optionInValue, optionOutValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ioControlCode" Type="System.Net.Sockets.IOControlCode" />
        <Parameter Name="optionInValue" Type="System.Byte[]" />
        <Parameter Name="optionOutValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="ioControlCode">Ein <see cref="T:System.Net.Sockets.IOControlCode" />-Wert, der den Steuerungscode des auszuführenden Vorgangs angibt.</param>
        <param name="optionInValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die für den Vorgang erforderlichen Eingabedaten enthält.</param>
        <param name="optionOutValue">Ein Array vom Typ <see cref="T:System.Byte" />, das die von dem Vorgang zurückgegebenen Ausgabedaten enthält.</param>
        <summary>Legt mithilfe der <see cref="T:System.Net.Sockets.Socket" />-Enumeration zum Angeben von Steuerungscodes Betriebsmodi niedriger Ebene für den <see cref="T:System.Net.Sockets.IOControlCode" /> fest.</summary>
        <returns>Die Anzahl der Bytes im <paramref name="optionOutValue" />-Parameter.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode bietet auf niedriger Ebene Zugriff auf das Betriebssystem <xref:System.Net.Sockets.Socket> zugrunde liegende der aktuellen Instanz von der <xref:System.Net.Sockets.Socket> Klasse. Weitere finden Sie in der Dokumentation WSAIoctl in der MSDN Library.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird, vergleicht die Ergebnisse des Aufrufs <xref:System.Net.Sockets.Socket.IOControl%2A> mit <xref:System.Net.Sockets.IOControlCode.DataToRead> und <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft.  
  
 [!code-cpp[NCLSocketIoControl1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketIoControl1/CPP/iocontrolcode.cpp#1)]
 [!code-csharp[NCLSocketIoControl1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketIoControl1/CS/iocontrolcode.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den blockierenden Modus ohne Verwendung der <see cref="P:System.Net.Sockets.Socket.Blocking" />-Eigenschaft zu ändern.</exception>
        <permission cref="T:System.Security.Permissions.SecurityPermission">zum Ausführen von nicht verwalteten Codes. Zugeordnete Enumeration: <see cref="F:System.Security.Permissions.SecurityPermissionFlag.UnmanagedCode" /></permission>
      </Docs>
    </Member>
    <Member MemberName="IsBound">
      <MemberSignature Language="C#" Value="public bool IsBound { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsBound" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.IsBound" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsBound As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsBound { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsBound : bool" Usage="System.Net.Sockets.Socket.IsBound" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> an einen bestimmten lokalen Anschluss gebunden ist.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> an einen lokalen Anschluss gebunden ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Socket gilt, die an einen lokalen Anschluss gebunden, wenn es explizit durch Aufrufen von gebunden ist die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, oder implizit durch Aufrufen von Membern wie gebundene <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, welche verwenden einen temporären lokalen Port (einen freien Anschluss größer als 1024, vom Betriebssystem ausgewählt.) Server verwenden die <xref:System.Net.Sockets.Socket.Bind%2A> Methode, um auf einen bekannten Port binden, damit Clients eine Verbindung damit herstellen können.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.IsBound%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LingerState">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.LingerOption LingerState { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.LingerOption LingerState" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LingerState" />
      <MemberSignature Language="VB.NET" Value="Public Property LingerState As LingerOption" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::LingerOption ^ LingerState { System::Net::Sockets::LingerOption ^ get(); void set(System::Net::Sockets::LingerOption ^ value); };" />
      <MemberSignature Language="F#" Value="member this.LingerState : System.Net.Sockets.LingerOption with get, set" Usage="System.Net.Sockets.Socket.LingerState" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.LingerOption</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.Socket" /> bei einem Versuch, alle ausstehenden Daten zu senden, das Schließen eines Sockets verzögert, oder legt diesen fest.</summary>
        <value>Eine <see cref="T:System.Net.Sockets.LingerOption" />, die angibt, wie der Nachlauf während des Schließens eines Sockets erfolgen soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LingerState%2A> -Eigenschaft ändert das <xref:System.Net.Sockets.Socket.Close%2A> Methode verhält sich. Diese Eigenschaft wird bei der Gruppe die Bedingungen ändert, unter denen die Verbindung durch Winsock zurückgesetzt werden kann. Können die Verbindung wird basierend auf das Verhalten des IP-Protokolls erfolgen.  
  
 Diese Eigenschaft steuert die Zeitspanne, die eine Verbindung mit verbindungsorientierten geöffnet, nach einem Aufruf von gehalten wird <xref:System.Net.Sockets.Socket.Close%2A> bleibt, wenn noch weitere Daten gesendet werden.  
  
 Wenn Sie Methoden zum Senden von Daten, die einen Peer aufrufen, werden diese Daten in ausgehenden Netzwerkpuffer eingefügt. Diese Eigenschaft kann verwendet werden, um sicherzustellen, dass die Daten mit dem Remotehost, bevor Sie gesendet wurden die <xref:System.Net.Sockets.TcpClient.Close%2A> Methode bricht die Verbindung.  
  
 Erstellen Sie aktivieren, indem eine <xref:System.Net.Sockets.LingerOption> -Instanz, die die gewünschten Werte enthält, und legen Sie die <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft dieser Instanz.  
  
 Die folgende Tabelle beschreibt das Verhalten von der <xref:System.Net.Sockets.Socket.Close%2A> -Methode für die möglichen Werte der <xref:System.Net.Sockets.LingerOption.Enabled%2A> Eigenschaft und die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft gespeichert wird, der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft.  
  
|LingerState.Enabled|LingerState.LingerTime|Verhalten|  
|-------------------------|----------------------------|--------------|  
|`false` (deaktiviert), den Standardwert|Das Timeout ist nicht zutreffend (Standard).|Ausstehende Daten zu senden, bis zum Ablauf des Standardtimeout für IP-Protokoll versucht.|  
|`true` (aktiviert)|Ein Timeout ungleich null|Versucht, ausstehende Daten zu senden, bis das angegebene Timeout abläuft, und wenn der Versuch fehlschlägt, klicken Sie dann Winsock setzt die Verbindung zurück.|  
|`true` (aktiviert)|0 (null) ein Timeout.|Verwirft alle ausstehenden Daten. Für verbindungsorientierten Socket (TCP, z. B.) setzt Winsock die Verbindung zurück.|  
  
 Der IP-Stapel berechnet der IP-Protokoll Standardtimeoutspanne zu verwenden, basierend auf den Roundtrip-Zeit der Verbindung. In den meisten Fällen ist das Timeout berechnet, indem dem Stapel als relevanter als eines von einer Anwendung definiert. Dies ist das Standardverhalten für einen Socket bei der <xref:System.Net.Sockets.Socket.LingerState%2A> Eigenschaft nicht festgelegt.  
  
 Wenn die <xref:System.Net.Sockets.LingerOption.LingerTime%2A> Eigenschaft gespeichert wird, der <xref:System.Net.Sockets.Socket.LingerState%2A> -Eigenschaft größer als das Standardtimeout für IP-Protokoll festgelegt ist, das Standardtimeout für IP-Protokoll werden weiterhin angewendet und überschreiben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.LingerState%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Listen">
      <MemberSignature Language="C#" Value="public void Listen (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Listen(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Listen (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Listen(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Listen : int -&gt; unit" Usage="socket.Listen backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</param>
        <summary>Versetzt einen <see cref="T:System.Net.Sockets.Socket" /> in den Überwachungszustand.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Listen%2A> bewirkt, dass ein verbindungsorientiertes <xref:System.Net.Sockets.Socket> zum Lauschen auf eingehende Verbindungsversuche. Die `backlog` Parameter gibt die Anzahl von eingehenden Verbindungen, die für die Aufnahme abgefragt werden können. Um die maximale Anzahl von Verbindungen zu ermitteln, können Sie angeben, Abrufen der <xref:System.Net.Sockets.SocketOptionName.MaxConnections> Wert. <xref:System.Net.Sockets.Socket.Listen%2A> wird nicht blockiert.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers. Verwendung <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.BeginAccept%2A> annehmen eine Verbindung aus der Warteschlange.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.Bind%2A> Methode vor dem Aufruf <xref:System.Net.Sockets.Socket.Listen%2A>, oder <xref:System.Net.Sockets.Socket.Listen%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
> [!NOTE]
>  Der Backlog-Parameter ist auf verschiedene Werte je nach Betriebssystem beschränkt. Sie können einen höheren Wert angeben, aber das Backlog ist beschränkt, basierend auf dem Betriebssystem.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.Socket> zum Lauschen auf eingehende Verbindungen.  
  
 [!code-cpp[Classic Socket.Listen Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Listen Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Listen Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Listen Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Listen Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Listen Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.MaxConnections" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="LocalEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.LocalEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den lokalen Endpunkt ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, den der <see cref="T:System.Net.Sockets.Socket" /> für die Kommunikation verwendet.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft ruft eine <xref:System.Net.EndPoint> , enthält die IP-Adresse und Portnummer Anschlussnummer zu dem Ihre <xref:System.Net.Sockets.Socket> gebunden ist. Sie müssen dies umwandeln <xref:System.Net.EndPoint> zu ein <xref:System.Net.IPEndPoint> vor dem Abrufen von Informationen. Rufen Sie anschließend die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode zum Abrufen des lokalen <xref:System.Net.IPAddress>, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode, um die lokale Portnummer abzurufen.  
  
 Die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft ist in der Regel festgelegt, nach dem vornehmen von eines Aufrufs der <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie zulassen, dass das System zum Zuweisen des Sockets die lokale IP-Adresse und Portnummer an, die <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft wird festgelegt, nach dem ersten e/a-Vorgang. Für verbindungsorientierte Protokolle, wäre der erste e/a-Vorgang einen Aufruf der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Für verbindungslose Protokolle würde der erste e/a-Vorgang werden für das Senden oder Empfangen von Anrufen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgerufen und die lokalen und Remoteendpunkte angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.Socket.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> ausgehende Multicastpakete empfängt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multicast ist eine skalierbare Methode für die m: n Kommunikation über das Internet. Ein Prozess abonniert eine Multicastadresse; Alle Pakete von einem abonnierten Prozess gesendet werden anschließend von jedem anderen abonniert die Multicastadresse Prozess empfangen.  
  
 Durch Festlegen dieser Eigenschaft auf einen Socket (TCP, Transmission Control Protocol) haben keine Wirkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.MulticastLoopback%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#2](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#2)]
 [!code-csharp[SocketPropertyTester#2](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="NoDelay">
      <MemberSignature Language="C#" Value="public bool NoDelay { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool NoDelay" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.NoDelay" />
      <MemberSignature Language="VB.NET" Value="Public Property NoDelay As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool NoDelay { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.NoDelay : bool with get, set" Usage="System.Net.Sockets.Socket.NoDelay" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der Stream-<see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, oder legt diesen fest.</summary>
        <value><see langword="false" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> den Nagle-Algorithmus verwendet, andernfalls <see langword="true" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um den Netzwerkverkehr zu reduzieren, verliert des Sockets, auf das kleine Pakete, und klicken Sie dann kombinieren und in einem Paket unter bestimmten Umständen zu senden, indem der Nagle-Algorithmus dient. Ein TCP-Paket besteht aus 40 Byte der Header und der Daten, die gesendet werden. Wenn kleine Datenpakete mit TCP gesendet werden, kann der Mehraufwand des TCP-Headers ein erheblicher Teil des Netzwerkdatenverkehrs werden. In stark ausgelasteten Netzwerken kann die Überlastung, die aus diesen zusätzlichen Aufwand verloren Datagramme und erneute Übertragungen als auch eine übermäßige Weitergabe Zeit, die aufgrund von Überlastung führen. Der Nagle-Algorithmus unterdrückt das Senden von neuen TCP Segmentswhen neue vom Benutzer ausgehenden Daten empfangen werden, wenn alle zuvor übertragene Daten für die Verbindung nicht bestätigte bleibt.  
  
 Die meisten Anwendungen sollten den Nagle-Algorithmus verwenden.  
  
 Durch Festlegen dieser Eigenschaft auf einen Socket User Datagram Protocol (UDP) haben keine Wirkung.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.NoDelay%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv4 (Internet Protocol, Version 4) unterstützen.</summary>
        <value><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das IPv4-Protokoll unterstützen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6-Protokolle unterstützen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="OSSupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool OSSupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool OSSupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property OSSupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool OSSupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.OSSupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.OSSupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob das zugrunde liegende Betriebssystem und die Netzwerkkarten IPv6 (Internet Protocol, Version 6) unterstützen.</summary>
        <value><see langword="true" />, wenn das Betriebssystem und die Netzwerkkarten das Protokoll IPv6 unterstützen, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6-Protokolle unterstützen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="Poll">
      <MemberSignature Language="C#" Value="public bool Poll (int microSeconds, System.Net.Sockets.SelectMode mode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Poll(int32 microSeconds, valuetype System.Net.Sockets.SelectMode mode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      <MemberSignature Language="VB.NET" Value="Public Function Poll (microSeconds As Integer, mode As SelectMode) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Poll(int microSeconds, System::Net::Sockets::SelectMode mode);" />
      <MemberSignature Language="F#" Value="member this.Poll : int * System.Net.Sockets.SelectMode -&gt; bool" Usage="socket.Poll (microSeconds, mode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="microSeconds" Type="System.Int32" />
        <Parameter Name="mode" Type="System.Net.Sockets.SelectMode" />
      </Parameters>
      <Docs>
        <param name="microSeconds">Die Zeit in Mikrosekunden, die auf eine Antwort gewartet werden soll.</param>
        <param name="mode">Einer der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</param>
        <summary>Bestimmt den Status des <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Der Status des <see cref="T:System.Net.Sockets.Socket" /> basierend auf dem im <paramref name="mode" />-Parameter übergebenen Abfragemoduswert.  
  
 <list type="table"><listheader><term> Modus 
 </term><description> Rückgabewert 
 </description></listheader><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectRead" /></term><description><see langword="true" />, wenn <see cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" /> aufgerufen wurde und eine Verbindung aussteht. 
- oder -  
 <see langword="true" />, wenn Daten zum Lesen verfügbar sind. 
- oder -  
 <see langword="true" />, wenn die Verbindung geschlossen, zurückgesetzt oder beendet wurde. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectWrite" /></term><description><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> verarbeitet wird und die Verbindung erfolgreich war. 
- oder -  
 <see langword="true" />, wenn Daten gesendet werden können. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item><item><term><see cref="F:System.Net.Sockets.SelectMode.SelectError" /></term><description><see langword="true" />, wenn ein <see cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" /> ohne Blockierung verarbeitet wird und der Verbindungsaufbau fehlgeschlagen ist. 
- oder -  
 <see langword="true" />, wenn <see cref="F:System.Net.Sockets.SocketOptionName.OutOfBandInline" /> nicht festgelegt ist und Out-of-Band-Daten verfügbar sind. 
Andernfalls wird <see langword="false" /> zurückgegeben.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Poll%2A> Methode prüft den Status der <xref:System.Net.Sockets.Socket>. Geben Sie <xref:System.Net.Sockets.SelectMode.SelectRead?displayProperty=nameWithType> für die `selectMode` Parameter, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket> gelesen werden kann. Geben Sie <xref:System.Net.Sockets.SelectMode.SelectWrite?displayProperty=nameWithType> zu entscheiden, ob die <xref:System.Net.Sockets.Socket> geschrieben werden kann. Verwendung <xref:System.Net.Sockets.SelectMode.SelectError?displayProperty=nameWithType> um eine fehlerbedingung zu erkennen. <xref:System.Net.Sockets.Socket.Poll%2A> blockiert die Ausführung erst im angegebenen Zeitraum, gemessen in `microseconds`, abgelaufen ist. Legen Sie die `microSeconds` Parameter, um eine negative ganze Zahl, wenn Sie, um unbegrenzt zu warten, bis eine Antwort möchten. Wenn Sie den Status mehrerer Sockets überprüfen möchten, möglicherweise möchten Sie verwenden die <xref:System.Net.Sockets.Socket.Select%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Diese Methode kann nicht feststellen, dass bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde. Sie müssen versuchen, zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket erstellt, eine Verbindung mit einem Server her und verwendet <xref:System.Net.Sockets.Socket.Poll%2A> zum Überprüfen des Status des Sockets.  
  
 [!code-cpp[SelectModeExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SelectModeExample/CPP/source.cpp#1)]
 [!code-csharp[SelectModeExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SelectModeExample/CS/source.cs#1)]
 [!code-vb[SelectModeExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/SelectModeExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der <paramref name="mode" />-Parameter ist keiner der <see cref="T:System.Net.Sockets.SelectMode" />-Werte.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie weiter unten im Abschnitt "Hinweise".</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SelectMode" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <Member MemberName="ProtocolType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.ProtocolType ProtocolType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.ProtocolType ProtocolType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ProtocolType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ProtocolType As ProtocolType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::ProtocolType ProtocolType { System::Net::Sockets::ProtocolType get(); };" />
      <MemberSignature Language="F#" Value="member this.ProtocolType : System.Net.Sockets.ProtocolType" Usage="System.Net.Sockets.Socket.ProtocolType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.ProtocolType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Protokolltyp des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.ProtocolType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ProtocolType%2A> Eigenschaft wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> wird erstellt, und gibt das Protokoll, <xref:System.Net.Sockets.Socket>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Receive">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Rufen Sie <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierte und verbindungslose Sockets.  
  
 Diese Überladung muss nur mit einen Empfangspuffer bereitstellen. Der Puffer hat den Standardwert 0 (null) die Größe der Standardwert ist die Länge des Pufferparameters und der <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste in der Warteschlange Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird empfängt Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Receive buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> und fügt sie in die Liste der Empfangspuffer ein.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest Daten in den Puffer-Parameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Sie können sowohl die verbindungsorientierten als auch die verbindungslose Sockets aufrufen.  
  
 Diese Überladung müssen Sie angeben, oder Empfangspuffer.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der remote-Host-Verbindung hergestellt werden, dem eingehen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
 **Beachten Sie** dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die netzwerkablaufverfolgung in Ihrer Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (buffer As Span(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; -&gt; int" Usage="socket.Receive buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Rufen Sie <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierte und verbindungslose Sockets.  
  
 Diese Überladung müssen Sie zu einem Empfangspuffer und die erforderlichen <xref:System.Net.Sockets.SocketFlags>. Der Puffer hat den Standardwert 0, und die Größe ist standardmäßig auf die Länge des Byteparameters.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in den Puffer für den Protocol-Stapel sind, der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie Ihre receive-Methode.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt an, einen Datenpuffer und <xref:System.Net.Sockets.SocketFlags> für den Empfang von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest die Daten in die `buffers` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Sie können sowohl die verbindungsorientierten als auch die verbindungslose Sockets aufrufen.  
  
 Diese Überladung müssen Sie angeben, oder Empfangspuffer. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der remote-Host-Verbindung hergestellt werden, dem eingehen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> aufrufen, löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie zum Empfangen von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CPP/sendgeneric.cpp#2)]
 [!code-csharp[System.Net.Sockets.Socketgenerics#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.Socketgenerics/CS/sendgeneric.cs#2)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="buffers" />.Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest die Daten in die `buffer` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Rufen Sie <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierte und verbindungslose Sockets.  
  
 Diese Überladung müssen Sie zu einem Empfangspuffer, die Anzahl der Bytes, die Sie erhalten möchten, und die erforderlichen <xref:System.Net.Sockets.SocketFlags>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie Ihre receive-Methode.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie verfügbar ist, bis die Anzahl der Bytes, die angegeben wird die `size` Parameter. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste in der Warteschlange Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Die nachfolgenden Empfänge, Daten in den `buffer`, und gibt <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Send_Recieve#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Send_Recieve/CPP/source.cpp#4)]
 [!code-csharp[Socket_Send_Recieve#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Send_Recieve/CS/source.cs#4)]
 [!code-vb[Socket_Send_Recieve#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Send_Recieve/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist größer als <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste mit <see cref="T:System.ArraySegment`1" />s vom Typ <see cref="T:System.Byte" />, die die empfangenen Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in der Liste der Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode liest die Daten in die `buffers` Parameter und gibt die Anzahl der erfolgreich Bytes gelesenen. Sie können sowohl die verbindungsorientierten als auch die verbindungslose Sockets aufrufen.  
  
 Diese Überladung müssen Sie angeben, oder Empfangspuffer. Die <xref:System.Net.Sockets.SocketFlags> -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der remote-Host-Verbindung hergestellt werden, dem eingehen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> aufrufen, löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie bis zur Größe des Puffers verfügbar ist. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>,<xref:System.Net.Sockets.Socket.Receive%2A> liest das erste in der Warteschlange Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffers` Parameter `buffers` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="buffers" />.Count ist 0 (null).</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (Span&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(valuetype System.Span`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Span{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(Span&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : Span&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Empfängt die angegebene Anzahl von Bytes aus einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> an der angegebenen Offsetposition des Empfangspuffers, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Rufen Sie <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierte und verbindungslose Sockets.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Fehler beim Versuch, auf den Socket zuzugreifen. Siehe Hinweise unten. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie verfügbar ist, bis die Anzahl der Bytes, die Size-Parameter angegeben wird. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste in der Warteschlange Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt einen Datenpuffer, einem Offset, Größe und ein Socket-Flag an, bevor Sie empfangen von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public int Receive (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Receive(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Receive(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Receive : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Receive (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Empfängt Daten von einem gebundenen <see cref="T:System.Net.Sockets.Socket" /> in einem Empfangspuffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest Daten in den Pufferparameter und gibt die Anzahl der erfolgreich gelesenen Bytes zurück. Rufen Sie <xref:System.Net.Sockets.Socket.Receive%2A> verbindungsorientierte und verbindungslose Sockets.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder Aufruf <xref:System.Net.Sockets.Socket.Connect%2A> zum Herstellen einer Verbindung mit einem Remotehost oder <xref:System.Net.Sockets.Socket.Accept%2A> um eine eingehende Verbindung vor dem Aufruf <xref:System.Net.Sockets.Socket.Receive%2A>. Die <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest nur Daten, die von der Remotehost eintreffen der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie ein verbindungsloses Protokoll verwenden, können Sie auch die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> können Sie zum Empfangen von Daten, die von jedem Host.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.Receive%2A> Methode blockiert, bis die Daten verfügbar ist, es sei denn, ein Timeoutwert festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Receive%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Fehler beim Versuch, auf den Socket zuzugreifen. Siehe Hinweise unten. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Wenn Sie ein verbindungsorientiertes verwenden <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> Methode liest so viele Daten wie verfügbar ist, bis die Anzahl der Bytes, die Size-Parameter angegeben wird. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
 Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>, <xref:System.Net.Sockets.Socket.Receive%2A> liest das erste in der Warteschlange Datagramm aus die Zieladresse, die Sie, in angeben der <xref:System.Net.Sockets.Socket.Connect%2A> Methode. Ist das Datagramm, Sie erhalten, größer als die Größe des der `buffer` Parameter `buffer` gefüllt mit dem ersten Teil der Nachricht, die überzähligen Daten geht verloren und <xref:System.Net.Sockets.SocketException> ausgelöst.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft ist nicht festgelegt.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Startet eine asynchrone Anforderung, um Daten von einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt zu empfangen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> Methode wird verwendet, auf die verbundene Sockets oder gebundene Sockets ohne Verbindung und wird verwendet, um die eingehenden Daten lesen. Lokale Adresse des Sockets muss bekannt sein.  
  
 Diese Funktion beschränkt gebundenen verbindungslose Sockets die Adressen aus dem empfangene Nachrichten akzeptiert werden. Die Funktion gibt nur Nachrichten aus der in der Verbindung angegebene Remoteadresse. Nachrichten von anderen Adressen werden automatisch verworfen.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Eigenschaft für die `e` Parameter stellt den Dienstanbieter für Fenster-Sockets mit zusätzlichen Informationen über die leseanforderung bereit. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für Byte-Stream-Format-Sockets werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder alle intern gepufferten Daten beendet ist.  
  
 Für die Message-ausgerichteten Sockets, befindet sich eine eingehende Nachricht im Puffer bis zu die Gesamtgröße des zugeordneten Puffers der `e` Parameter. Wenn die Nachricht größer als der Puffer ist, wird der Puffer mit dem ersten Teil der Nachricht gefüllt.  
  
 Für verbindungsorientierte Sockets die <xref:System.Net.Sockets.Socket.ReceiveAsync%2A> können angeben, die ordnungsgemäße Beendigung der die virtuelle Verbindung in einem, zwei Methoden, mit denen abhängen, ob der Socket Bytestream oder meldungsorientiert ist. Bei Bytestreams gibt 0 (null) Bytes gelesen ordnungsgemäß geschlossen wird und keine Bytes mehr mehr gelesen werden. Bei Message-ausgerichteten Sockets, in denen eine NULL Byte großen Nachricht häufig zulässig ist, einen <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf den systemeigenen Winsock WSAEDISCON Fehlercode (10101) verwendet, um ordnungsgemäße Closure anzugeben. In jedem Fall eine <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> legen Sie auf die systemeigene Winsock WSAECONNRESET Fehlercode (10054) gibt an einem abbrechenden schließen ist aufgetreten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Ein Argument war ungültig. Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen. Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveBufferSize">
      <MemberSignature Language="C#" Value="public int ReceiveBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des Empfangspuffers des <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Größe des Empfangspuffer in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein größeren Puffer möglicherweise reduziert die Anzahl der leeren Bestätigungen (TCP-Pakete mit kein Datenteil), aber möglicherweise auch dann verzögern, die Erkennung von Verbindungsproblemen. Erhöhen Sie die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. eine Breitband Satellitenanbieter.)  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveBufferSize%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReceiveFrom">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Empfängt ein Datagramm und speichert den Endpunkt der Quelle.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.EndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFrom (buffer As Byte(), ByRef remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] *  -&gt; int" Usage="socket.ReceiveFrom (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt ein Datagramm im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode liest die Daten in die `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, verbindungslose Datagramme von einer unbekannten Host oder mehreren Hosts zu empfangen.  
  
 Diese Überladung müssen Sie eine Receive-Anweisung bereitstellen `buffer`, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Pufferoffset hat den Standardwert 0. Die Größe der Länge der wird standardmäßig die `buffer` Parameter und die `socketFlags` -Wert wird standardmäßig <xref:System.Net.Sockets.SocketFlags.None>.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm, die im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm, Sie erhalten, größer als die Größe des `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich ist, und lösen wird mit der Meldung eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein-unzuverlässigen Protokoll verwenden, werden überschüssigen Daten in die verloren gehen. Wenn Sie ein zuverlässiges Protokoll verwenden, überschüssigen Daten in die vom Dienstanbieter beibehalten werden werden und zum Abrufen dieses durch Aufrufen der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode mit einem ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie dazu entscheiden, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht einrichten oder nehmen Sie eine Verbindung vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In beiden Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode ignoriert die `remoteEP` Parameter und nur Daten aus dem verbundenen oder Standard-Remotehost empfangen.  
  
 Bei einem verbindungsorientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten wie verfügbar bis zur Länge ist `buffer`. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> übereinstimmen muss die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen.  
  
 [!code-cpp[Socket_Sync_Send_Receive#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#9)]
 [!code-csharp[Socket_Sync_Send_Receive#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#9)]
 [!code-vb[Socket_Sync_Send_Receive#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das der Speicherort für die empfangenen Daten ist.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> ein Datagramm im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode liest die Daten in die `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, verbindungslose Datagramme von einer unbekannten Host oder mehreren Hosts zu empfangen.  
  
 Diese Überladung müssen Sie zu einem Empfangspuffer, die erforderlichen <xref:System.Net.Sockets.SocketFlags>, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Offset der Standardwert ist 0 und die Standardgröße der Länge des Pufferparameters.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm, die im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm, Sie erhalten, größer als die Größe des `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich ist, und lösen wird mit der Meldung eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein-unzuverlässigen Protokoll verwenden, werden überschüssigen Daten in die verloren gehen. Wenn Sie ein zuverlässiges Protokoll verwenden, überschüssigen Daten in die vom Dienstanbieter beibehalten werden werden und zum Abrufen dieses durch Aufrufen der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode mit einem ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie dazu entscheiden, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht einrichten oder nehmen Sie eine Verbindung vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In beiden Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode ignoriert die `remoteEP` Parameter und nur Daten aus dem verbundenen oder Standard-Remotehost empfangen.  
  
 Bei einem verbindungsorientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten wie verfügbar bis zur Länge ist `buffer`. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> übereinstimmen muss die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. <xref:System.Net.Sockets.SocketFlags> zum Übergeben der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#10)]
 [!code-csharp[Socket_Sync_Send_Receive#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#10)]
 [!code-vb[Socket_Sync_Send_Receive#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt mithilfe der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> die angegebene Anzahl von Bytes im Datenpuffer und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode liest die Daten in die `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, verbindungslose Datagramme von einer unbekannten Host oder mehreren Hosts zu empfangen.  
  
 Diese Überladung müssen Sie zu einem Empfangspuffer, die Anzahl der Bytes, zu erhalten, die erforderlichen <xref:System.Net.Sockets.SocketFlags>, und ein <xref:System.Net.EndPoint> , der den Remotehost darstellt. Der Pufferoffset hat den Standardwert 0.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm, die im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm, Sie erhalten, größer als die Größe des `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich ist, und lösen wird mit der Meldung eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein-unzuverlässigen Protokoll verwenden, werden überschüssigen Daten in die verloren gehen. Wenn Sie ein zuverlässiges Protokoll verwenden, überschüssigen Daten in die vom Dienstanbieter beibehalten werden werden und zum Abrufen dieses durch Aufrufen der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode mit einem ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie dazu entscheiden, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht einrichten oder nehmen Sie eine Verbindung vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In beiden Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode ignoriert die `remoteEP` Parameter und nur Daten aus dem verbundenen oder Standard-Remotehost empfangen.  
  
 Bei einem verbindungsorientierten Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele Daten wie verfügbar bis zur Anzahl von Bytes, die angegeben ist die `size` Parameter. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> übereinstimmen muss die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. Die Größe des Puffers und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#11)]
 [!code-csharp[Socket_Sync_Send_Receive#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#11)]
 [!code-vb[Socket_Sync_Send_Receive#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFrom">
      <MemberSignature Language="C#" Value="public int ReceiveFrom (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFrom : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.ReceiveFrom (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert den Endpunkt.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode liest die Daten in die `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Remotehost-Endpunkt, von dem die Daten gesendet wurden. Diese Methode ist nützlich, wenn Sie beabsichtigen, verbindungslose Datagramme von einer unbekannten Host oder mehreren Hosts zu empfangen.  
  
 Mit verbindungslose Protokolle <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest das erste Datagramm, die im lokalen Netzwerk Puffer empfangen. Wenn das Datagramm, Sie erhalten, größer als die Größe des `buffer`, <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode füllt `buffer` mit so viel wie möglich ist, und lösen wird mit der Meldung eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein-unzuverlässigen Protokoll verwenden, werden überschüssigen Daten in die verloren gehen. Wenn Sie ein zuverlässiges Protokoll verwenden, überschüssigen Daten in die vom Dienstanbieter beibehalten werden werden und zum Abrufen dieses durch Aufrufen der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode mit einem ausreichend großen Puffer.  
  
 Wenn keine Daten für das Lesen, sind die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode blockiert, bis die Daten verfügbar sind. Wenn Sie befinden sich im nicht blockierenden Modus, und es keine Daten in sind die im Protokoll Stack-Puffer der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet wird, und löst eine <xref:System.Net.Sockets.SocketException>. Sie können die <xref:System.Net.Sockets.Socket.Available%2A> Eigenschaft, um zu bestimmen, ob die Daten zum Lesen verfügbar sind. Wenn <xref:System.Net.Sockets.Socket.Available%2A> ist ungleich NULL ist, wiederholen Sie den Receive-Vorgang.  
  
 Obwohl <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> richtet sich verbindungslose Protokolle können Sie auch ein verbindungsorientiertes Protokoll. Wenn Sie dazu entscheiden, Sie müssen zunächst entweder einrichten eine Remotehostverbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Remote Server-Verbindung durch Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie nicht einrichten oder nehmen Sie eine Verbindung vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> -Methode erhalten Sie eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode. In beiden Fällen die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode ignoriert die `remoteEP` Parameter und nur Daten aus dem verbundenen oder Standard-Remotehost empfangen.  
  
 Bei verbindungsorientierte Sockets <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> liest so viele verfügbaren Daten bis zu die Anzahl der Bytes, die gemäß der `size` Parameter. Wenn der Remotehost die <xref:System.Net.Sockets.Socket> -Verbindung mit der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, und alle verfügbaren Daten empfangen wurden, die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode sofort beendet und gibt 0 (null) Bytes zurück.  
  
> [!NOTE]
>  Vor dem Aufruf <xref:System.Net.Sockets.Socket.ReceiveFrom%2A>, müssen Sie explizit binden die <xref:System.Net.Sockets.Socket> an einen lokalen Endpunkt die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. Wenn Sie keinen <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> übereinstimmen muss die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein verbindungsloses Datagramm von einem Remotehost empfangen. Der Offset, die Puffergröße und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#12](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#12)]
 [!code-csharp[Socket_Sync_Send_Receive#12](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#12)]
 [!code-vb[Socket_Sync_Send_Receive#12](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#12)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder -  
Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Receive(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt den asynchronen Datenempfang aus dem angegebenen Netzwerkgerät.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> Methode wird in erster Linie zum Empfangen von Daten auf einem verbindungslosen Socket verwendet. Lokale Adresse des Sockets muss bekannt sein.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, von dem die Daten sind, empfangen werden kann.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> Eigenschaft für die `e` Parameter stellt den Dienstanbieter für Fenster-Sockets mit zusätzlichen Informationen über die leseanforderung bereit. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für die Message-ausgerichteten Sockets befindet sich eine eingehende Nachricht im Puffer bis zu die Gesamtgröße des Puffers. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 Für Byte-Stream-Format-Sockets werden der eingehende Daten in den Puffer eingefügt, bis der Puffer voll ist, die Verbindung geschlossen wird oder alle intern gepufferten Daten beendet ist. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFrom">
      <MemberSignature Language="C#" Value="public int ReceiveMessageFrom (byte[] buffer, int offset, int size, ref System.Net.Sockets.SocketFlags socketFlags, ref System.Net.EndPoint remoteEP, out System.Net.Sockets.IPPacketInformation ipPacketInformation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 ReceiveMessageFrom(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags&amp; socketFlags, class System.Net.EndPoint&amp; remoteEP, [out] valuetype System.Net.Sockets.IPPacketInformation&amp; ipPacketInformation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags@,System.Net.EndPoint@,System.Net.Sockets.IPPacketInformation@)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFrom (buffer As Byte(), offset As Integer, size As Integer, ByRef socketFlags As SocketFlags, ByRef remoteEP As EndPoint, ByRef ipPacketInformation As IPPacketInformation) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int ReceiveMessageFrom(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags % socketFlags, System::Net::EndPoint ^ % remoteEP, [Runtime::InteropServices::Out] System::Net::Sockets::IPPacketInformation % ipPacketInformation);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFrom : byte[] * int * int *  *  *  -&gt; int" Usage="socket.ReceiveMessageFrom (buffer, offset, size, socketFlags, remoteEP, ipPacketInformation)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" RefType="ref" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" RefType="ref" />
        <Parameter Name="ipPacketInformation" Type="System.Net.Sockets.IPPacketInformation" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array des Typs <see cref="T:System.Byte" />, bei dem es sich um den Speicherort für empfangene Daten handelt.</param>
        <param name="offset">Die Position im <paramref name="buffer" />-Parameter, an der die empfangenen Daten gespeichert werden sollen.</param>
        <param name="size">Die Anzahl der zu empfangenden Bytes.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Ein als Verweis übergebener <see cref="T:System.Net.EndPoint" />, der den Remoteserver darstellt.</param>
        <param name="ipPacketInformation">Ein <see cref="T:System.Net.Sockets.IPPacketInformation" />-Objekt, das Adress- und Schnittstelleninformationen enthält.</param>
        <summary>Empfängt die angegebene Anzahl von Datenbytes an der angegebenen Position im Datenpuffer, verwendet dabei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns>Die Anzahl der empfangenen Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode liest die Daten in die `buffer` Parameter, gibt die Anzahl der erfolgreich gelesenen Bytes und zeichnet den Endpunkt des remote-Host, von dem die Daten, sowie Informationen über das empfangene Paket gesendet wurden.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode wird in erster Linie zum Empfangen von Nachrichtendaten, die auf einem verbindungslosen Socket verwendet. Lokale Adresse des Sockets muss bekannt sein. Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden. Der Socket muss initialisiert werden, mit der Socket <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> vor dem Aufrufen dieser Methode. Dies ist möglich, wenn der Socket erstellt wurde, mithilfe von <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Für die Message-ausgerichteten Sockets, befindet sich eine eingehende Nachricht in die `buffer` Parameter bis zu die Gesamtgröße angegeben, der `size` Parameter. Die `offset` Parameter bestimmt, wo in der `buffer` befindet sich die Daten. Die tatsächliche Datenmenge abgelegt der `buffer` wird zurückgegeben, durch die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> -Methode legt automatisch die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` beim ersten Aufruf ist für einen bestimmten <xref:System.Net.Sockets.Socket>. Allerdings zurückgegebenen <xref:System.Net.Sockets.IPPacketInformation> Objekt werden nur für Pakete, die auf dem lokalen Computer zu empfangen, nachdem die Socketoption festgelegt wurde. Wenn ein Socket Pakete zwischen gesendet wird, wenn sie an einen lokalen Endpunkt gebunden ist (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine von der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methoden) und dem ersten Aufruf von der <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode aufruft, um <xref:System.Net.Sockets.Socket.ReceiveMessageFrom%2A> Methode gibt ungültige <xref:System.Net.Sockets.IPPacketInformation> Objekte für diese Pakete.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, eine Anwendung festlegen, sollten die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` , bevor sie an einen lokalen Endpunkt gebunden ist die <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> Methode.  
  
 Eine Anwendung kann Untersuchen der `ipPacketInformation` -Parameters, wenn muss klar sein, wenn das Datagramm mit einer Unicast, multicast oder broadcast gesendet wurde.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.ReceiveFrom%2A> übereinstimmen muss die <xref:System.Net.Sockets.AddressFamily> von der <xref:System.Net.EndPoint> verwendet <xref:System.Net.Sockets.Socket.SendTo%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
\- oder – 
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des offset-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Die <see cref="P:System.Net.Sockets.Socket.LocalEndPoint" />-Eigenschaft wurde nicht festgelegt.  
  
- oder -  
.NET Framework wird mit einem AMD 64 Bit-Prozessor ausgeführt.  
  
- oder -  
Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist Windows 2000 oder früher, für diese Methode ist jedoch Windows XP erforderlich.</exception>
        <permission cref="T:System.Net.SocketPermission">für das Akzeptieren von Verbindungen über das Netzwerk. Zugeordnete Enumeration: <see cref="F:System.Net.NetworkAccess.Accept" /></permission>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFrom(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint@)" />
        <altmember cref="P:System.Net.Sockets.Socket.Available" />
        <altmember cref="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromAsync">
      <MemberSignature Language="C#" Value="public bool ReceiveMessageFromAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool ReceiveMessageFromAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveMessageFromAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool ReceiveMessageFromAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.ReceiveMessageFromAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Beginnt unter Verwendung der angegebenen <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" /> den asynchronen Empfang der angegebenen Anzahl von Datenbytes an der angegebenen Position im Datenpuffer und speichert die Endpunkt- und Paketinformationen.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode wird in erster Linie zum Empfangen von Nachrichtendaten, die auf einem verbindungslosen Socket verwendet. Lokale Adresse des Sockets muss bekannt sein. Diese Methode kann nur mit Datagramm und raw-Sockets verwendet werden. Der Socket muss initialisiert werden, mit der Socket <xref:System.Net.Sockets.SocketType.Dgram> oder <xref:System.Net.Sockets.SocketType.Raw> vor dem Aufrufen dieser Methode. Dies ist möglich, wenn der Socket erstellt wurde, mithilfe von <xref:System.Net.Sockets.Socket.%23ctor%2A>.  
  
 Der Aufrufer muss Festlegen der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft, um die <xref:System.Net.IPEndPoint> des Remotehosts, von dem die Daten sind, empfangen werden kann.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Für die Message-ausgerichteten Sockets befindet sich eine eingehende Nachricht im Puffer bis zu die Gesamtgröße des Puffers. Die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Eigenschaften im Puffer der Platzierung der Daten und die Menge der Daten zu bestimmen.  
  
 Die <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> -Methode legt automatisch die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf `true` beim ersten Aufruf ist für einen angegebenen <xref:System.Net.Sockets.Socket>. Allerdings die <xref:System.Net.Sockets.IPPacketInformation> Objekt werden nur für Pakete, die auf dem lokalen Computer zu empfangen, nachdem die Socketoption festgelegt wurde. Wenn ein Socket Pakete zwischen gesendet wird, wenn der Socket an einen lokalen Endpunkt gebunden ist (explizit durch die <xref:System.Net.Sockets.Socket.Bind%2A> Methode oder implizit durch eine von der <xref:System.Net.Sockets.Socket.Connect%2A>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A>, <xref:System.Net.Sockets.Socket.SendTo%2A>, oder <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methoden) und der erste Aufruf der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A>Methode aufruft, um <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A> Methode führt dazu, ungültige <xref:System.Net.Sockets.IPPacketInformation> Objekte für diese Pakete.  
  
 Um sicherzustellen, dass alle <xref:System.Net.Sockets.IPPacketInformation> Objekte gültig sind, eine Anwendung festlegen, sollten die <xref:System.Net.Sockets.SocketOptionName.PacketInformation> Socketoption auf`true` , bevor sie an einen lokalen Endpunkt gebunden ist die <xref:System.Net.Sockets.Socket.SetSocketOption%28System.Net.Sockets.SocketOptionLevel%2CSystem.Net.Sockets.SocketOptionName%2CSystem.Boolean%29> Methode.  
  
 Eine Anwendung kann die resultierende untersuchen <xref:System.Net.Sockets.IPPacketInformation> Objekte an, wenn muss klar sein, wenn das Datagramm mit einer Unicast, multicast oder broadcast gesendet wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveTimeout">
      <MemberSignature Language="C#" Value="public int ReceiveTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 ReceiveTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property ReceiveTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int ReceiveTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveTimeout : int with get, set" Usage="System.Net.Sockets.Socket.ReceiveTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Receive" />-Aufrufs angibt, oder legt diesen fest.</summary>
        <value>Der Timeoutwert in Millisekunden. Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an. Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt für synchrone <xref:System.Net.Sockets.Socket.Receive%2A> nur aufruft. Wenn das Timeout überschritten wird, die <xref:System.Net.Sockets.Socket.Receive%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.ReceiveTimeout%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint" Usage="System.Net.Sockets.Socket.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Remoteendpunkt ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, mit dem der <see cref="T:System.Net.Sockets.Socket" /> kommuniziert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung einer verbindungsorientiertes Protokoll, das <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> eigenschaftsabrufvorgängen der <xref:System.Net.EndPoint> mit Angaben dazu remote IP-Adresse und Port, der <xref:System.Net.Sockets.Socket> verbunden ist. Wenn Sie ein verbindungsloses Protokoll, verwenden <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> enthält die standardmäßige remote IP-Adresse und Portnummer, die mit dem die <xref:System.Net.Sockets.Socket> kommuniziert. Sie müssen dies umwandeln <xref:System.Net.EndPoint> zu ein <xref:System.Net.IPEndPoint> vor dem Abrufen von Informationen. Rufen Sie anschließend die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Methode zum Abrufen der entfernten <xref:System.Net.IPAddress>, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Methode zum Abrufen der Nummer des Remoteports.  
  
 Die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> festgelegt ist, nach einem Aufruf von entweder <xref:System.Net.Sockets.Socket.Accept%2A> oder <xref:System.Net.Sockets.Socket.Connect%2A>. Wenn Sie versuchen, Zugriff auf diese Eigenschaft zuvor <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird abgerufen und die lokalen und Remoteendpunkte angezeigt.  
  
 [!code-cpp[Socket_Socket_Options#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#4)]
 [!code-csharp[Socket_Socket_Options#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#4)]
 [!code-vb[Socket_Socket_Options#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
      </Docs>
    </Member>
    <Member MemberName="Select">
      <MemberSignature Language="C#" Value="public static void Select (System.Collections.IList checkRead, System.Collections.IList checkWrite, System.Collections.IList checkError, int microSeconds);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void Select(class System.Collections.IList checkRead, class System.Collections.IList checkWrite, class System.Collections.IList checkError, int32 microSeconds) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Select(System.Collections.IList,System.Collections.IList,System.Collections.IList,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub Select (checkRead As IList, checkWrite As IList, checkError As IList, microSeconds As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void Select(System::Collections::IList ^ checkRead, System::Collections::IList ^ checkWrite, System::Collections::IList ^ checkError, int microSeconds);" />
      <MemberSignature Language="F#" Value="static member Select : System.Collections.IList * System.Collections.IList * System.Collections.IList * int -&gt; unit" Usage="System.Net.Sockets.Socket.Select (checkRead, checkWrite, checkError, microSeconds)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="checkRead" Type="System.Collections.IList" />
        <Parameter Name="checkWrite" Type="System.Collections.IList" />
        <Parameter Name="checkError" Type="System.Collections.IList" />
        <Parameter Name="microSeconds" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="checkRead">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob sie gelesen werden können.</param>
        <param name="checkWrite">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, bei denen geprüft werden soll, ob in sie geschrieben werden kann.</param>
        <param name="checkError">Eine <see cref="T:System.Collections.IList" /> von <see cref="T:System.Net.Sockets.Socket" />-Instanzen, die auf Fehler überprüft werden sollen.</param>
        <param name="microSeconds">Der Timeoutwert in Mikrosekunden. Ein Wert von -1 gibt ein unendliches Timeout an.</param>
        <summary>Bestimmt den Status von einem oder mehreren Sockets.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Select%2A> ist eine statische Methode, die bestimmt, den Status eines oder mehrerer <xref:System.Net.Sockets.Socket> Instanzen. Man muss einem oder mehreren Sockets in einer <xref:System.Collections.IList> vor der Verwendung der <xref:System.Net.Sockets.Socket.Select%2A> Methode. Überprüfen Sie durch den Aufruf zur besseren Lesbarkeit <xref:System.Net.Sockets.Socket.Select%2A> mit der <xref:System.Collections.IList> als die `checkRead` Parameter. Überprüfen Sie Ihre Sockets geprüft, verwenden die `checkWrite` Parameter. Verwenden Sie zum Erkennen von fehlerbedingungen, `checkError`. Nach dem Aufruf <xref:System.Net.Sockets.Socket.Select%2A>, <xref:System.Collections.IList> wird übernommen, nur diese Sockets, die die Bedingungen erfüllen.  
  
 Wenn Sie in einem Wartezustand sind, Lesbarkeit bedeutet, dass einen Aufruf von <xref:System.Net.Sockets.Socket.Accept%2A> ist erfolgreich, ohne zu blockieren. Wenn Sie die Verbindung bereits akzeptiert haben, bedeutet die Lesbarkeit, dass Daten zum Lesen verfügbar sind. In diesen Fällen erhalten Sie alle Vorgänge werden erfolgreich ausgeführt werden, ohne zu blockieren. Lesbarkeit kann auch angegeben, ob die Remote <xref:System.Net.Sockets.Socket> verfügt über die Verbindung; in diesem Fall schließen einen Aufruf von <xref:System.Net.Sockets.Socket.Receive%2A> wird sofort zurückgegeben, und 0 (null) Bytes zurückgegeben.  
  
 <xref:System.Net.Sockets.Socket.Select%2A> Gibt zurück, wenn mindestens eine der Sockets von Interesse sind (die Sockets in der `checkRead`, `checkWrite`, und `checkError` aufgeführt) die angegebenen Kriterien erfüllen, oder die `microSeconds` Parameter überschritten wird, welcher Fall zuerst eintritt. Festlegen von `microSeconds` auf-1 gibt ein unendliches Timeout.  
  
 Wenn Sie einen nicht blockierenden Aufruf vornehmen <xref:System.Net.Sockets.Socket.Connect%2A>, schreibbarkeit bedeutet, dass Sie erfolgreich eine Verbindung hergestellt haben. Wenn Sie bereits eine Verbindung hergestellt haben, bedeutet geprüft, dass alle, dass Vorgänge erfolgreich ausgeführt werden senden, ohne zu blockieren.  
  
 Wenn Sie einen nicht blockierenden Aufruf vorgenommen haben <xref:System.Net.Sockets.Socket.Connect%2A>, `checkerror` Parameter identifiziert, Sockets, die nicht erfolgreich eine Verbindung hergestellt haben.  
  
> [!NOTE]
>  Verwenden der <xref:System.Net.Sockets.Socket.Poll%2A> Methode, wenn Sie nur den Status einer einzelnen bestimmen möchten <xref:System.Net.Sockets.Socket>.  
  
> [!NOTE]
>  Diese Methode kann nicht feststellen, dass bestimmte Arten von Verbindungsproblemen, z. B. eine fehlerhafte Netzwerkkabel oder, die der Remotehost nicht ordnungsgemäß heruntergefahren wurde. Sie müssen versuchen, zum Senden oder Empfangen von Daten, um diese Arten von Fehlern zu erkennen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.Socket.Select%2A> um zu bestimmen, welche empfangsbereiten Sockets eine verbindungsanforderung.  
  
 [!code-cpp[Socket_Select#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Select/CPP/source.cpp#1)]
 [!code-csharp[Socket_Select#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Select/CS/source.cs#1)]
 [!code-vb[Socket_Select#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Select/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="checkRead" />-Parameter ist <see langword="null" /> oder leer.  
  
- und - 
Der <paramref name="checkWrite" />-Parameter ist <see langword="null" /> oder leer. 
- und - 
Der <paramref name="checkError" />-Parameter ist <see langword="null" /> oder leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <altmember cref="T:System.Collections.IList" />
        <altmember cref="M:System.Net.Sockets.Socket.Accept" />
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Poll(System.Int32,System.Net.Sockets.SelectMode)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As Byte()) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <summary>Sendet Daten an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss es sich um einen Puffer, der die Daten enthält, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> Wert hat den Standardwert 0, der Puffer hat den Standardwert 0, und die Anzahl der zu sendenden Bytes entspricht der Größe des Puffers.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden, die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn es kleiner als die Anzahl der Bytes im Puffer gesendet. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#1)]
 [!code-csharp[Socket_Sync_Send_Receive#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#1)]
 [!code-vb[Socket_Sync_Send_Receive#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffers As IList(Of ArraySegment(Of Byte))) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; -&gt; int" Usage="socket.Send buffers" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <summary>Sendet den Satz der Puffer in der Liste an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss mindestens einen Puffer mit den Daten, die Sie senden möchten.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden, die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn es kleiner als die Anzahl der Bytes im Puffer gesendet. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[])" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Weitere Informationen finden Sie unten im Abschnitt Hinweise.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (buffer As ReadOnlySpan(Of Byte)) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; -&gt; int" Usage="socket.Send buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet Daten mithilfe der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> sendet Daten synchron an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. Die <xref:System.Net.Sockets.Socket.Send%2A> Methode kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss ein Puffer mit den Daten gesendet werden soll und eine bitweise Kombination von <xref:System.Net.Sockets.SocketFlags>. Der Puffer hat den Standardwert 0, und die Anzahl der zu sendenden Bytes entspricht der Größe des Puffers. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` Parameterwert, der die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, Sie müssen zum Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf auf <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn es kleiner als die Anzahl der Bytes im Puffer gesendet. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Service Providers überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, sendende von Daten über einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#2)]
 [!code-csharp[Socket_Sync_Send_Receive#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#2)]
 [!code-vb[Socket_Sync_Send_Receive#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffers, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss mindestens einen Puffer mit den Daten, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> Wert hat den Standardwert 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketFlags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden, die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn es kleiner als die Anzahl der Bytes im Puffer gesendet. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> sendet Daten synchron an den Remotehost die <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Diese Überladung muss ein Puffer mit den Daten zu senden, die Anzahl der Bytes, die Sie senden möchten, und eine bitweise Kombination der <xref:System.Net.Sockets.SocketFlags>. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode, Sie müssen zum Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf an die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Mit einem verbindungsorientiertes Protokoll <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Sie müssen sicherstellen, dass die Größe die maximale Paketgröße des zugrunde liegenden Service Providers nicht überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet die Daten in den Puffer und gibt an, <xref:System.Net.Sockets.SocketFlags.None> für <xref:System.Net.Sockets.SocketFlags>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#3)]
 [!code-csharp[Socket_Sync_Send_Receive#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#3)]
 [!code-vb[Socket_Sync_Send_Receive#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size" /> ist größer als 0 oder übersteigt die Puffergröße.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Beim Zugriff auf den Socket ist ein Fehler auf Betriebssystemebene aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; buffers, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; buffers, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Collections.Generic.IList{System.ArraySegment{System.Byte}},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ buffers, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffers, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffers" Type="System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffers">Eine Liste von <see cref="T:System.ArraySegment`1" /> vom Typ <see cref="T:System.Byte" /> mit den zu sendenden Daten.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Sendet den Satz von Puffern in der Liste unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss mindestens einen Puffer mit den Daten, die Sie senden möchten. Die <xref:System.Net.Sockets.SocketFlags> Wert hat den Standardwert 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketFlags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. Wenn Sie nicht verwenden, die <xref:System.Net.Sockets.Socket.SendTo%2A> -Methode müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Sie können <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis alle Bytes im Puffer gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn es kleiner als die Anzahl der Bytes im Puffer gesendet. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die Bytes im Puffer gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <exception cref="T:System.ArgumentNullException"><paramref name="buffers" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="buffers" /> ist leer.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (ReadOnlySpan&lt;byte&gt; buffer, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.ReadOnlySpan{System.Byte},System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(ReadOnlySpan&lt;System::Byte&gt; buffer, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : ReadOnlySpan&lt;byte&gt; * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">To be added.</param>
        <param name="socketFlags">To be added.</param>
        <param name="errorCode">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />, beginnend bei einem angegebenen Offset und unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A>. Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A>, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Sie müssen auch darauf achten, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe, und <xref:System.Net.Sockets.SocketFlags> zum Senden von Daten an einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, out System.Net.Sockets.SocketError errorCode);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, [out] valuetype System.Net.Sockets.SocketError&amp; errorCode) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.Sockets.SocketError@)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, [Runtime::InteropServices::Out] System::Net::Sockets::SocketError % errorCode);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * int * System.Net.Sockets.SocketFlags *  -&gt; int" Usage="socket.Send (buffer, offset, size, socketFlags, errorCode)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="errorCode" Type="System.Net.Sockets.SocketError" RefType="out" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="errorCode">Ein <see cref="T:System.Net.Sockets.SocketError" />-Objekt, in dem der Socketfehler gespeichert wird.</param>
        <summary>Sendet unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.Socket" /> die angegebene Anzahl von Datenbytes an einen verbundenen <see cref="T:System.Net.Sockets.SocketFlags" />, beginnend beim angegebenen Offset.</summary>
        <returns>Die Anzahl der an den <see cref="T:System.Net.Sockets.Socket" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.Send%2A> sendet Daten synchron mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> -Methode und gibt die Anzahl der erfolgreich Bytes gesendeten. <xref:System.Net.Sockets.Socket.Send%2A> kann für verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode oder <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Wenn Sie ein verbindungsloses Protokoll und den Plan verwenden, Daten an mehrere verschiedener Hosts senden, verwenden Sie <xref:System.Net.Sockets.Socket.SendTo%2A>. Wenn Sie nicht verwenden <xref:System.Net.Sockets.Socket.SendTo%2A>, müssen Sie rufen <xref:System.Net.Sockets.Socket.Connect%2A> vor jedem Aufruf von <xref:System.Net.Sockets.Socket.Send%2A>. Es ist in Ordnung verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> auch verwendet werden, nachdem Sie einen Standardremotehost mit eingerichtet haben <xref:System.Net.Sockets.Socket.Connect%2A>. Sie können auch ändern, vor dem Aufrufen der Standard-Remotehost <xref:System.Net.Sockets.Socket.Send%2A> durch einen anderen Aufruf <xref:System.Net.Sockets.Socket.Connect%2A>.  
  
 Sie müssen auch darauf achten, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.Send%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.Send%2A> blockiert, bis die angeforderte Anzahl von Bytes gesendet werden, es sei denn, ein Timeout festgelegt wurde, mithilfe von <xref:System.Net.Sockets.Socket.SendTimeout%2A?displayProperty=nameWithType>. Wenn der Timeoutwert überschritten wurde, die <xref:System.Net.Sockets.Socket.Send%2A> lösen eine <xref:System.Net.Sockets.SocketException>. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.Send%2A> möglicherweise erfolgreich abgeschlossen, auch wenn er kleiner als die Anzahl der Bytes sendet Sie anfordern. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.Send%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Der erfolgreiche Abschluss eines Sendevorgangs gibt keine, dass die Daten erfolgreich übermittelt wurde. Ist kein Pufferplatz verfügbar innerhalb des Systems Transport zum Speichern der Daten übertragen werden, blockiert senden, wenn der Socket in den nicht blockierenden Modus versetzt wurde.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel gibt an, den Datenpuffer, ein Offset, Größe, und <xref:System.Net.Sockets.SocketFlags> zum Senden von Daten an einen verbundenen <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Socket_Sync_Send_Receive#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#4)]
 [!code-csharp[Socket_Sync_Send_Receive#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#4)]
 [!code-vb[Socket_Sync_Send_Receive#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public bool SendAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet Daten asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode wird verwendet, um ausgehende Daten aus einem oder mehreren Puffern für einen verbindungsorientierten Socket zu schreiben. Diese Methode kann auch, jedoch bei verbindungslosen Sockets verwendet werden, die einen remote-Host auf einen Vorgang Connect angegeben haben.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost die <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType> Wenn <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType> festgelegt ist  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Die <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode löst eine Ausnahme aus, wenn Sie nicht zuerst Aufrufen <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A> <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A>.  
  
 Aufrufen der <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden.  
  
 Überschreiten Sie bei Message-ausgerichteten Sockets Sie die maximale Nachrichtengröße für die zugrunde liegenden Windows Sockets-Service-Anbieter nicht. Wenn die Daten zu lang und automatisch über den zugrunde liegenden Dienstanbieter sind, werden keine Daten übertragen und die <xref:System.Net.Sockets.Socket.SendAsync%2A> -Methode löst eine <xref:System.Net.Sockets.SocketException> mit der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A?displayProperty=nameWithType> auf die systemeigene Winsock-Fehlercode WSAEMSGSIZE (10040) festgelegt.  
  
 Beachten Sie, dass vom erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendAsync%2A> Methode ist nicht, dass die Daten erfolgreich übermittelt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft oder <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft des <paramref name="e" />-Parameters muss auf gültige Puffer verweisen. Eine dieser Eigenschaften kann festgelegt werden, nicht jedoch beide gleichzeitig.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Der <see cref="T:System.Net.Sockets.Socket" /> ist noch nicht verbunden oder wurde nicht über eine <see cref="M:System.Net.Sockets.Socket.Accept" />-<see cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />- oder <see cref="Overload:System.Net.Sockets.Socket.BeginAccept" />-Methode abgerufen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendBufferSize">
      <MemberSignature Language="C#" Value="public int SendBufferSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendBufferSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendBufferSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendBufferSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendBufferSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendBufferSize : int with get, set" Usage="System.Net.Sockets.Socket.SendBufferSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Größe des Sendepuffers für den <see cref="T:System.Net.Sockets.Socket" /> angibt, oder legt diesen fest.</summary>
        <value>Ein <see cref="T:System.Int32" />, das die Größe des Sendepuffer in Bytes enthält. Der Standard ist 8192.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein größeren Puffer kann die Erkennung von Verbindungsproblemen verzögern. Erhöhen Sie die Puffergröße, wenn Sie große Dateien übertragen, oder Sie verwenden eine hohe Bandbreite, die hohe Latenz der Verbindung (z. B. eine Breitband Satellitenanbieter.)  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendBufferSize%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als 0.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendFile">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet eine Datei und optionale Daten synchron an einen verbundenen <see cref="T:System.Net.Sockets.Socket" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string -&gt; unit" Usage="socket.SendFile fileName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> mit dem <see cref="T:System.Net.Sockets.Socket" />-Übertragungsflag an ein verbundenes <see cref="F:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet die Datei `fileName` an die verbundenen Socket. Die `flags` Parameter hat den Standardwert <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread> (0), und die `preBuffer` und `postBuffer` Parameter standardmäßig `null`. Wenn `fileName` ist im lokalen Verzeichnis befindet, kann es mit nur den Namen der Datei bezeichnet werden, andernfalls den vollständigen Pfad und Name der Datei angegeben werden müssen. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt. Wenn die Datei nicht gefunden wird, wird die Ausnahme <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Diese Methode verwendet die `TransmitFile` Funktion gefunden wird, in der Windows Sockets-API-2. Weitere Informationen zu den `TransmitFile` -Funktion und die Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> sendet synchron eine Datei mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. <xref:System.Net.Sockets.Socket.SendFile%2A> kann sowohl die verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen von dieser Methode wird andernfalls <xref:System.Net.Sockets.Socket.SendFile%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die Datei gesendet wird. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> möglicherweise erfolgreich abgeschlossen, bevor die ganze Datei gesendet wurde. Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt, der einen Socket verbunden und sendet dann eine Datei mit dem Remotehost. Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers.  
  
 [!code-cpp[NCLSocketEnhancements#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#3)]
 [!code-csharp[NCLSocketEnhancements#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendFile">
      <MemberSignature Language="C#" Value="public void SendFile (string fileName, byte[] preBuffer, byte[] postBuffer, System.Net.Sockets.TransmitFileOptions flags);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SendFile(string fileName, unsigned int8[] preBuffer, unsigned int8[] postBuffer, valuetype System.Net.Sockets.TransmitFileOptions flags) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendFile(System.String,System.Byte[],System.Byte[],System.Net.Sockets.TransmitFileOptions)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SendFile (fileName As String, preBuffer As Byte(), postBuffer As Byte(), flags As TransmitFileOptions)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SendFile(System::String ^ fileName, cli::array &lt;System::Byte&gt; ^ preBuffer, cli::array &lt;System::Byte&gt; ^ postBuffer, System::Net::Sockets::TransmitFileOptions flags);" />
      <MemberSignature Language="F#" Value="member this.SendFile : string * byte[] * byte[] * System.Net.Sockets.TransmitFileOptions -&gt; unit" Usage="socket.SendFile (fileName, preBuffer, postBuffer, flags)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="fileName" Type="System.String" />
        <Parameter Name="preBuffer" Type="System.Byte[]" />
        <Parameter Name="postBuffer" Type="System.Byte[]" />
        <Parameter Name="flags" Type="System.Net.Sockets.TransmitFileOptions" />
      </Parameters>
      <Docs>
        <param name="fileName">Ein <see cref="T:System.String" />, der den Pfad und Namen der Datei enthält, die gesendet werden soll. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="preBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, bevor die Datei gesendet wird. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="postBuffer">Ein <see cref="T:System.Byte" />-Array, das Daten enthält, die gesendet werden sollen, nachdem die Datei gesendet wurde. Dieser Parameter kann <see langword="null" /> sein.</param>
        <param name="flags">Mindestens ein <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert.</param>
        <summary>Sendet die Datei <paramref name="fileName" /> und puffert Daten mit dem angegebenen <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Wert in einem verbundenen <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung muss der Name der zu sendenden Datei und eine bitweise Kombination von <xref:System.Net.Sockets.TransmitFileOptions> Werte. Die `preBuffer` Parameter enthält alle Daten, die vor der Datei gesendet werden sollen. `postBuffer` enthält Daten, die auf die Datei folgen soll. Wenn `fileName` ist im aktuellen Arbeitsverzeichnis, kann er mit nur den Namen der Datei bezeichnet werden, andernfalls den vollständigen Pfad und Name der Datei angegeben werden müssen. Platzhalter ("... \\\myfile.txt ") und UNC-Freigabenamen ("\\\\\\\shared Directory\\\myfile.txt ") werden unterstützt.  
  
 Die `flags` Parameter stellt den Dienstanbieter für Fenster-Sockets mit zusätzlichen Informationen über die Dateiübertragung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Diese Methode verwendet die `TransmitFile` Funktion gefunden wird, in der Windows Sockets-API-2. Weitere Informationen zu den `TransmitFile` -Funktion und die Flags, die Windows Sockets-Dokumentation in der MSDN Library anzuzeigen.  
  
 <xref:System.Net.Sockets.Socket.SendFile%2A> sendet synchron eine Datei mit dem Remotehost, angegeben der <xref:System.Net.Sockets.Socket.Connect%2A> oder <xref:System.Net.Sockets.Socket.Accept%2A> Methode. <xref:System.Net.Sockets.Socket.SendFile%2A> kann sowohl die verbindungsorientierte und verbindungslose Protokolle verwendet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie aufrufen <xref:System.Net.Sockets.Socket.Connect%2A> vor dem Aufrufen dieser Methode ist; andernfalls <xref:System.Net.Sockets.Socket.SendFile%2A> löst eine <xref:System.Net.Sockets.SocketException>. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie entweder mit <xref:System.Net.Sockets.Socket.Connect%2A> um eine Verbindung herzustellen, oder verwenden Sie <xref:System.Net.Sockets.Socket.Accept%2A> um eingehende Verbindungen zu akzeptieren.  
  
 Bei Verwendung einer verbindungsorientiertes Protokoll, <xref:System.Net.Sockets.Socket.SendFile%2A> blockiert, bis die gesamte Datei gesendet wird. Im nicht blockierenden Modus <xref:System.Net.Sockets.Socket.SendFile%2A> möglicherweise erfolgreich abgeschlossen, bevor die ganze Datei gesendet wurde. Es gibt keine Garantie, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendFile%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird erstellt und verbindet einen Socket. Die Datei "test.txt" befindet sich im Stammverzeichnis des lokalen Computers. In diesem Beispiel haben wir erstellen eine Prebuffer und Postbuffer mit Daten und senden sie mit der Datei mit dem Remotehost. Der Standardwert <xref:System.Net.Sockets.TransmitFileOptions> verwendet werden.  
  
 [!code-cpp[NCLSocketEnhancements#4](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#4)]
 [!code-csharp[NCLSocketEnhancements#4](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Das Betriebssystem ist nicht Windows NT oder höher.  
  
\- oder – 
Der Socket ist nicht mit einem Remotehost verbunden.</exception>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.InvalidOperationException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt ist nicht im Blockierungsmodus und kann diesen synchronen Aufruf nicht annehmen.</exception>
        <exception cref="T:System.IO.FileNotFoundException">Die Datei <paramref name="fileName" /> wurde nicht gefunden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendPacketsAsync">
      <MemberSignature Language="C#" Value="public bool SendPacketsAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendPacketsAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendPacketsAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendPacketsAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendPacketsAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendPacketsAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("Not implemented")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet eine Auflistung von Dateien oder Datenpuffern im Speicher asynchron an ein verbundenes <see cref="T:System.Net.Sockets.Socket" />-Objekt.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode wird verwendet, um eine Auflistung von Dateien oder im Arbeitsspeicher von Datenpuffern an remote-Host zu senden. Die <xref:System.Net.Sockets.Socket> muss bereits eine Verbindung mit dem Remotehost.  
  
 Wenn eine <xref:System.Net.Sockets.SendPacketsElement?displayProperty=nameWithType> Verweise auf eine Datei im Arbeitsverzeichnis, kann mit nur den Namen der Datei bezeichnet werden, andernfalls den vollständigen Pfad und Name der Datei angegeben werden müssen. Platzhalter und UNC-Freigabenamen werden unterstützt. Wenn die Datei nicht gefunden wird, <xref:System.IO.FileNotFoundException> ausgelöst.  
  
 Zum Abschluss benachrichtigt werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs >-Delegaten, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Eigenschaft für die `e` Parameter stellt den Dienstanbieter für Fenster-Sockets mit zusätzlichen Informationen über die Dateiübertragung. Weitere Informationen zum Verwenden dieses Typs finden Sie unter <xref:System.Net.Sockets.TransmitFileOptions>.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Diese Methode verwendet, finden Sie in der Windows Sockets-API 2 TransmitPackets-Funktion. Weitere Informationen über TransmitPackets-Funktion und ihre Flags finden Sie unter der Windows Sockets-Dokumentation in der MSDN Library.  
  
 Obwohl für verbindungsorientierte Protokolle, bestimmt die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode funktioniert auch für verbindungslose Protokolle, vorausgesetzt, dass Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode, um einen Standardremotehost herzustellen. Mit verbindungslose Protokolle müssen Sie auch sicher sein, dass die Größe der Datei die maximale Paketgröße des zugrunde liegenden Service Providers nicht überschreitet. Wenn dies der Fall ist, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> löst eine <xref:System.Net.Sockets.SocketException> Ausnahme.  
  
 Die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode ist optimiert, nach dem Betriebssystem auf dem sie verwendet wird. Bei Windows Server-Editionen die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode ist für hohe Leistung optimiert.  
  
 Für Editionen von Windows-Clients die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methode ist für die minimale Arbeitsspeicher und die Ressourcenverwendung optimiert.  
  
 Verwenden der <xref:System.Net.Sockets.TransmitFileOptions.UseKernelApc?displayProperty=nameWithType> -flag in der <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A?displayProperty=nameWithType> Eigenschaft für die `e` Parameter kann beachtliche Leistungsvorteile bieten. Wenn der Thread initiiert die <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A> Methodenaufruf für die hohe Berechnungen verwendet wird, es ist möglich, obwohl es unwahrscheinlich, dass APCs Start verhindert werden können. Beachten Sie, dass es ein Unterschied zwischen der Kernel und im Benutzermodus APCs. Kernel-APCs starten, wenn ein Thread im Wartezustand befinden. Benutzermodus-APCs starten, wenn ein Thread in einem Wartezustand alertable  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.IO.FileNotFoundException">Die in der <see cref="P:System.Net.Sockets.SendPacketsElement.FilePath" />-Eigenschaft angegebene Datei wurde nicht gefunden.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich. Diese Ausnahme tritt auch auf, wenn <see cref="T:System.Net.Sockets.Socket" /> nicht mit einem Remotehost verbunden ist.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Ein verbindungsloser <see cref="T:System.Net.Sockets.Socket" /> wird verwendet, und die verwendete Datei überschreitet die maximale Paketgröße des zugrunde liegenden Transports.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SendTimeout">
      <MemberSignature Language="C#" Value="public int SendTimeout { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendTimeout" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SendTimeout" />
      <MemberSignature Language="VB.NET" Value="Public Property SendTimeout As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendTimeout { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendTimeout : int with get, set" Usage="System.Net.Sockets.Socket.SendTimeout" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zeitspanne bis zum Timeout eines synchronen <see cref="Overload:System.Net.Sockets.Socket.Send" />-Aufrufs angibt, oder legt diesen fest.</summary>
        <value>Der Timeoutwert in Millisekunden. Wenn Sie die Eigenschaft auf einen Wert zwischen 1 und 499 festlegen, wird der Wert in 500 geändert. Der Standardwert ist 0 und gibt ein unendliches Timeoutintervall an. Durch die Angabe von -1 wird ebenfalls ein unendliches Timeoutintervall angegeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Option gilt für synchrone <xref:System.Net.Sockets.Socket.Send%2A> nur aufruft. Wenn das Timeout überschritten wird, die <xref:System.Net.Sockets.Socket.Send%2A> Methode löst eine <xref:System.Net.Sockets.SocketException>.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.SendTimeout%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der für einen set-Vorgang angegebene Wert ist kleiner als -1.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="SendTo">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet Daten an einen bestimmten Endpunkt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.EndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendTo (buffer As Byte(), remoteEP As EndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der das Ziel der Daten darstellt.</param>
        <summary>Sendet Daten an den angegebenen Endpunkt.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung ist der Puffer hat den Standardwert 0 (null) die Anzahl der zu sendenden Bytes entspricht der Größe des der `buffer` Parameter, und die <xref:System.Net.Sockets.SocketFlags> Wert hat den Standardwert 0.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` Parameter überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie sind außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegenden Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugeordnete lokale Adresse und den Port identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für die verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Verbindung herstellen, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In beiden Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur sendet Daten an die verbundene oder Standard-Remotehost.  
  
 Blockierende Sockets blockiert, bis alle Bytes im Puffer gesendet werden. Da ein nicht blockierenden <xref:System.Net.Sockets.Socket> abgeschlossen wird sofort beendet, es kann nicht senden aller Bytes im der `buffer`. Es liegt in Ihrer Anwendung Verantwortung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung aller Bytes im sendet die `buffer`. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil der ausgehenden Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus befindet, verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> wird blockiert, bis das Datagramm gesendet wurde. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Sie müssen auch darauf achten, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost.  
  
 [!code-cpp[Socket_Sync_Send_Receive#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#5)]
 [!code-csharp[Socket_Sync_Send_Receive#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#5)]
 [!code-vb[Socket_Sync_Send_Receive#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet Daten an einen bestimmten Endpunkt unter Verwendung der angegebenen <see cref="T:System.Net.Sockets.SocketFlags" />.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung ist der Puffer hat den Standardwert 0 und die Anzahl der zu sendenden Bytes entspricht der Größe des der `buffer`. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` Parameter überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie sind außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegenden Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugeordnete lokale Adresse und den Port identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für die verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Verbindung herstellen, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In beiden Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur sendet Daten an die verbundene oder Standard-Remotehost.  
  
 Blockierende Sockets blockieren, bis die angeforderte alle Bytes in den `buffer` gesendet werden. Da ein nicht blockierenden <xref:System.Net.Sockets.Socket> abgeschlossen wird sofort beendet, es kann nicht senden aller Bytes im der `buffer`. Es liegt in Ihrer Anwendung Verantwortung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung aller Bytes im sendet die `buffer`. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil ausgehende Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus befindet, verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> wird blockiert, bis das Datagramm gesendet wurde. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Sie müssen auch darauf achten, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. <xref:System.Net.Sockets.SocketFlags> zum Übergeben der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#6)]
 [!code-csharp[Socket_Sync_Send_Receive#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#6)]
 [!code-vb[Socket_Sync_Send_Receive#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung ist der Pufferoffset hat den Standardwert 0. Bei Angabe der <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` Parameter überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie sind außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegenden Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugeordnete lokale Adresse und den Port identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für die verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Verbindung herstellen, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In beiden Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur sendet Daten an die verbundene oder Standard-Remotehost.  
  
 Blockierende Sockets blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Da ein nicht blockierenden <xref:System.Net.Sockets.Socket> schließt sofort es möglicherweise nicht zu senden alle Bytes in einem einzigen Vorgang angefordert. Es ist Aufgabe der Anwendung, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil ausgehende Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus befindet, verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> wird blockiert, bis das Datagramm gesendet wurde. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Sie müssen auch darauf achten, dass die Anzahl der gesendeten Bytes nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. Die Größe und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#7)]
 [!code-csharp[Socket_Sync_Send_Receive#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#7)]
 [!code-vb[Socket_Sync_Send_Receive#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die angegebene <paramref name="size" /> ist größer als <paramref name="buffer" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendTo">
      <MemberSignature Language="C#" Value="public int SendTo (byte[] buffer, int offset, int size, System.Net.Sockets.SocketFlags socketFlags, System.Net.EndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 SendTo(unsigned int8[] buffer, int32 offset, int32 size, valuetype System.Net.Sockets.SocketFlags socketFlags, class System.Net.EndPoint remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int SendTo(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int size, System::Net::Sockets::SocketFlags socketFlags, System::Net::EndPoint ^ remoteEP);" />
      <MemberSignature Language="F#" Value="member this.SendTo : byte[] * int * int * System.Net.Sockets.SocketFlags * System.Net.EndPoint -&gt; int" Usage="socket.SendTo (buffer, offset, size, socketFlags, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="size" Type="System.Int32" />
        <Parameter Name="socketFlags" Type="System.Net.Sockets.SocketFlags" />
        <Parameter Name="remoteEP" Type="System.Net.EndPoint" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Array vom Typ <see cref="T:System.Byte" />, das die zu sendenden Daten enthält.</param>
        <param name="offset">Die Position im Datenpuffer, an der mit dem Senden von Daten begonnen werden soll.</param>
        <param name="size">Die Anzahl von Bytes, die gesendet werden sollen.</param>
        <param name="socketFlags">Eine bitweise Kombination der <see cref="T:System.Net.Sockets.SocketFlags" />-Werte.</param>
        <param name="remoteEP">Der <see cref="T:System.Net.EndPoint" />, der den Zielort der Daten darstellt.</param>
        <summary>Sendet die angegebene Anzahl von Datenbytes an den angegebenen Endpunkt und beginnt dabei an der angegebenen Position im Puffer, wobei die angegebenen <see cref="T:System.Net.Sockets.SocketFlags" /> verwendet werden.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In dieser Überladung, wenn Sie angeben, die <xref:System.Net.Sockets.SocketFlags.DontRoute> kennzeichnen als die `socketflags` -Parameter, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.Send%2A> Methode. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendTo%2A>, `remoteEP` Parameter überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie sind außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> -Methode, da der zugrunde liegenden Dienstanbieter die am besten geeigneten LAN-Adresse und Port zuweist. Wenn Sie die zugeordnete lokale Adresse und den Port identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> -Eigenschaft nach der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode erfolgreich ausgeführt wird.  
  
 Obwohl für die verbindungslose Protokolle vorgesehen <xref:System.Net.Sockets.Socket.SendTo%2A> funktioniert auch mit verbindungsorientierte Protokolle. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst eine Verbindung herstellen, durch Aufrufen der <xref:System.Net.Sockets.Socket.Connect%2A> Methode, oder übernehmen Sie eine eingehende Verbindung Anforderung mithilfe der <xref:System.Net.Sockets.Socket.Accept%2A> Methode. Wenn Sie keine herstellen oder eine Remotehostverbindung annehmen <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>. Sie können auch eine Standard-Remotehost für ein verbindungsloses Protokoll vor dem Aufruf Einrichten der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode. In beiden Fällen <xref:System.Net.Sockets.Socket.SendTo%2A> ignoriert die `remoteEP` Parameter und nur sendet Daten an die verbundene oder Standard-Remotehost.  
  
 Blockierende Sockets blockiert, bis die angeforderte Anzahl von Bytes gesendet werden. Da ein nicht blockierender <xref:System.Net.Sockets.Socket> schließt sofort es möglicherweise nicht zu senden alle Bytes in einem einzigen Vorgang angefordert. Es ist Ihre Aufgabe Anwendungen, um zu verfolgen die Anzahl der gesendeten Bytes und den Vorgang zu wiederholen, bis die Anwendung die angeforderte Anzahl von Bytes gesendet. Es gibt auch keine Garantie dafür, die die Daten, die Sie senden unmittelbar im Netzwerk angezeigt werden. Um die Netzwerkeffizienz zu steigern, möglicherweise des zugrunde liegenden Systems Übertragung verzögern, bis ein erheblicher Teil ausgehende Daten gesammelt werden. Einen erfolgreichen Abschluss der <xref:System.Net.Sockets.Socket.SendTo%2A> Methode bedeutet, dass das zugrunde liegende System Platz, um Puffer wurden Ihre Daten für ein Netzwerk senden.  
  
 Wenn Sie ein verbindungsloses Protokoll im blockierenden Modus befindet, verwenden <xref:System.Net.Sockets.Socket.SendTo%2A> wird blockiert, bis das Datagramm gesendet wurde. Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>. Sie müssen auch darauf achten, dass die Größe nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.SendTo%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel sendet ein verbindungsloses Datagramm mit dem angegebenen Remotehost. Der Offset, Größe und <xref:System.Net.Sockets.SocketFlags> übergeben werden, um die <xref:System.Net.Sockets.Socket.SendTo%2A> Methode.  
  
 [!code-cpp[Socket_Sync_Send_Receive#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CPP/source.cpp#8)]
 [!code-csharp[Socket_Sync_Send_Receive#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Sync_Send_Receive/CS/source.cs#8)]
 [!code-vb[Socket_Sync_Send_Receive#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Sync_Send_Receive/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="buffer" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="remoteEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="offset" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="offset" /> ist größer als die Länge von <paramref name="buffer" />.  
  
- oder -  
 <paramref name="size" /> ist kleiner als 0.  
  
- oder -  
 <paramref name="size" /> ist größer als die Länge von <paramref name="buffer" /> minus dem Wert des <paramref name="offset" />-Parameters.</exception>
        <exception cref="T:System.Net.Sockets.SocketException"><paramref name="socketFlags" /> ist keine gültige Kombination von Werten.  
  
- oder -  
Beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" /> tritt ein Betriebssystemfehler auf.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Security.SecurityException">Ein Aufrufer in der Aufrufliste verfügt nicht über die erforderlichen Berechtigungen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Connect(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.Send(System.Byte[],System.Int32,System.Net.Sockets.SocketFlags)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendTo(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
        <altmember cref="P:System.Net.Sockets.Socket.LocalEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="SendToAsync">
      <MemberSignature Language="C#" Value="public bool SendToAsync (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool SendToAsync(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendToAsync (e As SocketAsyncEventArgs) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool SendToAsync(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="member this.SendToAsync : System.Net.Sockets.SocketAsyncEventArgs -&gt; bool" Usage="socket.SendToAsync e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e">Das <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt, das für diesen asynchronen Socketvorgang verwendet werden soll.</param>
        <summary>Sendet asynchron Daten an einen angegebenen Remotehost.</summary>
        <returns><see langword="true" />, wenn der E/A-Vorgang aussteht. Das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter wird nach dem Abschluss des Vorgangs ausgelöst.  
  
 <see langword="false" />, wenn der E/A-Vorgang synchron abgeschlossen wurde. In diesem Fall wird das <see cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />-Ereignis für den <paramref name="e" />-Parameter nicht ausgelöst, und das als Parameter übergebene <paramref name="e" />-Objekt kann direkt nach der Rückgabe des Methodenaufrufs untersucht werden, um die Ergebnisse des Vorgangs abzurufen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode startet einen asynchronen Sendevorgang an den Remotehost, angegeben der <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft der `e` Parameter. Aufrufen der <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode bietet Ihnen die Möglichkeit, Daten in einem separaten Ausführungsthread zu senden. Obwohl diese Methode für verbindungslose Protokolle dient <xref:System.Net.Sockets.Socket.SendToAsync%2A> arbeitet mit Verbindungs- und verbindungsorientierte Protokolle.  
  
 Zum Abschluss benachrichtigt werden, müssen Sie eine Rückrufmethode, die den EventHandler implementiert erstellen\<SocketAsyncEventArgs >-Delegaten, und fügen Sie den Rückruf, der die <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis.  
  
 Die folgenden Eigenschaften und Ereignisse auf die <xref:System.Net.Sockets.SocketAsyncEventArgs?displayProperty=nameWithType> Objekt sind erforderlich, um diese Methode erfolgreich aufzurufen:  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType>  
  
-   <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType>  
  
 Der Aufrufer kann festlegen, die <xref:System.Net.Sockets.SocketAsyncEventArgs.UserToken%2A?displayProperty=nameWithType> Eigenschaft, um ein Benutzerobjekt-Zustand gewünscht vor dem Aufruf der <xref:System.Net.Sockets.Socket.SendToAsync%2A> -Methode, damit die Informationen in der Rückrufmethode aufgerufen werden können. Wenn der Rückruf mehr Informationen als ein einzelnes Objekt benötigt, kann eine kleine Klasse erstellt werden, um die anderen erforderlichen Zustandsinformationen als Mitglieder enthalten.  
  
 Wenn Sie ein verbindungsorientiertes Protokoll verwenden, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode. Andernfalls <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>. Bei Verwendung einer verbindungsorientiertes Protokoll, die <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode ignoriert die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> -Eigenschaft und sendet Daten an die <xref:System.Net.EndPoint?displayProperty=nameWithType> hergestellt, der <xref:System.Net.Sockets.Socket.Accept%2A>, <xref:System.Net.Sockets.Socket.AcceptAsync%2A>, <xref:System.Net.Sockets.Socket.BeginAccept%2A>, <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A> , oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> Methode.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, müssen Sie nicht mit einem Standard-Remotehost herstellen die <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendToAsync%2A>. Müssen Sie nur dazu, wenn Sie beabsichtigen, rufen Sie die <xref:System.Net.Sockets.Socket.BeginSend%2A> oder <xref:System.Net.Sockets.Socket.SendAsync%2A> Methoden. Wenn Sie Aufrufen der <xref:System.Net.Sockets.Socket.BeginConnect%2A>, <xref:System.Net.Sockets.Socket.Connect%2A>, oder <xref:System.Net.Sockets.Socket.ConnectAsync%2A> aufrufen, bevor <xref:System.Net.Sockets.Socket.SendToAsync%2A>, <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A?displayProperty=nameWithType> Eigenschaft überschreibt die angegebene Standard-Remotehost, die nur für Sendevorgang. Sie werden außerdem nicht Aufruf erforderlich die <xref:System.Net.Sockets.Socket.Bind%2A> Methode. In diesem Fall weist der zugrunde liegenden Dienstanbieter am besten geeigneten lokalen Netzwerk IP-Adresse und den Port an. Verwenden Sie die Portnummer 0 (null), wenn Sie den zugrunde liegenden Dienstanbieter, um einen Free-Port auswählen möchten. Wenn Sie zugeordneten lokalen Netzwerk IP-Adresse und den Port an identifizieren möchten, können Sie mithilfe der <xref:System.Net.Sockets.Socket.LocalEndPoint%2A> Eigenschaft nach der <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed?displayProperty=nameWithType> Ereignis wird signalisiert, und die entsprechenden Delegaten aufgerufen werden.  
  
 Wenn Sie Daten an eine Broadcastadresse senden möchten, müssen Sie zuerst Aufrufen der <xref:System.Net.Sockets.Socket.SetSocketOption%2A> Methode, und legen den Socket option <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> auf "true". Sie müssen auch darauf achten, dass die Größe des Puffers nicht die maximale Paketgröße des zugrunde liegenden Dienstanbieters überschreitet. Wenn dies der Fall ist, das Datagramm wird nicht gesendet und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>.  
  
 Wenn Sie das Flag DontRoute im Angeben der <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A?displayProperty=nameWithType> -Eigenschaft, die Daten, die Sie senden werden nicht weitergeleitet werden.  
  
 Für die Message-ausgerichteten Sockets muss darauf geachtet werden, nicht zu überschreiten die maximale Größe des zugrunde liegenden Transports. Überschreitet die Größe des Puffers auf die maximale Paketgröße des zugrunde liegenden Service Providers, wird nicht das Datagramm gesendet und <xref:System.Net.Sockets.Socket.SendToAsync%2A> löst eine <xref:System.Net.Sockets.SocketException>. Vom erfolgreichen Abschluss einer <xref:System.Net.Sockets.Socket.SendToAsync%2A> Methode ist nicht, dass die Daten erfolgreich übermittelt wurde.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> darf nicht NULL sein.</exception>
        <exception cref="T:System.InvalidOperationException">Es wird bereits ein Socketvorgang mit dem im <paramref name="e" />-Parameter angegebenen <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Objekt ausgeführt.</exception>
        <exception cref="T:System.NotSupportedException">Für diese Methode ist Windows XP oder höher erforderlich.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Das angegebene Protokoll ist verbindungsorientiert, aber der <see cref="T:System.Net.Sockets.Socket" /> wurde noch nicht verbunden.</exception>
        <altmember cref="T:System.Net.Sockets.SocketAsyncEventArgs" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      </Docs>
    </Member>
    <Member MemberName="SetIPProtectionLevel">
      <MemberSignature Language="C#" Value="public void SetIPProtectionLevel (System.Net.Sockets.IPProtectionLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetIPProtectionLevel(valuetype System.Net.Sockets.IPProtectionLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetIPProtectionLevel (level As IPProtectionLevel)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetIPProtectionLevel(System::Net::Sockets::IPProtectionLevel level);" />
      <MemberSignature Language="F#" Value="member this.SetIPProtectionLevel : System.Net.Sockets.IPProtectionLevel -&gt; unit" Usage="socket.SetIPProtectionLevel level" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="level" Type="System.Net.Sockets.IPProtectionLevel" />
      </Parameters>
      <Docs>
        <param name="level">Die für diesen Socket festzulegende IP-Schutzebene.</param>
        <summary>Legt die IP-Schutzebene für einen Socket fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Methode ermöglicht die Einschränkung ein ein IPv6- oder die IP-Socket, auf einen angegebenen Bereich, zu überwachen, wie z. B. Adressen mit demselben linklokalen oder standortlokalen Präfix. Diese Socketoption kann Anwendungen zugriffseinschränkungen für IPv6- oder die IP-Sockets zu platzieren. Mit solchen Einschränkungen kann sich eine im privaten LAN ausgeführte Anwendung selbst einfach und stabil vor externen Angriffen schützen. Diese Socketoption kann auch verwendet werden, um zugriffsbeschränkungen bei Entfernen der `level` Parametersatz zu <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Diese Socketoption erweitert oder beschränkt den Bereich eines empfangsbereiten Sockets und ermöglicht so bei Bedarf den uneingeschränkten Zugriff von öffentlichen und privaten Benutzern oder beschränkt den Zugriff nur auf denselben Standort.  
  
 Für diese Socketoption sind in der <xref:System.Net.Sockets.IPProtectionLevel>-Enumeration angegebene Schutzebenen definiert.  
  
 Die <xref:System.Net.Sockets.Socket.SetIPProtectionLevel%2A> Methode dient zum Aktivieren oder Deaktivieren von Network Address Traversal (NAT) für eine <xref:System.Net.Sockets.Socket> Instanz. NAT-Durchlauf kann mit Teredo, 6to4 oder einen ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn die `level` Parametersatz zu <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, oder <xref:System.Net.Sockets.IPProtectionLevel.Restricted>, dies explizit deaktiviert die NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> Instanz.  
  
 Wenn die `level` Parameter auf festgelegt ist <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>, kann dadurch die NAT-Durchlauf für eine <xref:System.Net.Sockets.Socket> abhängig von Firewallregeln auf dem System.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">Der <paramref name="level" />-Parameter darf nicht <see cref="F:System.Net.Sockets.IPProtectionLevel.Unspecified" /> sein. Die IP-Schutzebene kann nicht auf nicht angegeben festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Die <see cref="T:System.Net.Sockets.AddressFamily" /> des Sockets muss <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> sein.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSocketOption">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt eine <see cref="T:System.Net.Sockets.Socket" />-Option fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, bool optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, bool optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * bool -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Der als <see cref="T:System.Boolean" />-Wert dargestellte Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen <see cref="T:System.Boolean" />-Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Legen Sie `optionValue` zu `true` auf die Option zu aktivieren oder `false` zum Deaktivieren der Option.  
  
 <xref:System.Net.Sockets.Socket> Optionen sind nach Maß an Unterstützung des Protokolls gruppiert.  
  
 Nachfolgend sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen, die mit dieser Überladung festgelegt werden können. Die Optionen sind vom entsprechenden gruppiert <xref:System.Net.Sockets.SocketOptionLevel> Wert. Wenn Sie beabsichtigen, eine der folgenden Optionen festlegen, werden Sie sicher, dass Sie den richtigen <xref:System.Net.Sockets.SocketOptionLevel> Wert für die `optionLevel` Parameter. Die Möglichkeit, Sie legen auch, muss angegeben werden, der `optionName` Parameter. Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.AcceptConnection>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName> Enumeration.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> Ausnahme verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein Socket geöffnet und ermöglicht die `DontLinger` und `OutOfBandInline` Socketoptionen.  
  
 [!code-cpp[NCLSocketEnhancements#5](~/samples/snippets/cpp/VS_Snippets_Remoting/NCLSocketEnhancements/CPP/nclsocketenhancements.cpp#5)]
 [!code-csharp[NCLSocketEnhancements#5](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLSocketEnhancements/CS/nclsocketenhancements.cs#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Das <see cref="T:System.Net.Sockets.Socket" />-Objekt wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, byte[] optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, unsigned int8[] optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, cli::array &lt;System::Byte&gt; ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * byte[] -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Array vom Typ <see cref="T:System.Byte" />, das den Wert der Option darstellt.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Bytearray dargestellten Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Mit dieser Überladung können Sie die festgelegt <xref:System.Net.Sockets.Socket> Optionen, die ein Bytearray als Optionswert erfordern.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, int32 optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, int optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * int -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Ein Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen ganzzahligen Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Für eine Option mit einem <xref:System.Boolean> -Datentyp, geben Sie einen Wert ungleich NULL, um die Option zu aktivieren und einen Nullwert auf die Option zu deaktivieren. Geben Sie für eine Option mit einem Integer-Datentyp den entsprechenden Wert ein. <xref:System.Net.Sockets.Socket> Optionen sind nach Maß an Unterstützung des Protokolls gruppiert.  
  
 Nachfolgend sind die verschiedenen <xref:System.Net.Sockets.Socket> Optionen, die mit dieser Überladung festgelegt werden können. Die Optionen sind vom entsprechenden gruppiert <xref:System.Net.Sockets.SocketOptionLevel>. Wenn Sie beabsichtigen, eine der folgenden Optionen festlegen, werden Sie sicher, dass Sie den richtigen <xref:System.Net.Sockets.SocketOptionLevel> für die `optionLevel` Parameter. Die Möglichkeit, Sie legen auch, muss angegeben werden, der `optionName` Parameter. Wenn Sie den aktuellen Wert eines der aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Socket?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.Broadcast>  
  
-   <xref:System.Net.Sockets.SocketOptionName.DontLinger>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Debug>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Error>  
  
-   <xref:System.Net.Sockets.SocketOptionName.KeepAlive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.OutOfBandInline>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReceiveTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.ReuseAddress>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendBuffer>  
  
-   <xref:System.Net.Sockets.SocketOptionName.SendTimeout>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Type>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IP?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HeaderIncluded>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IPOptions>  
  
-   <xref:System.Net.Sockets.SocketOptionName.IpTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastInterface>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastLoopback>  
  
-   <xref:System.Net.Sockets.SocketOptionName.MulticastTimeToLive>  
  
-   <xref:System.Net.Sockets.SocketOptionName.TypeOfService>  
  
-   <xref:System.Net.Sockets.SocketOptionName.UseLoopback>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Tcp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.BsdUrgent>  
  
-   <xref:System.Net.Sockets.SocketOptionName.Expedited>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoDelay>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.Udp?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.ChecksumCoverage>  
  
-   <xref:System.Net.Sockets.SocketOptionName.NoChecksum>  
  
 <xref:System.Net.Sockets.SocketOptionLevel.IPv6?displayProperty=nameWithType> Optionen, die mit dieser Überladung festgelegt werden können.  
  
-   <xref:System.Net.Sockets.SocketOptionName.HopLimit>  
  
 Weitere Informationen zu diesen Optionen finden Sie in der <xref:System.Net.Sockets.SocketOptionName> Enumeration.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="SetSocketOption">
      <MemberSignature Language="C#" Value="public void SetSocketOption (System.Net.Sockets.SocketOptionLevel optionLevel, System.Net.Sockets.SocketOptionName optionName, object optionValue);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSocketOption(valuetype System.Net.Sockets.SocketOptionLevel optionLevel, valuetype System.Net.Sockets.SocketOptionName optionName, object optionValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.SetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSocketOption (optionLevel As SocketOptionLevel, optionName As SocketOptionName, optionValue As Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSocketOption(System::Net::Sockets::SocketOptionLevel optionLevel, System::Net::Sockets::SocketOptionName optionName, System::Object ^ optionValue);" />
      <MemberSignature Language="F#" Value="member this.SetSocketOption : System.Net.Sockets.SocketOptionLevel * System.Net.Sockets.SocketOptionName * obj -&gt; unit" Usage="socket.SetSocketOption (optionLevel, optionName, optionValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="optionLevel" Type="System.Net.Sockets.SocketOptionLevel" />
        <Parameter Name="optionName" Type="System.Net.Sockets.SocketOptionName" />
        <Parameter Name="optionValue" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="optionLevel">Einer der <see cref="T:System.Net.Sockets.SocketOptionLevel" />-Werte.</param>
        <param name="optionName">Einer der <see cref="T:System.Net.Sockets.SocketOptionName" />-Werte.</param>
        <param name="optionValue">Eine <see cref="T:System.Net.Sockets.LingerOption" /> oder <see cref="T:System.Net.Sockets.MulticastOption" /> mit dem Wert der Option.</param>
        <summary>Legt die angegebene <see cref="T:System.Net.Sockets.Socket" />-Option auf den angegebenen, als Objekt dargestellten Wert fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket> Optionen bestimmen das Verhalten des aktuellen <xref:System.Net.Sockets.Socket>. Mit dieser Überladung können Sie legen die <xref:System.Net.Sockets.SocketOptionName.Linger>, <xref:System.Net.Sockets.SocketOptionName.AddMembership>, und <xref:System.Net.Sockets.SocketOptionName.DropMembership> <xref:System.Net.Sockets.Socket> Optionen. Für die <xref:System.Net.Sockets.SocketOptionName.Linger> option können Sie <xref:System.Net.Sockets.Socket> für die `optionLevel` Parameter. Für <xref:System.Net.Sockets.SocketOptionName.AddMembership> und <xref:System.Net.Sockets.SocketOptionName.DropMembership>, verwenden Sie <xref:System.Net.Sockets.SocketOptionLevel.IP>. Wenn Sie den aktuellen Wert eines der oben aufgeführten Optionen abzurufen, verwenden Sie möchten die <xref:System.Net.Sockets.Socket.GetSocketOption%2A> Methode.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.LingerOption> und <xref:System.Net.Sockets.Socket.Send%2A> Timeoutwerte.  
  
 [!code-cpp[Socket_Socket_Options#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#1)]
 [!code-csharp[Socket_Socket_Options#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#1)]
 [!code-vb[Socket_Socket_Options#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="optionValue" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.SocketOptionName" />
        <altmember cref="T:System.Net.Sockets.SocketOptionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.GetSocketOption(System.Net.Sockets.SocketOptionLevel,System.Net.Sockets.SocketOptionName)" />
      </Docs>
    </Member>
    <Member MemberName="Shutdown">
      <MemberSignature Language="C#" Value="public void Shutdown (System.Net.Sockets.SocketShutdown how);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Shutdown(valuetype System.Net.Sockets.SocketShutdown how) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.Shutdown(System.Net.Sockets.SocketShutdown)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Shutdown (how As SocketShutdown)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Shutdown(System::Net::Sockets::SocketShutdown how);" />
      <MemberSignature Language="F#" Value="member this.Shutdown : System.Net.Sockets.SocketShutdown -&gt; unit" Usage="socket.Shutdown how" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="how" Type="System.Net.Sockets.SocketShutdown" />
      </Parameters>
      <Docs>
        <param name="how">Einer der <see cref="T:System.Net.Sockets.SocketShutdown" />-Werte, der den Vorgang angibt, der nicht mehr zulässig ist.</param>
        <summary>Deaktiviert Senden und Empfangen für einen <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei Verwendung einer verbindungsorientierten <xref:System.Net.Sockets.Socket>, rufen Sie immer die <xref:System.Net.Sockets.Socket.Shutdown%2A> Methode vor dem Schließen der <xref:System.Net.Sockets.Socket>. Dadurch wird sichergestellt, dass alle Daten gesendet und auf dem verbundenen Socket empfangen wird, bevor diese geschlossen wird.  
  
 Rufen Sie die <xref:System.Net.Sockets.Socket.Close%2A> -Methode zum Freigeben von allen verwalteten und nicht verwalteten Ressourcen, die zugeordneten der <xref:System.Net.Sockets.Socket>. Versuchen Sie nicht, Wiederverwenden der <xref:System.Net.Sockets.Socket> nach dem Schließen.  
  
 Die folgende Tabelle zeigt die <xref:System.Net.Sockets.SocketShutdown> Enumerationswerte, der für gültig sind die `how` Parameter.  
  
|Wert|Beschreibung |  
|-----------|-----------------|  
|Senden|Deaktiviert das Senden auf diesem <xref:System.Net.Sockets.Socket>.|  
|Empfangen|Deaktiviert das Empfangen auf diesem <xref:System.Net.Sockets.Socket>.|  
|Beides|Deaktiviert das Senden und empfangen auf diese <xref:System.Net.Sockets.Socket>.|  
  
 Festlegen von `how` zu <xref:System.Net.Sockets.SocketShutdown.Send> gibt an, dass bei nachfolgenden Aufrufen von <xref:System.Net.Sockets.Socket.Send%2A> sind nicht zulässig. Wenn Sie einem verbindungslosen <xref:System.Net.Sockets.Socket>Angabe <xref:System.Net.Sockets.SocketShutdown.Send> hat keine Auswirkungen.  
  
 Festlegen von `how` zu <xref:System.Net.Sockets.SocketShutdown.Receive> gibt an, dass bei nachfolgenden Aufrufen von <xref:System.Net.Sockets.Socket.Receive%2A> sind nicht zulässig. Dies hat keine Auswirkungen auf niedrigeren Protokollebenen. Wenn Sie ein verbindungsorientiertes Protokoll verwenden, wird die Verbindung beendet, wenn eine der folgenden Bedingungen, nach einem Aufruf von vorhanden <xref:System.Net.Sockets.Socket.Shutdown%2A> :  
  
-   Daten sind in der eingehenden Netzwerkpuffer, deren Empfang aussteht.  
  
-   Weitere Daten sind eingetroffen.  
  
 Wenn Sie ein verbindungsloses Protokoll verwenden, sind Datagramme akzeptiert und in die Warteschlange eingereiht. Wenn kein Pufferspeicher für zusätzliche eingehende Datagramme verfügbar ist, werden sie verworfen und kein Fehler wird an den Absender zurückgegeben werden. Mithilfe von <xref:System.Net.Sockets.Socket.Shutdown%2A> auf ein verbindungsloser <xref:System.Net.Sockets.Socket> wird nicht empfohlen.  
  
 Festlegen von `how` zu <xref:System.Net.Sockets.SocketShutdown.Both> deaktiviert sowohl senden und empfangen, wie oben beschrieben.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException> beim Aufrufen der <xref:System.Net.Sockets.Socket.Shutdown%2A> -Methode, mit der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel verwendet <xref:System.Net.Sockets.Socket.Shutdown%2A> So deaktivieren Sie die <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[Classic Socket.Close Example#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic Socket.Close Example/CPP/source.cpp#1)]
 [!code-csharp[Classic Socket.Close Example#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic Socket.Close Example/CS/source.cs#1)]
 [!code-vb[Classic Socket.Close Example#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic Socket.Close Example/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
        <altmember cref="T:System.Net.Sockets.SocketShutdown" />
      </Docs>
    </Member>
    <Member MemberName="SocketType">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketType SocketType { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketType SocketType" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SocketType" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property SocketType As SocketType" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketType SocketType { System::Net::Sockets::SocketType get(); };" />
      <MemberSignature Language="F#" Value="member this.SocketType : System.Net.Sockets.SocketType" Usage="System.Net.Sockets.Socket.SocketType" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketType</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Typ des <see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Einer der <see cref="T:System.Net.Sockets.SocketType" />-Werte.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.Socket.SocketType%2A> ist schreibgeschützt und wird festgelegt, wenn die <xref:System.Net.Sockets.Socket> erstellt wird.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.AddressFamily>, <xref:System.Net.Sockets.SocketType>, und <xref:System.Net.Sockets.ProtocolType> an die Konsole.  
  
 [!code-cpp[Socket_Socket_Options#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Socket_Socket_Options/CPP/source.cpp#3)]
 [!code-csharp[Socket_Socket_Options#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Socket_Socket_Options/CS/source.cs#3)]
 [!code-vb[Socket_Socket_Options#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Socket_Socket_Options/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SocketType" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv4">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv4 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv4" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv4 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv4 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv4 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv4" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv4 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv4 is obsoleted for this type, please use OSSupportsIPv4 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob IPv4-Unterstützung verfügbar und auf dem aktuellen Host aktiviert ist.</summary>
        <value><see langword="true" />, wenn der aktuelle Host das Protokoll IPv4 unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6-Protokolle unterstützen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv6" />
      </Docs>
    </Member>
    <Member MemberName="SupportsIPv6">
      <MemberSignature Language="C#" Value="public static bool SupportsIPv6 { get; }" />
      <MemberSignature Language="ILAsm" Value=".property bool SupportsIPv6" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property SupportsIPv6 As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property bool SupportsIPv6 { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.SupportsIPv6 : bool" Usage="System.Net.Sockets.Socket.SupportsIPv6" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use OSSupportsIPv6 instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-2.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.Obsolete("SupportsIPv6 is obsoleted for this type, please use OSSupportsIPv6 instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Member unterstützt.</summary>
        <value><see langword="true" />, wenn das Framework IPv6 für bestimmte veraltete <see cref="T:System.Net.Dns" />-Methoden unterstützt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Betriebssystem kann sowohl IPv4 als auch IPv6-Protokolle unterstützen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.Socket.OSSupportsIPv6" />
        <altmember cref="P:System.Net.Sockets.Socket.SupportsIPv4" />
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.Socket.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom <see cref="T:System.Net.Sockets.Socket" /> verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wenn Sie fertig sind, rufen Sie IDisposable.Dispose mithilfe der <xref:System.Net.Sockets.Socket>. Die IDisposable.Dispose-Methode lässt den <xref:System.Net.Sockets.Socket> in einem nicht verwendbaren Zustand. Nach dem rufen Sie IDisposable.Dispose auf, müssen Sie alle Verweise auf Freigeben der <xref:System.Net.Sockets.Socket> , damit der Garbage Collector den Arbeitsspeicher freigeben kann, die die <xref:System.Net.Sockets.Socket> belegt wurde. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer Dispose-Methode](~/docs/standard/garbage-collection/implementing-dispose.md).

> [!NOTE] 
> Rufen Sie IDisposable.Dispose immer, bevor Sie den letzten Verweis auf Freigeben der <xref:System.Net.Sockets.Socket>. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.Socket>-Methode des `Finalize`-Objekts aufruft.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.Socket.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Gültigkeitsdauer (TTL) von IP (Internet Protocol)-Paketen angibt, die vom <see cref="T:System.Net.Sockets.Socket" /> gesendet werden.</summary>
        <value>Der TTL-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der TTL-Wert gibt die maximale Anzahl der Router das Paket weitergeleitet werden kann, bevor der Router das Paket eine Message-Protokoll ICMP (Internet Control) "Gültigkeitsdauer (TTL) wurde überschritten" verwirft und Fehlermeldung an den Absender zurückgegeben.  
  
 Der TTL-Wert kann auf einen Wert von 0 bis 255 festgelegt werden. Wenn diese Eigenschaft nicht festgelegt ist, ist der Standardwert der Gültigkeitsdauer (TTL) für einen Socket 32.  
  
 Durch Festlegen dieser Eigenschaft auf einen Socket (TCP, Transmission Control Protocol) wird vom TCP/IP-Stapel ignoriert, wenn eine erfolgreiche Verbindung mit dem Socket eingerichtet wurde.  
  
 Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, in der Windows-Sockets, Version 2 Dokumentation zu API-Fehlercodes in der MSDN Library finden Sie eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.Socket.Ttl%2A>-Attributs veranschaulicht.  
  
 [!code-cpp[SocketPropertyTester#1](~/samples/snippets/cpp/VS_Snippets_Remoting/SocketPropertyTester/CPP/class1.cpp#1)]
 [!code-csharp[SocketPropertyTester#1](~/samples/snippets/csharp/VS_Snippets_Remoting/SocketPropertyTester/CS/class1.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Für den TTL-Wert kann keine negative Zahl festgelegt werden.</exception>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann nur für Sockets in der <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Familie oder der <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Familie festgelegt werden.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Versuch, auf den Socket zuzugreifen. Dieser Fehler wird auch zurückgegeben, wenn versucht wird, TTL auf einen höheren Wert als 255 festzulegen.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="UseOnlyOverlappedIO">
      <MemberSignature Language="C#" Value="public bool UseOnlyOverlappedIO { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool UseOnlyOverlappedIO" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberSignature Language="VB.NET" Value="Public Property UseOnlyOverlappedIO As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool UseOnlyOverlappedIO { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.UseOnlyOverlappedIO : bool with get, set" Usage="System.Net.Sockets.Socket.UseOnlyOverlappedIO" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("This doesn't do anything on Mono yet")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Socket nur den Modus für überlappende E/A-Vorgänge verwenden soll.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.Socket" /> nur überlappende E/A-Vorgänge verwendet, andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Legen Sie diese Eigenschaft auf `true` für eine <xref:System.Net.Sockets.Socket> Sie aufrufen möchten <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>. Ordnen Sie andernfalls das Framework kann ein Abschlussport an den Socket, der die Verwendung von verhindern würde <xref:System.Net.Sockets.Socket.DuplicateAndClose%2A>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Socket wurde an einen Abschlussanschluss gebunden.</exception>
      </Docs>
    </Member>
  </Members>
</Type>