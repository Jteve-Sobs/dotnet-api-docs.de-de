<Type Name="SendPacketsElement" FullName="System.Net.Sockets.SendPacketsElement">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="d6fe18013c2c07899d2e113d0089b9e64b18af7f" />
    <Meta Name="ms.sourcegitcommit" Value="434f60616a9793fa8436744549fc856e94f7a648" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="08/25/2018" />
    <Meta Name="ms.locfileid" Value="39753300" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class SendPacketsElement" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SendPacketsElement extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.SendPacketsElement" />
  <TypeSignature Language="VB.NET" Value="Public Class SendPacketsElement" />
  <TypeSignature Language="C++ CLI" Value="public ref class SendPacketsElement" />
  <TypeSignature Language="F#" Value="type SendPacketsElement = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Stellt ein Element in einem <see cref="T:System.Net.Sockets.SendPacketsElement" />-Array dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement> Klasse wird zum Verbessern der <xref:System.Net.Sockets.Socket> Klasse für die Verwendung von serveranwendungen, die asynchrone Netzwerk-e/a zu verwenden, um die höchste Leistung zu erzielen. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
    </remarks>
    <threadsafe>Instanzen dieser Klasse sind threadsicher.</threadsafe>
    <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (byte[] buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(cli::array &lt;System::Byte&gt; ^ buffer);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : byte[] -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement buffer" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray, das Daten enthält, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode gesendet werden sollen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung des angegebenen Puffers.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.Byte%5B%5D%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Datenklasse mit einem Bytearray. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter darf nicht NULL sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (string filepath);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filepath) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filepath As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(System::String ^ filepath);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : string -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement filepath" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="filepath" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="filepath">Der Dateiname der Datei, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode übertragen werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung der angegebenen Datei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.String%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Klasse mit einem Dateinamen einer Datei. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 Universal Naming Convention (UNC)-Pfade werden unterstützt, durch die `filepath` Parameter. Wenn die Datei in das aktuelle Arbeitsverzeichnis ist, muss keine Pfadinformationen angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filepath" />-Parameter darf nicht NULL sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : byte[] * int * int -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement (buffer, offset, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray, das Daten enthält, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode gesendet werden sollen.</param>
        <param name="offset">Der Offset in Bytes vom Anfang von <c>buffer</c> zur Position in <c>buffer</c> zum Beginnen des Sendevorgangs für die im <c>buffer</c>-Parameter angegebenen Daten.</param>
        <param name="count">Die Anzahl der zu sendenden Bytes, beginnend beim <c>offset</c>-Parameter. Wenn <c>count</c> 0 (null) ist, werden keine Bytes gesendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung des angegebenen Puffers, Pufferoffsets und der angegebenen Anzahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Datenklasse mit einem Bytearray. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter und der <paramref name="count" />-Parameter müssen größer oder gleich 0 (null) sein.  
  
<paramref name="offset" /> und <paramref name="count" /> müssen kleiner als die Größe des Puffers sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="T:System.ArgumentOutOfRangeException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (string filepath, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filepath, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filepath As String, offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(System::String ^ filepath, int offset, int count);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : string * int * int -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement (filepath, offset, count)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="filepath" Type="System.String" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="filepath">Der Dateiname der Datei, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode übertragen werden soll.</param>
        <param name="offset">Der Offset in Bytes vom Anfang der Datei zur Position in der Datei zum Beginnen des Sendevorgangs für die im <c>filepath</c>-Parameter angegebene Datei.</param>
        <param name="count">Die Anzahl der zu sendenden Bytes, beginnend beim <c>offset</c>-Parameter. Wenn <c>count</c> 0 (null) ist, wird die ganze Datei gesendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung des angegebenen Dateipfads, Offsets und der angegebenen Anzahl.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Klasse mit einem Dateinamen einer Datei. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 Universal Naming Convention (UNC)-Pfade werden unterstützt, durch die `filepath` Parameter. Wenn die Datei in das aktuelle Arbeitsverzeichnis ist, muss keine Pfadinformationen angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filepath" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter und der <paramref name="count" />-Parameter müssen größer oder gleich 0 (null) sein.  
  
<paramref name="offset" /> und <paramref name="count" /> müssen kleiner als die Größe der vom <paramref name="filepath" />-Parameter angegebenen Datei sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="T:System.ArgumentOutOfRangeException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (byte[] buffer, int offset, int count, bool endOfPacket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] buffer, int32 offset, int32 count, bool endOfPacket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.Byte[],System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (buffer As Byte(), offset As Integer, count As Integer, endOfPacket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count, bool endOfPacket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : byte[] * int * int * bool -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement (buffer, offset, count, endOfPacket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="endOfPacket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="buffer">Ein Bytearray, das Daten enthält, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode gesendet werden sollen.</param>
        <param name="offset">Der Offset in Bytes vom Anfang von <c>buffer</c> zur Position in <c>buffer</c> zum Beginnen des Sendevorgangs für die im <c>buffer</c>-Parameter angegebenen Daten.</param>
        <param name="count">Die Anzahl der zu sendenden Bytes, beginnend beim <c>offset</c>-Parameter. Wenn <c>count</c> 0 (null) ist, werden keine Bytes gesendet.</param>
        <param name="endOfPacket">Ein boolescher Wert, der angibt, dass dieses Element nicht mit dem nächsten Element in einer Sendeanforderung von der Socketsebene zum Transport kombiniert werden soll. Dieses Flag wird zum genaueren Steuern des Inhalts der einzelnen Nachrichten bei einem datagramm- oder nachrichtenorientierten Socket verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung des angegebenen Puffers, Pufferoffsets und der angegebenen Anzahl mit der Option zum Kombinieren dieses Elements mit dem nächsten Element in einer Sendeanforderung von der Socketsebene zum Transport.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Datenklasse mit einem Bytearray. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="buffer" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter und der <paramref name="count" />-Parameter müssen größer oder gleich 0 (null) sein.  
  
<paramref name="offset" /> und <paramref name="count" /> müssen kleiner als die Größe des Puffers sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="T:System.ArgumentOutOfRangeException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SendPacketsElement (string filepath, int offset, int count, bool endOfPacket);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string filepath, int32 offset, int32 count, bool endOfPacket) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SendPacketsElement.#ctor(System.String,System.Int32,System.Int32,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (filepath As String, offset As Integer, count As Integer, endOfPacket As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SendPacketsElement(System::String ^ filepath, int offset, int count, bool endOfPacket);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.SendPacketsElement : string * int * int * bool -&gt; System.Net.Sockets.SendPacketsElement" Usage="new System.Net.Sockets.SendPacketsElement (filepath, offset, count, endOfPacket)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="filepath" Type="System.String" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
        <Parameter Name="endOfPacket" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="filepath">Der Dateiname der Datei, die mit der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode übertragen werden soll.</param>
        <param name="offset">Der Offset in Bytes vom Anfang der Datei zur Position in der Datei zum Beginnen des Sendevorgangs für die im <c>filepath</c>-Parameter angegebene Datei.</param>
        <param name="count">Die Anzahl der zu sendenden Bytes, beginnend beim <c>offset</c>-Parameter. Wenn <c>count</c> 0 (null) ist, wird die ganze Datei gesendet.</param>
        <param name="endOfPacket">Ein boolescher Wert, der angibt, dass dieses Element nicht mit dem nächsten Element in einer Sendeanforderung von der Socketsebene zum Transport kombiniert werden soll. Dieses Flag wird zum genaueren Steuern des Inhalts der einzelnen Nachrichten bei einem datagramm- oder nachrichtenorientierten Socket verwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse unter Verwendung des angegebenen Dateipfads, Pufferoffsets und der angegebenen Anzahl mit der Option zum Kombinieren dieses Elements mit dem nächsten Element in einer Sendeanforderung von der Socketsebene zum Transport.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.SendPacketsElement.%23ctor%28System.String%2CSystem.Int32%2CSystem.Int32%2CSystem.Boolean%29> Konstruktor initialisiert eine neue Instanz der dem <xref:System.Net.Sockets.SendPacketsElement> Klasse mit einem Dateinamen einer Datei. Die <xref:System.Net.Sockets.SendPacketsElement> -Klasse wird zusammen mit den <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements%2A?displayProperty=nameWithType> Eigenschaft zum Abrufen oder Festlegen eines Datenpuffers oder der zu sendenden Datei mithilfe der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> Methode.  
  
 Universal Naming Convention (UNC)-Pfade werden unterstützt, durch die `filepath` Parameter. Wenn die Datei in das aktuelle Arbeitsverzeichnis ist, muss keine Pfadinformationen angegeben werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="filepath" />-Parameter darf nicht NULL sein.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="offset" />-Parameter und der <paramref name="count" />-Parameter müssen größer oder gleich 0 (null) sein.  
  
<paramref name="offset" /> und <paramref name="count" /> müssen kleiner als die Größe der vom <paramref name="filepath" />-Parameter angegebenen Datei sein.</exception>
        <altmember cref="T:System.ArgumentNullException" />
        <altmember cref="T:System.ArgumentOutOfRangeException" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public byte[] Buffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SendPacketsElement.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Buffer As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Buffer { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : byte[]" Usage="System.Net.Sockets.SendPacketsElement.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Puffer ab, der gesendet werden soll, wenn die <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse mit einem <paramref name="buffer" />-Parameter initialisiert wurde.</summary>
        <value>Der Bytepuffer, der gesendet werden soll, wenn die <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse mit einem <paramref name="buffer" />-Parameter initialisiert wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Net.Sockets.SendPacketsElement.Buffer%2A> Eigenschaft ist ein Array der Länge 0 (null), wenn die <xref:System.Net.Sockets.SendPacketsElement> Klasse wurde nicht initialisiert, mit einem `buffer` Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SendPacketsElement.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.Sockets.SendPacketsElement.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der zu sendenden Bytes ab.</summary>
        <value>Der Anzahl der zu sendenden Bytes, wenn die <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse mit einem <paramref name="count" />-Parameter initialisiert wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Net.Sockets.SendPacketsElement.Count%2A> Eigenschaft ist NULL, wenn die <xref:System.Net.Sockets.SendPacketsElement> Klasse wurde nicht initialisiert, mit einem `count` Parameter.  
  
 Wenn <xref:System.Net.Sockets.SendPacketsElement.Count%2A> ist 0 (null) für eine Datei, die ganze Datei gesendet wird. Wenn <xref:System.Net.Sockets.SendPacketsElement.Count%2A> ist 0 (null) für einen Puffer, die keine Bytes gesendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndOfPacket">
      <MemberSignature Language="C#" Value="public bool EndOfPacket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EndOfPacket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SendPacketsElement.EndOfPacket" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property EndOfPacket As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EndOfPacket { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.EndOfPacket : bool" Usage="System.Net.Sockets.SendPacketsElement.EndOfPacket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen booleschen Wert ab, der angibt, ob dieses Element nicht mit dem nächsten Element in einer Sendeanforderung von der Socketsebene zum Transport kombiniert werden soll.</summary>
        <value>Ein boolescher Wert, der angibt, ob dieses Element nicht mit dem nächsten Element in einer Sendeanforderung kombiniert werden soll.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A> Eigenschaft ist "false" Wenn die <xref:System.Net.Sockets.SendPacketsElement> Klasse wurde nicht initialisiert, mit einem `endOfPacket` Parameter auf "true" festgelegt ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="FilePath">
      <MemberSignature Language="C#" Value="public string FilePath { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string FilePath" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SendPacketsElement.FilePath" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property FilePath As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::String ^ FilePath { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.FilePath : string" Usage="System.Net.Sockets.SendPacketsElement.FilePath" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Dateinamen der zu sendenden Datei ab, wenn die <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse mit einem <paramref name="filepath" />-Parameter initialisiert wurde.</summary>
        <value>Der Dateiname der zu sendenden Datei, wenn die <see cref="T:System.Net.Sockets.SendPacketsElement" />-Klasse mit einem <paramref name="filepath" />-Parameter initialisiert wurde.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Universal Naming Convention (UNC)-Pfade werden unterstützt, durch die <xref:System.Net.Sockets.SendPacketsElement.FilePath%2A> Eigenschaft. Wenn die Datei in das aktuelle Arbeitsverzeichnis ist, muss keine Pfadinformationen angegeben werden.  
  
 Der Standardwert für die <xref:System.Net.Sockets.SendPacketsElement.FilePath%2A> Eigenschaft eine leere Zeichenfolge ist, wenn die <xref:System.Net.Sockets.SendPacketsElement> Klasse wurde nicht initialisiert, mit einem `filepath` Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Offset" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SendPacketsElement.Offset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Offset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Offset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Offset : int" Usage="System.Net.Sockets.SendPacketsElement.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Offset in Bytes vom Anfang des Datenpuffers oder der Datei zur Position im Puffer oder in der Datei zum Beginnen des Sendevorgangs für die Daten ab.</summary>
        <value>Der Offset in Bytes vom Anfang des Datenpuffers oder der Datei zur Position im Puffer oder in der Datei zum Beginnen des Sendevorgangs für die Daten.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Standardwert für die <xref:System.Net.Sockets.SendPacketsElement.Offset%2A> Eigenschaft ist NULL, wenn die <xref:System.Net.Sockets.SendPacketsElement> Klasse wurde nicht initialisiert, mit einem `offset` Parameter.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>