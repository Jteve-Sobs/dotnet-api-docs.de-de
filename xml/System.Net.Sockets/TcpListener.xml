<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e51f212013c0ee665f98720ffb164018f70142c9" /><Meta Name="ms.sourcegitcommit" Value="5333cc87886ffbd7d048590c0f7c7b0f90d4c32c" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/04/2020" /><Meta Name="ms.locfileid" Value="87564493" /></Metadata><TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Net.Sockets" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Überwacht Verbindungen von TCP-Netzwerkclients.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Net.Sockets.TcpListener> Klasse stellt einfache Methoden bereit, die eingehende Verbindungsanforderungen beim Blockieren des synchronen Modus lauschen und akzeptieren. Sie können entweder einen <xref:System.Net.Sockets.TcpClient> oder einen verwenden <xref:System.Net.Sockets.Socket> , um eine Verbindung mit herzustellen <xref:System.Net.Sockets.TcpListener> . Erstellen <xref:System.Net.Sockets.TcpListener> Sie ein mithilfe von <xref:System.Net.IPEndPoint> , einer lokalen IP-Adresse und einer Portnummer oder nur einer Portnummer. Geben <xref:System.Net.IPAddress.Any> Sie für die lokale IP-Adresse und 0 für die lokale Portnummer an, wenn der zugrunde liegende Dienstanbieter diese Werte zuweisen soll. Wenn Sie sich dafür entscheiden, können Sie die zugewiesene Informationen mithilfe der- <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft identifizieren, nachdem der Socket eine Verbindung hergestellt hat.  
  
 Verwenden Sie die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode, um mit der Überwachung eingehender Verbindungsanforderungen zu beginnen. <xref:System.Net.Sockets.TcpListener.Start%2A>fügt eingehende Verbindungen in die Warteschlange ein, bis Sie entweder die- <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode oder die Warteschlange aufgerufen haben <xref:System.Net.Sockets.SocketOptionName.MaxConnections> . Verwenden <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Sie entweder oder <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> , um eine Verbindung aus der Warteschlange für eingehende Verbindungsanforderungen abzurufen. Diese beiden Methoden werden blockiert. Wenn Sie die Blockierung vermeiden möchten, können Sie zuerst die- <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode verwenden, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange verfügbar sind.  
  
 Ruft die- <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode auf, um zu schließen <xref:System.Net.Sockets.TcpListener> .  
  
> [!NOTE]
>  Die- <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode schließt keine akzeptierten Verbindungen. Sie sind dafür verantwortlich, diese separat zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ein erstellt <xref:System.Net.Sockets.TcpListener> .  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 <xref:System.Net.Sockets.TcpClient>Ein Client Beispiel finden Sie unter.  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName Language="C#">[System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netcore-3.1;netstandard-2.1">
          <AttributeName Language="C#">[System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. https://go.microsoft.com/fwlink/?linkid=14202")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. https://go.microsoft.com/fwlink/?linkid=14202")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName Language="C#">[System.Obsolete("Use TcpListener(IPAddress localaddr, int port).")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use TcpListener(IPAddress localaddr, int port).")&gt;]</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName Language="C#">[System.Obsolete("Use TcpListener (IPAddress address, int port) instead")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Obsolete("Use TcpListener (IPAddress address, int port) instead")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse, die den angegebenen Anschluss überwacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist veraltet. Verwenden Sie <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> die <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> Konstruktoren oder.  
  
 Mit diesem Konstruktor können Sie die Portnummer angeben, auf der auf eingehende Verbindungsversuche gelauscht werden soll. Mit diesem Konstruktor weist der zugrunde liegende Dienstanbieter die am besten geeignete Netzwerkadresse zu. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall weist der Dienstanbieter eine verfügbare kurzlebige Portnummer zu. Wenn Sie diesen Ansatz verwenden, können Sie mithilfe der-Eigenschaft ermitteln, welche Adresse und Portnummer für das lokale Netzwerk zugewiesen wurden <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> .  
  
 Ruft die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.TcpListener> mit einer lokalen Portnummer erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Ein <see cref="T:System.Net.IPEndPoint" />, der den lokalen Endpunkt darstellt, an den der Listener-<see cref="T:System.Net.Sockets.Socket" /> gebunden werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse mit dem angegebenen lokalen Endpunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor können Sie die lokale IP-Adresse und die Portnummer angeben, für die auf eingehende Verbindungsversuche gelauscht werden soll. Bevor Sie diesen Konstruktor verwenden, müssen Sie <xref:System.Net.IPEndPoint> mithilfe der gewünschten lokalen IP-Adresse und Portnummer ein erstellen. Übergeben <xref:System.Net.IPEndPoint> Sie diese als-Parameter an den-Konstruktor `localEP` .  
  
 Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, können Sie <xref:System.Net.IPEndPoint> mithilfe von <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adress Parameter erstellen, und der zugrunde liegende Dienstanbieter weist die am besten geeignete Netzwerkadresse zu. Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie einen <xref:System.Net.IPEndPoint> mit 0 für die Portnummer erstellen. In diesem Fall weist der Dienstanbieter eine verfügbare kurzlebige Portnummer zu. Wenn Sie diesen Ansatz verwenden, können Sie mithilfe der-Eigenschaft ermitteln, welche Adresse und Portnummer für das lokale Netzwerk zugewiesen wurden <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> .  
  
 Ruft die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der- <xref:System.Net.Sockets.TcpListener> Klasse mit dem lokalen Endpunkt erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">Eine <see cref="T:System.Net.IPAddress" />, die die lokale IP-Adresse darstellt.</param>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse, die die eingehenden Verbindungsversuche mit der angegebenen lokalen IP-Adresse und Anschlussnummer überwacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor können Sie die lokale IP-Adresse und die Portnummer angeben, für die auf eingehende Verbindungsversuche gelauscht werden soll. Vor dem Aufrufen dieses Konstruktors müssen Sie zuerst <xref:System.Net.IPAddress> mithilfe der gewünschten lokalen Adresse ein erstellen. Übergeben <xref:System.Net.IPAddress> Sie diese als-Parameter an den-Konstruktor `localaddr` . Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, geben Sie <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> für den `localaddr` -Parameter an, und der zugrunde liegende Dienstanbieter weist die geeignetste Netzwerkadresse zu. Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 65535 zu. Wenn Sie diesen Ansatz verwenden, können Sie mithilfe der-Eigenschaft ermitteln, welche Adresse und Portnummer für das lokale Netzwerk zugewiesen wurden <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> .  
  
 Ruft die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der <xref:System.Net.Sockets.TcpListener> -Klasse unter Verwendung einer lokalen IP-Adresse und Portnummer erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localaddr" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Verbindungsanforderung an.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>ist eine blockierende Methode, die einen zurückgibt <xref:System.Net.Sockets.Socket> , den Sie zum Senden und empfangen von Daten verwenden können. Wenn Sie die Blockierung vermeiden möchten, verwenden Sie die- <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange für eingehende Verbindungen verfügbar sind.  
  
 Der <xref:System.Net.Sockets.Socket> zurückgegebene wird mit der IP-Adresse und der Portnummer des Remote Hosts initialisiert. Sie können eine der <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Receive%2A> in der-Klasse verfügbaren-und-Methoden verwenden <xref:System.Net.Sockets.Socket> , um mit dem Remote Host zu kommunizieren. Wenn Sie die Verwendung von abgeschlossen <xref:System.Net.Sockets.Socket> haben, stellen Sie sicher, dass Sie Ihre-Methode aufzurufen <xref:System.Net.Sockets.Socket.Close%2A> . Wenn die Anwendung relativ einfach ist, sollten Sie die Verwendung der- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode anstelle der-Methode in Erwägung gezogen <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> . <xref:System.Net.Sockets.TcpClient>bietet Ihnen einfache Methoden zum Senden und empfangen von Daten über ein Netzwerk im Modus zum Blockieren des synchronen Modus.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode verwendet, um zurückzugeben <xref:System.Net.Sockets.Socket> . Diese <xref:System.Net.Sockets.Socket> wird für die Kommunikation mit dem neu verbundenen Client verwendet.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Aufforderung zum Aufbau einer Verbindung als asynchroner Vorgang an.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Task-Objekt gibt <see cref="T:System.Net.Sockets.Socket" /> zurück, das verwendet wird, um Daten zu senden und zu empfangen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die Socketverbindung akzeptiert wurde.  
  
 Der, der <xref:System.Net.Sockets.Socket> in zurückgegeben <xref:System.Threading.Tasks.Task%601> wird, wird mit der IP-Adresse und der Portnummer des Remote Hosts initialisiert. Sie können eine der <xref:System.Net.Sockets.Socket.Send%2A> <xref:System.Net.Sockets.Socket.Receive%2A> in der-Klasse verfügbaren-und-Methoden verwenden <xref:System.Net.Sockets.Socket> , um mit dem Remote Host zu kommunizieren. Wenn Sie die Verwendung von abgeschlossen <xref:System.Net.Sockets.Socket> haben, stellen Sie sicher, dass Sie Ihre-Methode aufzurufen <xref:System.Net.Sockets.Socket.Close%2A> . Wenn die Anwendung relativ einfach ist, sollten Sie die Verwendung der- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode anstelle der-Methode in Erwägung gezogen <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> . <xref:System.Net.Sockets.TcpClient>bietet Ihnen einfache Methoden zum Senden und empfangen von Daten über ein Netzwerk im Modus zum Blockieren des synchronen Modus.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Verbindungsanforderung an.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.TcpClient" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>ist eine blockierende Methode, die einen zurückgibt <xref:System.Net.Sockets.TcpClient> , den Sie zum Senden und empfangen von Daten verwenden können. Verwenden Sie die- <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange für eingehende Verbindungen verfügbar sind, wenn Sie Blockierungen vermeiden möchten  
  
 Verwenden Sie die- <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> Methode, um den zugrunde liegenden <xref:System.Net.Sockets.NetworkStream> der zurückgegebenen abzurufen <xref:System.Net.Sockets.TcpClient> . <xref:System.Net.Sockets.NetworkStream>Bietet Methoden zum Senden und empfangen von mit dem Remote Host. Wenn Sie mit dem durchlaufen, stellen Sie sicher, dass Sie die zugehörige- <xref:System.Net.Sockets.TcpClient> <xref:System.Net.Sockets.TcpClient.Close%2A> Methode aufruft. Wenn Sie mehr Flexibilität als Angebote wünschen <xref:System.Net.Sockets.TcpClient> , sollten Sie die Verwendung von in Erwägung gezogen <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode verwendet, um zurückzugeben <xref:System.Net.Sockets.TcpClient> . Diese <xref:System.Net.Sockets.TcpClient> wird für die Kommunikation mit dem neu verbundenen Client verwendet.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Aufforderung zum Aufbau einer Verbindung als asynchroner Vorgang an.</summary>
        <returns>Das Aufgabenobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Task-Objekt gibt <see cref="T:System.Net.Sockets.TcpClient" /> zurück, das verwendet wird, um Daten zu senden und zu empfangen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die TCP-Verbindung akzeptiert wurde.  
  
 Verwenden Sie die- <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> Methode, um den zugrunde liegenden <xref:System.Net.Sockets.NetworkStream> der in der zurückgegebenen abzurufen <xref:System.Net.Sockets.TcpClient> <xref:System.Threading.Tasks.Task%601> . <xref:System.Net.Sockets.NetworkStream>Bietet Methoden zum Senden und empfangen von mit dem Remote Host. Wenn Sie mit dem durchlaufen, stellen Sie sicher, dass Sie die zugehörige- <xref:System.Net.Sockets.TcpClient> <xref:System.Net.Sockets.TcpClient.Close%2A> Methode aufruft. Wenn Sie mehr Flexibilität als Angebote wünschen <xref:System.Net.Sockets.TcpClient> , sollten Sie die Verwendung von oder in Erwägung gezogen <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Net.Sockets.TcpListener" /> Clientverbindungen aktiv überwacht.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Net.Sockets.TcpListener" /> aktiv überwacht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen <xref:System.Net.Sockets.TcpListener> , die von abgeleitet werden, können diese Eigenschaft verwenden, um zu bestimmen, ob <xref:System.Net.Sockets.Socket> derzeit auf eingehende Verbindungsversuche lauscht. Die- <xref:System.Net.Sockets.TcpClient.Active%2A> Eigenschaft kann verwendet werden, um redundante Versuche zu vermeiden <xref:System.Net.Sockets.TcpListener.Start%2A> .  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="allowed">Ein boolescher Wert, der angibt, ob die NAT-Überquerung aktiviert oder deaktiviert werden soll.</param>
        <summary>Aktiviert oder deaktiviert die NAT-Überquerung (Netzwerkadressenübersetzung) für eine <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Methode wird verwendet, um NAT-Traversale für eine-Instanz zu aktivieren oder zu deaktivieren <xref:System.Net.Sockets.TcpListener> . NAT-Durchlauf kann mithilfe von Teredo, IPv6-zu-IPv4 oder einem ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn der- `allowed` Parameter auf false festgelegt ist, wird die- <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> Option für den zugeordneten Socket auf festgelegt <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted> . Dadurch wird der NAT-Durchlauf für eine- <xref:System.Net.Sockets.TcpListener> Instanz explizit deaktiviert.  
  
 Wenn der- `allowed` Parameter true ist, <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> wird die-Option für den zugeordneten Socket auf festgelegt <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted> . Dies kann die NAT-Überquerung für eine <xref:System.Net.Sockets.TcpListener> abhängig von Firewallregeln im System ermöglichen.  
  
 Die- <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Methode muss aufgerufen werden, bevor die-Methode aufgerufen wird <xref:System.Net.Sockets.TcpListener.Start%2A> , um mit dem lauschen auf eingehende Verbindungsanforderungen (vor dem Binden des Sockets) zu beginnen. Wenn <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> die-Methode nach der-Methode aufgerufen wird <xref:System.Net.Sockets.TcpListener.Start%2A> , wird eine ausgelöst <xref:System.InvalidOperationException> .  
  
 Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001::/32. Teredo-Adressen können über die normale DNS-Namensauflösung zurückgegeben oder als eine IPv6-Adresse aufgezählt werden, die einer lokalen Schnittstelle zugewiesen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />-Methode wird nach dem Aufruf der <see cref="M:System.Net.Sockets.TcpListener.Start" />-Methode aufgerufen.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAcceptSocket (AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Annahmevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Erstellung des <see cref="T:System.Net.Sockets.Socket" /> verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> . In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen-Objekts aufzurufen <xref:System.Net.Sockets.Socket> , um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie einen erhalten <xref:System.Net.Sockets.SocketException> , verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> -Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> -Methode verwendet wird, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die- <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult? BeginAcceptTcpClient (AsyncCallback callback, object state);" FrameworkAlternate="net-5.0" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Annahmevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Erstellung des <see cref="T:System.Net.Sockets.TcpClient" /> verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> Vorgang muss durch Aufrufen der-Methode abgeschlossen werden <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> . In der Regel wird die-Methode vom-Delegaten aufgerufen `callback` .  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](/dotnet/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously).  
  
> [!NOTE]
>  Wenn Sie einen erhalten <xref:System.Net.Sockets.SocketException> , verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> -Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> -Methode verwendet wird, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die- <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Erstellt eine neue auf dem angegebenen Port lauschende <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</summary>
        <returns>Eine neue auf dem angegebenen Port lauschende <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein durch einen Aufruf der <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />-Methode zurückgegebenes <see cref="T:System.IAsyncResult" />.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />.  
  
Ein <see cref="T:System.Net.Sockets.Socket" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist. Verwenden Sie die-Methode, um diesen Vorgang synchron auszuführen <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> .  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen-Objekts aufzurufen <xref:System.Net.Sockets.Socket> , um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie einen erhalten <xref:System.Net.Sockets.SocketException> , verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> -Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> -Methode verwendet wird, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die- <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="asyncResult" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="asyncResult" />-Parameter wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />-Methode erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="net-5.0;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein durch einen Aufruf der <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />-Methode zurückgegebenes <see cref="T:System.IAsyncResult" />.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.TcpClient" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.TcpClient" />.  
  
Ein <see cref="T:System.Net.Sockets.TcpClient" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist. Verwenden Sie die-Methode, um diesen Vorgang synchron auszuführen <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> .  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zugrunde liegenden Sockets ( <xref:System.Net.Sockets.TcpClient.Client%2A> ) zum Identifizieren der Netzwerkadresse und der Portnummer des Remote Hosts aufzurufen.  
  
> [!NOTE]
>  Wenn Sie einen erhalten <xref:System.Net.Sockets.SocketException> , verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> -Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie die <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> -Methode verwendet wird, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die- <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.TcpListener" /> das Überwachen eines bestimmten Anschlusses durch nur einen einzigen zugrunde liegenden Socket zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.TcpListener" /> das Überwachen eines bestimmten Anschlusses durch nur einen einzigen <see cref="T:System.Net.Sockets.TcpListener" /> zulässt, andernfalls <see langword="false" />. Für Windows Server 2003 und Windows XP Service Pack 2 oder höher ist der Standardwert <see langword="true" />, für alle anderen Versionen <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig können mehrere Listener an einem bestimmten Port lauschen. Allerdings kann nur einer der Listener Vorgänge für den Netzwerk Datenverkehr ausführen, der an den Port gesendet wird. Wenn mehr als ein Listener versucht, eine Bindung an einen bestimmten Port durchzusetzen, verarbeitet der eine mit der spezifischeren IP-Adresse den Netzwerk Datenverkehr, der an diesen Port gesendet wird. Sie können die- <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> Eigenschaft verwenden, um zu verhindern, dass mehrere Listener an einem bestimmten Port lauschen.  
  
 Legen Sie diese Eigenschaft vor dem Aufrufen von fest <xref:System.Net.Sockets.TcpListener.Start%2A> , oder rufen Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A> -Methode auf, und legen Sie diese Eigenschaft  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die-Eigenschaft abgerufen und festgelegt <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> .  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.TcpListener" /> wurde gestartet. Rufen Sie die <see cref="M:System.Net.Sockets.TcpListener.Stop" />-Methode auf, und legen Sie anschließend die <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />-Eigenschaft fest.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den zugrunde liegenden Socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt von der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse verwendete Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Der <xref:System.Net.Sockets.TcpListener> Klassen-Finalizer gibt freie Ressourcen frei, die der-Instanz zugeordnet sind <xref:System.Net.Sockets.TcpListener> .

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden <see cref="T:System.Net.EndPoint" /> des aktuellen <see cref="T:System.Net.Sockets.TcpListener" /> ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, an den der <see cref="T:System.Net.Sockets.Socket" /> gebunden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> -Eigenschaft verwenden, um die lokale Netzwerkschnittstelle und die Portnummer zu identifizieren, die zum lauschen auf eingehende Client Verbindungsanforderungen verwendet werden, nachdem eine Socketverbindung hergestellt wurde. Sie müssen dies zuerst <xref:System.Net.EndPoint> in einen umwandeln <xref:System.Net.IPEndPoint> . Anschließend können Sie die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> -Eigenschaft aufrufen, um die lokale IP-Adresse abzurufen, und die- <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Eigenschaft, um die lokale Portnummer abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die lokale IP-Adresse und die Portnummer angezeigt, auf denen der <xref:System.Net.Sockets.TcpListener> eingehende Verbindungsanforderungen überwacht.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob ausstehende Verbindungsanforderungen vorliegen.</summary>
        <returns><see langword="true" />, wenn Verbindungen ausstehen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese nicht blockierende Methode bestimmt, ob ausstehende Verbindungsanforderungen vorhanden sind. Da die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> -und- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methoden die Ausführung blockieren, bis die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode eine eingehende Verbindungsanforderung in die Warteschlange eingereiht hat, kann die- <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode verwendet werden, um zu bestimmen, ob Verbindungen verfügbar sind, bevor Sie  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die- <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode überprüft. Wenn eine Verbindungsanforderung darauf wartet, akzeptiert zu werden, wird ein Rückruf der- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode durchgeführt.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Server { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Server As Socket" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden Netzwerk-<see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Der zugrundeliegende <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener>erstellt eine <xref:System.Net.Sockets.Socket> zum lauschen auf eingehende Client Verbindungsanforderungen. Von abgeleitete Klassen <xref:System.Net.Sockets.TcpListener> können diese Eigenschaft verwenden, um dies zu erhalten <xref:System.Net.Sockets.Socket> . Verwenden Sie den zugrunde liegenden <xref:System.Net.Sockets.Socket> , der von der-Eigenschaft zurückgegeben <xref:System.Net.Sockets.TcpListener.Server%2A> wird <xref:System.Net.Sockets.TcpListener>  
  
> [!NOTE]
>  Die- <xref:System.Net.Sockets.TcpListener.Server%2A> Eigenschaft gibt nur den zurück, der zum <xref:System.Net.Sockets.Socket> lauschen auf eingehende Client Verbindungsanforderungen verwendet wird. Verwenden <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Sie die-Methode, um eine ausstehende Verbindungsanforderung zu akzeptieren und <xref:System.Net.Sockets.Socket> zum Senden und empfangen von Daten eine abzurufen. Sie können auch die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> -Methode verwenden, um eine ausstehende Verbindungsanforderung zu akzeptieren und <xref:System.Net.Sockets.TcpClient> zum Senden und empfangen von Daten eine abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.TcpListener.Server%2A>-Attributs veranschaulicht. Der zugrunde liegende <xref:System.Net.Sockets.Socket> wird abgerufen, und die <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> Option ist so konfiguriert, dass nach 10 Sekunden ein Timeout auftritt, wenn die Daten nach dem Schließen der Verbindung noch im Netzwerk Puffer verbleiben.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt die Überwachung von eingehenden Verbindungsanforderungen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Überwachung von eingehenden Verbindungsanforderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket> , bindet Sie an einen lokalen Endpunkt und lauscht auf eingehende Verbindungsversuche. Wenn eine Verbindungsanforderung empfangen wird, fügt die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode die Anforderung in die Warteschlange ein und lauscht weiterhin auf weitere Anforderungen, bis Sie die-Methode aufgerufen haben <xref:System.Net.Sockets.TcpListener.Stop%2A> . Wenn <xref:System.Net.Sockets.TcpListener> eine Verbindungsanforderung empfängt, nachdem Sie bereits die maximale Anzahl von Verbindungen in die Warteschlange eingereiht hat, löst Sie eine <xref:System.Net.Sockets.SocketException> auf dem Client aus.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode oder die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> -Methode entfernt eine Verbindung aus der Warteschlange und gibt einen zurück <xref:System.Net.Sockets.TcpClient> , der zum Senden und empfangen von Daten verwendet werden kann. Die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode gibt einen zurück <xref:System.Net.Sockets.Socket> , den Sie verwenden können, um das gleiche zu tun. Wenn für Ihre Anwendung nur synchrone e/a erforderlich ist, verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> . Verwenden Sie zur ausführlicheren Verhaltenskontrolle <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> . Beide Methoden blockieren, bis eine Verbindungsanforderung in der Warteschlange verfügbar ist.  
  
 Verwenden <xref:System.Net.Sockets.TcpListener.Stop%2A> Sie die-Methode, um zu schließen und die Überwachung zu <xref:System.Net.Sockets.TcpListener> beenden. Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht <xref:System.Net.Sockets.TcpListener.Start%2A> , wie verwendet wird, um auf eingehende Client Verbindungsversuche zu lauschen.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" Index="0" FrameworkAlternate="net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="backlog">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</param>
        <summary>Beginnt die Überwachung eingehender Verbindungsanforderungen mit einer maximalen Anzahl ausstehender Verbindungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Net.Sockets.TcpListener.Start%2A> Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket> , bindet Sie an einen lokalen Endpunkt und lauscht auf eingehende Verbindungsversuche. Wenn eine Verbindungsanforderung empfangen wird, <xref:System.Net.Sockets.TcpListener.Start%2A> wird die Anforderung von in die Warteschlange eingereiht, bis Sie die-Methode aufgerufen haben <xref:System.Net.Sockets.TcpListener.Stop%2A> . Wenn <xref:System.Net.Sockets.TcpListener> eine Verbindungsanforderung empfängt, nachdem Sie bereits die maximale Anzahl von Verbindungen in die Warteschlange eingereiht hat, wird eine <xref:System.Net.Sockets.SocketException> auf dem Client ausgelöst.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die- <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode oder die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> -Methode entfernt eine Verbindung aus der Warteschlange und gibt einen zurück <xref:System.Net.Sockets.TcpClient> , der zum Senden und empfangen von Daten verwendet werden kann. Die- <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode gibt einen zurück <xref:System.Net.Sockets.Socket> , den Sie verwenden können, um das gleiche zu tun. Wenn für Ihre Anwendung nur synchrone e/a erforderlich ist, verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> . Verwenden Sie die-Methode für eine ausführlichere Verhaltenskontrolle <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> . Beide Methoden blockieren, bis eine Verbindungsanforderung in der Warteschlange verfügbar ist.  
  
 Verwenden <xref:System.Net.Sockets.TcpListener.Stop%2A> Sie die-Methode, um zu schließen und die Überwachung zu <xref:System.Net.Sockets.TcpListener> beenden. Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. In der Dokumentation zu API-Fehlercodes unter [Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht <xref:System.Net.Sockets.TcpListener.Start%2A> , wie verwendet wird, um auf eingehende Client Verbindungsversuche zu lauschen.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den Socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="backlog" />-Parameter ist kleiner als 0 (null) oder übersteigt die maximale Anzahl zulässiger Verbindungen.</exception>
        <exception cref="T:System.InvalidOperationException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> ist NULL.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A>schließt den Listener. Alle nicht akzeptierten Verbindungsanforderungen in der Warteschlange gehen verloren. Remote Hosts, die darauf warten, dass eine Verbindung akzeptiert wird, lösen eine aus <xref:System.Net.Sockets.SocketException> . Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](/dotnet/framework/network-programming/network-tracing).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der- <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode zum Schließen des zugrunde liegenden veranschaulicht <xref:System.Net.Sockets.Socket> .  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <block subset="none" type="usage"><para>Die <see cref="M:System.Net.Sockets.TcpListener.Stop" /> -Methode schließt auch den zugrunde liegenden <see cref="T:System.Net.Sockets.Socket" /> und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> für das <see cref="T:System.Net.Sockets.TcpListener" /> . Wenn Sie vor dem Aufrufen der-Methode Eigenschaften für den zugrunde liegenden festlegen <see cref="T:System.Net.Sockets.Socket" /> <see cref="M:System.Net.Sockets.TcpListener.Stop" /> , werden diese Eigenschaften nicht auf den neuen übertragen <see cref="T:System.Net.Sockets.Socket" /> .</para></block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>
