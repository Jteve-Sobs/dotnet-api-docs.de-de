<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="08844ec4200e956b530486778593461aeef6b051" />
    <Meta Name="ms.sourcegitcommit" Value="5a49536d99d2d0b54e4cb7280870903e043272df" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="07/03/2018" />
    <Meta Name="ms.locfileid" Value="37476658" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Listens for connections from TCP network clients.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener> -Klasse bietet einfache Methoden, die Abhören und akzeptieren von eingehenden verbindungsanforderungen im synchronen Modus blockiert. Verwenden Sie entweder eine <xref:System.Net.Sockets.TcpClient> oder <xref:System.Net.Sockets.Socket> für die Verbindung mit einer <xref:System.Net.Sockets.TcpListener>. Erstellen einer <xref:System.Net.Sockets.TcpListener> mithilfe einer <xref:System.Net.IPEndPoint>, eine lokale IP-Adresse und Portnummer oder nur eine Portnummer an. Geben Sie <xref:System.Net.IPAddress.Any> für die lokale IP-Adresse und 0 für die lokale Portnummer ein, wenn Sie den zugrunde liegenden Dienstanbieter, um diese Werte zuweisen möchten. Wenn Sie diese Option auswählen, können Sie mithilfe der <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft, um die zugewiesenen Informationen zu identifizieren, nach der Socket-Verbindung hergestellt hat.  
  
 Verwenden der <xref:System.Net.Sockets.TcpListener.Start%2A> Methode damit beginnt, Lauschen auf eingehende verbindungsanforderungen. <xref:System.Net.Sockets.TcpListener.Start%2A> eingehende Verbindungen wird Warteschlange stellen, bis Sie entweder Sie rufen die <xref:System.Net.Sockets.TcpListener.Stop%2A> -Methode, oder er wurde in die Warteschlange <xref:System.Net.Sockets.SocketOptionName.MaxConnections>. Verwenden Sie entweder <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> oder <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> , eine Verbindung aus der Warteschlange für eingehende Verbindungen Anforderung abzurufen. Diese beiden Methoden werden blockiert. Wenn Sie eine Blockierung zu vermeiden möchten, können Sie mithilfe der <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode, um zu bestimmen, ob die Weiterleitung von verbindungsanforderungen in der Warteschlange verfügbar sind.  
  
 Rufen Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode zum Schließen der <xref:System.Net.Sockets.TcpListener>.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode wird nicht akzeptierten Verbindungen geschlossen. Sie sind verantwortlich für das Schließen diese separat.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.TcpListener>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Finden Sie unter <xref:System.Net.Sockets.TcpClient> ein Beispiel für Client.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">Um eine ausgehende Verbindung herzustellen, oder übernehmen Sie eine eingehende Anforderung.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.TcpListener" /> class.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">The port on which to listen for incoming connection attempts.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.TcpListener" /> class that listens on the specified port.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist veraltet. Verwenden der <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType> oder <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType> Konstruktoren.  
  
 Dieser Konstruktor ermöglicht Ihnen die Angabe der Portnummer für das Lauschen auf eingehende Verbindungsversuche. Mit diesem Konstruktor weist der zugrunde liegenden Dienstanbieter die am besten geeignete Netzwerkadresse an. Wenn Sie nicht wichtig ist der lokaler Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall wird der Dienstanbieter eine Anzahl von verfügbaren kurzlebigen Port zugewiesen. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche lokalen Netzwerk Adresse und Port-Nummer mit zugewiesen wurde die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft.  
  
 Rufen Sie die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode, um eingehende Verbindungsversuche überwacht werden soll.  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine <xref:System.Net.Sockets.TcpListener> über eine lokale Portnummer.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> is not between <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">An <see cref="T:System.Net.IPEndPoint" /> that represents the local endpoint to which to bind the listener <see cref="T:System.Net.Sockets.Socket" />.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.TcpListener" /> class with the specified local endpoint.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ermöglicht Ihnen die Angabe die lokale IP-Adresse und Portnummer für das Lauschen auf eingehende Verbindung versucht. Bevor Sie diesen Konstruktor verwenden, müssen Sie erstellen eine <xref:System.Net.IPEndPoint> mit der gewünschten lokalen IP-Adresse und Portnummer. Übergeben Sie diese <xref:System.Net.IPEndPoint> als an den Konstruktor der `localEP` Parameter.  
  
 Wenn Sie sich nicht wichtig ist, welche lokalen Adresse zugewiesen ist, können Sie erstellen eine <xref:System.Net.IPEndPoint> mit <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adressenparameter und den zugrunde liegenden Dienst weist Anbieter die am besten geeignete Netzwerkadresse. Das kann hilfreich sein, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht wichtig ist der lokaler Port verwendet wird, können Sie erstellen eine <xref:System.Net.IPEndPoint> verwenden 0 für die Nummer des Ports. In diesem Fall wird der Dienstanbieter eine Anzahl von verfügbaren kurzlebigen Port zugewiesen. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche lokalen Netzwerk Adresse und Port-Nummer mit zugewiesen wurde die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft.  
  
 Rufen Sie die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode, um eingehende Verbindungsversuche überwacht werden soll.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz von der <xref:System.Net.Sockets.TcpListener> -Klasse unter Verwendung des lokalen Endpunkts.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localEP" /> is <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">An <see cref="T:System.Net.IPAddress" /> that represents the local IP address.</param>
        <param name="port">The port on which to listen for incoming connection attempts.</param>
        <summary>Initializes a new instance of the <see cref="T:System.Net.Sockets.TcpListener" /> class that listens for incoming connection attempts on the specified local IP address and port number.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ermöglicht Ihnen die Angabe die lokale IP-Adresse und Portnummer für das Lauschen auf eingehende Verbindung versucht. Sie müssen zuerst erstellen, vor dem Aufrufen dieses Konstruktors eine <xref:System.Net.IPAddress> mit der gewünschten lokalen Adresse. Übergeben Sie diese <xref:System.Net.IPAddress> als an den Konstruktor der `localaddr` Parameter. Wenn Sie sich nicht wichtig ist, welche lokalen Adresse zugewiesen ist, geben Sie <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> für die `localaddr` Parameter und den zugrunde liegenden Dienstanbieter wird die am besten geeignete Netzwerkadresse zuweisen. Das kann hilfreich sein, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht wichtig ist der lokaler Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche lokalen Netzwerk Adresse und Port-Nummer mit zugewiesen wurde die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft.  
  
 Rufen Sie die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode, um eingehende Verbindungsversuche überwacht werden soll.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel erstellt eine Instanz von der <xref:System.Net.Sockets.TcpListener> Klasse mithilfe einer lokalen IP-Adresse und Portnummer.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="localaddr" /> is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="port" /> is not between <see cref="F:System.Net.IPEndPoint.MinPort" /> and <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepts a pending connection request.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> blockierende Methode, die zurückgegeben wird ein <xref:System.Net.Sockets.Socket> , dass Sie zum Senden und Empfangen von Daten verwenden können. Wenn Sie die Blockierung zu vermeiden möchten, verwenden Sie die <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode, um zu bestimmen, ob die Weiterleitung von verbindungsanforderungen in der Warteschlange für eingehende Verbindungen verfügbar sind.  
  
 Die <xref:System.Net.Sockets.Socket> zurückgegeben, die mit der IP-Adresse und Portnummer des Remotehosts, initialisiert wird. Können Sie eines der <xref:System.Net.Sockets.Socket.Send%2A> und <xref:System.Net.Sockets.Socket.Receive%2A> in verfügbaren Methoden der <xref:System.Net.Sockets.Socket> Klasse für die Kommunikation mit dem Remotehost. Wenn Sie fertig sind mit den <xref:System.Net.Sockets.Socket>, achten Sie darauf, dass Sie zum Aufrufen der <xref:System.Net.Sockets.Socket.Close%2A> Methode. Wenn Ihre Anwendung relativ einfach ist, sollten Sie verwenden die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode anstelle der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. <xref:System.Net.Sockets.TcpClient> bietet einfache Methoden zum Senden und Empfangen von Daten in einem Netzwerk im synchronen Modus blockiert.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode dient zum Zurückgeben einer <xref:System.Net.Sockets.Socket>. Dies <xref:System.Net.Sockets.Socket> wird verwendet, um mit der neu verbundenen Client zu kommunizieren.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The listener has not been started with a call to <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepts a pending connection request as an asynchronous operation.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />  The task object representing the asynchronous operation. The <see cref="P:System.Threading.Tasks.Task`1.Result" /> property on the task object returns a <see cref="T:System.Net.Sockets.Socket" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die Socket-Verbindung akzeptiert wurde.  
  
 Die <xref:System.Net.Sockets.Socket> in zurückgegebenen <xref:System.Threading.Tasks.Task%601> initialisiert wird, mit der IP-Adresse und Portnummer des Remotehosts. Können Sie eines der <xref:System.Net.Sockets.Socket.Send%2A> und <xref:System.Net.Sockets.Socket.Receive%2A> in verfügbaren Methoden der <xref:System.Net.Sockets.Socket> Klasse für die Kommunikation mit dem Remotehost. Wenn Sie fertig sind mit den <xref:System.Net.Sockets.Socket>, achten Sie darauf, dass Sie zum Aufrufen der <xref:System.Net.Sockets.Socket.Close%2A> Methode. Wenn Ihre Anwendung relativ einfach ist, sollten Sie verwenden die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode anstelle der <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A> Methode. <xref:System.Net.Sockets.TcpClient> bietet einfache Methoden zum Senden und Empfangen von Daten in einem Netzwerk im synchronen Modus blockiert.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The listener has not been started with a call to <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepts a pending connection request.</summary>
        <returns>A <see cref="T:System.Net.Sockets.TcpClient" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> blockierende Methode, die zurückgegeben wird ein <xref:System.Net.Sockets.TcpClient> , dass Sie zum Senden und Empfangen von Daten verwenden können. Verwenden der <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode, um zu bestimmen, ob die Weiterleitung von verbindungsanforderungen sind in der Warteschlange für eingehende Verbindungen verfügbar, wenn Sie die Blockierung zu vermeiden möchten.  
  
 Verwenden der <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> Methode zum Abrufen der zugrunde liegende <xref:System.Net.Sockets.NetworkStream> des zurückgegebenen <xref:System.Net.Sockets.TcpClient>. Die <xref:System.Net.Sockets.NetworkStream> erhalten Sie Methoden zum Senden und empfangen mit dem Remotehost. Wenn Sie über mit sind die <xref:System.Net.Sockets.TcpClient>, achten Sie darauf, dass Sie zum Aufrufen der <xref:System.Net.Sockets.TcpClient.Close%2A> Methode. Wenn Sie mehr Flexibilität als möchten eine <xref:System.Net.Sockets.TcpClient> Angebote in Betracht <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel zeigt die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode dient zum Zurückgeben einer <xref:System.Net.Sockets.TcpClient>. Dies <xref:System.Net.Sockets.TcpClient> wird verwendet, um mit der neu verbundenen Client zu kommunizieren.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The listener has not been started with a call to <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Accepts a pending connection request as an asynchronous operation.</summary>
        <returns>Returns <see cref="T:System.Threading.Tasks.Task`1" />  The task object representing the asynchronous operation. The <see cref="P:System.Threading.Tasks.Task`1.Result" /> property on the task object returns a <see cref="T:System.Net.Sockets.TcpClient" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die TCP-Verbindung akzeptiert wurde.  
  
 Verwenden der <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType> Methode zum Abrufen der zugrunde liegende <xref:System.Net.Sockets.NetworkStream> des zurückgegebenen <xref:System.Net.Sockets.TcpClient> in die <xref:System.Threading.Tasks.Task%601>. Die <xref:System.Net.Sockets.NetworkStream> erhalten Sie Methoden zum Senden und empfangen mit dem Remotehost. Wenn Sie über mit sind die <xref:System.Net.Sockets.TcpClient>, achten Sie darauf, dass Sie zum Aufrufen der <xref:System.Net.Sockets.TcpClient.Close%2A> Methode. Wenn Sie mehr Flexibilität als möchten eine <xref:System.Net.Sockets.TcpClient> Angebote in Betracht <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> oder <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The listener has not been started with a call to <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets a value that indicates whether <see cref="T:System.Net.Sockets.TcpListener" /> is actively listening for client connections.</summary>
        <value>
          <see langword="true" /> Wenn <see cref="T:System.Net.Sockets.TcpListener" /> wird aktiv überwacht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Abgeleitete Klassen von <xref:System.Net.Sockets.TcpListener> können diese Eigenschaft verwenden, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket> ist derzeit für eingehende Verbindungsversuche überwacht. Die <xref:System.Net.Sockets.TcpClient.Active%2A> Eigenschaft kann verwendet werden, um vermeiden Sie redundante <xref:System.Net.Sockets.TcpListener.Start%2A> versucht.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="allowed">A Boolean value that specifies whether to enable or disable NAT traversal.</param>
        <summary>Enables or disables Network Address Translation (NAT) traversal on a <see cref="T:System.Net.Sockets.TcpListener" /> instance.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Methode dient zum Aktivieren oder deaktivieren die NAT-Durchlauf für eine <xref:System.Net.Sockets.TcpListener> Instanz. NAT-Durchlauf kann mit Teredo, 6to4 oder einen ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn die `allowed` Parameter ist "false", die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> legen Sie die Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>. Dadurch werden explizit deaktiviert die NAT-Durchlauf für eine <xref:System.Net.Sockets.TcpListener> Instanz.  
  
 Wenn die `allowed` Parameter ist "true", die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel> legen Sie die Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>. Dadurch kann die NAT-Durchlauf für eine <xref:System.Net.Sockets.TcpListener> abhängig von Firewallregeln auf dem System.  
  
 Die <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Methode muss aufgerufen werden, vor dem Aufrufen der <xref:System.Net.Sockets.TcpListener.Start%2A> Methode zum Beginnen des Lauschens für eingehende verbindungsanforderungen (vor der Socket gebunden ist). Wenn <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A> Methode wird aufgerufen, nachdem die <xref:System.Net.Sockets.TcpListener.Start%2A> -Methode, und klicken Sie dann eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001:: / 32. Teredo-Adressen können über die normale DNS-namensauflösung zurückgegeben oder aufgelistet, die als IPv6-Adresse einer lokale Schnittstelle zugewiesen werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" /> method was called after calling the <see cref="M:System.Net.Sockets.TcpListener.Start" /> method</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object containing information about the accept operation. This object is passed to the <c>callback</c> delegate when the operation is complete.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous creation of the <see cref="T:System.Net.Sockets.Socket" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> den Hostnamen des Remotehosts Adresse und den Port identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der Windows Sockets-Version 2 zur API in der MSDN Library unter [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> -Methode zum Erstellen und Verbinden eines Sockets. Der Rückrufdelegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Methode, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" />
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="callback">An <see cref="T:System.AsyncCallback" /> delegate that references the method to invoke when the operation is complete.</param>
        <param name="state">A user-defined object containing information about the accept operation. This object is passed to the <c>callback</c> delegate when the operation is complete.</param>
        <summary>Begins an asynchronous operation to accept an incoming connection attempt.</summary>
        <returns>An <see cref="T:System.IAsyncResult" /> that references the asynchronous creation of the <see cref="T:System.Net.Sockets.TcpClient" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> Vorgang muss abgeschlossen sein, durch den Aufruf der <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Methode. In der Regel wird die Methode aufgerufen, indem die `callback` delegieren.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Verwenden Sie zum Blockieren, bis der Vorgang abgeschlossen ist, die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Calling Synchronous Methods Asynchronously](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der Windows Sockets-Version 2 zur API in der MSDN Library unter [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> -Methode zum Erstellen und Verbinden eines Sockets. Der Rückrufdelegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Methode, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">The port on which to listen for incoming connection attempts.</param>
        <summary>Creates a new <see cref="T:System.Net.Sockets.TcpListener" /> instance to listen on the specified port.</summary>
        <returns>Returns <see cref="T:System.Net.Sockets.TcpListener" />.  A new <see cref="T:System.Net.Sockets.TcpListener" /> instance to listen on the specified port.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" /> method.</param>
        <summary>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.Socket" /> to handle remote host communication.</summary>
        <returns>A <see cref="T:System.Net.Sockets.Socket" />.  The <see cref="T:System.Net.Sockets.Socket" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis der Vorgang ist abgeschlossen. Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> -Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> den Hostnamen des Remotehosts Adresse und den Port identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der Windows Sockets-Version 2 zur API in der MSDN Library unter [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> -Methode zum Erstellen und Verbinden eines Sockets. Der Rückrufdelegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A> Methode, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">The underlying <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
        <exception cref="T:System.ArgumentNullException">The <paramref name="asyncResult" /> parameter is <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">The <paramref name="asyncResult" /> parameter was not created by a call to the <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" /> method.</exception>
        <exception cref="T:System.InvalidOperationException">The <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" /> method was previously called.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while attempting to access the <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" />
      </Parameters>
      <Docs>
        <param name="asyncResult">An <see cref="T:System.IAsyncResult" /> returned by a call to the <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" /> method.</param>
        <summary>Asynchronously accepts an incoming connection attempt and creates a new <see cref="T:System.Net.Sockets.TcpClient" /> to handle remote host communication.</summary>
        <returns>A <see cref="T:System.Net.Sockets.TcpClient" />.  The <see cref="T:System.Net.Sockets.TcpClient" /> used to send and receive data.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode blockiert, bis der Vorgang ist abgeschlossen. Um diesen Vorgang synchron auszuführen, verwenden die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode.  
  
> [!NOTE]
>  Rufen Sie die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A> Eigenschaft für den zugrunde liegenden Socket (<xref:System.Net.Sockets.TcpClient.Client%2A>) den Hostnamen des Remotehosts Adresse und den Port identifizieren.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der Windows Sockets-Version 2 zur API in der MSDN Library unter [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) für eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung von der <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> -Methode zum Erstellen und Verbinden eines Sockets. Der Rückrufdelegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A> Methode, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets or sets a <see cref="T:System.Boolean" /> value that specifies whether the <see cref="T:System.Net.Sockets.TcpListener" /> allows only one underlying socket to listen to a specific port.</summary>
        <value>
          <see langword="true" /> Wenn die <see cref="T:System.Net.Sockets.TcpListener" /> erlaubt es nur einem <see cref="T:System.Net.Sockets.TcpListener" /> um auf einen bestimmten Port zu lauschen, andernfalls <see langword="false" />. sein. Für Windows Server 2003 und Windows XP Service Pack 2 oder höher ist der Standardwert <see langword="true" />, für alle anderen Versionen <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig können mehrere Listener zu einem bestimmten Port lauschen. Allerdings kann nur einer der Listener Vorgänge für den Netzwerkdatenverkehr an den Port gesendete ausführen. Wenn mehrere Listener versucht, die für einen bestimmten Port binden, verarbeitet der Auftrag mit dem die spezifische IP-Adresse den Netzwerkdatenverkehr an diesen Port gesendet werden soll. Sie können die <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A> Eigenschaft, um zu verhindern, dass mehrere Listener zu einem bestimmten Port überwacht.  
  
 Legen Sie diese Eigenschaft vor dem Aufruf <xref:System.Net.Sockets.TcpListener.Start%2A>, oder rufen Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode, und Sie diese Eigenschaft festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird ermittelt und definiert die <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A> Eigenschaft.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The <see cref="T:System.Net.Sockets.TcpListener" /> has been started. Call the <see cref="M:System.Net.Sockets.TcpListener.Stop" /> method and then set the <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" /> property.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred when attempting to access the underlying socket.</exception>
        <exception cref="T:System.ObjectDisposedException">The underlying <see cref="T:System.Net.Sockets.Socket" /> has been closed.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the underlying <see cref="T:System.Net.EndPoint" /> of the current <see cref="T:System.Net.Sockets.TcpListener" />.</summary>
        <value>Die <see cref="T:System.Net.EndPoint" /> , der die <see cref="T:System.Net.Sockets.Socket" /> gebunden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A> Eigenschaft, um die LAN-Schnittstelle und den Port identifizieren, zum Lauschen auf eingehende Anforderungen für die Client-Verbindung, nachdem eine Socket-Verbindung hergestellt wurde. Sie müssen diese zunächst umwandeln <xref:System.Net.EndPoint> auf eine <xref:System.Net.IPEndPoint>. Rufen Sie anschließend die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType> Eigenschaft, um die lokale IP-Adresse abzurufen und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType> Eigenschaft, um die lokale Portnummer abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die lokale IP-Adresse und Port-Nummer angezeigt, auf dem die <xref:System.Net.Sockets.TcpListener> Lauscht auf eingehende verbindungsanforderungen.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Determines if there are pending connection requests.</summary>
        <returns>
          <see langword="true" /> if connections are pending; otherwise, <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode nicht blockierend ermittelt, ob alle ausstehende verbindungsanforderungen. Da der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> und <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methoden blockiert die Ausführung, bis der <xref:System.Net.Sockets.TcpListener.Start%2A> Methode verfügt über eine eingehende verbindungsanforderung, in der Warteschlange der <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode kann verwendet werden, um zu bestimmen, ob die Verbindungen zur Verfügung stehen, bevor Sie versuchen, die die Bedingungen akzeptieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird überprüft die <xref:System.Net.Sockets.TcpListener.Pending%2A> Methode. Wenn eine verbindungsanforderung wartet, um akzeptiert zu werden, klicken Sie dann einen Aufruf der <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode erfolgt.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">The listener has not been started with a call to <see cref="M:System.Net.Sockets.TcpListener.Start" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gets the underlying network <see cref="T:System.Net.Sockets.Socket" />.</summary>
        <value>Der zugrundeliegende <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> erstellt eine <xref:System.Net.Sockets.Socket> zum Lauschen auf eingehende Clientanforderungen Verbindung. Abgeleitete Klassen von <xref:System.Net.Sockets.TcpListener> können diese Eigenschaft verwenden, um dieses <xref:System.Net.Sockets.Socket>. Verwenden Sie das zugrunde liegende <xref:System.Net.Sockets.Socket> zurückgegebenes der <xref:System.Net.Sockets.TcpListener.Server%2A> Eigenschaft, wenn Sie benötigen Zugriff auf darüber hinaus die <xref:System.Net.Sockets.TcpListener> enthält.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.TcpListener.Server%2A> Eigenschaft gibt nur zurück, die <xref:System.Net.Sockets.Socket> zum Lauschen auf eingehende Clientanforderungen Verbindung verwendet. Verwenden der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode akzeptiert eine ausstehende verbindungsanforderung an und erhalten eine <xref:System.Net.Sockets.Socket> für das Senden und Empfangen von Daten. Sie können auch der <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode akzeptiert eine ausstehende verbindungsanforderung an und erhalten eine <xref:System.Net.Sockets.TcpClient> für das Senden und Empfangen von Daten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.TcpListener.Server%2A>-Attributs veranschaulicht. Die zugrunde liegende <xref:System.Net.Sockets.Socket> abgerufen wird und die <xref:System.Net.Sockets.SocketOptionName.Linger> <xref:System.Net.Sockets.Socket> Option wird zu einem Timeout nach 10 Sekunden konfiguriert, wenn die Daten immer noch im Netzwerkpuffer verbleibt, nachdem die Verbindung geschlossen wird.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Starts listening for incoming connection requests.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Starts listening for incoming connection requests.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket>, bindet es an einem lokalen Endpunkt und Lauscht auf eingehende Verbindungsversuche. Wenn eine verbindungsanforderung eingeht, die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode die Anforderung in die Warteschlange und weiterhin zusätzliche Anforderungen warten, bis zum Aufruf der <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode. Wenn <xref:System.Net.Sockets.TcpListener> eine verbindungsanforderung empfängt, nachdem es bereits die maximale Anzahl von Verbindungen in die Warteschlange eingereiht wurde, löst es eine <xref:System.Net.Sockets.SocketException> auf dem Client.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode oder der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode eine Verbindung aus der Warteschlange entfernt und zurückgegeben wird ein <xref:System.Net.Sockets.TcpClient> , dass Sie zum Senden und Empfangen von Daten verwenden können. Die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode gibt eine <xref:System.Net.Sockets.Socket> , Sie verwenden können, können Sie das gleiche erreichen. Wenn Ihre Anwendung nur synchrone e/a erfordert, verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Detaillierte Verhalten Steuerelement verwenden <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>. Beide Methoden blockiert, bis eine verbindungsanforderung, in der Warteschlange verfügbar ist.  
  
 Verwenden der <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode zum Schließen der <xref:System.Net.Sockets.TcpListener> und Beenden der Überwachung. Sie sind verantwortlich für das Schließen von der zulässigen Verbindungen getrennt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Net.Sockets.TcpListener.Start%2A> wird verwendet, um das Lauschen auf eingehende Verbindungsversuche des Clients.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="backlog">The maximum length of the pending connections queue.</param>
        <summary>Starts listening for incoming connection requests with a maximum number of pending connection.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.Start%2A> Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket>, bindet es an einem lokalen Endpunkt und Lauscht auf eingehende Verbindungsversuche. Wenn eine verbindungsanforderung eingeht, <xref:System.Net.Sockets.TcpListener.Start%2A> wird die Anforderung in die Warteschlange und weiterhin zusätzliche Anforderungen warten, bis zum Aufruf der <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode. Wenn <xref:System.Net.Sockets.TcpListener> eine verbindungsanforderung empfängt, nachdem es bereits die maximale Anzahl von Verbindungen in der Warteschlange wurde es löst eine <xref:System.Net.Sockets.SocketException> auf dem Client.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode oder der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> Methode eine Verbindung aus der Warteschlange entfernt und zurückgegeben wird ein <xref:System.Net.Sockets.TcpClient> , dass Sie zum Senden und Empfangen von Daten verwenden können. Die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode gibt eine <xref:System.Net.Sockets.Socket> , Sie verwenden können, können Sie das gleiche erreichen. Wenn Ihre Anwendung nur synchrone e/a erfordert, verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Detaillierte Verhalten Steuerelement verwenden <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> Methode. Beide Methoden blockiert, bis eine verbindungsanforderung, in der Warteschlange verfügbar ist.  
  
 Verwenden der <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode zum Schließen der <xref:System.Net.Sockets.TcpListener> und Beenden der Überwachung. Sie sind verantwortlich für das Schließen von der zulässigen Verbindungen getrennt.  
  
> [!NOTE]
>  Verwenden der <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode abzurufen, und finden in der Windows Sockets-Version 2 zur API in der MSDN Library unter [ http://msdn.microsoft.com/library/ ](http://msdn.microsoft.com/library/) eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Net.Sockets.TcpListener.Start%2A> wird verwendet, um das Lauschen auf eingehende Verbindungsversuche des Clients.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">An error occurred while accessing the socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">The <paramref name="backlog" /> parameter is less than zero or exceeds the maximum number of permitted connections.</exception>
        <exception cref="T:System.InvalidOperationException">The underlying <see cref="T:System.Net.Sockets.Socket" /> is null.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Closes the listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> Schließt den Listener. Alle nicht akzeptierten verbindungsanforderungen in der Warteschlange gehen verloren. Remotehosts wartet auf eine Verbindung zu akzeptierende löst eine <xref:System.Net.Sockets.SocketException>. Sie sind verantwortlich für das Schließen von der zulässigen Verbindungen getrennt.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerkablaufverfolgung in .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.Stop%2A> Methode zum Schließen der zugrunde liegende <xref:System.Net.Sockets.Socket>.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Use the <see cref="P:System.Net.Sockets.SocketException.ErrorCode" /> property to obtain the specific error code. When you have obtained this code, you can refer to the Windows Sockets version 2 API error code documentation in MSDN for a detailed description of the error.</exception>
        <block subset="none" type="usage">
          <para>Die <see cref="M:System.Net.Sockets.TcpListener.Stop" /> auch Methode schließt den zugrunde liegenden <see cref="T:System.Net.Sockets.Socket" />, und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> für die <see cref="T:System.Net.Sockets.TcpListener" />. Wenn Sie keine Eigenschaften für den zugrunde liegenden festlegen <see cref="T:System.Net.Sockets.Socket" /> vor dem Aufrufen der <see cref="M:System.Net.Sockets.TcpListener.Stop" /> -Methode, diese Eigenschaften werden nicht übertragen auf die neue <see cref="T:System.Net.Sockets.Socket" />.</para>
        </block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>