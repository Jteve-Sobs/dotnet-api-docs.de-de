<Type Name="TcpListener" FullName="System.Net.Sockets.TcpListener">
  <Metadata><Meta Name="ms.openlocfilehash" Value="0014908fb18a03875df290ddac98c9fa036dbc98" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75170437" /></Metadata><TypeSignature Language="C#" Value="public class TcpListener" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit TcpListener extends System.Object" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.TcpListener" />
  <TypeSignature Language="VB.NET" Value="Public Class TcpListener" />
  <TypeSignature Language="C++ CLI" Value="public ref class TcpListener" />
  <TypeSignature Language="F#" Value="type TcpListener = class" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Überwacht Verbindungen von TCP-Netzwerkclients.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener>-Klasse stellt einfache Methoden bereit, die eingehende Verbindungsanforderungen beim Blockieren des synchronen Modus lauschen und akzeptieren. Sie können entweder eine <xref:System.Net.Sockets.TcpClient> oder eine <xref:System.Net.Sockets.Socket> verwenden, um eine Verbindung mit einem <xref:System.Net.Sockets.TcpListener>herzustellen. Erstellen Sie eine <xref:System.Net.Sockets.TcpListener> mit einem <xref:System.Net.IPEndPoint>, einer lokalen IP-Adresse und einer Portnummer oder nur einer Portnummer. Geben Sie <xref:System.Net.IPAddress.Any> für die lokale IP-Adresse und den Wert 0 für die lokale Portnummer an, wenn der zugrunde liegende Dienstanbieter diese Werte zuweisen soll. Wenn Sie sich dafür entscheiden, können Sie die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>-Eigenschaft verwenden, um die zugewiesenen Informationen zu identifizieren, nachdem der Socket eine Verbindung hergestellt hat.  
  
 Verwenden Sie die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode, um das Lauschen auf eingehende Verbindungsanforderungen zu starten. <xref:System.Net.Sockets.TcpListener.Start%2A> werden eingehende Verbindungen in die Warteschlange eingereiht, bis Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode oder <xref:System.Net.Sockets.SocketOptionName.MaxConnections>in der Warteschlange aufgerufen haben. Verwenden Sie entweder <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> oder <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>, um eine Verbindung aus der Warteschlange für eingehende Verbindungsanforderungen abzurufen. Diese beiden Methoden werden blockiert. Wenn Sie das Blockieren vermeiden möchten, können Sie zuerst die <xref:System.Net.Sockets.TcpListener.Pending%2A>-Methode verwenden, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange verfügbar sind.  
  
 Ruft die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode auf, um die <xref:System.Net.Sockets.TcpListener>zu schließen.  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode schließt keine akzeptierten Verbindungen. Sie sind dafür verantwortlich, diese separat zu schließen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.TcpListener>erstellt.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 Ein Client Beispiel finden Sie unter <xref:System.Net.Sockets.TcpClient>.  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">, Um eine ausgehende Verbindung herzustellen oder eine eingehende Anforderung zu akzeptieren.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.Obsolete("Use TcpListener (IPAddress address, int port) instead")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1;netcore-3.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-1.1">
          <AttributeName>System.Obsolete("Use TcpListener(IPAddress localaddr, int port).")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-3.0;netstandard-2.1">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. https://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0">
          <AttributeName>System.Obsolete("This method has been deprecated. Please use TcpListener(IPAddress localaddr, int port) instead. http://go.microsoft.com/fwlink/?linkid=14202")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse, die den angegebenen Anschluss überwacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor ist veraltet. Verwenden Sie die <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPAddress%2CSystem.Int32%29?displayProperty=nameWithType>-oder <xref:System.Net.Sockets.TcpListener.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>-Konstruktoren.  
  
 Mit diesem Konstruktor können Sie die Portnummer angeben, auf der auf eingehende Verbindungsversuche gelauscht werden soll. Mit diesem Konstruktor weist der zugrunde liegende Dienstanbieter die am besten geeignete Netzwerkadresse zu. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall weist der Dienstanbieter eine verfügbare kurzlebige Portnummer zu. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche Adresse und Portnummer des lokalen Netzwerks mithilfe der <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>-Eigenschaft zugewiesen wurden.  
  
 Ruft die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.TcpListener> mit einer lokalen Portnummer erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPEndPoint -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Ein <see cref="T:System.Net.IPEndPoint" />, der den lokalen Endpunkt darstellt, an den der Listener-<see cref="T:System.Net.Sockets.Socket" /> gebunden werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse mit dem angegebenen lokalen Endpunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor können Sie die lokale IP-Adresse und die Portnummer angeben, für die auf eingehende Verbindungsversuche gelauscht werden soll. Bevor Sie diesen Konstruktor verwenden, müssen Sie eine <xref:System.Net.IPEndPoint> mithilfe der gewünschten lokalen IP-Adresse und Portnummer erstellen. Übergeben Sie diese <xref:System.Net.IPEndPoint> als `localEP`-Parameter an den Konstruktor.  
  
 Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, können Sie eine <xref:System.Net.IPEndPoint> mit <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> als Adress Parameter erstellen, und der zugrunde liegende Dienstanbieter weist die am besten geeignete Netzwerkadresse zu. Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie eine <xref:System.Net.IPEndPoint> mit 0 für die Portnummer erstellen. In diesem Fall weist der Dienstanbieter eine verfügbare kurzlebige Portnummer zu. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche Adresse und Portnummer des lokalen Netzwerks mithilfe der <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>-Eigenschaft zugewiesen wurden.  
  
 Ruft die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der <xref:System.Net.Sockets.TcpListener>-Klasse mit dem lokalen Endpunkt erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> ist <see langword="null" />.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public TcpListener (System.Net.IPAddress localaddr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPAddress localaddr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.#ctor(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localaddr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TcpListener(System::Net::IPAddress ^ localaddr, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.TcpListener : System.Net.IPAddress * int -&gt; System.Net.Sockets.TcpListener" Usage="new System.Net.Sockets.TcpListener (localaddr, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localaddr" Type="System.Net.IPAddress" />
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="localaddr">Eine <see cref="T:System.Net.IPAddress" />, die die lokale IP-Adresse darstellt.</param>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse, die die eingehenden Verbindungsversuche mit der angegebenen lokalen IP-Adresse und Anschlussnummer überwacht.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit diesem Konstruktor können Sie die lokale IP-Adresse und die Portnummer angeben, für die auf eingehende Verbindungsversuche gelauscht werden soll. Vor dem Aufrufen dieses Konstruktors müssen Sie zuerst einen <xref:System.Net.IPAddress> mithilfe der gewünschten lokalen Adresse erstellen. Übergeben Sie diese <xref:System.Net.IPAddress> als `localaddr`-Parameter an den Konstruktor. Wenn Sie nicht sicher sind, welche lokale Adresse zugewiesen ist, geben Sie <xref:System.Net.IPAddress.Any?displayProperty=nameWithType> für den Parameter `localaddr` an, und der zugrunde liegende Dienstanbieter weist die am besten geeignete Netzwerkadresse zu. Dies kann dazu beitragen, Ihre Anwendung zu vereinfachen, wenn Sie über mehrere Netzwerkschnittstellen verfügen. Wenn Sie nicht sicher sind, welcher lokale Port verwendet wird, können Sie für die Portnummer 0 angeben. In diesem Fall weist der Dienstanbieter eine verfügbare Portnummer zwischen 1024 und 5000 zu. Wenn Sie diesen Ansatz verwenden, können Sie ermitteln, welche Adresse und Portnummer des lokalen Netzwerks mithilfe der <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>-Eigenschaft zugewiesen wurden.  
  
 Ruft die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode auf, um mit der Überwachung eingehender Verbindungsversuche zu beginnen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine Instanz der <xref:System.Net.Sockets.TcpListener>-Klasse unter Verwendung einer lokalen IP-Adresse und Portnummer erstellt.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localaddr" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket AcceptSocket() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocket () As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ AcceptSocket();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : unit -&gt; System.Net.Sockets.Socket" Usage="tcpListener.AcceptSocket " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Verbindungsanforderung an.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> ist eine blockierende Methode, die eine <xref:System.Net.Sockets.Socket> zurückgibt, die Sie zum Senden und empfangen von Daten verwenden können. Wenn Sie Blockierungen vermeiden möchten, verwenden Sie die <xref:System.Net.Sockets.TcpListener.Pending%2A>-Methode, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange für eingehende Verbindungen verfügbar sind.  
  
 Der zurückgegebene <xref:System.Net.Sockets.Socket> wird mit der IP-Adresse und der Portnummer des Remote Hosts initialisiert. Sie können jede der <xref:System.Net.Sockets.Socket.Send%2A>-und <xref:System.Net.Sockets.Socket.Receive%2A> Methoden verwenden, die in der <xref:System.Net.Sockets.Socket>-Klasse zur Kommunikation mit dem Remote Host verfügbar sind. Wenn Sie die <xref:System.Net.Sockets.Socket>nicht mehr benötigen, müssen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufzurufen. Wenn Ihre Anwendung relativ einfach ist, sollten Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode anstelle der <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode verwenden. <xref:System.Net.Sockets.TcpClient> bietet Ihnen einfache Methoden zum Senden und empfangen von Daten über ein Netzwerk im Modus zum Blockieren des synchronen Modus.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode verwendet, um eine <xref:System.Net.Sockets.Socket>zurückzugeben. Diese <xref:System.Net.Sockets.Socket> wird für die Kommunikation mit dem neu verbundenen Client verwendet.  
  
 [!code-cpp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic TcpListener.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListener.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptSocketAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt; AcceptSocketAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.Socket&gt; AcceptSocketAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptSocketAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptSocketAsync () As Task(Of Socket)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::Socket ^&gt; ^ AcceptSocketAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptSocketAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;" Usage="tcpListener.AcceptSocketAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.Socket&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Aufforderung zum Aufbau einer Verbindung als asynchroner Vorgang an.</summary>
        <returns>Das Taskobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Task-Objekt gibt <see cref="T:System.Net.Sockets.Socket" /> zurück, das verwendet wird, um Daten zu senden und zu empfangen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die Socketverbindung akzeptiert wurde.  
  
 Das in <xref:System.Threading.Tasks.Task%601> zurückgegebene <xref:System.Net.Sockets.Socket> wird mit der IP-Adresse und der Portnummer des Remote Hosts initialisiert. Sie können jede der <xref:System.Net.Sockets.Socket.Send%2A>-und <xref:System.Net.Sockets.Socket.Receive%2A> Methoden verwenden, die in der <xref:System.Net.Sockets.Socket>-Klasse zur Kommunikation mit dem Remote Host verfügbar sind. Wenn Sie die <xref:System.Net.Sockets.Socket>nicht mehr benötigen, müssen Sie die <xref:System.Net.Sockets.Socket.Close%2A>-Methode aufzurufen. Wenn Ihre Anwendung relativ einfach ist, sollten Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode anstelle der <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>-Methode verwenden. <xref:System.Net.Sockets.TcpClient> bietet Ihnen einfache Methoden zum Senden und empfangen von Daten über ein Netzwerk im Modus zum Blockieren des synchronen Modus.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Pending" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient AcceptTcpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient AcceptTcpClient() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClient () As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ AcceptTcpClient();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClient : unit -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.AcceptTcpClient " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Verbindungsanforderung an.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.TcpClient" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> ist eine blockierende Methode, die eine <xref:System.Net.Sockets.TcpClient> zurückgibt, die Sie zum Senden und empfangen von Daten verwenden können. Verwenden Sie die <xref:System.Net.Sockets.TcpListener.Pending%2A>-Methode, um zu bestimmen, ob Verbindungsanforderungen in der Warteschlange für eingehende Verbindungen verfügbar sind, wenn Sie Blockierungen vermeiden möchten.  
  
 Verwenden Sie die <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.NetworkStream> der zurückgegebenen <xref:System.Net.Sockets.TcpClient>abzurufen. Der <xref:System.Net.Sockets.NetworkStream> stellt Ihnen Methoden zum Senden und empfangen mit dem Remote Host zur Verfügung. Wenn Sie die <xref:System.Net.Sockets.TcpClient>durchlaufen, achten Sie darauf, die <xref:System.Net.Sockets.TcpClient.Close%2A>-Methode aufzurufen. Wenn Sie mehr Flexibilität als ein <xref:System.Net.Sockets.TcpClient> Angebote wünschen, sollten Sie die Verwendung <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>in Erwägung gezogen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode verwendet, um eine <xref:System.Net.Sockets.TcpClient>zurückzugeben. Diese <xref:System.Net.Sockets.TcpClient> wird für die Kommunikation mit dem neu verbundenen Client verwendet.  
  
 [!code-cpp[Classic TcpListenerExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic TcpListenerExample/CPP/source.cpp#1)]
 [!code-csharp[Classic TcpListenerExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic TcpListenerExample/CS/source.cs#1)]
 [!code-vb[Classic TcpListenerExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic TcpListenerExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="AcceptTcpClientAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;class System.Net.Sockets.TcpClient&gt; AcceptTcpClientAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AcceptTcpClientAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function AcceptTcpClientAsync () As Task(Of TcpClient)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::TcpClient ^&gt; ^ AcceptTcpClientAsync();" />
      <MemberSignature Language="F#" Value="member this.AcceptTcpClientAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;" Usage="tcpListener.AcceptTcpClientAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.TcpClient&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Nimmt eine ausstehende Aufforderung zum Aufbau einer Verbindung als asynchroner Vorgang an.</summary>
        <returns>Das Taskobjekt, das den asynchronen Vorgang darstellt. Die <see cref="P:System.Threading.Tasks.Task`1.Result" />-Eigenschaft im Task-Objekt gibt <see cref="T:System.Net.Sockets.TcpClient" /> zurück, das verwendet wird, um Daten zu senden und zu empfangen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Das zurückgegebene <xref:System.Threading.Tasks.Task%601> Objekt wird abgeschlossen, nachdem die TCP-Verbindung akzeptiert wurde.  
  
 Verwenden Sie die <xref:System.Net.Sockets.TcpClient.GetStream%2A?displayProperty=nameWithType>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.NetworkStream> der zurückgegebenen <xref:System.Net.Sockets.TcpClient> in der <xref:System.Threading.Tasks.Task%601>abzurufen. Der <xref:System.Net.Sockets.NetworkStream> stellt Ihnen Methoden zum Senden und empfangen mit dem Remote Host zur Verfügung. Wenn Sie die <xref:System.Net.Sockets.TcpClient>durchlaufen, achten Sie darauf, die <xref:System.Net.Sockets.TcpClient.Close%2A>-Methode aufzurufen. Wenn Sie mehr Flexibilität als ein <xref:System.Net.Sockets.TcpClient> Angebote wünschen, sollten Sie die Verwendung <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> oder <xref:System.Net.Sockets.TcpListener.AcceptSocketAsync%2A>in Erwägung gezogen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="T:System.Net.Sockets.TcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.Sockets.NetworkStream" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Active" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool" Usage="System.Net.Sockets.TcpListener.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob <see cref="T:System.Net.Sockets.TcpListener" /> Clientverbindungen aktiv überwacht.</summary>
        <value><see langword="true" />, wenn <see cref="T:System.Net.Sockets.TcpListener" /> aktiv überwacht, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von <xref:System.Net.Sockets.TcpListener> abgeleitet werden, können diese Eigenschaft verwenden, um zu bestimmen, ob die <xref:System.Net.Sockets.Socket> derzeit auf eingehende Verbindungsversuche lauscht. Die <xref:System.Net.Sockets.TcpClient.Active%2A>-Eigenschaft kann verwendet werden, um redundante <xref:System.Net.Sockets.TcpListener.Start%2A> Versuche zu vermeiden.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="tcpListener.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="allowed">Ein boolescher Wert, der angibt, ob die NAT-Überquerung aktiviert oder deaktiviert werden soll.</param>
        <summary>Aktiviert oder deaktiviert die NAT-Überquerung (Netzwerkadressenübersetzung) für eine <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A>-Methode wird verwendet, um den NAT-Durchlauf für eine <xref:System.Net.Sockets.TcpListener> Instanz zu aktivieren oder zu deaktivieren. NAT-Durchlauf kann mithilfe von Teredo, IPv6-zu-IPv4 oder einem ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn der `allowed`-Parameter false ist, wird die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>-Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>festgelegt. Dadurch wird der NAT-Durchlauf für eine <xref:System.Net.Sockets.TcpListener> Instanz explizit deaktiviert.  
  
 Wenn der `allowed`-Parameter true ist, wird die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>-Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>festgelegt. Dies kann die NAT-Überquerung für eine <xref:System.Net.Sockets.TcpListener> abhängig von Firewallregeln auf dem System ermöglichen.  
  
 Die <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A>-Methode muss aufgerufen werden, bevor die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode aufgerufen wird, um mit dem lauschen auf eingehende Verbindungsanforderungen (vor dem Binden des Sockets) zu beginnen. Wenn <xref:System.Net.Sockets.TcpListener.AllowNatTraversal%2A>-Methode nach der <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode aufgerufen wird, wird eine <xref:System.InvalidOperationException> ausgelöst.  
  
 Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001::/32. Teredo-Adressen können über die normale DNS-Namensauflösung zurückgegeben oder als eine IPv6-Adresse aufgezählt werden, die einer lokalen Schnittstelle zugewiesen ist.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />-Methode wird nach dem Aufruf der <see cref="M:System.Net.Sockets.TcpListener.Start" />-Methode aufgerufen.</exception>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptSocket">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptSocket (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptSocket(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptSocket (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptSocket(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptSocket : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptSocket (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Annahmevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Erstellung des <see cref="T:System.Net.Sockets.Socket" /> verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> aufgerufen werden, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A>-Methode, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>-Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginAcceptTcpClient">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginAcceptTcpClient (AsyncCallback callback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginAcceptTcpClient(class System.AsyncCallback callback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginAcceptTcpClient (callback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginAcceptTcpClient(AsyncCallback ^ callback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginAcceptTcpClient : AsyncCallback * obj -&gt; IAsyncResult" Usage="tcpListener.BeginAcceptTcpClient (callback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="callback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="callback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Annahmevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="callback" />-Delegaten übergeben.</param>
        <summary>Beginnt einen asynchronen Vorgang, um eine eingehende Verbindung anzunehmen.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf die asynchrone Erstellung des <see cref="T:System.Net.Sockets.TcpClient" /> verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `callback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang abgeschlossen ist, verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A>-Methode, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>-Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Create">
      <MemberSignature Language="C#" Value="public static System.Net.Sockets.TcpListener Create (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Net.Sockets.TcpListener Create(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Create(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Create (port As Integer) As TcpListener" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Net::Sockets::TcpListener ^ Create(int port);" />
      <MemberSignature Language="F#" Value="static member Create : int -&gt; System.Net.Sockets.TcpListener" Usage="System.Net.Sockets.TcpListener.Create port" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpListener</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <summary>Erstellt eine neue auf dem angegebenen Port lauschende <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</summary>
        <returns>Eine neue auf dem angegebenen Port lauschende <see cref="T:System.Net.Sockets.TcpListener" />-Instanz.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket EndAcceptSocket (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.Socket EndAcceptSocket(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptSocket (asyncResult As IAsyncResult) As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::Socket ^ EndAcceptSocket(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptSocket : IAsyncResult -&gt; System.Net.Sockets.Socket" Usage="tcpListener.EndAcceptSocket asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein durch einen Aufruf der <see cref="T:System.IAsyncResult" />-Methode zurückgegebenes <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.Socket" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.Socket" />.  
  
Ein <see cref="T:System.Net.Sockets.Socket" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist. Verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode, um diesen Vorgang synchron auszuführen.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zurückgegebenen <xref:System.Net.Sockets.Socket> aufgerufen werden, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.BeginAcceptSocket%2A>-Methode, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptSocket%2A>-Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#4)]
 [!code-csharp[System.Net.Sockets.TcpListener1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#4)]
 [!code-vb[System.Net.Sockets.TcpListener1#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException">Der Parameter <paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der <paramref name="asyncResult" />-Parameter wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptSocket(System.AsyncCallback,System.Object)" />-Methode erstellt.</exception>
        <exception cref="T:System.InvalidOperationException">Die <see cref="M:System.Net.Sockets.TcpListener.EndAcceptSocket(System.IAsyncResult)" />-Methode wurde bereits zuvor aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndAcceptTcpClient">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TcpClient EndAcceptTcpClient (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Net.Sockets.TcpClient EndAcceptTcpClient(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.EndAcceptTcpClient(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndAcceptTcpClient (asyncResult As IAsyncResult) As TcpClient" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Net::Sockets::TcpClient ^ EndAcceptTcpClient(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndAcceptTcpClient : IAsyncResult -&gt; System.Net.Sockets.TcpClient" Usage="tcpListener.EndAcceptTcpClient asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TcpClient</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein durch einen Aufruf der <see cref="T:System.IAsyncResult" />-Methode zurückgegebenes <see cref="M:System.Net.Sockets.TcpListener.BeginAcceptTcpClient(System.AsyncCallback,System.Object)" />.</param>
        <summary>Nimmt asynchron einen eingehenden Verbindungsversuch an und erstellt einen neuen <see cref="T:System.Net.Sockets.TcpClient" /> zum Behandeln der Remotehostkommunikation.</summary>
        <returns>Ein <see cref="T:System.Net.Sockets.TcpClient" />.  
  
Ein <see cref="T:System.Net.Sockets.TcpClient" /> zum Senden und Empfangen von Daten.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist. Verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode, um diesen Vorgang synchron auszuführen.  
  
> [!NOTE]
>  Sie können die <xref:System.Net.Sockets.Socket.RemoteEndPoint%2A>-Eigenschaft des zugrunde liegenden Sockets (<xref:System.Net.Sockets.TcpClient.Client%2A>) abrufen, um die Netzwerkadresse und die Portnummer des Remote Hosts zu identifizieren.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.BeginAcceptTcpClient%2A>-Methode, um einen Socket zu erstellen und zu verbinden. Der Rückruf Delegat ruft die <xref:System.Net.Sockets.TcpListener.EndAcceptTcpClient%2A>-Methode auf, um die asynchrone Anforderung zu beenden.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#5)]
 [!code-csharp[System.Net.Sockets.TcpListener1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#5)]
 [!code-vb[System.Net.Sockets.TcpListener1#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.TcpListener.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.TcpListener" /> das Überwachen eines bestimmten Anschlusses durch nur einen einzigen zugrunde liegenden Socket zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.TcpListener" /> das Überwachen eines bestimmten Anschlusses durch nur einen einzigen <see cref="T:System.Net.Sockets.TcpListener" /> zulässt, andernfalls <see langword="false" />. . Für Windows Server 2003 und Windows XP Service Pack 2 oder höher ist der Standardwert <see langword="true" />, für alle anderen Versionen <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig können mehrere Listener an einem bestimmten Port lauschen. Allerdings kann nur einer der Listener Vorgänge für den Netzwerk Datenverkehr ausführen, der an den Port gesendet wird. Wenn mehr als ein Listener versucht, eine Bindung an einen bestimmten Port durchzusetzen, verarbeitet der eine mit der spezifischeren IP-Adresse den Netzwerk Datenverkehr, der an diesen Port gesendet wird. Sie können die <xref:System.Net.Sockets.Socket.ExclusiveAddressUse%2A>-Eigenschaft verwenden, um zu verhindern, dass mehrere Listener an einem bestimmten Port lauschen.  
  
 Legen Sie diese Eigenschaft vor dem Aufrufen von <xref:System.Net.Sockets.TcpListener.Start%2A>fest, oder rufen Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode auf, und legen Sie diese Eigenschaft  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.TcpListener.ExclusiveAddressUse%2A>-Eigenschaft abgerufen und festgelegt.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#2)]
 [!code-csharp[System.Net.Sockets.TcpListener1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#2)]
 [!code-vb[System.Net.Sockets.TcpListener1#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.TcpListener" /> wurde gestartet. Rufen Sie die <see cref="M:System.Net.Sockets.TcpListener.Stop" />-Methode auf, und legen Sie anschließend die <see cref="P:System.Net.Sockets.Socket.ExclusiveAddressUse" />-Eigenschaft fest.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den zugrunde liegenden Socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~TcpListener ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!TcpListener ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="tcpListener.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt von der <see cref="T:System.Net.Sockets.TcpListener" />-Klasse verwendete Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Der <xref:System.Net.Sockets.TcpListener> Klassen-Finalizer freie Ressourcen, die der <xref:System.Net.Sockets.TcpListener> Instanz zugeordnet sind.

]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LocalEndpoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint LocalEndpoint { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint LocalEndpoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LocalEndpoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ LocalEndpoint { System::Net::EndPoint ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LocalEndpoint : System.Net.EndPoint" Usage="System.Net.Sockets.TcpListener.LocalEndpoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden <see cref="T:System.Net.EndPoint" /> des aktuellen <see cref="T:System.Net.Sockets.TcpListener" /> ab.</summary>
        <value>Der <see cref="T:System.Net.EndPoint" />, an den der <see cref="T:System.Net.Sockets.Socket" /> gebunden ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können die <xref:System.Net.Sockets.TcpListener.LocalEndpoint%2A>-Eigenschaft verwenden, um die lokale Netzwerkschnittstelle und die Portnummer zu identifizieren, die zum lauschen auf eingehende Client Verbindungsanforderungen verwendet werden, nachdem eine Socketverbindung hergestellt wurde. Sie müssen diese <xref:System.Net.EndPoint> zuerst in eine <xref:System.Net.IPEndPoint>umwandeln. Anschließend können Sie die <xref:System.Net.IPEndPoint.Address%2A?displayProperty=nameWithType>-Eigenschaft aufrufen, um die lokale IP-Adresse abzurufen, und die <xref:System.Net.IPEndPoint.Port%2A?displayProperty=nameWithType>-Eigenschaft, um die lokale Portnummer abzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel werden die lokale IP-Adresse und die Portnummer angezeigt, auf denen der <xref:System.Net.Sockets.TcpListener> auf eingehende Verbindungsanforderungen lauscht.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="T:System.Net.EndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Pending">
      <MemberSignature Language="C#" Value="public bool Pending ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Pending() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Pending" />
      <MemberSignature Language="VB.NET" Value="Public Function Pending () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Pending();" />
      <MemberSignature Language="F#" Value="member this.Pending : unit -&gt; bool" Usage="tcpListener.Pending " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bestimmt, ob ausstehende Verbindungsanforderungen vorliegen.</summary>
        <returns><see langword="true" />, wenn Verbindungen ausstehen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese nicht blockierende Methode bestimmt, ob ausstehende Verbindungsanforderungen vorhanden sind. Da die Methoden <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A> und <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A> die Ausführung blockieren, bis die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode eine eingehende Verbindungsanforderung in die Warteschlange eingereiht hat, kann mithilfe der <xref:System.Net.Sockets.TcpListener.Pending%2A>-Methode bestimmt werden, ob Verbindungen verfügbar sind, bevor Sie versuchen, Sie zu akzeptieren.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die <xref:System.Net.Sockets.TcpListener.Pending%2A>-Methode überprüft. Wenn eine Verbindungsanforderung darauf wartet, akzeptiert zu werden, wird ein Rückruf der <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode durchgeführt.  
  
 [!code-cpp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/cpp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CPP/source.cpp#1)]
 [!code-csharp[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/CS/source.cs#1)]
 [!code-vb[TcpListener_Pending_LocalEndPoint#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListener_Pending_LocalEndPoint/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Der Listener wurde nicht mit einem Aufruf von <see cref="M:System.Net.Sockets.TcpListener.Start" /> gestartet.</exception>
        <altmember cref="M:System.Net.Sockets.TcpListener.Start" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <Member MemberName="Server">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Server { get; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Server" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Server As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Server : System.Net.Sockets.Socket" Usage="System.Net.Sockets.TcpListener.Server" />
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Server { get; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected ReadOnly Property Server As Socket" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Server { System::Net::Sockets::Socket ^ get(); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden Netzwerk-<see cref="T:System.Net.Sockets.Socket" /> ab.</summary>
        <value>Der zugrundeliegende <see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener> erstellt eine <xref:System.Net.Sockets.Socket>, um auf eingehende Client Verbindungsanforderungen zu lauschen. Klassen, die von <xref:System.Net.Sockets.TcpListener> abgeleitet werden, können diese Eigenschaft verwenden, um diese <xref:System.Net.Sockets.Socket>zu erhalten. Verwenden Sie die zugrunde liegende <xref:System.Net.Sockets.Socket>, die von der <xref:System.Net.Sockets.TcpListener.Server%2A>-Eigenschaft zurückgegeben wird, wenn Sie über die, die <xref:System.Net.Sockets.TcpListener> bereitstellt,  
  
> [!NOTE]
>  Die <xref:System.Net.Sockets.TcpListener.Server%2A>-Eigenschaft gibt nur den <xref:System.Net.Sockets.Socket> zurück, der zum lauschen auf eingehende Client Verbindungsanforderungen verwendet wird. Verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode, um eine ausstehende Verbindungsanforderung zu akzeptieren und eine <xref:System.Net.Sockets.Socket> für das Senden und empfangen von Daten zu erhalten. Sie können auch die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode verwenden, um eine ausstehende Verbindungsanforderung zu akzeptieren und eine <xref:System.Net.Sockets.TcpClient> für das Senden und empfangen von Daten zu erhalten.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung des <xref:System.Net.Sockets.TcpListener.Server%2A>-Attributs veranschaulicht. Die zugrunde liegende <xref:System.Net.Sockets.Socket> wird abgerufen, und die <xref:System.Net.Sockets.SocketOptionName.Linger><xref:System.Net.Sockets.Socket>-Option ist so konfiguriert, dass nach 10 Sekunden ein Timeout auftritt, wenn die Daten nach dem Schließen der Verbindung noch im Netzwerk Puffer verbleiben.  
  
 [!code-csharp[TcpListenerProtectedMembers1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/TcpListenerProtectedMembers1/CS/source.cs#1)]
 [!code-vb[TcpListenerProtectedMembers1#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/TcpListenerProtectedMembers1/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Start">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beginnt die Überwachung von eingehenden Verbindungsanforderungen.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start();" />
      <MemberSignature Language="F#" Value="member this.Start : unit -&gt; unit" Usage="tcpListener.Start " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beginnt die Überwachung von eingehenden Verbindungsanforderungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket>, bindet Sie an einen lokalen Endpunkt und lauscht auf eingehende Verbindungsversuche. Wenn eine Verbindungsanforderung empfangen wird, wird die Anforderung durch die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode in die Warteschlange eingereiht, bis Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode aufruft. Wenn <xref:System.Net.Sockets.TcpListener> eine Verbindungsanforderung empfängt, nachdem diese bereits die maximale Anzahl von Verbindungen in die Warteschlange eingereiht hat, löst Sie eine <xref:System.Net.Sockets.SocketException> auf dem Client aus.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode oder die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode entfernt eine Verbindung aus der Warteschlange und gibt eine <xref:System.Net.Sockets.TcpClient> zurück, die Sie zum Senden und empfangen von Daten verwenden können. Die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode gibt eine <xref:System.Net.Sockets.Socket> zurück, die Sie verwenden können, um das gleiche zu tun. Wenn Ihre Anwendung nur synchrone e/a-Vorgänge erfordert, verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>, um eine ausführlichere Verhaltenskontrolle zu erhalten. Beide Methoden blockieren, bis eine Verbindungsanforderung in der Warteschlange verfügbar ist.  
  
 Verwenden Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode, um die <xref:System.Net.Sockets.TcpListener> zu schließen und die Überwachung zu beenden. Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Net.Sockets.TcpListener.Start%2A> zum lauschen auf eingehende Client Verbindungsversuche verwendet wird.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Start">
      <MemberSignature Language="C#" Value="public void Start (int backlog);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Start(int32 backlog) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Start(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Start (backlog As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Start(int backlog);" />
      <MemberSignature Language="F#" Value="member this.Start : int -&gt; unit" Usage="tcpListener.Start backlog" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="backlog" Type="System.Int32" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="backlog">Die maximale Länge der Warteschlange für ausstehende Verbindungen.</param>
        <summary>Beginnt die Überwachung eingehender Verbindungsanforderungen mit einer maximalen Anzahl ausstehender Verbindungen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.TcpListener.Start%2A>-Methode initialisiert die zugrunde liegende <xref:System.Net.Sockets.Socket>, bindet Sie an einen lokalen Endpunkt und lauscht auf eingehende Verbindungsversuche. Wenn eine Verbindungsanforderung empfangen wird, wird die Anforderung von <xref:System.Net.Sockets.TcpListener.Start%2A> in die Warteschlange eingereiht, bis Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode aufgerufen haben. Wenn <xref:System.Net.Sockets.TcpListener> eine Verbindungsanforderung empfängt, nachdem Sie bereits die maximale Anzahl von Verbindungen in die Warteschlange eingereiht hat, wird eine <xref:System.Net.Sockets.SocketException> auf dem Client ausgelöst.  
  
 Um eine Verbindung aus der Warteschlange für eingehende Verbindungen zu entfernen, verwenden Sie entweder die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode oder die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode. Die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>-Methode entfernt eine Verbindung aus der Warteschlange und gibt eine <xref:System.Net.Sockets.TcpClient> zurück, die Sie zum Senden und empfangen von Daten verwenden können. Die <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode gibt eine <xref:System.Net.Sockets.Socket> zurück, die Sie verwenden können, um das gleiche zu tun. Wenn Ihre Anwendung nur synchrone e/a-Vorgänge erfordert, verwenden Sie die <xref:System.Net.Sockets.TcpListener.AcceptTcpClient%2A>. Verwenden Sie <xref:System.Net.Sockets.TcpListener.AcceptSocket%2A>-Methode, um eine ausführlichere Verhaltenskontrolle zu erhalten. Beide Methoden blockieren, bis eine Verbindungsanforderung in der Warteschlange verfügbar ist.  
  
 Verwenden Sie die <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode, um die <xref:System.Net.Sockets.TcpListener> zu schließen und die Überwachung zu beenden. Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Verwenden Sie die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>-Eigenschaft, um den spezifischen Fehlercode abzurufen. In der Dokumentation zu API-Fehlercodes unter [Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) finden Sie eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie <xref:System.Net.Sockets.TcpListener.Start%2A> zum lauschen auf eingehende Client Verbindungsversuche verwendet wird.  
  
 [!code-cpp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/cpp/tcpserver.cpp#3)]
 [!code-csharp[System.Net.Sockets.TcpListener1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/CS/tcpserver.cs#3)]
 [!code-vb[System.Net.Sockets.TcpListener1#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener1/VB/tcpserver.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den Socket.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="backlog" />-Parameter ist kleiner als 0 (null) oder übersteigt die maximale Anzahl zulässiger Verbindungen.</exception>
        <exception cref="T:System.InvalidOperationException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> ist NULL.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Listen(System.Int32)" />
        <altmember cref="M:System.Net.Sockets.Socket.Bind(System.Net.EndPoint)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptTcpClient" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AcceptSocket" />
        <altmember cref="M:System.Net.Sockets.TcpListener.Stop" />
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.TcpListener.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="tcpListener.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt den Listener.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.TcpListener.Stop%2A> schließt den Listener. Alle nicht akzeptierten Verbindungsanforderungen in der Warteschlange gehen verloren. Remote Hosts, die darauf warten, dass eine Verbindung akzeptiert wird, lösen eine <xref:System.Net.Sockets.SocketException>aus. Sie sind dafür verantwortlich, die akzeptierten Verbindungen separat zu schließen.  
  
> [!NOTE]
>  Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren. Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht die Verwendung der <xref:System.Net.Sockets.TcpListener.Stop%2A>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.Socket>zu schließen.  
  
 [!code-cpp[System.Net.Sockets.TcpListener#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CPP/tcpserver.cpp#1)]
 [!code-csharp[System.Net.Sockets.TcpListener#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/CS/tcpserver.cs#1)]
 [!code-vb[System.Net.Sockets.TcpListener#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.TcpListener/VB/tcpserver.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Mit der <see cref="P:System.Net.Sockets.SocketException.ErrorCode" />-Eigenschaft können Sie den spezifischen Fehlercode abrufen. Wenn Sie diesen Code abgerufen haben, finden Sie in der Dokumentation zu API-Fehlercodes unter <see href="/windows/desktop/winsock/windows-sockets-error-codes-2">Windows Sockets, Version 2</see>, eine ausführliche Beschreibung des Fehlers.</exception>
        <block subset="none" type="usage"><para>Die <see cref="M:System.Net.Sockets.TcpListener.Stop" />-Methode schließt außerdem die zugrunde liegende <see cref="T:System.Net.Sockets.Socket" />und erstellt eine neue <see cref="T:System.Net.Sockets.Socket" /> für die <see cref="T:System.Net.Sockets.TcpListener" />. Wenn Sie Eigenschaften für den zugrunde liegenden <see cref="T:System.Net.Sockets.Socket" /> festlegen, bevor Sie die <see cref="M:System.Net.Sockets.TcpListener.Stop" />-Methode aufrufen, werden diese Eigenschaften nicht auf den neuen <see cref="T:System.Net.Sockets.Socket" />übertragen.</para></block>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
  </Members>
</Type>
