<Type Name="UdpClient" FullName="System.Net.Sockets.UdpClient">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d10194c5809c1b262628083d69fef9615fb15785" /><Meta Name="ms.sourcegitcommit" Value="8ae9a18b248625c8e1851e607c00346a64849587" /><Meta Name="ms.translationtype" Value="HT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/17/2019" /><Meta Name="ms.locfileid" Value="75110910" /></Metadata><TypeSignature Language="C#" Value="public class UdpClient : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit UdpClient extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.UdpClient" />
  <TypeSignature Language="VB.NET" Value="Public Class UdpClient&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class UdpClient : IDisposable" />
  <TypeSignature Language="F#" Value="type UdpClient = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
    <AssemblyVersion>4.2.2.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>1.0.5000.0</AssemblyVersion>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt die UDP-Netzwerkdienste (User Datagram Protocol) bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient>-Klasse stellt einfache Methoden zum Senden und empfangen von Verbindungs losen UDP-Datagramme im blockierenden synchronen Modus bereit. Da UDP ein verbindungsloses Transportprotokoll ist, müssen Sie vor dem Senden und empfangen von Daten keine Remote Host Verbindung herstellen. Sie haben jedoch die Möglichkeit, einen Standard-Remote Host auf eine der beiden folgenden Arten einzurichten:  
  
-   Erstellen Sie eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse, indem Sie den Remote Hostnamen und die Portnummer als Parameter verwenden.  
  
-   Erstellen Sie eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse, und rufen Sie dann die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode auf.  
  
 Sie können eine der im <xref:System.Net.Sockets.UdpClient> bereitgestellten Sende Methoden verwenden, um Daten an ein Remote Gerät zu senden. Verwenden Sie die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode, um Daten von Remote Hosts zu empfangen.  
  
> [!NOTE]
>  Wenn Sie bereits einen Standard-Remote Host angegeben haben, können Sie <xref:System.Net.Sockets.UdpClient.Send%2A> nicht mit einem Hostnamen oder <xref:System.Net.IPEndPoint> abrufen. Wenn Sie dies tun, wird <xref:System.Net.Sockets.UdpClient> eine Ausnahme auslösen.  
  
 mit <xref:System.Net.Sockets.UdpClient> Methoden können Sie auch Multicast Datagramme senden und empfangen. Verwenden Sie die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode, um eine <xref:System.Net.Sockets.UdpClient> für eine Multicast Gruppe zu abonnieren. Verwenden Sie die <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode, um ein <xref:System.Net.Sockets.UdpClient> von einer Multicast Gruppe abzubestellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine <xref:System.Net.Sockets.UdpClient> Verbindung mithilfe des Host namens `www.contoso.com` auf Port 11000 hergestellt. Eine kleine Zeichen folgen Nachricht wird an zwei separate Remote Host Computer gesendet. Durch die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode wird die Ausführung blockiert, bis eine Nachricht empfangen wird. Mithilfe der an <xref:System.Net.Sockets.UdpClient.Receive%2A>über gebenden <xref:System.Net.IPEndPoint> wird die Identität des antwortenden Hosts offengelegt.  
  
 [!code-cpp[Classic UdpClientExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClientExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClientExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClientExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClientExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClientExample/VB/source.vb#1)]  
  
 ]]></format>
    </remarks>
    <permission cref="T:System.Net.SocketPermission">, Um eine ausgehende Verbindung herzustellen oder eine eingehende Anforderung zu akzeptieren.</permission>
    <altmember cref="T:System.Net.Sockets.TcpClient" />
    <related type="Article" href="~/docs/framework/network-programming/tcp-udp.md">TCP-UDP</related>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine neue <xref:System.Net.Sockets.UdpClient> und ermöglicht dem zugrunde liegenden Dienstanbieter die Zuweisung der am besten geeigneten lokalen IPv4-Adresse und Portnummer. Wenn dieser Konstruktor verwendet wird, wird die <xref:System.Net.Sockets.UdpClient> Instanz mit einer Adressfamilie von IPv4 festgelegt, die nicht durch einen Connect-Methodenaufrufe mit einem IPv6-Ziel geändert oder überschrieben werden kann.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Dieser Konstruktor ist nicht zum beitreten zu einer Multicast Gruppe geeignet, da er keine socketbindung ausführt. Außerdem funktioniert Sie nur mit IPv4-Adresstypen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der Parameter lose Konstruktor verwendet wird, um eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse zu erstellen.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#4)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#4)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#4](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient port" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="port">Die Nummer des lokalen Anschlusses, über den die Kommunikation stattfinden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse und bindet sie an die angegebene lokale Anschlussnummer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine zugrunde liegende <xref:System.Net.Sockets.Socket> und bindet Sie an die Portnummer, von der aus Sie kommunizieren möchten. Verwenden Sie diesen Konstruktor, wenn Sie nur die lokale Portnummer festlegen möchten. Der zugrunde liegende Dienstanbieter weist die lokale IP-Adresse zu. Wenn Sie 0 an den-Konstruktor übergeben, weist der zugrunde liegende Dienstanbieter eine Portnummer zu. Wenn dieser Konstruktor verwendet wird, wird die <xref:System.Net.Sockets.UdpClient> Instanz mit einer Adressfamilie von IPv4 festgelegt, die nicht durch einen Connect-Methodenaufrufe mit einem IPv6-Ziel geändert oder überschrieben werden kann.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Dieser Konstruktor kann nur mit IPv4-Adresstypen verwendet werden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine lokale Portnummer verwendet wird, um eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse zu erstellen.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der <paramref name="port" />-Parameter ist größer als <see cref="F:System.Net.IPEndPoint.MaxPort" /> oder kleiner als <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.IPEndPoint localEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Net.IPEndPoint localEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (localEP As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::IPEndPoint ^ localEP);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.IPEndPoint -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient localEP" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="localEP" Type="System.Net.IPEndPoint" />
      </Parameters>
      <Docs>
        <param name="localEP">Ein <see cref="T:System.Net.IPEndPoint" />, der den lokalen Endpunkt darstellt, an den Sie die UDP-Verbindung binden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse und bindet sie an den angegebenen lokalen Endpunkt.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt einen neuen <xref:System.Net.Sockets.UdpClient> und bindet ihn an die vom `localEP`-Parameter angegebene <xref:System.Net.IPEndPoint>. Bevor Sie diesen Konstruktor aufzurufen, müssen Sie eine <xref:System.Net.IPEndPoint> mithilfe der IP-Adresse und der Portnummer erstellen, von denen Sie Daten senden und empfangen möchten. Sie müssen keine lokale IP-Adresse und Portnummer angeben, um Daten zu senden und zu empfangen. Andernfalls weist der zugrunde liegende Dienstanbieter die am besten geeignete lokale IP-Adresse und Portnummer zu.  
  
 Wenn dieser Konstruktor verwendet wird, wird die <xref:System.Net.Sockets.UdpClient> Instanz mit der Adressfamilie festgelegt, die durch den `localEP`-Parameter angegeben wird, der nicht durch einen Connect-Methodenaufrufe mit einer anderen Adressfamilie geändert oder überschrieben werden kann.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse mit einem lokalen Endpunkt erstellt wird.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#2)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#2)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="localEP" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient family" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="family">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte, der das Adressierungsschema für den Socket angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `family`-Parameter bestimmt, ob der Listener eine IPv4-Adresse (IP Version 4) oder eine IPv6-Adresse (IP Version 6) verwendet. Wenn Sie eine IPv4-Adresse verwenden möchten, übergeben Sie den <xref:System.Net.Sockets.AddressFamily.InterNetwork> Wert. Übergeben Sie den <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> Wert, um eine IPv6-Adresse zu verwenden. Das Übergeben eines anderen Werts bewirkt, dass die Methode eine <xref:System.ArgumentException>auslöst.  
  
 Wenn dieser Konstruktor verwendet wird, wird die <xref:System.Net.Sockets.UdpClient> Instanz mit der Adressfamilie festgelegt, die durch den `family`-Parameter angegeben wird, der nicht durch einen Connect-Methodenaufrufe mit einer anderen Adressfamilie geändert oder überschrieben werden kann.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Der <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> ist nicht zum beitreten zu einer Multicast Gruppe geeignet, da er keine socketbindung ausführt.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="family" /> ist nicht <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (int port, System.Net.Sockets.AddressFamily family);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 port, valuetype System.Net.Sockets.AddressFamily family) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.Int32,System.Net.Sockets.AddressFamily)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (port As Integer, family As AddressFamily)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(int port, System::Net::Sockets::AddressFamily family);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : int * System.Net.Sockets.AddressFamily -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (port, family)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="port" Type="System.Int32" />
        <Parameter Name="family" Type="System.Net.Sockets.AddressFamily" />
      </Parameters>
      <Docs>
        <param name="port">Der Anschluss, der auf eingehende Verbindungsversuche überwacht werden soll.</param>
        <param name="family">Einer der <see cref="T:System.Net.Sockets.AddressFamily" />-Werte, der das Adressierungsschema für den Socket angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse und bindet sie an die angegebene lokale Anschlussnummer.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor erstellt eine zugrunde liegende <xref:System.Net.Sockets.Socket> und bindet Sie an die Portnummer, von der aus Sie kommunizieren möchten.  
  
 Der `family`-Parameter bestimmt, ob der Listener eine IPv4-Adresse (IP Version 4) oder eine IPv6-Adresse (IP Version 6) verwendet. Wenn Sie eine IPv4-Adresse verwenden möchten, übergeben Sie den <xref:System.Net.Sockets.AddressFamily.InterNetwork> Wert. Übergeben Sie den <xref:System.Net.Sockets.AddressFamily.InterNetworkV6> Wert, um eine IPv6-Adresse zu verwenden. Das Übergeben eines anderen Werts bewirkt, dass die Methode eine <xref:System.ArgumentException>auslöst.  
  
 Wenn dieser Konstruktor verwendet wird, wird die <xref:System.Net.Sockets.UdpClient> Instanz mit der Adressfamilie festgelegt, die durch den `family`-Parameter angegeben wird, der nicht durch einen Connect-Methodenaufrufe mit einer anderen Adressfamilie geändert oder überschrieben werden kann.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Wenn Sie diesen Code abgerufen haben, finden Sie eine ausführliche Beschreibung des Fehlers in der [API-Fehlercode Dokumentation für Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird gezeigt, wie ein UDP-Client erstellt wird, der in einer Multicast Gruppe verwendet werden soll.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#3)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="family" /> ist nicht <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" /> oder <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> ist größer als <see cref="F:System.Net.IPEndPoint.MaxPort" /> oder kleiner als <see cref="F:System.Net.IPEndPoint.MinPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public UdpClient (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.#ctor(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; UdpClient(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="new System.Net.Sockets.UdpClient : string * int -&gt; System.Net.Sockets.UdpClient" Usage="new System.Net.Sockets.UdpClient (hostname, port)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="hostname">Der Name des Remote-DNS-Hosts, zu dem die Verbindung hergestellt werden soll.</param>
        <param name="port">Die Nummer des Remoteanschlusses, mit dem die Verbindung hergestellt werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Net.Sockets.UdpClient" />-Klasse und richtet einen Standardremotehost ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Konstruktor initialisiert eine neue <xref:System.Net.Sockets.UdpClient> und richtet mithilfe der Parameter `hostname` und `port` einen Remote Host ein. Das Einrichten eines Standard Remote Hosts ist optional. Wenn Sie diesen Konstruktor verwenden, müssen Sie keinen Remote Host in jedem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode angeben. Wenn Sie einen Standard-Remote Host angeben, werden Sie nur auf diesen Host beschränkt. Sie können den Standard-Remote Host jederzeit ändern, indem Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode aufrufen. Verwenden Sie diesen Konstruktor nicht, wenn Sie in der <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode einen Remote Host angeben möchten.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Instanz der <xref:System.Net.Sockets.UdpClient>-Klasse mit einem Hostnamen und einer Portnummer erstellt wird.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#3)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#3)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#3](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="hostname" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Active">
      <MemberSignature Language="C#" Value="protected bool Active { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool Active" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Active" />
      <MemberSignature Language="VB.NET" Value="Protected Property Active As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property bool Active { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.Active : bool with get, set" Usage="System.Net.Sockets.UdpClient.Active" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob ein Standardremotehost eingerichtet wurde, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn die Verbindung aktiviert ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Klassen, die von <xref:System.Net.Sockets.UdpClient> abgeleitet werden, können diese Eigenschaft verwenden, um zu bestimmen, ob ein Standard-Remote Host eingerichtet wurde. Sie können einen Standard-Remote Host einrichten, indem Sie den entsprechenden Konstruktor verwenden oder die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode aufrufen. Wenn Sie einen Standard-Remote Host einrichten, können Sie keinen Remote Host für den <xref:System.Net.Sockets.UdpClient.Send%2A>-Befehl angeben.  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.UdpClient" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      </Docs>
    </Member>
    <Member MemberName="AllowNatTraversal">
      <MemberSignature Language="C#" Value="public void AllowNatTraversal (bool allowed);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AllowNatTraversal(bool allowed) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.AllowNatTraversal(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AllowNatTraversal (allowed As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AllowNatTraversal(bool allowed);" />
      <MemberSignature Language="F#" Value="member this.AllowNatTraversal : bool -&gt; unit" Usage="udpClient.AllowNatTraversal allowed" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="allowed" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="allowed">Ein boolescher Wert, der angibt, ob die NAT-Überquerung aktiviert oder deaktiviert werden soll.</param>
        <summary>Aktiviert oder deaktiviert die NAT-Überquerung (Netzwerkadressenübersetzung) für eine <see cref="T:System.Net.Sockets.UdpClient" />-Instanz.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.AllowNatTraversal%2A>-Methode wird verwendet, um den NAT-Durchlauf für eine <xref:System.Net.Sockets.UdpClient> Instanz zu aktivieren oder zu deaktivieren. NAT-Durchlauf kann mithilfe von Teredo, IPv6-zu-IPv4 oder einem ISATAP-Tunnel bereitgestellt werden.  
  
 Wenn der `allowed`-Parameter false ist, wird die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>-Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.EdgeRestricted>festgelegt. Dadurch wird der NAT-Durchlauf für eine <xref:System.Net.Sockets.UdpClient> Instanz explizit deaktiviert.  
  
 Wenn der `allowed`-Parameter true ist, wird die <xref:System.Net.Sockets.SocketOptionName.IPProtectionLevel>-Option für den zugeordneten Socket auf <xref:System.Net.Sockets.IPProtectionLevel.Unrestricted>festgelegt. Dies kann die NAT-Überquerung für eine <xref:System.Net.Sockets.UdpClient> abhängig von Firewallregeln auf dem System ermöglichen.  
  
 Eine Teredo-Adresse ist eine IPv6-Adresse mit dem Präfix 2001::/32. Teredo-Adressen können über die normale DNS-Namensauflösung zurückgegeben oder als eine IPv6-Adresse aufgezählt werden, die einer lokalen Schnittstelle zugewiesen ist.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.IPAddress.IsIPv6Teredo" />
        <altmember cref="T:System.Net.Sockets.IPProtectionLevel" />
        <altmember cref="F:System.Net.Sockets.SocketOptionName.IPProtectionLevel" />
        <altmember cref="M:System.Net.Sockets.Socket.SetIPProtectionLevel(System.Net.Sockets.IPProtectionLevel)" />
        <altmember cref="M:System.Net.Sockets.TcpListener.AllowNatTraversal(System.Boolean)" />
      </Docs>
    </Member>
    <Member MemberName="Available">
      <MemberSignature Language="C#" Value="public int Available { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Available" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Available" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Available As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Available { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Available : int" Usage="System.Net.Sockets.UdpClient.Available" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die vom Netzwerk empfangene Datenmenge ab, die gelesen werden kann.</summary>
        <value>Die Anzahl der vom Netzwerk empfangenen Datenbytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Net.Sockets.UdpClient.Available%2A>-Eigenschaft wird festgelegt, wie viele Daten im Netzwerk Puffer zum Lesen in die Warteschlange eingereiht werden. Wenn Daten verfügbar sind, wenden Sie <xref:System.Net.Sockets.NetworkStream.Read%2A> an, um die Daten abzurufen. Wenn keine Daten verfügbar sind, gibt die <xref:System.Net.Sockets.UdpClient.Available%2A>-Eigenschaft 0 (null) zurück.  
  
 Wenn die Verbindung vom Remote Host heruntergefahren oder beendet wird, wird von der <xref:System.Net.Sockets.UdpClient.Available%2A>-Eigenschaft eine <xref:System.Net.Sockets.SocketException>ausgelöst.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. eine ausführliche Beschreibung des Fehlers finden Sie in der [API-Fehlercode Dokumentation von Windows Sockets Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) .  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.Available%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugriff auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="BeginReceive">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginReceive (AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginReceive(class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginReceive (requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginReceive(AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginReceive : AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginReceive (requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen über den Empfangsvorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Empfängt asynchron ein Datagramm von einem Remotehost.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />-Objekt, das auf den asynchronen Empfang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.UdpClient.EndReceive%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginReceive%2A> verwendet, um asynchron eine Serverantwort zu empfangen.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginSend">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet asynchron ein Datagramm an einen Remotehost.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein <see cref="T:System.Byte" />-Array, das die zu sendenden Daten enthält.</param>
        <param name="bytes">Die Anzahl der zu sendenden Bytes.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zum Sendevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Sendet asynchron ein Datagramm an einen Remotehost. Das Ziel wurde zuvor durch Aufruf von <see cref="Overload:System.Net.Sockets.UdpClient.Connect" /> angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.UdpClient.EndSend%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang abgeschlossen ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.UdpClient.Send%2A>-Methoden Überladungen.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginSend%2A> verwendet, um asynchron eine Server Anforderung zu senden.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient1#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.Net.IPEndPoint,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * System.Net.IPEndPoint * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, endPoint, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein <see cref="T:System.Byte" />-Array, das die zu sendenden Daten enthält.</param>
        <param name="bytes">Die Anzahl der zu sendenden Bytes.</param>
        <param name="endPoint">Der <see cref="T:System.Net.EndPoint" />, der das Ziel der Daten darstellt.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zum Sendevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Sendet asynchron ein Datagramm an ein Ziel. Das Ziel wird durch einen <see cref="T:System.Net.EndPoint" />angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.UdpClient.EndSend%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.UdpClient.Send%2A>-Methoden Überladungen.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginSend%2A> verwendet, um asynchron eine Server Anforderung zu senden.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient1#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginSend">
      <MemberSignature Language="C#" Value="public IAsyncResult BeginSend (byte[] datagram, int bytes, string hostname, int port, AsyncCallback requestCallback, object state);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.IAsyncResult BeginSend(unsigned int8[] datagram, int32 bytes, string hostname, int32 port, class System.AsyncCallback requestCallback, object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.BeginSend(System.Byte[],System.Int32,System.String,System.Int32,System.AsyncCallback,System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function BeginSend (datagram As Byte(), bytes As Integer, hostname As String, port As Integer, requestCallback As AsyncCallback, state As Object) As IAsyncResult" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; IAsyncResult ^ BeginSend(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port, AsyncCallback ^ requestCallback, System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.BeginSend : byte[] * int * string * int * AsyncCallback * obj -&gt; IAsyncResult" Usage="udpClient.BeginSend (datagram, bytes, hostname, port, requestCallback, state)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.IAsyncResult</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="requestCallback" Type="System.AsyncCallback" Index="4" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="state" Type="System.Object" Index="5" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein <see cref="T:System.Byte" />-Array, das die zu sendenden Daten enthält.</param>
        <param name="bytes">Die Anzahl der zu sendenden Bytes.</param>
        <param name="hostname">Der Zielhost.</param>
        <param name="port">Die Zielanschlussnummer.</param>
        <param name="requestCallback">Ein <see cref="T:System.AsyncCallback" />-Delegat, der auf die Methode verweist, die bei Abschluss des Vorgangs aufgerufen werden soll.</param>
        <param name="state">Ein benutzerdefiniertes Objekt, das Informationen zum Sendevorgang enthält. Dieses Objekt wird bei Abschluss des Vorgangs an den <paramref name="requestCallback" />-Delegaten übergeben.</param>
        <summary>Sendet asynchron ein Datagramm an ein Ziel. Das Ziel wird durch einen Hostnamen und eine Anschlussnummer angegeben.</summary>
        <returns>Ein <see cref="T:System.IAsyncResult" />, das auf den asynchronen Sendevorgang verweist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der asynchrone <xref:System.Net.Sockets.UdpClient.BeginSend%2A> Vorgang muss abgeschlossen werden, indem die <xref:System.Net.Sockets.UdpClient.EndSend%2A>-Methode aufgerufen wird. In der Regel wird die-Methode vom `requestCallback`-Delegaten aufgerufen.  
  
 Diese Methode wird nicht blockiert, bis der Vorgang beendet ist. Um zu blockieren, bis der Vorgang beendet ist, verwenden Sie eine der <xref:System.Net.Sockets.UdpClient.Send%2A>-Methoden Überladungen.  
  
 Ausführliche Informationen zur Verwendung des asynchronen Programmiermodells finden Sie unter [Asynchrones Aufrufen synchroner Methoden](~/docs/standard/asynchronous-programming-patterns/calling-synchronous-methods-asynchronously.md).  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginSend%2A> verwendet, um asynchron eine Server Anforderung zu senden.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient1#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Client">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket Client { get; set; }" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket Client" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="VB.NET" Value="Public Property Client As Socket" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      <MemberSignature Language="F#" Value="member this.Client : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.UdpClient.Client" />
      <MemberSignature Language="C#" Value="protected System.Net.Sockets.Socket Client { get; set; }" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="VB.NET" Value="Protected Property Client As Socket" FrameworkAlternate="netframework-1.1" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; property System::Net::Sockets::Socket ^ Client { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" FrameworkAlternate="netframework-1.1" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den zugrunde liegenden Netzwerk-<see cref="T:System.Net.Sockets.Socket" /> ab oder legt diesen fest.</summary>
        <value>Der zugrunde liegende Netzwerk-<see cref="T:System.Net.Sockets.Socket" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Net.Sockets.UdpClient> erstellt eine <xref:System.Net.Sockets.Socket>, die zum Senden und empfangen von Daten über ein Netzwerk verwendet wird. Klassen, die von <xref:System.Net.Sockets.UdpClient> abgeleitet werden, können diese Eigenschaft verwenden, um diese <xref:System.Net.Sockets.Socket>zu erhalten oder festzulegen. Verwenden Sie die zugrunde liegende <xref:System.Net.Sockets.Socket>, die von <xref:System.Net.Sockets.UdpClient.Client%2A> zurückgegeben werden, wenn der Zugriff über den von <xref:System.Net.Sockets.UdpClient> bereitgestellten hinaus Sie können auch <xref:System.Net.Sockets.UdpClient.Client%2A> verwenden, um die zugrunde liegende <xref:System.Net.Sockets.Socket> auf eine vorhandene <xref:System.Net.Sockets.Socket>festzulegen. Dies ist hilfreich, wenn Sie die Einfachheit der <xref:System.Net.Sockets.UdpClient> mithilfe einer bereits vorhandenen <xref:System.Net.Sockets.Socket>nutzen möchten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.Client%2A>-Eigenschaft veranschaulicht. In diesem Beispiel ist Broadcasting für die zugrunde liegende <xref:System.Net.Sockets.Socket>aktiviert.  
  
 [!code-cpp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CPP/source.cpp#1)]
 [!code-csharp[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/CS/source.cs#1)]
 [!code-vb[Classic UdpClient.ProtectedMethodsAndPropertiesExample#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.ProtectedMethodsAndPropertiesExample/VB/source.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <Member MemberName="Close">
      <MemberSignature Language="C#" Value="public void Close ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Close() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Close" />
      <MemberSignature Language="VB.NET" Value="Public Sub Close ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Close();" />
      <MemberSignature Language="F#" Value="member this.Close : unit -&gt; unit" Usage="udpClient.Close " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Schließt die UDP-Verbindung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Net.Sockets.UdpClient.Close%2A> deaktiviert die zugrunde liegende <xref:System.Net.Sockets.Socket> und gibt alle verwalteten und nicht verwalteten Ressourcen frei, die mit dem <xref:System.Net.Sockets.UdpClient>verknüpft sind.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie ein <xref:System.Net.Sockets.UdpClient> durch Aufrufen der <xref:System.Net.Sockets.UdpClient.Close%2A>-Methode geschlossen wird.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#15)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#15)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#15](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#15)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="M:System.Net.Sockets.Socket.Close" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Connect">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Richtet einen Standardremotehost ein.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (endPoint As IPEndPoint)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPEndPoint -&gt; unit" Usage="udpClient.Connect endPoint" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="endPoint">Ein <see cref="T:System.Net.IPEndPoint" />, der den Netzwerkendpunkt angibt, an den Daten gesendet werden sollen.</param>
        <summary>Richtet mit dem angegebenen Netzwerkendpunkt einen Standardremotehost ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode wird ein Standard-Remote Host mit dem im `endPoint`-Parameter angegebenen Wert festgelegt. Nach der Einrichtung müssen Sie in jedem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode keinen Remote Host angeben.  
  
 Das Einrichten eines Standard Remote Hosts ist optional. Wenn Sie einen Standard-Remote Host angeben, werden Sie nur auf diesen Host beschränkt. Wenn Sie Datagramme an einen anderen Remote Host senden möchten, müssen Sie einen weiteren Rückruf für die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode durchführen oder eine weitere <xref:System.Net.Sockets.UdpClient> ohne Standard-Remote Host erstellen. Wenn Sie einen Standard-Remote Host eingerichtet haben und Sie auch einen Remote Host für den <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode bereitstellen, lösen <xref:System.Net.Sockets.UdpClient.Send%2A> eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Sie können den Standard-Remote Host nicht mithilfe dieser Methode auf eine Broadcast Adresse festlegen, es sei denn, Sie erben von <xref:System.Net.Sockets.UdpClient>, verwenden die Client Methode zum Abrufen des zugrunde liegenden <xref:System.Net.Sockets.Socket>und legen die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest.  
  
 Sie können jedoch Daten an die Standard Broadcast Adresse 255.255.255.255 übertragen, wenn Sie <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> in Ihrem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode angeben. Wenn Ihre Anwendung eine bessere Kontrolle über Broadcast Adressen erfordert, können Sie auch auf die <xref:System.Net.Sockets.Socket>-Klasse zurückgreifen.  
  
> [!NOTE]
>  Da das UDP-Protokoll verbindungslose ist, wird die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht blockiert. Nennen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht, wenn Sie beabsichtigen, multicasted Datagramme zu empfangen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein-<xref:System.Net.IPEndPoint> verwendet, um einen Standard-Remote Host einzurichten.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#7)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#7)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#7](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#7)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="endPoint" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (System.Net.IPAddress addr, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(class System.Net.IPAddress addr, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (addr As IPAddress, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::Net::IPAddress ^ addr, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.Connect (addr, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="addr" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="addr">Die <see cref="T:System.Net.IPAddress" /> des Remotehosts, an die Daten gesendet werden sollen.</param>
        <param name="port">Die Anschlussnummer, an die Daten gesendet werden sollen.</param>
        <summary>Richtet einen Standardremotehost mithilfe der angegebenen IP-Adresse und Anschlussnummer ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode richtet einen Standard Remote Host mithilfe der Werte ein, die in den Parametern `addr` und `port` angegeben werden. Nach der Einrichtung müssen Sie in jedem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode keinen Remote Host angeben.  
  
 Das Einrichten eines Standard Remote Hosts ist optional. Wenn Sie einen Standard-Remote Host angeben, werden Sie nur auf diesen Host beschränkt. Wenn Sie Datagramme an einen anderen Remote Host senden möchten, müssen Sie einen weiteren Rückruf für die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode durchführen oder eine weitere <xref:System.Net.Sockets.UdpClient> ohne Standard-Remote Host erstellen. Wenn Sie einen Standard-Remote Host eingerichtet haben und Sie auch einen Remote Host für den <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode bereitstellen, lösen <xref:System.Net.Sockets.UdpClient.Send%2A> eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Sie können den Standard-Remote Host nicht mithilfe dieser Methode auf eine Broadcast Adresse festlegen, es sei denn, Sie erben von <xref:System.Net.Sockets.UdpClient>, verwenden die Client Methode zum Abrufen des zugrunde liegenden <xref:System.Net.Sockets.Socket>und legen die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest.  
  
 Sie können jedoch Daten an die Standard Broadcast Adresse 255.255.255.255 übertragen, wenn Sie <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> in Ihrem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode angeben. Wenn Ihre Anwendung eine bessere Kontrolle über Broadcast Adressen erfordert, können Sie auch auf die <xref:System.Net.Sockets.Socket>-Klasse zurückgreifen.  
  
> [!NOTE]
>  Da das UDP-Protokoll verbindungslose ist, wird die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht blockiert. Nennen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht, wenn Sie beabsichtigen, multicasted Datagramme zu empfangen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird eine IP-Adresse und eine Portnummer verwendet, um eine Verbindung mit einem Remote Host herzustellen.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#6)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#6)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#6](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="addr" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Connect">
      <MemberSignature Language="C#" Value="public void Connect (string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Connect(string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Connect (hostname As String, port As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Connect(System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Connect : string * int -&gt; unit" Usage="udpClient.Connect (hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="hostname" Type="System.String" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="hostname">Der DNS-Name des Remotehosts, an den Daten gesendet werden sollen.</param>
        <param name="port">Die Anschlussnummer auf dem Remotehost, an den Daten gesendet werden sollen.</param>
        <summary>Richtet einen Standardremotehost mit dem angegebenen Hostnamen und der Anschlussnummer ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode richtet einen Standard Remote Host mithilfe der Werte ein, die in den Parametern `port` und `hostname` angegeben werden. Nach der Einrichtung müssen Sie in jedem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode keinen Remote Host angeben.  
  
 Das Einrichten eines Standard Remote Hosts ist optional. Wenn Sie einen Standard-Remote Host angeben, werden Sie nur auf diesen Host beschränkt. Wenn Sie Datagramme an einen anderen Remote Host senden möchten, müssen Sie einen weiteren Rückruf für die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode durchführen oder eine weitere <xref:System.Net.Sockets.UdpClient> ohne Standard-Remote Host erstellen.  
  
 Wenn Sie einen Standard-Remote Host eingerichtet haben und Sie auch einen Remote Host für den <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode bereitstellen, lösen <xref:System.Net.Sockets.UdpClient.Send%2A> eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Wenn Sie die <xref:System.Net.Sockets.Socket.Connect%2A>-Methode aufzurufen, werden alle Datagramme verworfen, die von einer anderen Adresse als der angegebenen Standardadresse eintreffen. Sie können den Standard-Remote Host nicht mithilfe dieser Methode auf eine Broadcast Adresse festlegen, es sei denn, Sie erben von <xref:System.Net.Sockets.UdpClient>, verwenden die Client Methode zum Abrufen des zugrunde liegenden <xref:System.Net.Sockets.Socket>und legen die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest.  
  
 Sie können jedoch Daten an die Standard Broadcast Adresse 255.255.255.255 übertragen, wenn Sie <xref:System.Net.IPAddress.Broadcast?displayProperty=nameWithType> in Ihrem aufzurufenden <xref:System.Net.Sockets.UdpClient.Send%2A> Methode angeben. Wenn Ihre Anwendung eine bessere Kontrolle über Broadcast Adressen erfordert, können Sie auch auf die <xref:System.Net.Sockets.Socket>-Klasse zurückgreifen.  
  
> [!NOTE]
>  Da das UDP-Protokoll verbindungslose ist, wird die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht blockiert. Nennen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht, wenn Sie beabsichtigen, multicasted Datagramme zu empfangen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Hostname und die Portnummer verwendet, um eine Verbindung mit einem Remote Host herzustellen.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#5)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#5)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="port" /> liegt nicht zwischen <see cref="F:System.Net.IPEndPoint.MinPort" /> und <see cref="F:System.Net.IPEndPoint.MaxPort" />.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="udpClient.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt die vom <see cref="T:System.Net.Sockets.UdpClient" /> verwendeten verwalteten und nicht verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="udpClient.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Veröffentlicht die durch den <see cref="T:System.Net.Sockets.UdpClient" /> verwendeten nicht verwalteten Ressourcen und nimmt eine optionale Veröffentlichung der verwalteten Ressourcen vor.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von der öffentlichen `Dispose()`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen. `Dispose()` Ruft die geschützte `Dispose(Boolean)` Methode auf, wobei der `disposing`-Parameter auf `true`festgelegt ist. <xref:System.Object.Finalize%2A> ruft `Dispose` auf, bei dem `disposing` auf `false`festgelegt ist.  
  
 Wenn der `disposing`-Parameter den Wert true hat, gibt diese Methode alle Ressourcen frei, die von allen verwalteten Objekten aufbewahrt werden, auf die diese <xref:System.Net.Sockets.UdpClient> verweist Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden. Beim Überschreiben <see langword="Dispose(Boolean)" /> Sie darauf achten, nicht auf Objekte zu verweisen, die zuvor in einem früheren <see langword="Dispose" />von freigegeben wurden. Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" />finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.  
  
Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" />finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</para></block>
      </Docs>
    </Member>
    <Member MemberName="DontFragment">
      <MemberSignature Language="C#" Value="public bool DontFragment { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DontFragment" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.DontFragment" />
      <MemberSignature Language="VB.NET" Value="Public Property DontFragment As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DontFragment { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DontFragment : bool with get, set" Usage="System.Net.Sockets.UdpClient.DontFragment" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.UdpClient" /> die Fragmentierung von IP (Internet Protocol)-Datagrammen zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.UdpClient" /> die Datagrammfragmentierung zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="true" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Datagramme erfordern eine Fragmentierung, wenn ihre Größe die maximale Übertragungseinheit (MTU) des Übertragungsmediums überschreitet. Datagramme können vom sendenden Host oder von einem zwischen Router fragmentiert werden. Wenn ein Datagramm fragmentiert werden muss und die <xref:System.Net.Sockets.Socket.DontFragment%2A>-Option festgelegt ist, wird das Datagramm verworfen und eine ICMP (Internet Control Message Protocol)-Fehlermeldung an den Absender des Datagramms zurückgesendet.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.Socket.DontFragment%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException">Diese Eigenschaft kann nur für Sockets festgelegt werden, die das <see cref="F:System.Net.Sockets.AddressFamily.InterNetwork" />-Flag oder das <see cref="F:System.Net.Sockets.AddressFamily.InterNetworkV6" />-Flag verwenden.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="DropMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Verlässt eine Multicastgruppe.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.DropMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Die <see cref="T:System.Net.IPAddress" /> der zu verlassenden Multicastgruppe.</param>
        <summary>Verlässt eine Multicastgruppe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode zieht die <xref:System.Net.Sockets.UdpClient> von der durch den angegebenen <xref:System.Net.IPAddress>identifizierten Multicast Gruppe ab. Nach dem Aufrufen der <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode sendet der zugrunde liegende <xref:System.Net.Sockets.Socket> ein IGMP-Paket (Internet Group Management Protocol) an den Router, wobei der Router aus der Multicast Gruppe entfernt wird. Nachdem ein <xref:System.Net.Sockets.UdpClient> von der Gruppe abwehrt wurde, kann er keine an diese Gruppe gesendeten Datagramme mehr empfangen.  
  
> [!NOTE]
>  Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Multicast Gruppe durch Bereitstellen einer Multicast Adresse gelöscht wird.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Die IP-Adresse ist nicht mit dem <see cref="T:System.Net.Sockets.AddressFamily" />-Wert kompatibel, der das Adressierungsschema des Sockets definiert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="DropMulticastGroup">
      <MemberSignature Language="C#" Value="public void DropMulticastGroup (System.Net.IPAddress multicastAddr, int ifindex);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void DropMulticastGroup(class System.Net.IPAddress multicastAddr, int32 ifindex) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub DropMulticastGroup (multicastAddr As IPAddress, ifindex As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void DropMulticastGroup(System::Net::IPAddress ^ multicastAddr, int ifindex);" />
      <MemberSignature Language="F#" Value="member this.DropMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.DropMulticastGroup (multicastAddr, ifindex)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="ifindex" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Die <see cref="T:System.Net.IPAddress" /> der zu verlassenden Multicastgruppe.</param>
        <param name="ifindex">Die lokale Adresse der zu verlassenden Multicastgruppe.</param>
        <summary>Verlässt eine Multicastgruppe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode zieht die <xref:System.Net.Sockets.UdpClient> von der durch den angegebenen <xref:System.Net.IPAddress>identifizierten Multicast Gruppe ab. Nach dem Aufrufen der <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode sendet der zugrunde liegende <xref:System.Net.Sockets.Socket> ein IGMP-Paket (Internet Group Management Protocol) an den Router, wobei der Router aus der Multicast Gruppe entfernt wird. Nachdem ein <xref:System.Net.Sockets.UdpClient> von der Gruppe abwehrt wurde, kann er keine an diese Gruppe gesendeten Datagramme mehr empfangen.  
  
> [!NOTE]
>  Wenn Sie erhalten eine <xref:System.Net.Sockets.SocketException>, verwenden die <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType> Eigenschaft, um den spezifischen Fehlercode zu erhalten. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation für Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Multicast Gruppe durch Bereitstellen einer Multicast Adresse gelöscht wird.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#2)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#2](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Die IP-Adresse ist nicht mit dem <see cref="T:System.Net.Sockets.AddressFamily" />-Wert kompatibel, der das Adressierungsschema des Sockets definiert.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="EnableBroadcast">
      <MemberSignature Language="C#" Value="public bool EnableBroadcast { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool EnableBroadcast" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberSignature Language="VB.NET" Value="Public Property EnableBroadcast As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool EnableBroadcast { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.EnableBroadcast : bool with get, set" Usage="System.Net.Sockets.UdpClient.EnableBroadcast" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.UdpClient" /> Broadcastpakete senden oder empfangen darf, oder legt diesen Wert fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.UdpClient" /> Broadcastpakete zulässt, andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Broadcasting ist auf ein bestimmtes Subnetz beschränkt. Sie können an das lokale Subnetz übertragen, indem Sie ein Paket an 255.255.255.255 senden. oder Sie können die gesteuerte Broadcast Adresse verwenden, bei der es sich um den Netzwerk Teil einer IP-Adresse (Internet Protocol) handelt, bei dem alle Bits im Hostteil festgelegt sind. Wenn Ihre IP-Adresse beispielsweise 192.168.1.40 (eine Class C-Adresse mit dem Netzwerk Anteil als die ersten drei Oktette und der Hostteil das letzte Oktett) ist, lautet die gesteuerte Broadcast Adresse 192.168.1.255.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.EnableBroadcast%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#3](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#3)]
 [!code-csharp[System.Net.Sockets.UdpClient#3](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="EndReceive">
      <MemberSignature Language="C#" Value="public byte[] EndReceive (IAsyncResult asyncResult, ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] EndReceive(class System.IAsyncResult asyncResult, class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndReceive (asyncResult As IAsyncResult, ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ EndReceive(IAsyncResult ^ asyncResult, System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.EndReceive : IAsyncResult * IPEndPoint -&gt; byte[]" Usage="udpClient.EndReceive (asyncResult, remoteEP)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das durch einen Aufruf von <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" /> zurückgegeben wird.</param>
        <param name="remoteEP">Der angegebene Remoteendpunkt.</param>
        <summary>Beendet einen ausstehenden asynchronen Empfang.</summary>
        <returns>Bei Erfolg wird ein Array von Bytes zurückgegeben, dass Datagrammdaten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist.  
  
 Verwenden Sie die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode, um diesen Vorgang synchron auszuführen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginSend%2A> verwendet, um einen asynchronen Empfang einer Serverantwort abzuschließen.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient1#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.UdpClient.BeginReceive(System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.UdpClient.EndReceive(System.IAsyncResult,System.Net.IPEndPoint@)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den <see cref="T:System.Net.Sockets.Socket" />.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="EndSend">
      <MemberSignature Language="C#" Value="public int EndSend (IAsyncResult asyncResult);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 EndSend(class System.IAsyncResult asyncResult) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.EndSend(System.IAsyncResult)" />
      <MemberSignature Language="VB.NET" Value="Public Function EndSend (asyncResult As IAsyncResult) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int EndSend(IAsyncResult ^ asyncResult);" />
      <MemberSignature Language="F#" Value="member this.EndSend : IAsyncResult -&gt; int" Usage="udpClient.EndSend asyncResult" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="asyncResult" Type="System.IAsyncResult" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="asyncResult">Ein <see cref="T:System.IAsyncResult" />-Objekt, das durch einen Aufruf von <see cref="Overload:System.Net.Sockets.UdpClient.BeginSend" /> zurückgegeben wird.</param>
        <summary>Beendet einen ausstehenden asynchronen Sendevorgang.</summary>
        <returns>Wenn erfolgreich, die Anzahl der an den <see cref="T:System.Net.Sockets.UdpClient" /> gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird blockiert, bis der Vorgang beendet ist.  
  
 Verwenden Sie die <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode, um diesen Vorgang synchron auszuführen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird <xref:System.Net.Sockets.UdpClient.BeginSend%2A> verwendet, um einen asynchronen Sendevorgang einer Server Anforderung abzuschließen.  
  
 [!code-cpp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/cpp/asyncudp.cpp#2)]
 [!code-csharp[System.Net.Sockets.UdpClient1#2](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient1/CS/asyncudp.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="asyncResult" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException"><paramref name="asyncResult" /> wurde nicht durch einen Aufruf der <see cref="M:System.Net.Sockets.Socket.BeginSend(System.Byte[],System.Int32,System.Int32,System.Net.Sockets.SocketFlags,System.AsyncCallback,System.Object)" />-Methode zurückgegeben.</exception>
        <exception cref="T:System.InvalidOperationException"><see cref="M:System.Net.Sockets.Socket.EndSend(System.IAsyncResult)" /> wurde bereits für den asynchronen Lesevorgang aufgerufen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den zugrunde liegenden Socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ExclusiveAddressUse">
      <MemberSignature Language="C#" Value="public bool ExclusiveAddressUse { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool ExclusiveAddressUse" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberSignature Language="VB.NET" Value="Public Property ExclusiveAddressUse As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool ExclusiveAddressUse { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.ExclusiveAddressUse : bool with get, set" Usage="System.Net.Sockets.UdpClient.ExclusiveAddressUse" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob der <see cref="T:System.Net.Sockets.UdpClient" /> nur die Verwendung eines Port durch einen einzigen Client zulässt, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.UdpClient" /> die Verwendung eines bestimmten Ports durch nur einen einzigen Client zulässt, andernfalls <see langword="false" />. Für Windows Server 2003 und Windows XP Service Pack 2 oder höher ist der Standardwert <see langword="true" />, für alle anderen Versionen <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Standardmäßig können mehrere Clients einen bestimmten Port verwenden. Allerdings kann nur einer der Clients Vorgänge für den Netzwerk Datenverkehr ausführen, der an den Port gesendet wird. Sie können die <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>-Eigenschaft verwenden, um zu verhindern, dass mehrere Clients einen bestimmten Port verwenden.  
  
 Diese Eigenschaft muss festgelegt werden, bevor der zugrunde liegende Socket an einen ClientPort gebunden ist. Wenn Sie <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Int32%2CSystem.Net.Sockets.AddressFamily%29?displayProperty=nameWithType>, <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.IPEndPoint%29?displayProperty=nameWithType>oder <xref:System.Net.Sockets.UdpClient.%23ctor%28System.String%2CSystem.Int32%29?displayProperty=nameWithType>aufzurufen, wird der ClientPort als Nebeneffekt des Konstruktors gebunden, und Sie können anschließend die <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>-Eigenschaft nicht festlegen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird eine <xref:System.Net.Sockets.UdpClient>erstellt und die <xref:System.Net.Sockets.UdpClient.ExclusiveAddressUse%2A>-Eigenschaft abgerufen und festgelegt.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#4](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#4)]
 [!code-csharp[System.Net.Sockets.UdpClient#4](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.Net.Sockets.SocketException">Fehler beim Zugriff auf den zugrunde liegenden Socket.</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~UdpClient ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!UdpClient ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="udpClient.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="JoinMulticastGroup">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einer Multicastgruppe einen <see cref="T:System.Net.Sockets.UdpClient" /> hinzu.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup multicastAddr" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Die Multicast-<see cref="T:System.Net.IPAddress" /> der Gruppe, der Sie beitreten möchten.</param>
        <summary>Fügt einer Multicastgruppe einen <see cref="T:System.Net.Sockets.UdpClient" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode abonniert die <xref:System.Net.Sockets.UdpClient> mithilfe der angegebenen <xref:System.Net.IPAddress>in eine Multicast Gruppe. Nachdem die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode aufgerufen wurde, sendet der zugrunde liegende <xref:System.Net.Sockets.Socket> ein IGMP-Paket (Internet Group Management Protocol) an den Router, der die Mitgliedschaft bei der Multicast Gruppe anfordert. Der Multicast Adressbereich ist 224.0.0.0 zu 239.255.255.255. Wenn Sie eine Adresse außerhalb dieses Bereichs angeben oder der Router, an den die Anforderung gerichtet ist, nicht Multicast aktiviert ist, wird <xref:System.Net.Sockets.UdpClient> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Sobald die <xref:System.Net.Sockets.UdpClient> mit dem Router als Mitglied der Multicast Gruppe aufgelistet ist, kann Sie multicasted Datagramme empfangen, die an die angegebene <xref:System.Net.IPAddress>gesendet werden.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Net.Sockets.UdpClient> mit der Multicast Portnummer erstellen. Andernfalls sind Sie nicht in der Lage, multicasted Datagramme zu empfangen. Rufen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht vor, bevor Sie die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode aufrufen, oder die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode funktioniert nicht. Sie müssen nicht zu einer Multicast Gruppe gehören, um Datagramme an eine Multicast-IP-Adresse zu senden.  
  
 Vor dem beitreten zu einer Multicast Gruppe müssen Sie sicherstellen, dass der Socket an den Port oder Endpunkt gebunden ist. Dazu rufen Sie einen der Konstruktoren auf, die einen Port oder einen Endpunkt als Parameter akzeptieren.  
  
 Rufen Sie die <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode auf, und geben Sie den <xref:System.Net.IPAddress> der Gruppe an, von der Sie den Vorgang widerrufen möchten, um den Empfang von multicasted Datagramme zu verhindern.  
  
> [!NOTE]
>  Im Fall von IPv6 gibt es mehrere Multicast Adressbereiche, aus denen Sie auswählen können. Weitere Informationen finden Sie in der IETF RFC 2375.  
  
> [!NOTE]
>  Sie können <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> auf einem <xref:System.Net.Sockets.UdpClient> nicht ohne einen bestimmten lokalen Port (d. h. mithilfe des <xref:System.Net.Sockets.UdpClient.%23ctor> oder <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> Konstruktors) aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, wie eine Multicast Gruppe verknüpft wird, indem eine Multicast Adresse bereitgestellt wird.  
  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#1)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#1)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#1](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentException">Die IP-Adresse ist nicht mit dem <see cref="T:System.Net.Sockets.AddressFamily" />-Wert kompatibel, der das Adressierungsschema des Sockets definiert.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (int ifindex, System.Net.IPAddress multicastAddr);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(int32 ifindex, class System.Net.IPAddress multicastAddr) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Int32,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (ifindex As Integer, multicastAddr As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(int ifindex, System::Net::IPAddress ^ multicastAddr);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : int * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (ifindex, multicastAddr)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="ifindex" Type="System.Int32" />
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
      </Parameters>
      <Docs>
        <param name="ifindex">Der Schnittstellenindex, der der lokale IP-Adresse zugeordnet ist, an der die Multicastgruppe herzustellen ist.</param>
        <param name="multicastAddr">Die Multicast-<see cref="T:System.Net.IPAddress" /> der Gruppe, der Sie beitreten möchten.</param>
        <summary>Fügt einer Multicastgruppe einen <see cref="T:System.Net.Sockets.UdpClient" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Vor dem beitreten zu einer Multicast Gruppe müssen Sie sicherstellen, dass der Socket an den Port oder Endpunkt gebunden ist. Hierzu können Sie einen der Konstruktoren aufrufen, der einen Port oder einen Endpunkt als Parameter akzeptiert.  
  
 Der `infindex`-Parameter wird verwendet, um eine Hardwareschnittstelle auf demselben Link zu identifizieren.  
  
> [!NOTE]
>  Es gibt mehrere Multicast Adressbereiche, aus denen Sie auswählen können. Weitere Informationen finden Sie in der IETF RFC 2375.  
  
> [!NOTE]
>  Sie können <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> auf einem <xref:System.Net.Sockets.UdpClient> nicht ohne einen bestimmten lokalen Port (d. h. mithilfe des <xref:System.Net.Sockets.UdpClient.%23ctor?displayProperty=nameWithType> oder <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29?displayProperty=nameWithType> Konstruktors) aufzurufen.  
  
   
  
## Examples  
 [!code-cpp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CPP/joinmulticastgroup.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/CS/joinmulticastgroup.cs#5)]
 [!code-vb[System.Net.Sockets.UdpClient.JoinMulticastGroup#5](~/samples/snippets/visualbasic/VS_Snippets_Remoting/System.Net.Sockets.UdpClient.JoinMulticastGroup/VB/joinmulticastgroup.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, int timeToLive);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, int32 timeToLive) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, timeToLive As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, int timeToLive);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * int -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, timeToLive)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" />
        <Parameter Name="timeToLive" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Die <see cref="T:System.Net.IPAddress" /> der Multicastgruppe, der Sie beitreten möchten.</param>
        <param name="timeToLive">Die TTL, gemessen in Routerhops.</param>
        <summary>Fügt einer Multicasgruppe einen <see cref="T:System.Net.Sockets.UdpClient" /> mit angegebener Gültigkeitsdauer (TTL – Time To Live) hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode abonniert die <xref:System.Net.Sockets.UdpClient> mithilfe der angegebenen <xref:System.Net.IPAddress>in eine Multicast Gruppe. Nachdem die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode aufgerufen wurde, sendet der zugrunde liegende <xref:System.Net.Sockets.Socket> ein IGMP-Paket (Internet Group Management Protocol) an den Router, der die Mitgliedschaft bei der Multicast Gruppe anfordert. Der Multicast Adressbereich ist 224.0.0.0 zu 239.255.255.255. Wenn Sie eine Adresse außerhalb dieses Bereichs angeben oder der Router, an den die Anforderung gerichtet ist, nicht Multicast aktiviert ist, wird <xref:System.Net.Sockets.UdpClient> eine <xref:System.Net.Sockets.SocketException>auslösen. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers. Der `timeToLive`-Parameter gibt an, wie viele Routerhops für ein multicasted Datagramm zugelassen werden, bevor Sie verworfen werden. Sobald die <xref:System.Net.Sockets.UdpClient> mit dem Router als Mitglied der Multicast Gruppe aufgelistet ist, kann Sie multicasted Datagramme empfangen, die an die angegebene <xref:System.Net.IPAddress>gesendet werden.  
  
> [!NOTE]
>  Sie müssen die <xref:System.Net.Sockets.UdpClient> mit der Multicast Portnummer erstellen, andernfalls können Sie keine multicasted-Datagramme empfangen. Rufen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht vor, bevor Sie die <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode aufrufen, oder die Receive-Methode funktioniert nicht. Sie müssen nicht zu einer Multicast Gruppe gehören, um Datagramme an eine Multicast-IP-Adresse zu senden.  
  
 Stellen Sie vor dem beitreten zu einer Multicast Gruppe sicher, dass der Socket an den Port oder Endpunkt gebunden ist. Dies geschieht durch Aufrufen eines Konstruktors, der als Parameter einen Port oder einen Endpunkt akzeptiert.  
  
 Rufen Sie die <xref:System.Net.Sockets.UdpClient.DropMulticastGroup%2A>-Methode auf, und geben Sie den <xref:System.Net.IPAddress> der Gruppe an, von der Sie den Vorgang widerrufen möchten, um den Empfang von multicasted Datagramme zu verhindern.  
  
> [!NOTE]
>  Sie können <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> auf einem <xref:System.Net.Sockets.UdpClient> nicht ohne einen bestimmten lokalen Port (d. h. mithilfe des <xref:System.Net.Sockets.UdpClient.%23ctor> oder <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> Konstruktors) aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie eine Multicast Gruppe verknüpft wird, indem zwei Parameter, eine Multicast Adresse und eine Zahl bereitgestellt werden, die die Gültigkeitsdauer darstellt.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#13)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#13)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#13](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#13)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Die bereitgestellte TTL liegt nicht zwischen 0 und 255</exception>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="multicastAddr" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Die IP-Adresse ist nicht mit dem <see cref="T:System.Net.Sockets.AddressFamily" />-Wert kompatibel, der das Adressierungsschema des Sockets definiert.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.DropMulticastGroup(System.Net.IPAddress)" />
      </Docs>
    </Member>
    <Member MemberName="JoinMulticastGroup">
      <MemberSignature Language="C#" Value="public void JoinMulticastGroup (System.Net.IPAddress multicastAddr, System.Net.IPAddress localAddress);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void JoinMulticastGroup(class System.Net.IPAddress multicastAddr, class System.Net.IPAddress localAddress) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.JoinMulticastGroup(System.Net.IPAddress,System.Net.IPAddress)" />
      <MemberSignature Language="VB.NET" Value="Public Sub JoinMulticastGroup (multicastAddr As IPAddress, localAddress As IPAddress)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void JoinMulticastGroup(System::Net::IPAddress ^ multicastAddr, System::Net::IPAddress ^ localAddress);" />
      <MemberSignature Language="F#" Value="member this.JoinMulticastGroup : System.Net.IPAddress * System.Net.IPAddress -&gt; unit" Usage="udpClient.JoinMulticastGroup (multicastAddr, localAddress)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="multicastAddr" Type="System.Net.IPAddress" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="localAddress" Type="System.Net.IPAddress" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="multicastAddr">Die Multicast-<see cref="T:System.Net.IPAddress" /> der Gruppe, der Sie beitreten möchten.</param>
        <param name="localAddress">Die lokale <see cref="T:System.Net.IPAddress" />.</param>
        <summary>Fügt einer Multicastgruppe einen <see cref="T:System.Net.Sockets.UdpClient" /> hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bevor Sie einer Multicast Gruppe beitreten, müssen Sie sicherstellen, dass der Socket an den Port oder Endpunkt gebunden ist. Hierzu können Sie einen der Konstruktoren aufrufen, der einen Port oder einen Endpunkt als Parameter akzeptiert.  
  
> [!NOTE]
>  Es gibt mehrere Multicast Adressbereiche, aus denen Sie auswählen können. Sie finden Sie in der IETF RFC 2375.  
  
> [!NOTE]
>  Sie können <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A> auf einem <xref:System.Net.Sockets.UdpClient> nicht ohne einen bestimmten lokalen Port (d. h. mithilfe des <xref:System.Net.Sockets.UdpClient.%23ctor> oder <xref:System.Net.Sockets.UdpClient.%23ctor%28System.Net.Sockets.AddressFamily%29> Konstruktors) aufzurufen.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.JoinMulticastGroup%2A>-Methode veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#6](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#6)]
 [!code-csharp[System.Net.Sockets.UdpClient#6](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#6)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="MulticastLoopback">
      <MemberSignature Language="C#" Value="public bool MulticastLoopback { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool MulticastLoopback" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberSignature Language="VB.NET" Value="Public Property MulticastLoopback As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool MulticastLoopback { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.MulticastLoopback : bool with get, set" Usage="System.Net.Sockets.UdpClient.MulticastLoopback" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen <see cref="T:System.Boolean" />-Wert ab, der angibt, ob ausgehende Multicastpakete an die sendende Anwendung übermittelt werden, oder legt diesen fest.</summary>
        <value><see langword="true" />, wenn der <see cref="T:System.Net.Sockets.UdpClient" /> ausgehende Multicastpakete empfängt, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Multicast ist eine skalierbare Methode für die m:n-Kommunikation im Internet. Wenn ein Prozess eine Multicast Adresse abonniert, werden alle von diesem Prozess gesendeten Pakete von jedem anderen Prozess empfangen, der die Multicast Adresse abonniert hat.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.MulticastLoopback%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#7](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#7)]
 [!code-csharp[System.Net.Sockets.UdpClient#7](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Receive">
      <MemberSignature Language="C#" Value="public byte[] Receive (ref System.Net.IPEndPoint remoteEP);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] Receive(class System.Net.IPEndPoint&amp; remoteEP) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Receive(System.Net.IPEndPoint@)" />
      <MemberSignature Language="VB.NET" Value="Public Function Receive (ByRef remoteEP As IPEndPoint) As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ Receive(System::Net::IPEndPoint ^ % remoteEP);" />
      <MemberSignature Language="F#" Value="member this.Receive : IPEndPoint -&gt; byte[]" Usage="udpClient.Receive remoteEP" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="remoteEP" Type="System.Net.IPEndPoint" RefType="ref" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="remoteEP">Ein <see cref="T:System.Net.IPEndPoint" />, der den Remotehost darstellt, von dem die Daten gesendet wurden.</param>
        <summary>Gibt ein von einem Remotehost gesendetes UDP-Datagramm zurück.</summary>
        <returns>Ein Array vom Typ <see cref="T:System.Byte" />, das Datagrammdaten enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode wird blockiert, bis ein Datagramm von einem Remote Host eingeht. Wenn Daten verfügbar sind, liest die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode das erste in die Warteschlange eingereihte Datagramm und gibt den Daten Anteil als Bytearray zurück. Diese Methode füllt den `remoteEP`-Parameter mit dem <xref:System.Net.IPAddress> und der Portnummer des Absenders auf.  
  
 Wenn Sie einen Standard-Remote Host in der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode angeben, akzeptiert die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode nur Datagramme von diesem Host. Alle anderen Datagramme werden verworfen.  
  
 Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!NOTE]
>  Wenn Sie beabsichtigen, multicasted Datagramme zu empfangen, rufen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht vor, bevor Sie die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode aufrufen. Der <xref:System.Net.Sockets.UdpClient>, den Sie zum Empfangen von Datagrammen verwenden, muss mit der Multicast Portnummer erstellt werden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Net.Sockets.UdpClient.Receive%2A> Methode. Die <xref:System.Net.Sockets.UdpClient.Receive%2A>-Methode blockiert die Ausführung, bis eine Nachricht empfangen wird. Mithilfe der an <xref:System.Net.Sockets.UdpClient.Receive%2A>über gebenden <xref:System.Net.IPEndPoint> wird die Identität des antwortenden Hosts offengelegt.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#11)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#11)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#11](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#11)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
        <altmember cref="T:System.Net.IPEndPoint" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.IPAddress" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;valuetype System.Net.Sockets.UdpReceiveResult&gt; ReceiveAsync() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.ReceiveAsync" />
      <MemberSignature Language="VB.NET" Value="Public Function ReceiveAsync () As Task(Of UdpReceiveResult)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;System::Net::Sockets::UdpReceiveResult&gt; ^ ReceiveAsync();" />
      <MemberSignature Language="F#" Value="member this.ReceiveAsync : unit -&gt; System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;" Usage="udpClient.ReceiveAsync " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Net.Sockets.UdpReceiveResult&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt ein von einem Remotehost gesendetes UDP-Datagramm asynchron zurück.</summary>
        <returns>Das Taskobjekt, das den asynchronen Vorgang darstellt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dieser Vorgang wird nicht blockiert. Der zurückgegebene <xref:System.Threading.Tasks.Task%601>>-Objekt wird nach dem Empfang des UDP-Pakets abgeschlossen.  
  
 Wenn Sie einen Standard-Remote Host in der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode angeben, akzeptiert diese Methode nur Datagramme von diesem Host. Alle anderen Datagramme werden verworfen.  
  
 Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
> [!WARNING]
>  Wenn Sie beabsichtigen, multicasted Datagramme zu empfangen, rufen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode nicht auf, bevor Sie diese Methode aufrufen. Der <xref:System.Net.Sockets.UdpClient>, den Sie zum Empfangen von Datagrammen verwenden, muss mit der Multicast Portnummer erstellt werden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ObjectDisposedException">Der zugrunde liegende <see cref="T:System.Net.Sockets.Socket" /> wurde geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Send">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet ein UDP-Datagramm an einen Remotehost.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int -&gt; int" Usage="udpClient.Send (dgram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <summary>Sendet ein UDP-Datagramm an einen Remotehost.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet Datagramme an den Remote Host, der in der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode festgelegt wurde, und gibt die Anzahl der gesendeten Bytes zurück. Wenn Sie <xref:System.Net.Sockets.UdpClient.Connect%2A> vor dem Aufrufen dieser Überladung nicht aufrufen, löst die <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Wenn Sie Datagramme an einen anderen Remote Host senden möchten, müssen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode abrufen und den gewünschten Remote Host angeben. Verwenden Sie eine der anderen <xref:System.Net.Sockets.UdpClient.Send%2A> Methoden Überladungen, um Datagramme an eine Broadcast Adresse zu senden.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Net.Sockets.UdpClient.Send%2A> Methode. Vor der Verwendung dieser Überladung muss ein Standard-Remote Host eingerichtet werden.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#10)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#10)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#10](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#10)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * System.Net.IPEndPoint -&gt; int" Usage="udpClient.Send (dgram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <param name="endPoint">Ein <see cref="T:System.Net.IPEndPoint" />, der den Host und Port darstellt, an die das Datagramm gesendet werden soll.</param>
        <summary>Sendet ein UDP-Datagramm an den Host am angegebenen Remoteendpunkt.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode sendet Datagramme an den angegebenen Endpunkt und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. Vor dem Aufrufen dieser Überladung müssen Sie zuerst einen <xref:System.Net.IPEndPoint> mithilfe der IP-Adresse und der Portnummer des Remote Hosts erstellen, an den die Datagramme übermittelt werden. Sie können Datagramme an die Standard Broadcast Adresse 255.255.255.255 senden, indem Sie <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> für die <xref:System.Net.IPAddress.Address%2A>-Eigenschaft der <xref:System.Net.IPEndPoint>angeben. Nachdem Sie diese <xref:System.Net.IPEndPoint>erstellt haben, übergeben Sie Sie als `endPoint`-Parameter an die <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode.  
  
 Wenn Sie Datagramme an eine andere Broadcast Adresse senden möchten, verwenden Sie die <xref:System.Net.Sockets.UdpClient.Client%2A>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.Socket>abzurufen, und legen Sie die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest. Sie können auch die <xref:System.Net.Sockets.Socket>-Klasse wieder verwenden.  
  
> [!NOTE]
>  Geben Sie für diese Methode keinen `endPoint`-Parameter an, wenn Sie bereits einen Remote Host mit der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode eingerichtet haben. Wenn Sie dies tun, löst die <xref:System.Net.Sockets.UdpClient.Send%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Net.Sockets.UdpClient.Send%2A> Methode. In diesem Beispiel wird ein <xref:System.Net.IPEndPoint> zum Angeben des Zielhosts verwendet.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#8)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#8)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#8](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
        <altmember cref="T:System.Net.IPEndPoint" />
      </Docs>
    </Member>
    <Member MemberName="Send">
      <MemberSignature Language="C#" Value="public int Send (byte[] dgram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 Send(unsigned int8[] dgram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.Send(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Send (dgram As Byte(), bytes As Integer, hostname As String, port As Integer) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int Send(cli::array &lt;System::Byte&gt; ^ dgram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.Send : byte[] * int * string * int -&gt; int" Usage="udpClient.Send (dgram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dgram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-1.1;netframework-2.0;netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="dgram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <param name="hostname">Der Name des Remotehosts, an den das Datagramm gesendet werden soll.</param>
        <param name="port">Die Nummer des Remoteports, mit dem kommuniziert werden soll.</param>
        <summary>Sendet ein UDP-Datagramm an einen angegebenen Port auf einem angegebenen Remotehost.</summary>
        <returns>Die Anzahl der gesendeten Bytes.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Net.Sockets.UdpClient.Send%2A>-Methode sendet Datagramme an die Werte, die von den Parametern `hostname` und `port` angegeben werden, und gibt die Anzahl der erfolgreich gesendeten Bytes zurück. Sie können Datagramme an die Standard Broadcast Adresse senden, indem Sie für den `hostname` Parameterwert "255.255.255.255" angeben.  
  
 Wenn Sie Datagramme an eine andere Broadcast Adresse senden möchten, verwenden Sie die <xref:System.Net.Sockets.UdpClient.Client%2A>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.Socket>abzurufen, und legen Sie die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest. Sie können auch die <xref:System.Net.Sockets.Socket>-Klasse wieder verwenden.  
  
> [!NOTE]
>  Geben Sie für diese Methode keinen Hostnamen oder keine Portnummer an, wenn Sie bereits einen Remote Host mit der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode eingerichtet haben. Wenn Sie dies tun, löst die <xref:System.Net.Sockets.UdpClient.Send%2A> Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die <xref:System.Net.Sockets.UdpClient.Send%2A> Methode. In diesem Beispiel werden ein Hostname und eine Portnummer zum Identifizieren des Zielhosts verwendet.  
  
 [!code-cpp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/cpp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CPP/source.cpp#9)]
 [!code-csharp[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/csharp/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/CS/source.cs#9)]
 [!code-vb[Classic UdpClient.PublicMethodsAndPropertiesExample#9](~/samples/snippets/visualbasic/VS_Snippets_Remoting/Classic UdpClient.PublicMethodsAndPropertiesExample/VB/source.vb#9)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
        <altmember cref="F:System.Net.Sockets.SocketOptionName.Broadcast" />
        <altmember cref="M:System.Net.Sockets.UdpClient.Connect(System.String,System.Int32)" />
        <altmember cref="T:System.Net.Sockets.Socket" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SendAsync">
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Sendet asynchron ein UPD-Datagramm an einen Remotehost.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <summary>Sendet asynchron ein UPD-Datagramm an einen Remotehost.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task`1" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung sendet Datagramme an den Remote Host, der in der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode festgelegt ist. Wenn Sie <xref:System.Net.Sockets.UdpClient.Connect%2A> vor dem Aufrufen dieser Überladung nicht aufrufen, löst die Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 Wenn Sie Datagramme an einen anderen Remote Host senden möchten, müssen Sie die <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode abrufen und den gewünschten Remote Host angeben. Verwenden Sie eine der anderen <xref:System.Net.Sockets.UdpClient.SendAsync%2A> Methoden Überladungen, um Datagramme an eine Broadcast Adresse zu senden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, System.Net.IPEndPoint endPoint);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, class System.Net.IPEndPoint endPoint) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.Net.IPEndPoint)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, endPoint As IPEndPoint) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::Net::IPEndPoint ^ endPoint);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * System.Net.IPEndPoint -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, endPoint)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="endPoint" Type="System.Net.IPEndPoint" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <param name="endPoint">Ein <see cref="T:System.Net.IPEndPoint" />, der den Host und Port darstellt, an die das Datagramm gesendet werden soll.</param>
        <summary>Sendet asynchron ein UPD-Datagramm an einen Remotehost.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task`1" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sendet Datagramme an den angegebenen Endpunkt. Vor dem Aufrufen dieser Überladung müssen Sie zuerst einen <xref:System.Net.IPEndPoint> mithilfe der IP-Adresse und der Portnummer des Remote Hosts erstellen, an den die Datagramme übermittelt werden. Sie können Datagramme an die Standard Broadcast Adresse 255.255.255.255 senden, indem Sie <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType> für die <xref:System.Net.IPAddress.Address%2A>-Eigenschaft der <xref:System.Net.IPEndPoint>angeben. Nachdem Sie dieses <xref:System.Net.IPEndPoint>erstellt haben, übergeben Sie es als `endPoint` Parameter an diese Methode.  
  
 Wenn Sie Datagramme an eine andere Broadcast Adresse senden möchten, verwenden Sie die <xref:System.Net.Sockets.UdpClient.Client%2A>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.Socket>abzurufen, und legen Sie die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest. Sie können auch die <xref:System.Net.Sockets.Socket>-Klasse wieder verwenden.  
  
> [!WARNING]
>  Geben Sie für diese Methode keinen `endPoint`-Parameter an, wenn Sie bereits einen Remote Host mit der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode eingerichtet haben. Wenn Sie dies tun, löst diese Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="SendAsync">
      <MemberSignature Language="C#" Value="public System.Threading.Tasks.Task&lt;int&gt; SendAsync (byte[] datagram, int bytes, string hostname, int port);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Threading.Tasks.Task`1&lt;int32&gt; SendAsync(unsigned int8[] datagram, int32 bytes, string hostname, int32 port) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.SendAsync(System.Byte[],System.Int32,System.String,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function SendAsync (datagram As Byte(), bytes As Integer, hostname As String, port As Integer) As Task(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Threading::Tasks::Task&lt;int&gt; ^ SendAsync(cli::array &lt;System::Byte&gt; ^ datagram, int bytes, System::String ^ hostname, int port);" />
      <MemberSignature Language="F#" Value="member this.SendAsync : byte[] * int * string * int -&gt; System.Threading.Tasks.Task&lt;int&gt;" Usage="udpClient.SendAsync (datagram, bytes, hostname, port)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Threading.Tasks.Task&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="datagram" Type="System.Byte[]" Index="0" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="bytes" Type="System.Int32" Index="1" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="hostname" Type="System.String" Index="2" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
        <Parameter Name="port" Type="System.Int32" Index="3" FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
      </Parameters>
      <Docs>
        <param name="datagram">Ein Array vom Typ <see cref="T:System.Byte" />, das das von Ihnen zu sendende UDP-Datagramm in Form eines Bytearrays angibt.</param>
        <param name="bytes">Die Anzahl der Bytes im Datagramm.</param>
        <param name="hostname">Der Name des Remotehosts, an den das Datagramm gesendet werden soll.</param>
        <param name="port">Die Nummer des Remoteports, mit dem kommuniziert werden soll.</param>
        <summary>Sendet asynchron ein UPD-Datagramm an einen Remotehost.</summary>
        <returns>Gibt <see cref="T:System.Threading.Tasks.Task`1" /> zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode sendet Datagramme an die Werte, die von den Parametern `hostname` und `port` angegeben werden. Sie können Datagramme an die Standard Broadcast Adresse senden, indem Sie für den `hostname` Parameterwert "255.255.255.255" angeben.  
  
 Wenn Sie Datagramme an eine andere Broadcast Adresse senden möchten, verwenden Sie die <xref:System.Net.Sockets.UdpClient.Client%2A>-Methode, um die zugrunde liegende <xref:System.Net.Sockets.Socket>abzurufen, und legen Sie die Socketoption auf <xref:System.Net.Sockets.SocketOptionName.Broadcast?displayProperty=nameWithType>fest. Sie können auch die <xref:System.Net.Sockets.Socket>-Klasse wieder verwenden.  
  
> [!WARNING]
>  Geben Sie für diese Methode keinen Hostnamen oder keine Portnummer an, wenn Sie bereits einen Remote Host mit der <xref:System.Net.Sockets.UdpClient.Connect%2A>-Methode eingerichtet haben. Wenn Sie dies tun, löst diese Methode eine <xref:System.Net.Sockets.SocketException>aus. Wenn Sie eine <xref:System.Net.Sockets.SocketException>erhalten, verwenden Sie <xref:System.Net.Sockets.SocketException.ErrorCode%2A?displayProperty=nameWithType>, um den spezifischen Fehlercode abzurufen. Nachdem Sie diesen Code abgerufen haben, finden Sie in der [API-Fehlercode Dokumentation der Windows Sockets, Version 2](/windows/desktop/winsock/windows-sockets-error-codes-2) , eine ausführliche Beschreibung des Fehlers.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="dgram" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Der <see cref="T:System.Net.Sockets.UdpClient" /> hat bereits einen Standard-Remotehost eingerichtet.</exception>
        <exception cref="T:System.ObjectDisposedException">Der <see cref="T:System.Net.Sockets.UdpClient" /> ist geschlossen.</exception>
        <exception cref="T:System.Net.Sockets.SocketException">Beim Zugreifen auf den Socket ist ein Fehler aufgetreten.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.IDisposable.Dispose">
      <MemberSignature Language="C#" Value="void IDisposable.Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance void System.IDisposable.Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.UdpClient.System#IDisposable#Dispose" />
      <MemberSignature Language="VB.NET" Value="Sub Dispose () Implements IDisposable.Dispose" />
      <MemberSignature Language="C++ CLI" Value=" virtual void System.IDisposable.Dispose() = IDisposable::Dispose;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>1.0.5000.0</AssemblyVersion>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Veröffentlicht alle durch den <see cref="T:System.Net.Sockets.UdpClient" /> verwendeten Ressourcen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks  
Wenn Sie die <xref:System.Net.Sockets.UdpClient>nicht mehr benötigen, nennen Sie iverwerf. verwerfen. Die iverwerf. verwerfen-Methode verbleibt die <xref:System.Net.Sockets.UdpClient> in einem nicht verwendbaren Zustand. Nach dem Aufrufen von "iverwerf. verwerfen" müssen Sie alle Verweise auf die <xref:System.Net.Sockets.UdpClient> freigeben, damit der Garbage Collector den Speicher freigeben kann, den der <xref:System.Net.Sockets.UdpClient> belegt hat. Weitere Informationen finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.

> [!NOTE] 
> Bevor Sie den letzten Verweis auf die <xref:System.Net.Sockets.UdpClient>freigeben, müssen Sie immer "iverwerf. verwerfen" anrufen. Andernfalls bleiben die verwendeten Ressourcen reserviert, bis die Garbage Collection die <xref:System.Net.Sockets.UdpClient>-Methode des `Finalize`-Objekts aufruft.

]]></format>
        </remarks>
        <forInternalUseOnly />
      </Docs>
    </Member>
    <Member MemberName="Ttl">
      <MemberSignature Language="C#" Value="public short Ttl { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int16 Ttl" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.UdpClient.Ttl" />
      <MemberSignature Language="VB.NET" Value="Public Property Ttl As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property short Ttl { short get(); void set(short value); };" />
      <MemberSignature Language="F#" Value="member this.Ttl : int16 with get, set" Usage="System.Net.Sockets.UdpClient.Ttl" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
        <AssemblyVersion>4.2.2.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Gültigkeitsdauer (TTL – Time to Live) von IP (Internet Protocol)-Paketen angibt, die vom <see cref="T:System.Net.Sockets.UdpClient" /> gesendet werden.</summary>
        <value>Der TTL-Wert.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der TTL-Wert gibt die maximale Anzahl von Routern an, die von einem Paket durchlaufen werden können, bevor der Router das Paket verwirft, und eine ICMP (Internet Control Message Protocol)-Fehlermeldung (ICMP) wird an den Absender zurückgegeben.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird die Verwendung der <xref:System.Net.Sockets.UdpClient.Ttl%2A>-Eigenschaft veranschaulicht.  
  
 [!code-cpp[System.Net.Sockets.UdpClient#5](~/samples/snippets/cpp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CPP/newudpclient.cpp#5)]
 [!code-csharp[System.Net.Sockets.UdpClient#5](~/samples/snippets/csharp/VS_Snippets_Remoting/System.Net.Sockets.UdpClient/CS/newudpclient.cs#5)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
