<Type Name="SocketAsyncEventArgs" FullName="System.Net.Sockets.SocketAsyncEventArgs">
  <Metadata><Meta Name="ms.openlocfilehash" Value="44f795db5121254ce83e94705990592f00936b52" /><Meta Name="ms.sourcegitcommit" Value="d4927e9cfed35ec2d092c9f431fc195bddc59a2b" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="10/26/2019" /><Meta Name="ms.locfileid" Value="72959778" /></Metadata><TypeSignature Language="C#" Value="public class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit SocketAsyncEventArgs extends System.EventArgs implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Net.Sockets.SocketAsyncEventArgs" />
  <TypeSignature Language="VB.NET" Value="Public Class SocketAsyncEventArgs&#xA;Inherits EventArgs&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class SocketAsyncEventArgs : EventArgs, IDisposable" />
  <TypeSignature Language="F#" Value="type SocketAsyncEventArgs = class&#xA;    inherit EventArgs&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Net.Sockets</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.0.0</AssemblyVersion>
    <AssemblyVersion>4.2.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Net</AssemblyName>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.EventArgs</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary><span data-ttu-id="c254c-101">Stellt einen asynchronen Socketvorgang dar.</span><span class="sxs-lookup"><span data-stu-id="c254c-101">Represents an asynchronous socket operation.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-102">Die <xref:System.Net.Sockets.SocketAsyncEventArgs>-Klasse ist Teil einer Reihe von Erweiterungen für die <xref:System.Net.Sockets.Socket?displayProperty=nameWithType>-Klasse, die ein alternatives asynchrones Muster bereitstellen, das von spezialisierten hochleistungsfähigen Socketanwendungen verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-102">The <xref:System.Net.Sockets.SocketAsyncEventArgs> class is part of a set of enhancements to the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class that provide an alternative asynchronous pattern that can be used by specialized high-performance socket applications.</span></span> <span data-ttu-id="c254c-103">Diese Klasse wurde speziell für Netzwerkserver Anwendungen entwickelt, die eine hohe Leistung erfordern.</span><span class="sxs-lookup"><span data-stu-id="c254c-103">This class was specifically designed for network server applications that require high performance.</span></span> <span data-ttu-id="c254c-104">Eine Anwendung kann das erweiterte asynchrone Muster exklusiv oder nur in Ziel-Hot-Bereichen verwenden (z. b. beim Empfang großer Datenmengen).</span><span class="sxs-lookup"><span data-stu-id="c254c-104">An application can use the enhanced asynchronous pattern exclusively or only in targeted hot areas (for example, when receiving large amounts of data).</span></span>  
  
 <span data-ttu-id="c254c-105">Die Hauptfunktion dieser Erweiterungen ist die Vermeidung der wiederholten Zuordnung und Synchronisierung von Objekten während asynchroner Socket-E/A mit hohem Volumen.</span><span class="sxs-lookup"><span data-stu-id="c254c-105">The main feature of these enhancements is the avoidance of the repeated allocation and synchronization of objects during high-volume asynchronous socket I/O.</span></span> <span data-ttu-id="c254c-106">Das Begin/End-Entwurfsmuster, das derzeit von der <xref:System.Net.Sockets.Socket?displayProperty=nameWithType>-Klasse implementiert wird, erfordert, dass für jeden asynchronen Socketvorgang ein <xref:System.IAsyncResult?displayProperty=nameWithType> Objekt zugeordnet wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-106">The Begin/End design pattern currently implemented by the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class requires a <xref:System.IAsyncResult?displayProperty=nameWithType> object be allocated for each asynchronous socket operation.</span></span>  
  
 <span data-ttu-id="c254c-107">In den neuen Erweiterungen der <xref:System.Net.Sockets.Socket?displayProperty=nameWithType>-Klasse werden asynchrone Socketvorgänge durch wiederverwendbare <xref:System.Net.Sockets.SocketAsyncEventArgs> Objekte beschrieben, die von der Anwendung zugewiesen und verwaltet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-107">In the new <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class enhancements, asynchronous socket operations are described by reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects allocated and maintained by the application.</span></span> <span data-ttu-id="c254c-108">Socketanwendungen mit hoher Leistung kennen die Menge an überlappenden Socketvorgängen, die aufrechterhalten werden müssen, am besten.</span><span class="sxs-lookup"><span data-stu-id="c254c-108">High-performance socket applications know best the amount of overlapped socket operations that must be sustained.</span></span> <span data-ttu-id="c254c-109">Die Anwendung kann so viele <xref:System.Net.Sockets.SocketAsyncEventArgs>-Objekte erstellen wie nötig.</span><span class="sxs-lookup"><span data-stu-id="c254c-109">The application can create as many of the <xref:System.Net.Sockets.SocketAsyncEventArgs> objects that it needs.</span></span> <span data-ttu-id="c254c-110">Wenn z. b. für eine Serveranwendung immer 15 Socket-Accept-Vorgänge ausstehen müssen, um eingehende Client Verbindungsraten zu unterstützen, kann Sie 15 wiederverwendbare <xref:System.Net.Sockets.SocketAsyncEventArgs> Objekte zu diesem Zweck zuordnen.</span><span class="sxs-lookup"><span data-stu-id="c254c-110">For example, if a server application needs to have 15 socket accept operations outstanding at all times to support incoming client connection rates, it can allocate 15 reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects for that purpose.</span></span>  
  
 <span data-ttu-id="c254c-111">Das Muster zum Ausführen eines asynchronen Socketvorgangs mit dieser Klasse besteht aus den folgenden Schritten:</span><span class="sxs-lookup"><span data-stu-id="c254c-111">The pattern for performing an asynchronous socket operation with this class consists of the following steps:</span></span>  
  
1.  <span data-ttu-id="c254c-112">Zuweisen eines neuen <xref:System.Net.Sockets.SocketAsyncEventArgs>-Kontextobjekt oder Abrufen eines kostenlosen aus einem Anwendungspool.</span><span class="sxs-lookup"><span data-stu-id="c254c-112">Allocate a new <xref:System.Net.Sockets.SocketAsyncEventArgs> context object, or get a free one from an application pool.</span></span>  
  
2.  <span data-ttu-id="c254c-113">Legen Sie Eigenschaften für das Kontext Objekt auf den Vorgang fest, der ausgeführt werden soll (die Abschluss Rückruf Methode, der Datenpuffer, der Offset im Puffer und die maximale zu übertragenden Datenmenge).</span><span class="sxs-lookup"><span data-stu-id="c254c-113">Set properties on the context object to the operation about to be performed (the completion callback method, the data buffer, the offset into the buffer, and the maximum amount of data to transfer, for example).</span></span>  
  
3.  <span data-ttu-id="c254c-114">Aufrufen der entsprechenden Socketmethode (XxxAsync) zum Initiieren des asynchronen Vorgangs.</span><span class="sxs-lookup"><span data-stu-id="c254c-114">Call the appropriate socket method (xxxAsync) to initiate the asynchronous operation.</span></span>  
  
4.  <span data-ttu-id="c254c-115">Wenn die asynchrone Socketmethode (xxxAsync) true zurückgibt, Fragen Sie im Rückruf die Kontexteigenschaften nach Abschluss Status ab.</span><span class="sxs-lookup"><span data-stu-id="c254c-115">If the asynchronous socket method (xxxAsync) returns true, in the callback, query the context properties for completion status.</span></span>  
  
5.  <span data-ttu-id="c254c-116">Wenn die asynchrone Socketmethode (xxxAsync) false zurückgibt, wurde der Vorgang synchron abgeschlossen.</span><span class="sxs-lookup"><span data-stu-id="c254c-116">If the asynchronous socket method (xxxAsync) returns false, the operation completed synchronously.</span></span> <span data-ttu-id="c254c-117">Die Kontexteigenschaften könnten möglicherweise für das Betriebsergebnis abgefragt werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-117">The context properties may be queried for the operation result.</span></span>  
  
6.  <span data-ttu-id="c254c-118">Verwenden Sie den Kontext für einen anderen Vorgang erneut, fügen Sie ihn wieder in den Pool ein, oder verwerfen Sie ihn.</span><span class="sxs-lookup"><span data-stu-id="c254c-118">Reuse the context for another operation, put it back in the pool, or discard it.</span></span>  
  
 <span data-ttu-id="c254c-119">Die Lebensdauer des neuen Kontext Objekts für den asynchronen Socketvorgang wird durch Verweise durch den Anwendungscode und asynchrone e/a-Verweise bestimmt.</span><span class="sxs-lookup"><span data-stu-id="c254c-119">The lifetime of the new asynchronous socket operation context object is determined by references by the application code and asynchronous I/O references.</span></span> <span data-ttu-id="c254c-120">Es ist nicht erforderlich, dass die Anwendung einen Verweis auf das Kontextobjekt des asynchronen Socketvorgangs beibehält, nachdem er als Parameter an eine der Methoden des asynchronen Socketvorgangs gesendet wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-120">It is not necessary for the application to retain a reference to an asynchronous socket operation context object after it is submitted as a parameter to one of the asynchronous socket operation methods.</span></span> <span data-ttu-id="c254c-121">Der Verweis bleibt bestehen, bis der Abschlussrückruf zurückgegeben wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-121">It will remain referenced until the completion callback returns.</span></span> <span data-ttu-id="c254c-122">Es ist jedoch von Vorteil, dass die Anwendung den Verweis auf den Kontext beibehält, damit Sie für einen zukünftigen asynchronen Socketvorgang wieder verwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-122">However it is advantageous for the application to retain the reference to the context so that it can be reused for a future asynchronous socket operation.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c254c-123">Im folgenden Codebeispiel wird die Verbindungs Logik für den Socketserver implementiert, der die <xref:System.Net.Sockets.SocketAsyncEventArgs>-Klasse verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-123">The following code example implements the connection logic for the socket server that uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> class.</span></span> <span data-ttu-id="c254c-124">Nachdem eine Verbindung akzeptiert wurde, werden alle vom Client gelesenen Daten zurück an den Client gesendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-124">After accepting a connection, all data read from the client is sent back to the client.</span></span> <span data-ttu-id="c254c-125">Der Lese-und Echo Vorgang des Client Musters wird fortgesetzt, bis der Client die Verbindung trennt.</span><span class="sxs-lookup"><span data-stu-id="c254c-125">The read and echo back to the client pattern is continued until the client disconnects.</span></span> <span data-ttu-id="c254c-126">Die von diesem Beispiel verwendete BufferManager-Klasse wird im Codebeispiel für die <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29>-Methode angezeigt.</span><span class="sxs-lookup"><span data-stu-id="c254c-126">The BufferManager class that is used by this example is displayed in the code example for the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%28System.Byte%5B%5D%2CSystem.Int32%2CSystem.Int32%29> method.</span></span> <span data-ttu-id="c254c-127">Die socketasynceventargspool-Klasse, die in diesem Beispiel verwendet wird, wird im Codebeispiel für den <xref:System.Net.Sockets.SocketAsyncEventArgs.%23ctor%2A>-Konstruktor angezeigt.</span><span class="sxs-lookup"><span data-stu-id="c254c-127">The SocketAsyncEventArgsPool class that is used in this example is displayed in the code example for the <xref:System.Net.Sockets.SocketAsyncEventArgs.%23ctor%2A> constructor.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#3)]  
  
 ]]></format>
    </remarks>
    <altmember cref="T:System.IAsyncResult" />
    <altmember cref="T:System.Net.Sockets.Socket" />
    <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
    <related type="Article" href="~/docs/framework/network-programming/index.md"><span data-ttu-id="c254c-128">Netzwerkprogrammierung in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="c254c-128">Network Programming in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/network-tracing.md"><span data-ttu-id="c254c-129">Netzwerkablaufverfolgung in .NET Framework</span><span class="sxs-lookup"><span data-stu-id="c254c-129">Network Tracing in the .NET Framework</span></span></related>
    <related type="Article" href="~/docs/framework/network-programming/socket-performance-enhancements-in-version-3-5.md"><span data-ttu-id="c254c-130">Erweiterungen der Socketleistung in Version 3.5</span><span class="sxs-lookup"><span data-stu-id="c254c-130">Socket Performance Enhancements in Version 3.5</span></span></related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; SocketAsyncEventArgs();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c254c-131">Erstellt eine leere <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Instanz.</span><span class="sxs-lookup"><span data-stu-id="c254c-131">Creates an empty <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> instance.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-132">Nachdem Sie diesen Konstruktor aufgerufen haben, haben alle Eigenschaften ihre Standardwerte:</span><span class="sxs-lookup"><span data-stu-id="c254c-132">After calling this constructor all properties will have their default values:</span></span>  
  
-   <span data-ttu-id="c254c-133">Objekt Verweise sind NULL.</span><span class="sxs-lookup"><span data-stu-id="c254c-133">Object references will be null</span></span>  
  
-   <span data-ttu-id="c254c-134">Eigenschaften, die eine ganze Zahl zurückgeben, geben NULL zurück.</span><span class="sxs-lookup"><span data-stu-id="c254c-134">Properties that return an integer will return zero.</span></span>  
  
-   <span data-ttu-id="c254c-135">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.LastOperation%2A>-Eigenschaft ist gleich <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span><span class="sxs-lookup"><span data-stu-id="c254c-135">The <xref:System.Net.Sockets.SocketAsyncEventArgs.LastOperation%2A> property will be equal to <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span></span>  
  
-   <span data-ttu-id="c254c-136">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A>-Eigenschaft ist gleich <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread?displayProperty=nameWithType>, wodurch angegeben wird, dass keine Flags verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-136">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags%2A> property will be equal to <xref:System.Net.Sockets.TransmitFileOptions.UseDefaultWorkerThread?displayProperty=nameWithType>, which specifies no flags will be used.</span></span>  
  
-   <span data-ttu-id="c254c-137">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A>-Eigenschaft ist gleich <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span><span class="sxs-lookup"><span data-stu-id="c254c-137">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags%2A> property will be equal to <xref:System.Net.Sockets.SocketAsyncOperation.None>.</span></span>  
  
 <span data-ttu-id="c254c-138">Der Aufrufer muss die entsprechenden Eigenschaften festlegen, bevor das Objekt an die entsprechende asynchronen Socket (xxxAsync)-Methode übergeben wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-138">The caller must set the appropriate properties prior to passing the object to the appropriate asynchronous socket (xxxAsync) method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c254c-139">Das folgende Codebeispiel stellt eine Auflistung von wiederverwendbaren <xref:System.Net.Sockets.SocketAsyncEventArgs>-Objekten dar.</span><span class="sxs-lookup"><span data-stu-id="c254c-139">The following code example represents a collection of reusable <xref:System.Net.Sockets.SocketAsyncEventArgs> objects.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#2](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#2)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><span data-ttu-id="c254c-140">Die Plattform wird nicht unterstützt.</span><span class="sxs-lookup"><span data-stu-id="c254c-140">The platform is not supported.</span></span></exception>
      </Docs>
    </Member>
    <Member MemberName="AcceptSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket AcceptSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket AcceptSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property AcceptSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ AcceptSocket { System::Net::Sockets::Socket ^ get(); void set(System::Net::Sockets::Socket ^ value); };" />
      <MemberSignature Language="F#" Value="member this.AcceptSocket : System.Net.Sockets.Socket with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.AcceptSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-141">Ruft den Socket ab, der zum Akzeptieren einer Verbindung mit einer asynchronen Socketmethode erstellt wird, oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-141">Gets or sets the socket to use or the socket created for accepting a connection with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="c254c-142">Der zu verwendende <see cref="T:System.Net.Sockets.Socket" /> oder der Socket, der zum Akzeptieren einer Verbindung mit einer asynchronen Socketmethode erstellt wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-142">The <see cref="T:System.Net.Sockets.Socket" /> to use or the socket created for accepting a connection with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-143">Diese Eigenschaft kann verwendet werden, um einen bereits erstellten <xref:System.Net.Sockets.Socket> bereitzustellen, der für einen asynchronen Socket-Accept-Vorgang verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-143">This property can be used to provide an already created <xref:System.Net.Sockets.Socket> that will be used for an asynchronous socket accept operation.</span></span> <span data-ttu-id="c254c-144">Nach Abschluss des Accept-Vorgangs ist dies der Socket, der die akzeptierte Verbindung darstellt.</span><span class="sxs-lookup"><span data-stu-id="c254c-144">Upon completion of the accept operation, it is the socket representing the accepted connection.</span></span> <span data-ttu-id="c254c-145">Wenn keine Angabe erfolgt (festgelegt auf null), bevor die <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>-Methode aufgerufen wird, wird automatisch ein neuer Socket erstellt, und im Abschluss Rückruf mit dieser Eigenschaft kann darauf zugegriffen werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-145">If not supplied (set to null) before calling the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> method, a new socket will be created automatically and be accessible in the completion callback with this property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Buffer">
      <MemberSignature Language="C#" Value="public byte[] Buffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance unsigned int8[] Buffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Buffer As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Byte&gt; ^ Buffer { cli::array &lt;System::Byte&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Buffer : byte[]" Usage="System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-146">Ruft den Datenpuffer ab, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-146">Gets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="c254c-147">Ein <see cref="T:System.Byte" />-Array, das den Datenpuffer darstellt, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-147">A <see cref="T:System.Byte" /> array that represents the data buffer to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-148">Diese Eigenschaft ruft den Datenpuffer ab, der der <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz derzeit zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-148">This property gets the data buffer currently associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance.</span></span> <span data-ttu-id="c254c-149">Um den Puffer festzulegen, muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>-Methode verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-149">To set the buffer, the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method must be used.</span></span>  
  
 <span data-ttu-id="c254c-150">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>und <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-150">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="BufferList">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; BufferList { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;valuetype System.ArraySegment`1&lt;unsigned int8&gt;&gt; BufferList" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
      <MemberSignature Language="VB.NET" Value="Public Property BufferList As IList(Of ArraySegment(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ BufferList { System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ get(); void set(System::Collections::Generic::IList&lt;ArraySegment&lt;System::Byte&gt;&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.BufferList : System.Collections.Generic.IList&lt;ArraySegment&lt;byte&gt;&gt; with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.BufferList" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.ArraySegment&lt;System.Byte&gt;&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-151">Ruft ein Array von Datenpuffern ab, die mit einer asynchronen Socketmethode verwendet werden sollen, oder legt es fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-151">Gets or sets an array of data buffers to use with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="c254c-152">Eine <see cref="T:System.Collections.IList" />, die ein Array von Datenpuffern darstellt, die mit einer asynchronen Socketmethode verwendet werden sollen.</span><span class="sxs-lookup"><span data-stu-id="c254c-152">An <see cref="T:System.Collections.IList" /> that represents an array of data buffers to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-153">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-153">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c254c-154">Diese Eigenschaft wird verwendet, um mehrere Datenpuffer bereitzustellen, die gesendet werden sollen, oder um mehrere Puffer bereitzustellen, in denen empfangene Daten für einen asynchronen Socketvorgang gespeichert werden, der Daten senden oder empfangen kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-154">This property is used to provide multiple buffers of data to be sent or to provide multiple buffers in which to store received data for an asynchronous socket operation that can send or receive data.</span></span> <span data-ttu-id="c254c-155">Mehrere Puffer, die die <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Eigenschaft verwenden, werden von den Methoden <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> unterstützt.</span><span class="sxs-lookup"><span data-stu-id="c254c-155">Multiple buffers using the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property are supported by the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c254c-156">Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Eigenschaft auf einen Wert ungleich NULL festgelegt ist, muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft NULL sein und wird von den Methoden <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> ignoriert.</span><span class="sxs-lookup"><span data-stu-id="c254c-156">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property is set to a non-null value, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property must be null and is ignored by the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c254c-157">Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> auf einen nicht-NULL-Wert festgelegt wurde und versucht wird, die <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Eigenschaft auf einen Wert ungleich NULL festzulegen, wird eine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="c254c-157">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> was set to a non-null value and an attempt is made to set the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property to a non-null value, an exception is thrown.</span></span>  
  
 <span data-ttu-id="c254c-158">Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Eigenschaft auf einen Wert ungleich NULL festgelegt wird, lösen die Methoden <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> einen <xref:System.ArgumentException>aus.</span><span class="sxs-lookup"><span data-stu-id="c254c-158">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property is set to a non-null value, the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType> methods will throw an <xref:System.ArgumentException>.</span></span>  
  
 <span data-ttu-id="c254c-159">Der <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Parameter wird von den Methoden <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> und <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> ignoriert.</span><span class="sxs-lookup"><span data-stu-id="c254c-159">The <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> parameter is ignored by the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> and <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c254c-160">Für einen set-Vorgang wurden mehrdeutige Puffer angegeben.</span><span class="sxs-lookup"><span data-stu-id="c254c-160">There are ambiguous buffers specified on a set operation.</span></span> <span data-ttu-id="c254c-161">Diese Ausnahme tritt auf, wenn die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft auf einen Wert ungleich NULL festgelegt wurde und versucht wurde, die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft auf einen Wert ungleich NULL festzulegen.</span><span class="sxs-lookup"><span data-stu-id="c254c-161">This exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property has been set to a non-null value and an attempt was made to set the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property to a non-null value.</span></span></exception>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="BytesTransferred">
      <MemberSignature Language="C#" Value="public int BytesTransferred { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BytesTransferred" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.BytesTransferred" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property BytesTransferred As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BytesTransferred { int get(); };" />
      <MemberSignature Language="F#" Value="member this.BytesTransferred : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.BytesTransferred" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-162">Ruft die Anzahl der im Socketvorgang übertragenen Bytes ab.</span><span class="sxs-lookup"><span data-stu-id="c254c-162">Gets the number of bytes transferred in the socket operation.</span></span></summary>
        <value><span data-ttu-id="c254c-163">Ein <see cref="T:System.Int32" /> mit der Anzahl der im Socketvorgang übertragenen Bytes.</span><span class="sxs-lookup"><span data-stu-id="c254c-163">An <see cref="T:System.Int32" /> that contains the number of bytes transferred in the socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-164">Diese Eigenschaft gibt die Anzahl der Bytes an, die in einem asynchronen Socketvorgang übertragen werden, der Daten empfangen oder senden kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-164">This property provides the number of bytes transferred in an asynchronous socket operation that can receive or send data.</span></span> <span data-ttu-id="c254c-165">Wenn NULL von einem Lesevorgang zurückgegeben wird, hat das Remote Ende die Verbindung geschlossen.</span><span class="sxs-lookup"><span data-stu-id="c254c-165">If zero is returned from a read operation, the remote end has closed the connection.</span></span>  
  
 <span data-ttu-id="c254c-166">Diese Eigenschaft wird von allen asynchronen Socketvorgängen außer der <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>-Methode festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-166">This property is set by all asynchronous socket operations except the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Completed">
      <MemberSignature Language="C#" Value="public event EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; Completed;" />
      <MemberSignature Language="ILAsm" Value=".event class System.EventHandler`1&lt;class System.Net.Sockets.SocketAsyncEventArgs&gt; Completed" />
      <MemberSignature Language="DocId" Value="E:System.Net.Sockets.SocketAsyncEventArgs.Completed" />
      <MemberSignature Language="VB.NET" Value="Public Custom Event Completed As EventHandler(Of SocketAsyncEventArgs) " />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; event EventHandler&lt;System::Net::Sockets::SocketAsyncEventArgs ^&gt; ^ Completed;" />
      <MemberSignature Language="F#" Value="member this.Completed : EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; " Usage="member this.Completed : System.EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt; " />
      <MemberType>Event</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.EventHandler&lt;System.Net.Sockets.SocketAsyncEventArgs&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-167">Das Ereignis, das zum Abschließen eines asynchronen Vorgangs verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-167">The event used to complete an asynchronous operation.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-168">Das Ereignis <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> bietet Client Anwendungen die Möglichkeit, einen asynchronen Socketvorgang abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="c254c-168">The <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event provides a way for client applications to complete an asynchronous socket operation.</span></span> <span data-ttu-id="c254c-169">Beim Initiieren eines asynchronen Socketvorgangs sollte ein Ereignishandler an das-Ereignis innerhalb einer <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz angefügt werden. andernfalls kann die Anwendung nicht ermitteln, wann der Vorgang abgeschlossen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-169">An event handler should be attached to the event within a <xref:System.Net.Sockets.SocketAsyncEventArgs> instance when an asynchronous socket operation is initiated, otherwise the application will not be able to determine when the operation completes.</span></span>  
  
 <span data-ttu-id="c254c-170">Die vom <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> Ereignis referenzierten Beendigungs Rückruf Delegaten enthalten Programmlogik, um die Verarbeitung des asynchronen Socketvorgangs für den Client abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="c254c-170">The completion callback delegates referenced by the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event contains program logic to finish processing the asynchronous socket operation for the client.</span></span>  
  
 <span data-ttu-id="c254c-171">Wenn das Ereignis signalisiert wird, verwendet die Anwendung den <xref:System.Net.Sockets.SocketAsyncEventArgs> Object-Parameter, um den Status des abgeschlossenen asynchronen Socketvorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c254c-171">When the event is signaled, the application uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> object parameter to obtain the status of the completed asynchronous socket operation.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ConnectByNameError">
      <MemberSignature Language="C#" Value="public Exception ConnectByNameError { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Exception ConnectByNameError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectByNameError As Exception" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Exception ^ ConnectByNameError { Exception ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectByNameError : Exception" Usage="System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Exception</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-172">Ruft die Ausnahme im Fall eines Verbindungsfehlers ab, wenn <see cref="T:System.Net.DnsEndPoint" /> verwendet wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-172">Gets the exception in the case of a connection failure when a <see cref="T:System.Net.DnsEndPoint" /> was used.</span></span></summary>
        <value><span data-ttu-id="c254c-173">Ein <see cref="T:System.Exception" />, das die Ursache des Verbindungsfehlers angibt, wenn ein <see cref="T:System.Net.DnsEndPoint" /> für die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />-Eigenschaft angegeben wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-173">An <see cref="T:System.Exception" /> that indicates the cause of the connection error when a <see cref="T:System.Net.DnsEndPoint" /> was specified for the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" /> property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-174">Im Fall eines Verbindungsfehlers, wenn ein <xref:System.Net.DnsEndPoint> für die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A>-Eigenschaft angegeben wurde, enthält die <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>-Eigenschaft die Ausnahme, die die detaillierte Ursache des Socketfehlers angibt.</span><span class="sxs-lookup"><span data-stu-id="c254c-174">In the case of a connection failure when a <xref:System.Net.DnsEndPoint> was specified for the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> property, the <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property will contain the exception that indicates the detailed cause of the socket error.</span></span>  
  
 <span data-ttu-id="c254c-175">Wenn ein <xref:System.Net.IPEndPoint> für die <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A>-Eigenschaft angegeben wurde und ein Verbindungsfehler auftritt, ist die <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>-Eigenschaft ein `null` Verweis.</span><span class="sxs-lookup"><span data-stu-id="c254c-175">When an <xref:System.Net.IPEndPoint> was specified for the <xref:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint%2A> property and a connection failure occurs, the <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property will be a `null` reference.</span></span>  
  
 <span data-ttu-id="c254c-176">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A>-Eigenschaft wird immer im Fall eines Verbindungsfehlers festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-176">The <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> property is always set in the case of a connection failure.</span></span> <span data-ttu-id="c254c-177">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A>-Eigenschaft enthält weitere Informationen zu dem Fehler, wenn beim Herstellen einer Verbindung mit einem <xref:System.Net.DnsEndPoint>ein Fehler aufgetreten ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-177">The <xref:System.Net.Sockets.SocketAsyncEventArgs.ConnectByNameError%2A> property contains more information about the failure if it was a failure connecting to a <xref:System.Net.DnsEndPoint>.</span></span> <span data-ttu-id="c254c-178">Wenn eine Anwendung nur daran interessiert ist, ob der Verbindungsvorgang erfolgreich war oder fehlgeschlagen ist, muss die Anwendung nur die <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A>-Eigenschaft überprüfen.</span><span class="sxs-lookup"><span data-stu-id="c254c-178">If an application is only interested in whether the connect operation succeeded or failed, then the application only needs to check the <xref:System.Net.Sockets.SocketAsyncEventArgs.SocketError%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="ConnectSocket">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.Socket ConnectSocket { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.Socket ConnectSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ConnectSocket" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ConnectSocket As Socket" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::Socket ^ ConnectSocket { System::Net::Sockets::Socket ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.ConnectSocket : System.Net.Sockets.Socket" Usage="System.Net.Sockets.SocketAsyncEventArgs.ConnectSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.Socket</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-179">Das erstellte und verbundene <see cref="T:System.Net.Sockets.Socket" />-Objekt nach dem erfolgreichen Beenden der <see cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />-Methode.</span><span class="sxs-lookup"><span data-stu-id="c254c-179">The created and connected <see cref="T:System.Net.Sockets.Socket" /> object after successful completion of the <see cref="Overload:System.Net.Sockets.Socket.ConnectAsync" /> method.</span></span></summary>
        <value><span data-ttu-id="c254c-180">Das verbundene <see cref="T:System.Net.Sockets.Socket" />-Objekt.</span><span class="sxs-lookup"><span data-stu-id="c254c-180">The connected <see cref="T:System.Net.Sockets.Socket" /> object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-181">Nach erfolgreichem Abschluss der <xref:System.Net.Sockets.Socket.ConnectAsync%2A>-Methode enthält diese Eigenschaft das neu erstellte und verbundene <xref:System.Net.Sockets.Socket>-Objekt.</span><span class="sxs-lookup"><span data-stu-id="c254c-181">After successful completion of the <xref:System.Net.Sockets.Socket.ConnectAsync%2A> method, this property contains the newly created and connected <xref:System.Net.Sockets.Socket> object.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Net.Sockets.Socket.ConnectAsync" />
      </Docs>
    </Member>
    <Member MemberName="Count">
      <MemberSignature Language="C#" Value="public int Count { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Count" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Count As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Count { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Count : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.Count" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-182">Ruft die maximale Datenmenge in Bytes ab, die in einem asynchronen Vorgang gesendet oder empfangen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-182">Gets the maximum amount of data, in bytes, to send or receive in an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="c254c-183">Ein <see cref="T:System.Int32" /> mit der maximalen Datenmenge in Bytes, die gesendet oder empfangen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-183">An <see cref="T:System.Int32" /> that contains the maximum amount of data, in bytes, to send or receive.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-184">Diese Eigenschaft wird durch Aufrufen der <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>-Methode festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-184">This property is set by calling the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="c254c-185">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>und <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-185">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="DisconnectReuseSocket">
      <MemberSignature Language="C#" Value="public bool DisconnectReuseSocket { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool DisconnectReuseSocket" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      <MemberSignature Language="VB.NET" Value="Public Property DisconnectReuseSocket As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool DisconnectReuseSocket { bool get(); void set(bool value); };" />
      <MemberSignature Language="F#" Value="member this.DisconnectReuseSocket : bool with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.DisconnectReuseSocket" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-186">Ruft einen Wert ab, der angibt, ob ein Socket nach einem Trennvorgang wiederverwendet werden kann, oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-186">Gets or sets a value that specifies if socket can be reused after a disconnect operation.</span></span></summary>
        <value><span data-ttu-id="c254c-187">Ein <see cref="T:System.Boolean" />, der angibt, ob ein Socket nach einem Trennvorgang wiederverwendet werden kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-187">A <see cref="T:System.Boolean" /> that specifies if socket can be reused after a disconnect operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-188">Diese Eigenschaft wird verwendet, um das Verhalten <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>-Methode zu ändern.</span><span class="sxs-lookup"><span data-stu-id="c254c-188">This property is used to alter the behavior of <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c254c-189">True gibt an, dass ein durch die <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType>-Methode verbundener Socket wieder verwendet werden kann, nachdem die Beendigung in nachfolgenden Socket Accept-oder Connect-Vorgängen</span><span class="sxs-lookup"><span data-stu-id="c254c-189">If true, a socket disconnected by the <xref:System.Net.Sockets.Socket.DisconnectAsync%2A?displayProperty=nameWithType> method can be reused after disconnect completion in subsequent socket accept or connect operations.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="socketAsyncEventArgs.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c254c-190">Gibt die von der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Instanz verwendeten nicht verwalteten Ressourcen zurück und verwirft optional die verwalteten Ressourcen.</span><span class="sxs-lookup"><span data-stu-id="c254c-190">Releases the unmanaged resources used by the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> instance and optionally disposes of the managed resources.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-191">Diese Methode wird von der öffentlichen `Dispose()`-Methode und der <xref:System.Object.Finalize%2A>-Methode aufgerufen.</span><span class="sxs-lookup"><span data-stu-id="c254c-191">This method is called by the public `Dispose()` method and the <xref:System.Object.Finalize%2A> method.</span></span> <span data-ttu-id="c254c-192">`Dispose()` ruft die geschützte `Dispose(Boolean)`-Methode auf, wobei der `disposing`-Parameter auf `true` festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-192">`Dispose()` invokes the protected `Dispose(Boolean)` method with the `disposing` parameter set to `true`.</span></span> <span data-ttu-id="c254c-193"><xref:System.Object.Finalize%2A> ruft `Dispose` auf, wenn `disposing` auf `false` festgelegt ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-193"><xref:System.Object.Finalize%2A> invokes `Dispose` with `disposing` set to `false`.</span></span>  
  
 <span data-ttu-id="c254c-194">Wenn der `disposing`-Parameter `true` ist, gibt diese Methode sämtliche Ressourcen frei, die für verwaltete Objekte reserviert sind, auf die dieser <xref:System.Net.Sockets.SocketAsyncEventArgs> verweist.</span><span class="sxs-lookup"><span data-stu-id="c254c-194">When the `disposing` parameter is `true`, this method releases all resources held by any managed objects that this <xref:System.Net.Sockets.SocketAsyncEventArgs> references.</span></span> <span data-ttu-id="c254c-195">Diese Methode ruft die `Dispose()`-Methode aller Objekte auf, auf die verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-195">This method invokes the `Dispose()` method of each referenced object.</span></span>  
  
> [!NOTE]
>  <span data-ttu-id="c254c-196">Dieser Member gibt Ablaufverfolgungsinformationen aus, wenn Sie die Netzwerkablaufverfolgung in der Anwendung aktivieren.</span><span class="sxs-lookup"><span data-stu-id="c254c-196">This member outputs trace information when you enable network tracing in your application.</span></span> <span data-ttu-id="c254c-197">Weitere Informationen finden Sie unter [Netzwerk Ablauf Verfolgung in der .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span><span class="sxs-lookup"><span data-stu-id="c254c-197">For more information, see [Network Tracing in the .NET Framework](~/docs/framework/network-programming/network-tracing.md).</span></span>  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para><span data-ttu-id="c254c-198">
            <see langword="Dispose" /> kann von anderen Objekten mehrmals aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-198">
            <see langword="Dispose" /> can be called multiple times by other objects.</span></span> <span data-ttu-id="c254c-199">Beim Überschreiben von <see langword="Dispose(Boolean)" /> müssen Sie darauf achten, nicht auf Objekte zu verweisen, die durch einen früheren Aufruf von <see langword="Dispose" /> freigegeben wurden.</span><span class="sxs-lookup"><span data-stu-id="c254c-199">When overriding <see langword="Dispose(Boolean)" />, be careful not to reference objects that have been previously disposed of in an earlier call to <see langword="Dispose" />.</span></span> <span data-ttu-id="c254c-200">Weitere Informationen zum Implementieren von <see langword="Dispose(Boolean)" /> finden Sie unter [Implementieren einer](~/docs/standard/garbage-collection/implementing-dispose.md)verwerfen-Methode.</span><span class="sxs-lookup"><span data-stu-id="c254c-200">For more information about how to implement <see langword="Dispose(Boolean)" />, see [Implementing a Dispose Method](~/docs/standard/garbage-collection/implementing-dispose.md).</span></span>  
  
<span data-ttu-id="c254c-201">Weitere Informationen zu <see langword="Dispose" /> und <see cref="M:System.Object.Finalize" /> finden Sie unter [Bereinigen von nicht verwalteten Ressourcen](~/docs/standard/garbage-collection/unmanaged.md) und überschreiben [der Finalize-Methode](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span><span class="sxs-lookup"><span data-stu-id="c254c-201">For more information about <see langword="Dispose" /> and <see cref="M:System.Object.Finalize" />, see [Cleaning Up Unmanaged Resources](~/docs/standard/garbage-collection/unmanaged.md) and [Overriding the Finalize Method](https://docs.microsoft.com/previous-versions/dotnet/netframework-4.0/ddae83kx(v=vs.100)).</span></span></para></block>
        <altmember cref="M:System.Object.Finalize" />
      </Docs>
    </Member>
    <Member MemberName="Finalize">
      <MemberSignature Language="C#" Value="~SocketAsyncEventArgs ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void Finalize() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.Finalize" />
      <MemberSignature Language="VB.NET" Value="Finalize ()" />
      <MemberSignature Language="C++ CLI" Value="!SocketAsyncEventArgs ()" />
      <MemberSignature Language="F#" Value="override this.Finalize : unit -&gt; unit" Usage="socketAsyncEventArgs.Finalize " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="c254c-202">Gibt von der <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" />-Klasse verwendete Ressourcen frei.</span><span class="sxs-lookup"><span data-stu-id="c254c-202">Frees resources used by the <see cref="T:System.Net.Sockets.SocketAsyncEventArgs" /> class.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-203">Der <xref:System.Net.Sockets.SocketAsyncEventArgs>-Klassen-Finalizer schließt die <xref:System.Net.Sockets.SocketAsyncEventArgs> und die freien Ressourcen, die dem <xref:System.Net.Sockets.SocketAsyncEventArgs>zugeordnet sind.</span><span class="sxs-lookup"><span data-stu-id="c254c-203">The <xref:System.Net.Sockets.SocketAsyncEventArgs> class finalizer closes the <xref:System.Net.Sockets.SocketAsyncEventArgs> and free resources associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs>.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="LastOperation">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketAsyncOperation LastOperation { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketAsyncOperation LastOperation" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.LastOperation" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LastOperation As SocketAsyncOperation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketAsyncOperation LastOperation { System::Net::Sockets::SocketAsyncOperation get(); };" />
      <MemberSignature Language="F#" Value="member this.LastOperation : System.Net.Sockets.SocketAsyncOperation" Usage="System.Net.Sockets.SocketAsyncEventArgs.LastOperation" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketAsyncOperation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-204">Ruft den Typ des Socketvorgangs ab, der zuletzt mit diesem Kontextobjekt ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-204">Gets the type of socket operation most recently performed with this context object.</span></span></summary>
        <value><span data-ttu-id="c254c-205">Eine <see cref="T:System.Net.Sockets.SocketAsyncOperation" />-Instanz, die den Typ des Socketvorgangs angibt, der zuletzt mit diesem Kontextobjekt ausgeführt wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-205">A <see cref="T:System.Net.Sockets.SocketAsyncOperation" /> instance that indicates the type of socket operation most recently performed with this context object.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-206">Diese Eigenschaft beschreibt den asynchronen Socketvorgang, der zuletzt mit diesem <xref:System.Net.Sockets.SocketAsyncEventArgs> Objekt abgeschlossen wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-206">This property describes the asynchronous socket operation that was most recently completed using this <xref:System.Net.Sockets.SocketAsyncEventArgs> object.</span></span> <span data-ttu-id="c254c-207">Der Wert dieser Eigenschaft wird <xref:System.Net.Sockets.SocketAsyncOperation.None?displayProperty=nameWithType>, bis die <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz verwendet wird, um einen asynchronen Socketvorgang zu starten.</span><span class="sxs-lookup"><span data-stu-id="c254c-207">The value of this property will be <xref:System.Net.Sockets.SocketAsyncOperation.None?displayProperty=nameWithType> until the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance is used to begin an asynchronous socket operation.</span></span> <span data-ttu-id="c254c-208">Die-Eigenschaft wird dann auf den Typ des Vorgangs festgelegt, der in den Methoden ausgeführt wird, die den <xref:System.Net.Sockets.SocketAsyncEventArgs> als Parameter annehmen.</span><span class="sxs-lookup"><span data-stu-id="c254c-208">The property will then be set to the type of operation being performed in the methods that take the <xref:System.Net.Sockets.SocketAsyncEventArgs> as a parameter.</span></span> <span data-ttu-id="c254c-209">Diese Eigenschaft erleichtert die Verwendung eines einzelnen Vervollständigungs Rückruf Delegaten für mehrere Arten von asynchronen Socketvorgängen.</span><span class="sxs-lookup"><span data-stu-id="c254c-209">This property more easily facilitates using a single completion callback delegate for multiple kinds of asynchronous socket operations.</span></span>  
  
 <span data-ttu-id="c254c-210">Diese Eigenschaft bleibt in einer <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz gültig, bis die <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz für einen anderen asynchronen Socketvorgang (xxxAsync) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-210">This property remains valid in a <xref:System.Net.Sockets.SocketAsyncEventArgs> instance until the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance is used for another asynchronous socket (xxxAsync) operation.</span></span>  
  
 <span data-ttu-id="c254c-211">Diese Eigenschaft wird von allen asynchronen Socketmethoden (xxxAsync) festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-211">This property is set by all asynchronous socket (xxxAsync) methods.</span></span>  
  
 <span data-ttu-id="c254c-212">Wenn eine asynchrone Socketmethode (xxxAsync) für die <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> Klasse aufgerufen wird, wird dieser Eigenschafts Wert festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-212">Calling an asynchronous socket method (xxxAsync) on the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class sets this property value.</span></span> <span data-ttu-id="c254c-213">Diese Eigenschaft ist für die Verwendung mit der von der Anwendung implementierten SocketAsyncCallback-Vervollständigungs Routine vorgesehen.</span><span class="sxs-lookup"><span data-stu-id="c254c-213">This property is intended for use with the SocketAsyncCallback completion routine implemented by the application.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketAsyncOperation" />
      </Docs>
    </Member>
    <Member MemberName="MemoryBuffer">
      <MemberSignature Language="C#" Value="public Memory&lt;byte&gt; MemoryBuffer { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Memory`1&lt;unsigned int8&gt; MemoryBuffer" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property MemoryBuffer As Memory(Of Byte)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property Memory&lt;System::Byte&gt; MemoryBuffer { Memory&lt;System::Byte&gt; get(); };" />
      <MemberSignature Language="F#" Value="member this.MemoryBuffer : Memory&lt;byte&gt;" Usage="System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Memory&lt;System.Byte&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-214">Ruft den Arbeitsspeicherbereich ab, der als Puffer mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-214">Gets the region of memory to use as a buffer with an asynchronous socket method.</span></span></summary>
        <value><span data-ttu-id="c254c-215">Ein Arbeitsspeicher Bereich, der den Datenpuffer darstellt, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-215">A region of memory that represents the data buffer to use with an asynchronous socket method.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks

<span data-ttu-id="c254c-216">Diese Eigenschaft ruft den Datenpuffer ab, der der <xref:System.Net.Sockets.SocketAsyncEventArgs> Instanz derzeit zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-216">This property gets the data buffer currently associated with the <xref:System.Net.Sockets.SocketAsyncEventArgs> instance.</span></span> <span data-ttu-id="c254c-217">Um den Puffer festzulegen, muss die <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>-Methode verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-217">To set the buffer, the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method must be used.</span></span>

<span data-ttu-id="c254c-218">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>und <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-218">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  

 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="Overload:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer" />
      </Docs>
    </Member>
    <Member MemberName="Offset">
      <MemberSignature Language="C#" Value="public int Offset { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Offset" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Offset As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Offset { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Offset : int" Usage="System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-219">Ruft den Offset in Bytes im Datenpuffer ab, auf den von der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-219">Gets the offset, in bytes, into the data buffer referenced by the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span></summary>
        <value><span data-ttu-id="c254c-220">Ein <see cref="T:System.Int32" /> mit dem Offset in Bytes im Datenpuffer, auf den von der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft verwiesen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-220">An <see cref="T:System.Int32" /> that contains the offset, in bytes, into the data buffer referenced by the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-221">Diese Eigenschaft beschreibt den Start Byte Offset von Daten in der <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="c254c-221">This property describes the starting byte offset of data in the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span> <span data-ttu-id="c254c-222">Dieser Wert wird durch Aufrufen der <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A>-Methode festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-222">This value is set by calling the <xref:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer%2A> method.</span></span>  
  
 <span data-ttu-id="c254c-223">Diese Eigenschaft gilt nicht für die <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="c254c-223">This property does not apply to the <xref:System.Net.Sockets.SocketAsyncEventArgs.BufferList%2A> property.</span></span>  
  
 <span data-ttu-id="c254c-224">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>und <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-224">This property is used with the <xref:System.Net.Sockets.Socket.AcceptAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
      </Docs>
    </Member>
    <Member MemberName="OnCompleted">
      <MemberSignature Language="C#" Value="protected virtual void OnCompleted (System.Net.Sockets.SocketAsyncEventArgs e);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void OnCompleted(class System.Net.Sockets.SocketAsyncEventArgs e) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted(System.Net.Sockets.SocketAsyncEventArgs)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub OnCompleted (e As SocketAsyncEventArgs)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void OnCompleted(System::Net::Sockets::SocketAsyncEventArgs ^ e);" />
      <MemberSignature Language="F#" Value="abstract member OnCompleted : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit&#xA;override this.OnCompleted : System.Net.Sockets.SocketAsyncEventArgs -&gt; unit" Usage="socketAsyncEventArgs.OnCompleted e" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Net.Sockets.SocketAsyncEventArgs" />
      </Parameters>
      <Docs>
        <param name="e"><span data-ttu-id="c254c-225">Das signalisierte Ereignis.</span><span class="sxs-lookup"><span data-stu-id="c254c-225">The event that is signaled.</span></span></param>
        <summary><span data-ttu-id="c254c-226">Stellt eine Methode dar, die beim Abschluss eines asynchronen Vorgangs aufgerufen wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-226">Represents a method that is called when an asynchronous operation completes.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-227">Diese Methode kann nicht von Benutzercode aufgerufen werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-227">This method is not callable by user code.</span></span> <span data-ttu-id="c254c-228">Diese Methode wird von den Internalen des <xref:System.Net.Sockets.SocketAsyncEventArgs> Objekts aufgerufen, wenn der aktuelle Vorgang beendet ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-228">This method gets called by the internals of the <xref:System.Net.Sockets.SocketAsyncEventArgs> object when the current operation is complete.</span></span> <span data-ttu-id="c254c-229">Diese Methode wird mit allen asynchronen Socketmethoden (xxxAsync) verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-229">This method is used with all asynchronous socket (xxxAsync) methods.</span></span>  
  
 <span data-ttu-id="c254c-230">Eine Anwendung, die eine Klasse erstellt, die von <xref:System.Net.Sockets.SocketAsyncEventArgs> erbt, kann diese Methode überschreiben, um mit dieser Abschluss Benachrichtigung zu schließen und alle Ressourcen zu bereinigen, die für den Vorgang reserviert wurden.</span><span class="sxs-lookup"><span data-stu-id="c254c-230">An application that creates a class inheriting from <xref:System.Net.Sockets.SocketAsyncEventArgs> can override this method to hook into this completion notification and clean up any resources that it allocated for the operation.</span></span> <span data-ttu-id="c254c-231">Die Standard Implementierung löst nur das <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed>-Ereignis aus.</span><span class="sxs-lookup"><span data-stu-id="c254c-231">The default implementation just raises the <xref:System.Net.Sockets.SocketAsyncEventArgs.Completed> event.</span></span>  
  
 <span data-ttu-id="c254c-232">Diese Methode wird verwendet, um einen Ereignishandler zu verbinden, der als Abschluss Rückruf für einen nachfolgenden asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-232">This method is used to hook up an event handler to be used as the completion callback for a subsequent asynchronous socket operation.</span></span> <span data-ttu-id="c254c-233">Der Aufrufer muss mindestens einen von dieser Methode geerbten Rückruf Delegaten implementieren, bevor ein asynchroner Socketvorgang mit einer der asynchronen Methoden (xxxAsync) für die <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> Klasse gestartet wird.</span><span class="sxs-lookup"><span data-stu-id="c254c-233">The caller must implement at least one callback delegate inherited from this method prior to starting an asynchronous socket operation using one of the asynchronous (xxxAsync) methods on the <xref:System.Net.Sockets.Socket?displayProperty=nameWithType> class.</span></span>  
  
 <span data-ttu-id="c254c-234">Die <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A>-Methode des Aufrufers bietet Client Anwendungen die Möglichkeit, einen asynchronen Socketvorgang abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="c254c-234">The caller's <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> method provides a way for client applications to complete an asynchronous socket operation.</span></span> <span data-ttu-id="c254c-235">Beim Initiieren eines asynchronen Socketvorgangs muss ein Rückruf Delegat implementiert werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-235">A callback delegate must be implemented when an asynchronous socket operation is initiated.</span></span> <span data-ttu-id="c254c-236">Die von der <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A>-Methode geerbten Beendigungs Rückruf Delegaten müssen Programmlogik enthalten, um die Verarbeitung des asynchronen Socketvorgangs für den Client abzuschließen.</span><span class="sxs-lookup"><span data-stu-id="c254c-236">The completion callback delegate(s) inherited from the <xref:System.Net.Sockets.SocketAsyncEventArgs.OnCompleted%2A> method must contain program logic to finish processing the asynchronous socket operation for the client.</span></span>  
  
 <span data-ttu-id="c254c-237">Wenn ein asynchroner Vorgang signalisiert wird, verwendet die Anwendung den <xref:System.Net.Sockets.SocketAsyncEventArgs> Object-Parameter, um den Status des abgeschlossenen asynchronen Socketvorgangs abzurufen.</span><span class="sxs-lookup"><span data-stu-id="c254c-237">When an asynchronous operation is signaled, the application uses the <xref:System.Net.Sockets.SocketAsyncEventArgs> object parameter to obtain status of the completed asynchronous socket operation.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="ReceiveMessageFromPacketInfo">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.IPPacketInformation ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.ReceiveMessageFromPacketInfo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property ReceiveMessageFromPacketInfo As IPPacketInformation" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::IPPacketInformation ReceiveMessageFromPacketInfo { System::Net::Sockets::IPPacketInformation get(); };" />
      <MemberSignature Language="F#" Value="member this.ReceiveMessageFromPacketInfo : System.Net.Sockets.IPPacketInformation" Usage="System.Net.Sockets.SocketAsyncEventArgs.ReceiveMessageFromPacketInfo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.IPPacketInformation</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-238">Ruft die IP-Adresse und Schnittstelle eines empfangenen Pakets ab.</span><span class="sxs-lookup"><span data-stu-id="c254c-238">Gets the IP address and interface of a received packet.</span></span></summary>
        <value><span data-ttu-id="c254c-239">Eine <see cref="T:System.Net.Sockets.IPPacketInformation" />-Instanz, die die IP-Zieladresse und Schnittstelle eines empfangenen Pakets enthält.</span><span class="sxs-lookup"><span data-stu-id="c254c-239">An <see cref="T:System.Net.Sockets.IPPacketInformation" /> instance that contains the destination IP address and interface of a received packet.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-240">Diese Eigenschaft enthält Informationen zu einem Paket, das mit der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>-Methode empfangen wurde.</span><span class="sxs-lookup"><span data-stu-id="c254c-240">This property provides information about a packet received using the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="c254c-241">Diese Eigenschaft wird mit der <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>-Methode verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-241">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.IPAddress" />
        <altmember cref="T:System.Net.Sockets.IPPacketInformation" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Address" />
        <altmember cref="P:System.Net.Sockets.IPPacketInformation.Interface" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="RemoteEndPoint">
      <MemberSignature Language="C#" Value="public System.Net.EndPoint RemoteEndPoint { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.EndPoint RemoteEndPoint" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
      <MemberSignature Language="VB.NET" Value="Public Property RemoteEndPoint As EndPoint" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::EndPoint ^ RemoteEndPoint { System::Net::EndPoint ^ get(); void set(System::Net::EndPoint ^ value); };" />
      <MemberSignature Language="F#" Value="member this.RemoteEndPoint : System.Net.EndPoint with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.RemoteEndPoint" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.EndPoint</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-242">Ruft den Remote-IP-Endpunkt für einen asynchronen Vorgang ab oder legt ihn fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-242">Gets or sets the remote IP endpoint for an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="c254c-243">Ein <see cref="T:System.Net.EndPoint" />, der den Remote-IP-Endpunkt für einen asynchronen Vorgang darstellt.</span><span class="sxs-lookup"><span data-stu-id="c254c-243">An <see cref="T:System.Net.EndPoint" /> that represents the remote IP endpoint for an asynchronous operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-244">Diese Eigenschaft gibt den Remote Endpunkt an.</span><span class="sxs-lookup"><span data-stu-id="c254c-244">This property specifies the remote endpoint.</span></span> <span data-ttu-id="c254c-245">Mit dieser Eigenschaft kann der Remote Endpunkt angegeben werden, mit dem mit der <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>-Methode eine Verbindung hergestellt werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-245">This property can specify the remote endpoint to which to connect using the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c254c-246">Mit dieser Eigenschaft kann der Remote Endpunkt, an den Daten gesendet werden sollen, mithilfe <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType>-Methode angegeben werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-246">This property can specify the remote endpoint to which to send data using <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> method.</span></span> <span data-ttu-id="c254c-247">Mit dieser Eigenschaft kann der Remote Endpunkt angegeben werden, von dem aus mithilfe der Methoden <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType> oder <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> Daten empfangen wurden.</span><span class="sxs-lookup"><span data-stu-id="c254c-247">This property can specify the remote endpoint from which data was received using the <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType> or <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 <span data-ttu-id="c254c-248">Dieser Remote Endpunkt, der durch diese Eigenschaft angegeben wird, kann eine IPv4-oder IPv6-Adresse enthalten.</span><span class="sxs-lookup"><span data-stu-id="c254c-248">This remote endpoint specified by this property can include an IPv4 or IPv6 address.</span></span>  
  
 <span data-ttu-id="c254c-249">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>oder <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-249">This property is used with the <xref:System.Net.Sockets.Socket.ConnectAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveMessageFromAsync%2A?displayProperty=nameWithType>, or <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.EndPoint" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsElements">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SendPacketsElement[] SendPacketsElements { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Net.Sockets.SendPacketsElement[] SendPacketsElements" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsElements As SendPacketsElement()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ SendPacketsElements { cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ get(); void set(cli::array &lt;System::Net::Sockets::SendPacketsElement ^&gt; ^ value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsElements : System.Net.Sockets.SendPacketsElement[] with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsElements" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SendPacketsElement[]</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-250">Ruft ein Array von Puffern ab, die für einen von der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode verwendeten asynchronen Vorgang gesendet werden sollen, oder legt es fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-250">Gets or sets an array of buffers to be sent for an asynchronous operation used by the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span></summary>
        <value><span data-ttu-id="c254c-251">Ein Array von <see cref="T:System.Net.Sockets.SendPacketsElement" />-Objekten, das ein Array von zu sendenden Puffern darstellt.</span><span class="sxs-lookup"><span data-stu-id="c254c-251">An array of <see cref="T:System.Net.Sockets.SendPacketsElement" /> objects that represent an array of buffers to be sent.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-252">Das Puffer Array kann eine Datei oder Dateien im Arbeitsspeicher oder einen Satz von Speicherdaten Puffern darstellen.</span><span class="sxs-lookup"><span data-stu-id="c254c-252">The array of buffers can represent a file or files in memory or a set of memory data buffers.</span></span> <span data-ttu-id="c254c-253">Diese Eigenschaft wird mit der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType>-Methode verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-253">This property is used with the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="T:System.Net.Sockets.SendPacketsElement" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.TransmitFileOptions SendPacketsFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.TransmitFileOptions SendPacketsFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsFlags As TransmitFileOptions" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::TransmitFileOptions SendPacketsFlags { System::Net::Sockets::TransmitFileOptions get(); void set(System::Net::Sockets::TransmitFileOptions value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsFlags : System.Net.Sockets.TransmitFileOptions with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.TransmitFileOptions</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-254">Ruft eine bitweise Kombination von <see cref="T:System.Net.Sockets.TransmitFileOptions" />-Werten für einen asynchronen Vorgang ab, der von der <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />-Methode verwendet wird, oder legt sie fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-254">Gets or sets a bitwise combination of <see cref="T:System.Net.Sockets.TransmitFileOptions" /> values for an asynchronous operation used by the <see cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" /> method.</span></span></summary>
        <value><span data-ttu-id="c254c-255"><see cref="T:System.Net.Sockets.TransmitFileOptions" /> mit einer bitweisen Kombination von Werten, die mit einem asynchronen Vorgang verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-255">A <see cref="T:System.Net.Sockets.TransmitFileOptions" /> that contains a bitwise combination of values that are used with an asynchronous operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-256">Diese Eigenschaft gibt die <xref:System.Net.Sockets.TransmitFileOptions> an, die von der <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType>-Methode verwendet werden.</span><span class="sxs-lookup"><span data-stu-id="c254c-256">This property specifies the <xref:System.Net.Sockets.TransmitFileOptions> that are used by the <xref:System.Net.Sockets.Socket.SendPacketsAsync%2A?displayProperty=nameWithType> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.TransmitFileOptions" />
      </Docs>
    </Member>
    <Member MemberName="SendPacketsSendSize">
      <MemberSignature Language="C#" Value="public int SendPacketsSendSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 SendPacketsSendSize" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SendPacketsSendSize" />
      <MemberSignature Language="VB.NET" Value="Public Property SendPacketsSendSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int SendPacketsSendSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.SendPacketsSendSize : int with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SendPacketsSendSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
          <AttributeName>System.MonoTODO("unused property")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-257">Ruft die Größe des im Sendevorgang verwendeten Datenblocks in Bytes ab oder legt diese fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-257">Gets or sets the size, in bytes, of the data block used in the send operation.</span></span></summary>
        <value><span data-ttu-id="c254c-258">Ein <see cref="T:System.Int32" /> mit der Größe des im Sendevorgang verwendeten Datenblocks in Bytes.</span><span class="sxs-lookup"><span data-stu-id="c254c-258">An <see cref="T:System.Int32" /> that contains the size, in bytes, of the data block used in the send operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-259">Legen Sie diese Eigenschaft auf NULL fest, damit die Socketschicht eine standardmäßige Sende Größe auswählt.</span><span class="sxs-lookup"><span data-stu-id="c254c-259">Set this property to zero to let the sockets layer select a default send size.</span></span> <span data-ttu-id="c254c-260">Wenn Sie diese Eigenschaft auf "0xffffffff" festlegen, kann der Aufrufer die Größe und den Inhalt der einzelnen Sende Anforderungen mithilfe der <xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A?displayProperty=nameWithType>-Eigenschaft steuern.</span><span class="sxs-lookup"><span data-stu-id="c254c-260">Setting this property to 0xFFFFFFFF enables the caller to control the size and content of each send request, achieved by using the <xref:System.Net.Sockets.SendPacketsElement.EndOfPacket%2A?displayProperty=nameWithType> property.</span></span> <span data-ttu-id="c254c-261">Diese Funktion ist für Nachrichten Protokolle nützlich, bei denen Einschränkungen hinsichtlich der Größe einzelner Sende Anforderungen gelten.</span><span class="sxs-lookup"><span data-stu-id="c254c-261">This capability is useful for message protocols that place limitations on the size of individual send requests.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SendPacketsElement.EndOfPacket" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SetBuffer">
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="c254c-262">Initialisiert den Datenpuffer, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-262">Initializes the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-263">Mit dieser Methode wird die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft auf NULL festgelegt, und die Eigenschaften <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> und <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> auf NULL festgelegt.</span><span class="sxs-lookup"><span data-stu-id="c254c-263">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property to null and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> properties to zero.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </MemberGroup>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (Memory&lt;byte&gt; buffer);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(valuetype System.Memory`1&lt;unsigned int8&gt; buffer) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Memory{System.Byte})" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Memory(Of Byte))" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(Memory&lt;System::Byte&gt; buffer);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : Memory&lt;byte&gt; -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer buffer" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Memory&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="c254c-264">Der Arbeitsspeicherbereich, der als Puffer mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-264">The region of memory to use as a buffer with an asynchronous socket method.</span></span></param>
        <summary><span data-ttu-id="c254c-265">Legt den Arbeitsspeicherbereich fest, der als Puffer mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-265">Sets the region of memory to use as a buffer with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
## Remarks

<span data-ttu-id="c254c-266">Diese Methode legt die <xref:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer%2A>-Eigenschaft auf den `buffer`-Parameter, die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>-Eigenschaft auf die `buffer` Länge und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>-Eigenschaft auf 0 (null) fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-266">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.MemoryBuffer%2A> property to the `buffer` parameter, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `buffer` length, and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to zero.</span></span>

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : int * int -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer (offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="offset"><span data-ttu-id="c254c-267">Der Offset (in Bytes) im Datenpuffer, in dem der Vorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="c254c-267">The offset, in bytes, in the data buffer where the operation starts.</span></span></param>
        <param name="count"><span data-ttu-id="c254c-268">Die maximale Datenmenge in Bytes, die im Puffer gesendet oder empfangen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-268">The maximum amount of data, in bytes, to send or receive in the buffer.</span></span></param>
        <summary><span data-ttu-id="c254c-269">Legt den Datenpuffer fest, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-269">Sets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-270">Die Parameter "`offset`" und "`count`" dürfen keine negativen Zahlen sein.</span><span class="sxs-lookup"><span data-stu-id="c254c-270">The `offset` and `count` parameters can't be negative numbers.</span></span> <span data-ttu-id="c254c-271">Die Kombination der Parameter "`offset`" und "`count`" muss in den Grenzen des Puffer Arrays in der <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> Eigenschaft liegen.</span><span class="sxs-lookup"><span data-stu-id="c254c-271">The combination of the `offset` and `count` parameters must be in bounds of the buffer array in the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span>  
  
 <span data-ttu-id="c254c-272">Diese Methode legt die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>-Eigenschaft auf den `count`-Parameter und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>-Eigenschaft auf den `offset`-Parameter fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-272">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `count` parameter and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to the `offset` parameter.</span></span> <span data-ttu-id="c254c-273">Wenn die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft NULL ist, ignoriert diese Methode die Parameter `offset` und `count` und legt die <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>-und <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>-Eigenschaften auf 0 fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-273">If the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property is null, this method ignores the `offset` and `count` parameters and sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> and <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> properties to 0.</span></span>  
  
 <span data-ttu-id="c254c-274">Mit dieser Methode wird die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft nicht geändert.</span><span class="sxs-lookup"><span data-stu-id="c254c-274">This method does not change the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property.</span></span>  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c254c-275">Ein Argument lag außerhalb des gültigen Bereichs.</span><span class="sxs-lookup"><span data-stu-id="c254c-275">An argument was out of range.</span></span> <span data-ttu-id="c254c-276">Diese Ausnahme tritt auf, wenn der <paramref name="offset" />-Parameter kleiner als 0 (null) oder größer als die Länge des Arrays in der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-276">This exception occurs if the <paramref name="offset" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span> <span data-ttu-id="c254c-277">Diese Ausnahme tritt außerdem auf, wenn der <paramref name="count" />-Parameter kleiner als 0 (null) oder größer als die Länge des Arrays in der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft abzüglich des <paramref name="offset" />-Parameters ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-277">This exception also occurs if the <paramref name="count" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property minus the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SetBuffer">
      <MemberSignature Language="C#" Value="public void SetBuffer (byte[] buffer, int offset, int count);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetBuffer(unsigned int8[] buffer, int32 offset, int32 count) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Net.Sockets.SocketAsyncEventArgs.SetBuffer(System.Byte[],System.Int32,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetBuffer (buffer As Byte(), offset As Integer, count As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetBuffer(cli::array &lt;System::Byte&gt; ^ buffer, int offset, int count);" />
      <MemberSignature Language="F#" Value="member this.SetBuffer : byte[] * int * int -&gt; unit" Usage="socketAsyncEventArgs.SetBuffer (buffer, offset, count)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="buffer" Type="System.Byte[]" />
        <Parameter Name="offset" Type="System.Int32" />
        <Parameter Name="count" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="buffer"><span data-ttu-id="c254c-278">Der Datenpuffer, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-278">The data buffer to use with an asynchronous socket method.</span></span></param>
        <param name="offset"><span data-ttu-id="c254c-279">Der Offset (in Bytes) im Datenpuffer, in dem der Vorgang beginnt.</span><span class="sxs-lookup"><span data-stu-id="c254c-279">The offset, in bytes, in the data buffer where the operation starts.</span></span></param>
        <param name="count"><span data-ttu-id="c254c-280">Die maximale Datenmenge in Bytes, die im Puffer gesendet oder empfangen werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-280">The maximum amount of data, in bytes, to send or receive in the buffer.</span></span></param>
        <summary><span data-ttu-id="c254c-281">Legt den Datenpuffer fest, der mit einer asynchronen Socketmethode verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-281">Sets the data buffer to use with an asynchronous socket method.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-282">Die Parameter "`offset`" und "`count`" dürfen keine negativen Zahlen sein.</span><span class="sxs-lookup"><span data-stu-id="c254c-282">The `offset` and `count` parameters can't be negative numbers.</span></span> <span data-ttu-id="c254c-283">Die Kombination der Parameter "`offset`" und "`count`" muss in den Grenzen des Daten Arrays im `buffer`-Parameter liegen.</span><span class="sxs-lookup"><span data-stu-id="c254c-283">The combination of the `offset` and `count` parameters must be in bounds of the data array in the `buffer` parameter.</span></span>  
  
 <span data-ttu-id="c254c-284">Diese Methode legt die <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A>-Eigenschaft auf den `buffer`-Parameter, die <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A>-Eigenschaft auf den `count`-Parameter und die <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A>-Eigenschaft auf den `offset`-Parameter fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-284">This method sets the <xref:System.Net.Sockets.SocketAsyncEventArgs.Buffer%2A> property to the `buffer` parameter, the <xref:System.Net.Sockets.SocketAsyncEventArgs.Count%2A> property to the `count` parameter, and the <xref:System.Net.Sockets.SocketAsyncEventArgs.Offset%2A> property to the `offset` parameter.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="c254c-285">Im folgenden Codebeispiel wird ein einzelner großer Puffer erstellt, der <xref:System.Net.Sockets.SocketAsyncEventArgs>-Objekten für die Verwendung mit jedem Socket-e/a-Vorgang aufgeteilt und zugewiesen werden kann.</span><span class="sxs-lookup"><span data-stu-id="c254c-285">The following code example creates a single large buffer which can be divided up and assigned to <xref:System.Net.Sockets.SocketAsyncEventArgs> objects for use with each socket I/O operation.</span></span> <span data-ttu-id="c254c-286">Dies ermöglicht die einfache Wiederverwendung von Puffern und schützt vor der Fragmentierung des Heap Speichers.</span><span class="sxs-lookup"><span data-stu-id="c254c-286">This enables buffers to be easily reused and guards against fragmenting heap memory.</span></span>  
  
 [!code-csharp[NCLAsyncSocketServer#1](~/samples/snippets/csharp/VS_Snippets_Remoting/NCLAsyncSocketServer/CS/AsyncSocketServer.cs#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><span data-ttu-id="c254c-287">Es wurden mehrdeutige Puffer angegeben.</span><span class="sxs-lookup"><span data-stu-id="c254c-287">There are ambiguous buffers specified.</span></span> <span data-ttu-id="c254c-288">Diese Ausnahme tritt auf, wenn die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft nicht NULL ist und die <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" />-Eigenschaft ebenfalls nicht NULL ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-288">This exception occurs if the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property is also not null and the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.BufferList" /> property is also not null.</span></span></exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><span data-ttu-id="c254c-289">Ein Argument lag außerhalb des gültigen Bereichs.</span><span class="sxs-lookup"><span data-stu-id="c254c-289">An argument was out of range.</span></span> <span data-ttu-id="c254c-290">Diese Ausnahme tritt auf, wenn der <paramref name="offset" />-Parameter kleiner als 0 (null) oder größer als die Länge des Arrays in der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-290">This exception occurs if the <paramref name="offset" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property.</span></span> <span data-ttu-id="c254c-291">Diese Ausnahme tritt außerdem auf, wenn der <paramref name="count" />-Parameter kleiner als 0 (null) oder größer als die Länge des Arrays in der <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />-Eigenschaft abzüglich des <paramref name="offset" />-Parameters ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-291">This exception also occurs if the <paramref name="count" /> parameter is less than zero or greater than the length of the array in the <see cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" /> property minus the <paramref name="offset" /> parameter.</span></span></exception>
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Buffer" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Count" />
        <altmember cref="P:System.Net.Sockets.SocketAsyncEventArgs.Offset" />
      </Docs>
    </Member>
    <Member MemberName="SocketClientAccessPolicyProtocol">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketClientAccessPolicyProtocol As SocketClientAccessPolicyProtocol" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketClientAccessPolicyProtocol SocketClientAccessPolicyProtocol { System::Net::Sockets::SocketClientAccessPolicyProtocol get(); void set(System::Net::Sockets::SocketClientAccessPolicyProtocol value); };" />
      <MemberSignature Language="F#" Value="member this.SocketClientAccessPolicyProtocol : System.Net.Sockets.SocketClientAccessPolicyProtocol with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketClientAccessPolicyProtocol" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.Obsolete("This API supports the .NET Framework infrastructure and is not intended to be used directly from your code.", true)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketClientAccessPolicyProtocol</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-292">Ruft das Protokoll ab oder legt es fest, das verwenden wird, um die Socketclient-Zugriffsrichtliniendatei herunterzuladen.</span><span class="sxs-lookup"><span data-stu-id="c254c-292">Gets or sets the protocol to use to download the socket client access policy file.</span></span></summary>
        <value><span data-ttu-id="c254c-293">Das Protokoll, das verwendet wird, um die Socketclient-Zugriffsrichtliniendatei herunterzuladen.</span><span class="sxs-lookup"><span data-stu-id="c254c-293">The protocol to use to download the socket client access policy file.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-294">Der <xref:System.Net.Sockets.SocketClientAccessPolicyProtocol> gibt die Methode zum Herunterladen einer Client Zugriffsrichtlinien Datei an.</span><span class="sxs-lookup"><span data-stu-id="c254c-294">The <xref:System.Net.Sockets.SocketClientAccessPolicyProtocol> specifies the method to download a client access policy file.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SocketError">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketError SocketError { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketError SocketError" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketError" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketError As SocketError" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketError SocketError { System::Net::Sockets::SocketError get(); void set(System::Net::Sockets::SocketError value); };" />
      <MemberSignature Language="F#" Value="member this.SocketError : System.Net.Sockets.SocketError with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketError" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketError</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-295">Ruft das Ergebnis des asynchronen Socketvorgangs ab oder legt dieses fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-295">Gets or sets the result of the asynchronous socket operation.</span></span></summary>
        <value><span data-ttu-id="c254c-296">Ein <see cref="T:System.Net.Sockets.SocketError" />, der das Ergebnis des asynchronen Socketvorgangs darstellt.</span><span class="sxs-lookup"><span data-stu-id="c254c-296">A <see cref="T:System.Net.Sockets.SocketError" /> that represents the result of the asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-297">Diese Eigenschaft stellt den Abschluss Status eines asynchronen Socketvorgangs bereit.</span><span class="sxs-lookup"><span data-stu-id="c254c-297">This property provides the completion status of an asynchronous socket operation.</span></span> <span data-ttu-id="c254c-298">Der Wert <xref:System.Net.Sockets.SocketError.Success?displayProperty=nameWithType> der einen erfolgreichen Abschluss eines Vorgangs angibt.</span><span class="sxs-lookup"><span data-stu-id="c254c-298">A value of <xref:System.Net.Sockets.SocketError.Success?displayProperty=nameWithType> indicates successful completion of an operation.</span></span> <span data-ttu-id="c254c-299">Diese Eigenschaft wird hauptsächlich in der Ereignishandlerroutine einer Anwendung verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-299">This property is primarily used in an application's event handler routine.</span></span>  
  
 <span data-ttu-id="c254c-300">Diese Eigenschaft wird mit allen asynchronen Socket (xxxAsync)-Methoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-300">This property is used with all of the asynchronous socket (xxxAsync) methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketError" />
      </Docs>
    </Member>
    <Member MemberName="SocketFlags">
      <MemberSignature Language="C#" Value="public System.Net.Sockets.SocketFlags SocketFlags { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Net.Sockets.SocketFlags SocketFlags" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />
      <MemberSignature Language="VB.NET" Value="Public Property SocketFlags As SocketFlags" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Net::Sockets::SocketFlags SocketFlags { System::Net::Sockets::SocketFlags get(); void set(System::Net::Sockets::SocketFlags value); };" />
      <MemberSignature Language="F#" Value="member this.SocketFlags : System.Net.Sockets.SocketFlags with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.SocketFlags" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Net.Sockets.SocketFlags</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-301">Ruft die Ergebnisse eines asynchronen Socketvorgangs ab oder legt das Verhalten eines asynchronen Vorgangs fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-301">Gets the results of an asynchronous socket operation or sets the behavior of an asynchronous operation.</span></span></summary>
        <value><span data-ttu-id="c254c-302"><see cref="T:System.Net.Sockets.SocketFlags" />, die die Ergebnisse eines asynchronen Socketvorgangs darstellen.</span><span class="sxs-lookup"><span data-stu-id="c254c-302">A <see cref="T:System.Net.Sockets.SocketFlags" /> that represents the results of an asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-303">Die-Eigenschaft gibt die bitweise Kombination der <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> an, die für einen asynchronen Socketvorgang verwendet werden soll.</span><span class="sxs-lookup"><span data-stu-id="c254c-303">The property specifies the bitwise combination of the <xref:System.Net.Sockets.SocketFlags?displayProperty=nameWithType> to be used for an asynchronous socket operation.</span></span>  
  
 <span data-ttu-id="c254c-304">Diese Eigenschaft wird mit den Methoden <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>und <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-304">This property is used with the <xref:System.Net.Sockets.Socket.ReceiveAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.ReceiveFromAsync%2A?displayProperty=nameWithType>, <xref:System.Net.Sockets.Socket.SendAsync%2A?displayProperty=nameWithType>, and <xref:System.Net.Sockets.Socket.SendToAsync%2A?displayProperty=nameWithType> methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="T:System.Net.Sockets.SocketFlags" />
      </Docs>
    </Member>
    <Member MemberName="UserToken">
      <MemberSignature Language="C#" Value="public object UserToken { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object UserToken" />
      <MemberSignature Language="DocId" Value="P:System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      <MemberSignature Language="VB.NET" Value="Public Property UserToken As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Object ^ UserToken { System::Object ^ get(); void set(System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.UserToken : obj with get, set" Usage="System.Net.Sockets.SocketAsyncEventArgs.UserToken" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Net.Sockets</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.0.0</AssemblyVersion>
        <AssemblyVersion>4.2.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Net</AssemblyName>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>set: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="c254c-305">Ruft ein Benutzer- oder Anwendungsobjekt ab, das diesem asynchronen Socketvorgang zugeordnet ist, oder legt es fest.</span><span class="sxs-lookup"><span data-stu-id="c254c-305">Gets or sets a user or application object associated with this asynchronous socket operation.</span></span></summary>
        <value><span data-ttu-id="c254c-306">Ein Objekt, das das Benutzer- oder Anwendungsobjekt darstellt, das diesem asynchronen Socketvorgang zugeordnet ist.</span><span class="sxs-lookup"><span data-stu-id="c254c-306">An object that represents the user or application object associated with this asynchronous socket operation.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="c254c-307">Diese Eigenschaft kann von einer Anwendung verwendet werden, um ein Anwendungs Zustands Objekt dem <xref:System.Net.Sockets.SocketAsyncEventArgs> Objekt zuzuordnen.</span><span class="sxs-lookup"><span data-stu-id="c254c-307">This property can be used by an application to associate an application state object with the <xref:System.Net.Sockets.SocketAsyncEventArgs> object.</span></span> <span data-ttu-id="c254c-308">Hauptsächlich ist diese Eigenschaft eine Methode, mit der eine Anwendung den Zustand an den Ereignishandler der Anwendung übergibt (z. b. die Methode zum Abschluss der asynchronen Operation).</span><span class="sxs-lookup"><span data-stu-id="c254c-308">Primarily, this property is a way for an application to pass state to the application's event handler (for example, the asynchronous operation completion method).</span></span>  
  
 <span data-ttu-id="c254c-309">Diese Eigenschaft wird mit allen asynchronen Socket (xxxAsync)-Methoden verwendet.</span><span class="sxs-lookup"><span data-stu-id="c254c-309">This property is used with all of the asynchronous socket (xxxAsync) methods.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Net.Sockets.Socket.AcceptAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ConnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.DisconnectAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.ReceiveMessageFromAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendPacketsAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
        <altmember cref="M:System.Net.Sockets.Socket.SendToAsync(System.Net.Sockets.SocketAsyncEventArgs)" />
      </Docs>
    </Member>
  </Members>
</Type>
