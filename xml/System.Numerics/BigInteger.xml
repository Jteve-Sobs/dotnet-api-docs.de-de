<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="073c2f454818fb175ef8bf63702301eeccb18ed7" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48692171" />
  </Metadata>
  <TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
      <AttributeName>Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine beliebig große ganze Zahl mit Vorzeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger> Typ ist ein unveränderlicher Typ, der eine beliebig große ganze Zahl darstellt, deren Wert theoretisch keine Ober- und Untergrenze hat. Die Mitglieder der <xref:System.Numerics.BigInteger> -Typs ähneln im Wesentlichen denen der anderen ganzzahligen Typen (die <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>, und <xref:System.UInt64> Typen). Dieser Typ unterscheidet sich von der anderen ganzzahligen Typen in der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], die durch einen Bereich haben ihre `MinValue` und `MaxValue` Eigenschaften.  
  
> [!NOTE]
>  Da die <xref:System.Numerics.BigInteger> Typ ist unveränderlich (finden Sie unter [Veränderlichkeit und BigInteger-Struktur](#mutability)) und da er keine oberen und unteren Grenzen hat ein <xref:System.OutOfMemoryException> ausgelöst werden kann, für jeden Vorgang, der bewirkt, dass eine <xref:System.Numerics.BigInteger> Wert zu vergrößern. große.  
  
## <a name="instantiating-a-biginteger-object"></a>Instanziieren eines Objekts BigInteger  
 Instanziieren Sie ein <xref:System.Numerics.BigInteger> Objekts auf verschiedene Weise:  
  
-   Können Sie die `new` Schlüsselwort, und geben Sie einen beliebigen ganzzahligen oder Gleitkomma-Wert als Parameter an die <xref:System.Numerics.BigInteger> Konstruktor. (Gleitkommazahlen-Punktwerte werden abgeschnitten, bevor sie zugewiesen sind die <xref:System.Numerics.BigInteger>.) Das folgende Beispiel veranschaulicht, wie Sie mit der `new` Schlüsselwort zum Instanziieren <xref:System.Numerics.BigInteger> Werte.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Sie können deklarieren, ein <xref:System.Numerics.BigInteger> Variable und weisen Sie ein Wert wie würde alle numerischen Typen, solange dieser Wert ein ganzzahliger Typ ist. Im folgenden Beispiel wird die Zuweisung zum Erstellen einer <xref:System.Numerics.BigInteger> Wert aus einer <xref:System.Int64>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Sie können einen decimal "oder" Gleitkomma-Wert zum Zuweisen einer <xref:System.Numerics.BigInteger> Objekt, wenn Sie wandeln Sie den Wert, oder konvertieren es zuerst. Im folgenden Beispiel wird explizit umgewandelt (in c#) oder (in Visual Basic) konvertiert eine <xref:System.Double> und <xref:System.Decimal> -Werts in einen <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Diese Methoden ermöglichen es Ihnen, zu instanziieren einer <xref:System.Numerics.BigInteger> Objekt, dessen Wert in den Wertebereich eines vorhandenen numerischen Typen nur. Instanziieren Sie ein <xref:System.Numerics.BigInteger> Objekt, dessen Wert des Bereichs von vorhandenen numerischen Typen in einer von drei Methoden überschreiten kann:  
  
-   Können Sie die `new` Schlüsselwort, und geben Sie ein Byte-Array von beliebiger Größe für die <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> Konstruktor. Zum Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Rufen Sie die <xref:System.Numerics.BigInteger.Parse%2A> oder <xref:System.Numerics.BigInteger.TryParse%2A> Methoden konvertieren die angegebene Zeichenfolgendarstellung einer Zahl in eine <xref:System.Numerics.BigInteger>. Zum Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Rufen Sie eine `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> -Methode, die einen Vorgang für einen numerischen Ausdruck ausführt, und gibt einen berechneten <xref:System.Numerics.BigInteger> Ergebnis. Durch cuberstellung wird im folgende Beispiel <xref:System.UInt64.MaxValue?displayProperty=nameWithType> und das Ergebnis, das Zuweisen einer <xref:System.Numerics.BigInteger>.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Den nicht initialisierten Wert des einem <xref:System.Numerics.BigInteger> ist <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Ausführen von Vorgängen für BigInteger-Werte  
 Sie können eine <xref:System.Numerics.BigInteger> Instanz, wie Sie einen anderen ganzzahligen Typ verwenden würden. <xref:System.Numerics.BigInteger> Überladungen die standardmäßigen numerischen Operatoren, damit Sie grundlegende mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation, Subtraktion, Negation und unäre Negation ausführen können. Sie können auch die standardmäßigen numerischen Operatoren verwenden, um zwei <xref:System.Numerics.BigInteger> Werte miteinander. Wie die anderen ganzzahligen Typen <xref:System.Numerics.BigInteger> unterstützt auch das bitweise `And`, `Or`, `XOr`, linke UMSCHALTTASTE und right Shift-Operatoren. Für Sprachen, die keine benutzerdefinierte Operatoren, unterstützen die <xref:System.Numerics.BigInteger> Struktur stellt auch die entsprechende Methoden für mathematische Operationen ausführen. Dazu gehören <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>, und andere.  
  
 Viele Elemente der der <xref:System.Numerics.BigInteger> Struktur direkt auf Mitglieder der anderen ganzzahligen Typen entsprechen. Darüber hinaus <xref:System.Numerics.BigInteger> fügt Elemente wie den folgenden:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, einen Wert, der das Vorzeichen gibt an, womit eine <xref:System.Numerics.BigInteger> Wert.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, womit der Absolute Wert des einem <xref:System.Numerics.BigInteger> Wert.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, womit sowohl den Quotienten und den Rest eines divisionsvorgangs.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, womit der größte gemeinsame Divisor von zwei <xref:System.Numerics.BigInteger> Werte.  
  
 Viele dieser zusätzlichen Member die Member der entsprechen den <xref:System.Math> -Klasse, die die Funktionen für die Arbeit mit den primitiven numerischen Typen bereitstellt.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Veränderlichkeit und BigInteger-Struktur  
 Das folgende Beispiel instanziiert ein <xref:System.Numerics.BigInteger> Objekt aus, und klicken Sie dann den Wert um eins erhöht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Obwohl in diesem Beispiel angezeigt wird, um den Wert des vorhandenen Objekts ändern, ist dies nicht der Fall. <xref:System.Numerics.BigInteger> -Objekte sind unveränderlich, was bedeutet, dass intern, die common Language Runtime erstellt tatsächlich ein neues <xref:System.Numerics.BigInteger> -Objekt und weist ihr den Wert eins größer ist als der vorherige Wert. Dieses neue Objekt wird an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Die numerischen Typen in .NET Framework sind ebenfalls unveränderlich. Aber da die <xref:System.Numerics.BigInteger> Typ verfügt über keine Ober- und Untergrenze, seine Werte werden sehr groß und einen messbaren Einfluss auf die Leistung haben können.  
  
 Obwohl dieser Prozess für den Aufrufer transparent ist, es zu Leistungseinbußen. In einigen Fällen, insbesondere wenn wiederholte Vorgänge werden in einer Schleife für sehr große <xref:System.Numerics.BigInteger> Werte, diese Leistungseinbußen kann erheblich sein. Beispielsweise in folgenden Beispiel ein Vorgang ausgeführt wird wiederholt, bis zu eine Million Mal, und ein <xref:System.Numerics.BigInteger> Wert wird um eins erhöht, jedes Mal, wenn der Vorgang erfolgreich ist.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In diesem Fall können Sie die Leistung verbessern, durch Ausführen von alle Zwischenergebnisse Zuweisungen zu einer <xref:System.Int32> Variable. Der endgültige Wert der Variablen kann dann zugewiesen werden, auf die <xref:System.Numerics.BigInteger> Objekt, wenn die Schleife beendet wird. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Arbeiten mit Byte-Arrays und Zeichenfolgen mit hexadezimal-  
 Wenn Sie konvertieren <xref:System.Numerics.BigInteger> Werte auf Byte-Arrays, oder wenn Sie Bytearrays zu konvertieren <xref:System.Numerics.BigInteger> Werte, berücksichtigen Sie die Reihenfolge der Bytes. Die <xref:System.Numerics.BigInteger> Struktur erwartet, dass die einzelnen Bytes in einem Bytearray in little-Endian-Reihenfolge angezeigt werden (d. h. die niederwertigen Bytes des Wertes vor stehen die höherwertigen Bytes). Sie können einen Roundtrip eine <xref:System.Numerics.BigInteger> -Wert durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode und dann das resultierende Byte-array an die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Instanziiert eine <xref:System.Numerics.BigInteger> Wert aus einem Bytearray, das einen Wert eines anderen ganzzahligen Typs darstellt, können Sie den ganzzahligen Wert zu übergeben die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> Methode, und klicken Sie dann übergeben, das sich ergebende Byte-array an, die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor. Das folgende Beispiel instanziiert ein <xref:System.Numerics.BigInteger> Wert aus einem Bytearray, das stellt ein <xref:System.Int16> Wert.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger> Struktur wird davon ausgegangen, dass negative Werte mit zwei der Ergänzung Darstellung gespeichert werden. Da die <xref:System.Numerics.BigInteger> Struktur darstellt, einen numerischen Wert ohne feste Länge, die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor immer das höchstwertige Bit der das letzte Byte im Array als Vorzeichenbit interpretiert. Um zu verhindern, dass die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> -Konstruktor von verwirrend erscheinen die beiden Komplement Darstellung eines negativen Werts mit dem Zeichen und Größe Zeichenfolgendarstellung ein positiver Wert sein, positive Werte in der die meisten niederwertigste Bit des letzten Bytes im Bytearray Normalerweise wäre Set sollte ein zusätzlicher Byte, deren Wert 0 gleich, enthalten. Z. B. 0xC0 0xBD 0xF0 0xFF ist die hexadezimale Darstellung der little-Endian--1,000,000 oder 4,293,967,296. Da das höchstwertige Bit der das letzte Byte im Array auf befindet, wird der Wert des Bytearrays von interpretiert werden die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor als-1.000.000. Instanziiert eine <xref:System.Numerics.BigInteger> , deren Wert ist positiv, ein Byte-Array, dessen Elemente 0xC0, 0xBD 0xF0 0xFF 0x00 muss an den Konstruktor übergeben werden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Byte-Arrays erstellt werden, indem die <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode von positive Werte enthalten, diese zusätzliche NULL-Wert-Byte. Aus diesem Grund die <xref:System.Numerics.BigInteger> Struktur können erfolgreich in Werte, indem Sie zum Zuweisen und dann wiederhergestellt werden diese Bytearrays, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Allerdings müssen möglicherweise Bytearrays, die dynamisch vom Entwickler erstellt werden, oder durch Methoden, die ganzen Zahlen ohne Vorzeichen in Bytearrays zu konvertieren zurückgegeben werden, diese zusätzlichen Byte mit dem Wert 0 (null) hinzugefügt (z. B. <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>, und <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Bei der Analyse einer hexadezimalen Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> und <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methoden davon aus, dass wenn das höchstwertige Bit des ersten Bytes in der Zeichenfolge festgelegt ist, oder wenn die erste hexadezimale Ziffer der Zeichenfolge die unteren vier Bits, der ein Byte-Wert darstellt, der Wert ist Mithilfe von zwei der Ergänzung Darstellung dargestellt. Zum Beispiel darstellen sowohl "FF01" und "F01" den Dezimalwert-255 dar. Um positive von negativen Werten zu unterscheiden, sollte positive Werte eine führende 0 (null) enthalten. Die entsprechenden Überladungen der <xref:System.Numerics.BigInteger.ToString%2A> Methode, wenn sie mit die Formatzeichenfolge "X" übergeben werden, hinzufügen eine führende Null in der zurückgegebenen hexadezimale Zeichenfolge für positive Werte. Dies ermöglicht einen Roundtrip <xref:System.Numerics.BigInteger> Werte mithilfe der <xref:System.Numerics.BigInteger.ToString%2A> und <xref:System.Numerics.BigInteger.Parse%2A> Methoden, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Allerdings die Hexadezimalzeichenfolgen erstellt durch Aufrufen der `ToString` Methoden der anderen ganzzahligen Typen oder die Überladungen der der <xref:System.Convert.ToString%2A> Methode, die implizit enthalten eine `toBase` Parameter nicht angegeben wird, die Vorzeichen des Werts oder der Quelldatentyp aus dem die hexadezimale Zeichenfolge abgeleitet wurde. Instanziieren erfolgreich eine <xref:System.Numerics.BigInteger> Wert aus einer solchen Zeichenfolge ist zusätzliche Logik erforderlich. Im folgenden Beispiel wird eine mögliche Implementierung.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array der Bytewerte in Little-Endian-Reihenfolge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung der Werte in einem Bytearray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes in den `value` Array sollte in der little-Endian-Reihenfolge von Byte von niedrigsten zum höchsten Byte sein. Beispielsweise wird der numerische Wert 1.000.000.000.000 dargestellt, wie in der folgenden Tabelle dargestellt:  
  
|||  
|-|-|  
|Hexadezimale Zeichenfolge|E8D4A51000|  
|Byte-Array (zuerst niedrigsten index)|00 10 A5 D4 E8 00|  
  
 Die meisten Methoden, die numerische Werte wie z. B. in Bytearrays zu konvertieren <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> und <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, Bytearrays in little-Endian-Reihenfolge zurück.  
  
 Der Konstruktor erwartet positive Werte in das Bytearray, das SSO-Wert-Darstellung und negative Werte verwenden, um die zwei Komplement Darstellung verwenden. Das heißt, wenn der höchsten Priorität des höchstwertigen Bytes in Bit `value` festgelegt ist, wird die resultierende <xref:System.Numerics.BigInteger> Wert ist negativ. Abhängig von der Quelle des Bytearrays kann dies dazu führen, dass einen positiven Wert als einen negativen Wert fehlinterpretiert werden. Byte-Arrays werden in der Regel folgendermaßen generiert:  
  
-   Durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> Methode. Da diese Methode ein Bytearray mit den höchsten Bit des höchstwertigen Bytes in den Array 0 (null) für positive Werte zurückgibt, ist gibt es keine Chance, Formatelementen einen positiven Wert als negativ. Unverändert-Byte-Arrays erstellt die <xref:System.Numerics.BigInteger.ToByteArray%2A> Methode immer erfolgreich zurückkonvertiert, wenn es sich bei der Übergabe an die <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und eine Ganzzahl mit Vorzeichen als Parameter übergeben. Da Ganzzahlen mit Vorzeichen sowohl Vorzeichen-Wert-Darstellung als auch die zwei Komplement Darstellung behandeln, ist keine Chance, einen positiven Wert als negativ Formatelementen.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und eine Ganzzahl ohne Vorzeichen als Parameter übergeben. Da Ganzzahlen ohne Vorzeichen, die nur durch ihre Größe dargestellt werden, können als negative Werte falsch positive Werte interpretiert werden. Um diese Fehlinterpretationen zu vermeiden, können Sie einen NULL-Byte-Wert am Ende des Arrays hinzufügen. Im Beispiel im nächsten Abschnitt wird veranschaulicht.  
  
-   Durch Erstellen eines Bytearrays entweder dynamisch oder statisch ohne unbedingt Aufrufen von einem der vorherigen Methoden oder Ändern eines vorhandenen Bytearrays. Um zu verhindern, dass positive Werte, die als negative Werte interpretiert werden, können Sie einen NULL-Byte-Wert am Ende des Arrays hinzufügen.  
  
 Wenn `value` ist eine leere <xref:System.Byte> Array, das neue <xref:System.Numerics.BigInteger> -Objekt initialisiert wird, auf einen Wert von <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Wenn `value` ist `null`, löst der Konstruktor ein <xref:System.ArgumentNullException>.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Numerics.BigInteger> Objekt aus einem 5-Element. Bytearray, deren Wert ist {5, 4, 3, 2, 1}. Es zeigt dann die <xref:System.Numerics.BigInteger> , als dezimalen und hexadezimalen Zahlen, an der Konsole dargestellten Wert. Ein Vergleich des Eingabe-Array mit der Textausgabe wird klar, warum diese Überladung von der <xref:System.Numerics.BigInteger> Klassenkonstruktor erstellt ein <xref:System.Numerics.BigInteger> Objekt, dessen Wert 4328719365 (oder 0 x 102030405). Das erste Element des Byte-Arrays, dessen Wert 5 ist, definiert den Wert des niedrigsten Bytes des dem <xref:System.Numerics.BigInteger> -Objekt, das 0 x 05 ist. Das zweite Element des Byte-Array, dessen Wert 4 ist, definiert den Wert, der das zweite Byte der <xref:System.Numerics.BigInteger> -Objekt, das 0 x 04 ist, und So weiter.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Das folgende Beispiel instanziiert ein positiver und negativer <xref:System.Numerics.BigInteger> -Wert, übergibt sie an der <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode, und das Original wiederhergestellt <xref:System.Numerics.BigInteger> Werte aus dem resultierenden Bytearray. Beachten Sie, dass die beiden Werte durch identische Bytearrays dargestellt werden. Der einzige Unterschied zwischen ihnen ist in das höchstwertige Bit des letzten Elements im Bytearray. Dieses Bit ist festgelegt (der Wert des Bytes ist 0xFF), bei der Erstellung des Arrays von eine Negative <xref:System.Numerics.BigInteger> Wert. Das Bit nicht festgelegt ist (der Wert des Bytes ist 0 (null)), bei der Erstellung des Arrays von eine Positive <xref:System.Numerics.BigInteger> Wert.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Das folgende Beispiel veranschaulicht, wie Sie sicherstellen, dass ein positiver Wert nicht nicht ordnungsgemäß als ein negativer Wert instanziiert wird durch das Hinzufügen von Byte, dessen Wert auf 0 (null) bis zum Ende des Arrays ist.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Dezimalzahl.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit einem <see cref="T:System.Decimal" />-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis des Aufrufs dieser Konstruktor ist identisch mit dem expliziten Zuweisen einer <xref:System.Decimal> -Werts in einen <xref:System.Numerics.BigInteger> Variable.  
  
 Aufrufen des Konstruktors kann zu Datenverlusten führen; Dezimalstellen `value` wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Es definiert ein Array von <xref:System.Decimal> Werte und übergibt dann jedes einzelnen Werts der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> Konstruktor. Beachten Sie, dass die <xref:System.Decimal> Wert abgeschnitten und nicht gerundet, wenn er zugewiesen ist die <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit doppelter Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
 Aufgrund der fehlenden Genauigkeit der <xref:System.Double> Datentyp Aufrufen dieses Konstruktors kann dazu führen, dass Daten verloren gehen.  
  
 Die <xref:System.Numerics.BigInteger> -Wert aus dem Aufrufen dieses Konstruktors ist identisch mit dem Wert an, die aus expliziten Zuweisen eine <xref:System.Double> Wert eine <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Darüber hinaus veranschaulicht es die Verlust der Genauigkeit, die auftreten können, bei der Verwendung der <xref:System.Double> -Datentyp. Ein <xref:System.Double> erhält einen hohen Wert, der dann zugewiesen ist eine <xref:System.Numerics.BigInteger> Objekt. Wie die Ausgabe zeigt, umfasst diese Zuordnung ein Genauigkeitsverlust auf. Beide Werte werden dann um eins erhöht. Die Ausgabe zeigt, dass die <xref:System.Numerics.BigInteger> Objekts gibt den geänderten Wert wieder, während die <xref:System.Double> Objekt jedoch nicht.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NaN" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NegativeInfinity" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Verlust an Genauigkeit bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt mit diesem Konstruktor.  
  
 Die <xref:System.Numerics.BigInteger> Wert an, die aus Aufrufen dieses Konstruktors ist identisch mit dem Wert aus der zuweisen eine <xref:System.Int32> -Werts in einen <xref:System.Numerics.BigInteger>.  
  
 Die <xref:System.Numerics.BigInteger> Struktur umfasst keine Konstruktoren mit einem Parameter vom Typ <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>, oder <xref:System.UInt16>. Allerdings die <xref:System.Int32> Typ unterstützt die implizite Konvertierung von 8-Bit- und 16-Bit-Ganzzahlen mit und ohne Vorzeichen in 32-Bit-Ganzzahlen mit Vorzeichen. Dieser Konstruktor wird daher aufgerufen, wenn `value` ist eine der folgenden vier ganzzahligen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> Konstruktor zum Instanziieren <xref:System.Numerics.BigInteger> Werte aus einem Array von 32-Bit-Ganzzahlen. Implizite Konvertierung außerdem verwendet, um jeden 32-Bit-Ganzzahl-Wert zum Zuweisen einer <xref:System.Numerics.BigInteger> Variable. Klicken Sie dann die zwei Werte verglichen, um festzulegen, dass die resultierende <xref:System.Numerics.BigInteger> Werte entsprechen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Verlust an Genauigkeit bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt mit diesem Konstruktor.  
  
 Die <xref:System.Numerics.BigInteger> Wert an, die aus Aufrufen dieses Konstruktors ist identisch mit dem Wert aus der zuweisen eine <xref:System.Int64> -Werts in einen <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> Konstruktor zum Instanziieren <xref:System.Numerics.BigInteger> Werte aus einem Array von 64-Bit-Ganzzahlen. Implizite Konvertierung außerdem verwendet, um jeder 64-Bit-Ganzzahl-Wert zum Zuweisen einer <xref:System.Numerics.BigInteger> Variable. Klicken Sie dann die zwei Werte verglichen, um festzulegen, dass die resultierende <xref:System.Numerics.BigInteger> Werte entsprechen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit einfacher Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter wird abgeschnitten, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Objekt.  
  
 Aufgrund der fehlenden Genauigkeit der <xref:System.Single> Datentyp Aufrufen dieses Konstruktors kann zu Datenverlust führen.  
  
 Die <xref:System.Numerics.BigInteger> -Wert aus dem Aufrufen dieses Konstruktors ist identisch mit dem Wert an, die aus expliziten Zuweisen eine <xref:System.Single> Wert eine <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt. Darüber hinaus veranschaulicht es die Verlust der Genauigkeit, die auftreten können, bei der Verwendung der <xref:System.Single> -Datentyp. Ein <xref:System.Single> erhält einen großen negativen Wert, der dann zugewiesen ist eine <xref:System.Numerics.BigInteger> Objekt. Wie die Ausgabe zeigt, umfasst diese Zuordnung ein Genauigkeitsverlust auf. Beide Werte werden dann um eins erhöht. Die Ausgabe zeigt, dass die <xref:System.Numerics.BigInteger> Objekts gibt den geänderten Wert wieder, während die <xref:System.Single> Objekt jedoch nicht.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NaN" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NegativeInfinity" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Ein 32-Bit-Ganzzahlwert ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Verlust an Genauigkeit bei der Instanziierung einer <xref:System.Numerics.BigInteger> Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> Wert an, die aus Aufrufen dieses Konstruktors ist identisch mit dem Wert aus der zuweisen eine <xref:System.UInt32> -Werts in einen <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> Konstruktor und in einer zuweisungsanweisung initialisiert <xref:System.Numerics.BigInteger> Werte aus einem Array von 32-Bit-Ganzzahlen ohne Vorzeichen. Klicken Sie dann die zwei Werte verglichen, um zu veranschaulichen, die die zwei Methoden zum Initialisieren von einem <xref:System.Numerics.BigInteger> Wert werden identische Ergebnisse erzielt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Verlust an Genauigkeit bei der Instanziierung einer <xref:System.Numerics.BigInteger> Verwendung dieses Konstruktors.  
  
 Die <xref:System.Numerics.BigInteger> Wert an, die aus Aufrufen dieses Konstruktors ist identisch mit dem Wert aus der zuweisen eine <xref:System.UInt64> -Werts in einen <xref:System.Numerics.BigInteger>.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> Konstruktor zum Instanziieren einer <xref:System.Numerics.BigInteger> Objekt, dessen Wert gleich <xref:System.UInt64.MaxValue>.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl.</param>
        <summary>Ruft den absoluten Wert eines <see cref="T:System.Numerics.BigInteger" />-Objekts ab.</summary>
        <returns>Der Absolutbetrag von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Absolute Wert einer Zahl ist diese Zahl ohne Vorzeichen, wie in der folgenden Tabelle gezeigt.  
  
|`value`-Parameter|Rückgabewert|  
|-----------------------|------------------|  
|`value` >= 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Die <xref:System.Numerics.BigInteger.Abs%2A> Methode entspricht der <xref:System.Math.Abs%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Abs%2A> Methode zum Konvertieren einer <xref:System.Numerics.BigInteger> Wert zwischen zwei der Ergänzung Darstellung und Vorzeichen-Wert-Darstellung vornehmen, bevor es in eine Datei serialisiert wird. Klicken Sie dann Daten in der Datei deserialisiert und ein neues zugewiesen <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt das Ergebnis zurück.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die Überladung von Operatoren oder benutzerdefinierten Operatoren nicht unterstützen können die <xref:System.Numerics.BigInteger.Add%2A> -Methode zum Hinzufügen mit <xref:System.Numerics.BigInteger> Werte.  
  
 Die <xref:System.Numerics.BigInteger.Add%2A> Methode ist ein geeigneter Ersatz für den Additionsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie eine Summe aus der Addition, zuweisen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Vergleicht zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt eine ganze Zahl zurück, die angibt, ob der erste Wert kleiner oder größer als der zweite Wert oder gleich dem zweiten Wert ist.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relativen Werte von <paramref name="left" /> und <paramref name="right" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="left" /> ist kleiner als <paramref name="right" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="left" /> ist gleich <paramref name="right" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="left" /> ist größer als <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl die <xref:System.Numerics.BigInteger> Typ verfügt über keinen festen Bereich, der Vergleiche von <xref:System.Numerics.BigInteger> Werte sind nicht gekennzeichnet, durch den Mangel an Genauigkeit, die den Vergleich von Gleitkommazahlen charakterisiert. Im folgende Beispiel werden zwei <xref:System.Numerics.BigInteger> Werte, die durch und jede unterscheiden hat 1,896 Ziffern haben. Die <xref:System.Numerics.BigInteger.Compare%2A> Methode meldet ordnungsgemäß, dass die beiden Werte nicht gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht den Wert dieser Instanz mit einem anderen Wert und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der andere Wert ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl mit Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl mit Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu ein <xref:System.Int64> Wert fest, wenn die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> Methode wird aufgerufen.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt das Ergebnis des Aufrufs der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> Methode mit ganzzahligen Werten.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem zweiten <see cref="T:System.Numerics.BigInteger" /> und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Numerics.BigInteger.CompareTo%2A> Methode implementiert die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> Methode. Es wird von generischen Auflistungsobjekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> Methode, um eine Liste der `StarInfo` Objekte. Jede `StarInfo` Objekt enthält Informationen zu einem Stern Name und der Abstand zwischen den Erdradius in Meilen. `StarInfo` implementiert die <xref:System.IComparable%601> Schnittstelle, wodurch `StarInfo` Objekte nach generische Auflistungsklassen sortiert werden. Die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> Implementierung umfasst einfach einen Aufruf von <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Klicken Sie dann instanziiert der folgende Code vier `StarInfo` Objekten und speichert sie in einem generischen <xref:System.Collections.Generic.List%601> Objekt. Nach der <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> Methode wird aufgerufen, `StarInfo` Objekte werden in der Reihenfolge ihrer Entfernung von der Erde angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die Beziehung der aktuellen Instanz zum <paramref name="obj" />-Parameter angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="obj" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="obj" />, oder der <paramref name="obj" />-Parameter ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung von der <xref:System.Numerics.BigInteger.CompareTo%2A> Methode implementiert die <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> Methode. Es wird von nicht generische Auflistung von Objekten zum Sortieren der Elemente in der Auflistung.  
  
 Die `obj` -Parameter muss eine der folgenden sein:  
  
-   Ein Objekt, dessen Typ zur Laufzeit <xref:System.Numerics.BigInteger>.  
  
-   Ein <xref:System.Object> Variable, deren Wert `null`. Wenn der Wert des der `obj` Parameter `null`, die Methode gibt 1 zurück, der angibt, dass, der die aktuelle Instanz größer als `obj`.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> -Methode zum Vergleichen einer <xref:System.Numerics.BigInteger> Wert mit jedem Element in einem Objektarray  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="obj" /> ist keine <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl ohne Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl ohne Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die den relativen Wert dieser Instanz und von <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung  
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen und gibt das Ergebnis zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Divide%2A> Methode führt die Ganzzahldivision; die aus der Division ergibt Rest wird verworfen. Rufen Sie zum Ausführen der ganzzahligen Division und gleichzeitig den Rest der <xref:System.Numerics.BigInteger.DivRem%2A> Methode. Rufen Sie zum Abrufen des Rests der <xref:System.Numerics.BigInteger.Remainder%2A> Methode.  
  
 Die <xref:System.Numerics.BigInteger.Divide%2A> Methode kann verwendet werden, von Sprachen, die Überladung von Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Division mit der Divisionsoperator.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, der Divisionsoperator (/), und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <param name="remainder">Die Rückgabe dieser Methode enthält einen <see cref="T:System.Numerics.BigInteger" />-Wert, der den Rest der Division darstellt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen, gibt das Ergebnis zurück und gibt den Rest in einem Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird beibehalten, sowohl den Quotienten und den Rest einer Ganzzahldivision. Wenn Sie nicht den Rest interessiert sind, verwenden Sie die <xref:System.Numerics.BigInteger.Divide%2A> Methode oder der Divisionsoperator; Wenn Sie sind nur im weiteren Verlauf, möchten Sie verwenden die <xref:System.Numerics.BigInteger.Remainder%2A> Methode.  
  
 Das Vorzeichen des zurückgegebenen `remainder` Wert ist identisch mit das Vorzeichen der `dividend` Parameter.  
  
 Das Verhalten der <xref:System.Numerics.BigInteger.DivRem%2A> Methode ist identisch mit der <xref:System.Math.DivRem%2A?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, der Divisionsoperator (/), und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> ist 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Der Wert der 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl mit Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />, wenn die 64-Bit-Ganzzahl mit Vorzeichen und die aktuelle Instanz über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn die Methode aufgerufen wird.  
  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein <xref:System.Numerics.BigInteger> Objekt aus jedem ganzzahligen Typ außer <xref:System.UInt64>. Es ruft dann die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> -Methode zum Vergleichen der <xref:System.Numerics.BigInteger> Wert mit der ursprünglichen ganzen Zahl, die übergeben wurde, die <xref:System.Numerics.BigInteger> Konstruktor. Die Ausgabe zeigt, sind die Werte in beiden Fällen gleich.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes <see cref="T:System.Numerics.BigInteger" />-Objekt über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />, wenn dieses <see cref="T:System.Numerics.BigInteger" />-Objekt und <paramref name="other" /> über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601> -Schnittstelle und führt etwas bessere Leistung als <xref:System.Numerics.BigInteger.Equals%28System.Object%29> , da es keine konvertieren die `other` Parameter, um eine <xref:System.Numerics.BigInteger> Objekt.  
  
 Um zu bestimmen, die Beziehung zwischen den beiden <xref:System.Numerics.BigInteger> -Objekte anstelle von nur auf Gleichheit, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen, die von der Erde, mit der Entfernung des Epsilon Indi von der Erde zu bestimmen, ob diese gleich sind. Im Beispiel wird jeder Überladung der <xref:System.Numerics.BigInteger.Equals%2A> Methode zum Testen auf Gleichheit.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />, wenn das <paramref name="obj" />-Argument ein <see cref="T:System.Numerics.BigInteger" />-Objekt darstellt und dessen Wert der aktuellen <see cref="T:System.Numerics.BigInteger" />-Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die `obj` Argument ist keine <xref:System.Numerics.BigInteger> Wert, der Methodenrückgabe `false`. Gibt die Methode zurück `true` nur, wenn `obj` ist eine <xref:System.Numerics.BigInteger> -Instanz, deren Wert gleich der aktuellen Instanz ist.  
  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel definiert die parallele <xref:System.Object> und <xref:System.Numerics.BigInteger> Arrays. Jedes Element eines Arrays hat den gleichen Wert wie das entsprechende Element des zweiten Arrays. Wie die Ausgabe des Beispiels zeigt, die Instanz in der <xref:System.Numerics.BigInteger> Array gilt als gleich der Instanz in der <xref:System.Object> array nur, wenn die zweite ist ein <xref:System.Numerics.BigInteger> und deren Werte gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns>
          <see langword="true" />, wenn die aktuelle Instanz und die 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Beziehung zwischen den beiden Objekten statt nur Testen auf Gleichheit zu bestimmen, rufen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen, die von der Erde, mit der Entfernung des Epsilon Indi von der Erde zu bestimmen, ob diese gleich sind. Im Beispiel wird jeder Überladung der <xref:System.Numerics.BigInteger.Equals%2A> Methode zum Testen auf Gleichheit.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.BigInteger" />-Objekt zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Sucht den größten gemeinsamen Divisor von zwei <see cref="T:System.Numerics.BigInteger" />-Werten.</summary>
        <returns>Der größte gemeinsame Divisor von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der größte gemeinsame Teiler ist die größte Zahl in die die beiden <xref:System.Numerics.BigInteger> -Werte unterteilt werden können, ohne einen Rest zurückzugeben.  
  
 Wenn die `left` und `right` Parameter sind ungleich 0-Ziffern, die Methode gibt immer mindestens den Wert 1 zurück, da alle Zahlen von 1 geteilt werden können. Wenn einer der Parameter NULL ist, gibt die Methode den absoluten Wert des Parameters ungleich NULL zurück. Wenn beide Werte NULL sind, gibt die Methode 0 (null) zurück.  
  
> [!NOTE]
>  Der größte gemeinsame Divisor von sehr großen Werten für Computing `left` und `right` kann ein sehr zeitraubender Vorgang sein.  
  
 Der Rückgabewert von der <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> Methode ist immer positive unabhängig vom Vorzeichen der `left` und `right` Parameter.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen Aufruf der <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> -Methode und der Webdienst zur Ausnahmebehandlung erforderlich, die nützliche Informationen zum Bereitstellen einer <xref:System.ArgumentOutOfRangeException>. Das Ergebnis gibt an, dass der größte gemeinsame Divisor von diesen beiden Werten 1 ist.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist.</summary>
        <value>
          <see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist eine Annehmlichkeit, der angibt, ob eine <xref:System.Numerics.BigInteger> Wert wird von zwei gleichmäßig geteilt werden. Dies entspricht dem folgenden Ausdruck:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, gibt die Eigenschaft `true`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist.</summary>
        <value>
          <see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine bedeutend bessere Leistung als andere Vergleiche mit, wie z. B. `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist.</summary>
        <value>
          <see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, ob eine <xref:System.Numerics.BigInteger> Wert hat ein einzelnes ungleich NULL-Bit festgelegt. Dies bedeutet, dass zurückgegeben `true` Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt ist 1 (d. h. 2<sup>0</sup>) oder eine höhere Potenz von zwei. Es gibt `false` Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekt ist 0.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist.</summary>
        <value>
          <see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine bedeutend bessere Leistung als `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Logarithmus der angegebenen Zahl zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Der natürliche Logarithmus (Basis <see langword="e" />) von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter wird als Zahl zur Basis 10 angegeben.  
  
 Der genaue Rückgabewert dieser Methode abhängig ist, auf der `value`, wie in die folgende Tabelle dargestellt.  
  
|Melden von `value` Parameter|Rückgabewert|  
|-------------------------------|------------------|  
|Positiv|Der natürliche Logarithmus des `value`; d. h. ln `value`, oder Log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>|  
|Negativ|<xref:System.Double.NaN>|  
  
 Um den Logarithmus zur Basis 10 Berechnen einer <xref:System.Numerics.BigInteger> Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log10%2A> Methode. Um den Logarithmus einer Zahl in einem anderen zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> Methode.  
  
 Sie finden die Quadratwurzel einer Zahl durch Aufrufen der <xref:System.Numerics.BigInteger.Log%2A> Methode zusammen mit den <xref:System.Math.Exp%2A?displayProperty=nameWithType> Methode. Beachten Sie, dass das Ergebnis <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ist das Ergebnis größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>. Das folgende Beispiel berechnet die Quadratwurzel der einzelnen Elemente in ein Array von <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Diese Methode entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der natürliche Logarithmus von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <param name="baseValue">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Der Logarithmus zur Basis <paramref name="baseValue" /> von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` und `baseValue` Parameter werden angegeben, wie Zahlen zur Basis 10.  
  
 Der genaue Rückgabewert der Methode abhängig ist, auf der `value` und für die Anmeldung und den Wert eines `baseValue`, wie in die folgende Tabelle dargestellt.  
  
|`value`-Parameter|`baseValue`-Parameter|Rückgabewert|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1) – oder – (`baseValue` > 1)|logbaseValue(`value`)|  
|`value` < 0|(beliebiger Wert)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Um den Logarithmus zur Basis 10 Berechnen einer <xref:System.Numerics.BigInteger> Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log10%2A> Methode. Um den natürlichen Logarithmus einer Zahl zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> Methode.  
  
 Diese Methode entspricht der <xref:System.Math.Log%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das Protokoll von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Der Logarithmus zur Basis 10 von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` -Parameter wird als Zahl zur Basis 10 angegeben.  
  
 Der genaue Rückgabewert der Methode abhängig ist, auf der `value`, wie in die folgende Tabelle dargestellt.  
  
|Anzeichen für "Value"-Parameter|Rückgabewert|  
|-----------------------------|------------------|  
|Positiv|Der Logarithmus zur Basis 10 von `value`; d. h. log10`value`.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>|  
|Negativ|<xref:System.Double.NaN?displayProperty=nameWithType>|  
  
 Berechnet den natürlichen Logarithmus einer <xref:System.Numerics.BigInteger> Wert, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Methode. Um den Logarithmus einer Zahl in einem anderen zu berechnen, rufen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> Methode.  
  
 Diese Methode entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Logarithmus zur Basis 10 von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den größeren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der größere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Max%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Max%2A> Methode, um die größte Zahl in ein Array von wählen <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den kleineren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Min%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Min%2A> Methode wählen Sie die kleinste Zahl in ein Array von <xref:System.Numerics.BigInteger> Werte.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl -1 darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert -1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.MinusOne%2A> Eigenschaft wird verwendet, um zu vergleichen einer <xref:System.Numerics.BigInteger> Wert – 1 oder-1 und Zuweisen einer <xref:System.Numerics.BigInteger> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <c>exponent</c> Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <c>value</c> potenziert werden soll.</param>
        <param name="modulus">Die Zahl, durch die <c>value</c> hoch <c>exponent</c> dividiert wird.</param>
        <summary>Führt eine Modulodivision für eine zur Potenz einer anderen Zahl erhobene Zahl aus.</summary>
        <returns>Der Rest nach der Division von <paramref name="value" /><sup>exponent</sup> durch <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ModPow%2A> Methode wertet den folgenden Ausdruck:  
  
 (BaseValue ^ Exponent) MOD-Modulo  
  
 Zum Ausführen von Potenzierung auf <xref:System.Numerics.BigInteger> Werte ohne Modulo-Division, verwenden die <xref:System.Numerics.BigInteger.Pow%2A> Methode.  
  
   
  
## Examples  
 Das folgende Beispiel enthält eine einfache Darstellung des Aufrufs der <xref:System.Numerics.BigInteger.ModPow%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="modulus" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="exponent" /> ist ein negativer Wert.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Die erste zu multiplizierende Zahl.</param>
        <param name="right">Die zweite zu multiplizierende Zahl.</param>
        <summary>Gibt das Produkt der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Multiply%2A> Methode wird implementiert, für die Sprachen, die Überladung von Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Multiplikation mit der Multiplikationsoperator. Darüber hinaus die <xref:System.Numerics.BigInteger.Multiply%2A> Methode ist ein geeigneter Ersatz für den Multiplikationsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie ein Produkt aus der Multiplikation zuweisen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Wenn erforderlich, führt diese Methode automatisch implizite Konvertierung von anderen ganzzahligen Typen auf <xref:System.Numerics.BigInteger> Objekte. Dies wird im Beispiel im nächsten Abschnitt veranschaulicht, in denen die <xref:System.Numerics.BigInteger.Multiply%2A> -Methode übergeben zwei <xref:System.Int64> Werte.  
  
   
  
## Examples  
 Im folgenden Beispiel wird versucht, die Multiplikation mit zwei langen ganzen Zahlen ausführen. Da das Ergebnis des Bereichs einer langen ganzen Zahl, überschreitet ein <xref:System.OverflowException> ausgelöst wird, und die <xref:System.Numerics.BigInteger.Multiply%2A> aufgerufen, um die Multiplikation zu behandeln. Beachten Sie, dass c# erfordert, dass Sie entweder die `checked` Schlüsselwort (wie in diesem Beispiel) oder die `/checked+` -Compileroption verwenden, um sicherzustellen, dass bei einem numerischen Überlauf wird eine Ausnahme ausgelöst.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negation erhält die Additive Inverse einer Zahl. Die Additive Inverse einer Zahl ist eine Zahl, die den Wert 0 (null) generiert, wenn sie die ursprüngliche Anzahl hinzugefügt wird.  
  
 Die <xref:System.Numerics.BigInteger.Negate%2A> Methode wird implementiert, für die Sprachen, die benutzerdefinierte Operatoren nicht unterstützen. Das Verhalten ist identisch mit den unären Negationsoperator Negation. Darüber hinaus die <xref:System.Numerics.BigInteger.Negate%2A> Methode ist ein geeigneter Ersatz für den Negationsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variablen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die drei Möglichkeiten, um den Wert des Negieren einer <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl 1 darstellt.</summary>
        <value>Ein Objekt, dessen Wert 1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.One%2A> Eigenschaft wird in der Regel zum Vergleich einer <xref:System.Numerics.BigInteger> Wert auf 1 oder 1 bis zuweisen eine <xref:System.Numerics.BigInteger> Objekt.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert die Werte von zwei angegebenen <see cref="T:System.Numerics.BigInteger" />-Objekten.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Addition%2A> Methode definiert die Additionsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Add%2A> Methode stattdessen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="And" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="And" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Methode definiert die bitweise `And` Vorgang für <xref:System.Numerics.BigInteger> Werte. Der bitweise `And` Vorgang legt ein Ergebnis nur fest, wenn die entsprechenden Bits in `left` und `right` festgelegt wurden, wie in der folgenden Tabelle gezeigt.  
  
|Bit `left`|Bit `right`|Bit im Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> Methode führt das bitweise `And` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="Or" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Methode definiert die bitweise `Or` Vorgang für <xref:System.Numerics.BigInteger> Werte. Der bitweise `Or` Vorgang legt ein Ergebnisbit nur, wenn eine oder beide der entsprechenden Bits in `left` und `right` festgelegt sind, wie in der folgenden Tabelle gezeigt.  
  
|Bit `left`|Bit `right`|Bit im Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> Methode führt das bitweise `Or` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu dekrementierende Wert.</param>
        <summary>Dekrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 dekrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Decrement%2A> Methode definiert der dekrementvorgang für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Subtract%2A> Methode stattdessen. Zum Beispiel:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte sind unveränderlich, die <xref:System.Numerics.BigInteger.op_Decrement%2A> Operator erstellt eine neue <xref:System.Numerics.BigInteger> Objekt, dessen Wert ist, kleiner als der <xref:System.Numerics.BigInteger> durch dargestellte Objekt `value`. Dies bedeutet, die wiederholte Aufrufe <xref:System.Numerics.BigInteger.op_Decrement%2A> kann teuer sein.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert mit einer Ganzzahldivision.</summary>
        <returns>Das ganzzahlige Ergebnis der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Division%2A> Methode definiert die Divisionsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Sprachen, die benutzerdefinierte Operatoren und überladene Operatoren nicht unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Divide%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel erstellt ein Array von <xref:System.Numerics.BigInteger> Werte. Anschließend wird jedes Element als der Quotient bei einer Division, die verwendet die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, der Divisionsoperator (/), und die <xref:System.Numerics.BigInteger.DivRem%2A> Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> Methode definiert, die auf Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> stattdessen Instanzmethode.  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl mit Vorzeichen gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> Methode definiert, die auf Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> stattdessen Instanzmethode.  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Werte von zwei <see cref="T:System.Numerics.BigInteger" />-Objekten gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Methode definiert, den Vorgang des Gleichheitsoperators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> stattdessen Instanzmethode.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl ohne Vorzeichen gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> Methode definiert, die auf Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> stattdessen Instanzmethode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> Methode definiert, die auf Gleichheit Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> stattdessen Instanzmethode.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise exklusive <see langword="Or" />-Operation (<see langword="XOr" />-Operation) für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis einer bitweisen exklusiven `Or` Vorgang `true` , wenn die Werte der zwei Bits verschieden; andernfalls sind, ist es `false`. Die folgende Tabelle zeigt die exklusive `Or` Vorgang.  
  
|Bit-X in `left`|Bit-X in `right`|Rückgabewert|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> Methode führt die bitweise exklusive `Or` -Operation für zwei <xref:System.Numerics.BigInteger> Werte, als wären sie in der zwei Komplement Darstellung mit virtuellen vorzeichenerweiterung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Decimal" />-Objekts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter vor der Konvertierung abgeschnitten.

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Decimal> zu <xref:System.Numerics.BigInteger> kann das Abschneiden der Dezimalstellen umfassen `value`, Sprachcompiler führen diese Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.   

 Für Sprachen, die benutzerdefinierten Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in ein Array von <xref:System.Decimal> Werte <xref:System.Numerics.BigInteger> Objekte aus, und klicken Sie dann das Ergebnis der jede Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Decimal> Wert wird während der Konvertierung abgeschnitten.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Double" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter vor der Konvertierung abgeschnitten.

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Double> zu <xref:System.Numerics.BigInteger> kann das Abschneiden der Dezimalstellen umfassen `value`, Sprachcompiler führen diese Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.

 Für Sprachen, die benutzerdefinierten Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in ein Array von <xref:System.Double> Werte <xref:System.Numerics.BigInteger> Objekte aus, und klicken Sie dann das Ergebnis der jede Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Double> Wert wird während der Konvertierung abgeschnitten.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NaN" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.PositiveInfinity" />.
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Byte" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Bytewert ohne Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CByte` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Byte> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.Byte> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Byte> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Byte> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.Byte.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Decimal" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CDec` in Visual Basic) wird verwendet.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Decimal> -Datentyp. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Decimal> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Decimal> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.Decimal.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Double" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Double" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CDbl` in Visual Basic) wird verwendet.   

 Da die <xref:System.Numerics.BigInteger> Werte sind möglich außerhalb des Bereichs von der <xref:System.Double> -Datentyp, dieser Vorgang ist eine einschränkende Konvertierung. Wenn die Konvertierung fehlschlägt, löst eine <xref:System.OverflowException>. Stattdessen, wenn die <xref:System.Numerics.BigInteger> Wert ist kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>, die resultierende <xref:System.Double> Wert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Wenn die <xref:System.Numerics.BigInteger> Wert ist größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>, die resultierende <xref:System.Double> Wert <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Die Konvertierung von einem <xref:System.Numerics.BigInteger> auf eine <xref:System.Double> kann mit einem Genauigkeitsverlust verbunden. In einigen Fällen möglicherweise den Verlust der Genauigkeit den Umwandlung oder Konvertierung Vorgang erfolgreich ausgeführt werden kann, wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Double> -Datentyp. Dies wird im folgenden Beispiel veranschaulicht. Weist den maximalen Wert von einem <xref:System.Double> auf zwei <xref:System.Numerics.BigInteger> Variablen, erhöht eine <xref:System.Numerics.BigInteger> Variable, indem Sie um 9. 999e291 und prüft die zwei Variablen auf Gleichheit. Wie erwartet und den Aufruf der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode zeigt, dass sie ungleich sind. Allerdings die Konvertierung des größeren <xref:System.Numerics.BigInteger> Wert zurück, an eine <xref:System.Double> erfolgreich, obwohl die <xref:System.Numerics.BigInteger> Wert jetzt überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Double> Werte.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CShort` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int16> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.Int16> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int16> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int16> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.Int16.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CInt` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int32> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.Int16> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int32> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int32> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.Int32.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CLng` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int64> -Datentyp. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Int64> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Int64> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.Int64.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen 8-Bit-Wert mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen 8-Bit-Wert mit Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int16" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CSByte` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.SByte> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.SByte> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.SByte> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.SByte> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.SByte.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen Gleitkommawert mit einfacher Genauigkeit konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Gleitkommawert mit einfacher Genauigkeit.</summary>
        <returns>Ein Objekt, das die nächstmögliche Darstellung des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da dies zu Datenverlust oder einem Genauigkeitsverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CSng` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.    

 Da die <xref:System.Numerics.BigInteger> Werte sind möglich außerhalb des Bereichs von der <xref:System.Single> -Datentyp, dieser Vorgang ist eine einschränkende Konvertierung. Wenn die Konvertierung fehlschlägt, löst eine <xref:System.OverflowException>. Stattdessen, wenn die <xref:System.Numerics.BigInteger> Wert ist kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>, die resultierende <xref:System.Single> Wert <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Wenn die <xref:System.Numerics.BigInteger> Wert ist größer als <xref:System.Single.MaxValue?displayProperty=nameWithType>, die resultierende <xref:System.Single> Wert <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Die Konvertierung von einem <xref:System.Numerics.BigInteger> auf eine <xref:System.Single> kann mit einem Genauigkeitsverlust verbunden. In einigen Fällen möglicherweise den Verlust der Genauigkeit den Umwandlung oder Konvertierung Vorgang erfolgreich ausgeführt werden kann, wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.Single> -Datentyp. Dies wird im folgenden Beispiel veranschaulicht. Weist den maximalen Wert von einem <xref:System.Single> auf zwei <xref:System.Numerics.BigInteger> Variablen, erhöht eine <xref:System.Numerics.BigInteger> Variable, indem Sie um 9. 999e291 und prüft die zwei Variablen auf Gleichheit. Wie erwartet und den Aufruf der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode zeigt, dass sie ungleich sind. Allerdings die Konvertierung des größeren <xref:System.Numerics.BigInteger> Wert zurück, an eine <xref:System.Single> erfolgreich, obwohl die <xref:System.Numerics.BigInteger> Wert jetzt überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.Single> Werte.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int32" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CUShort` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt16> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.UInt16> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt16> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt16> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.UInt16.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int64" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CUInt` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt32> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.UInt32> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt32> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt32> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.UInt32.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` oder `CULng` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert wird, löst es eine <xref:System.OverflowException> zur Laufzeit Wenn die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt64> -Datentyp. Es gibt keinen Verlust der Genauigkeit in die resultierende <xref:System.UInt64> -Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> zu <xref:System.UInt64> Werte. Er führt auch eine <xref:System.OverflowException> , die ausgelöst wird, da die <xref:System.Numerics.BigInteger> Wert liegt außerhalb des Bereichs von der <xref:System.UInt64> -Datentyp.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> beträgt weniger als <see cref="F:System.UInt64.MinValue" />.  
  
- oder -  
Der Wert von <paramref name="value" /> beträgt mehr als <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Single" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter vor der Konvertierung abgeschnitten.
 
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem eine <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Single> zu <xref:System.Numerics.BigInteger> kann das Abschneiden der Dezimalstellen umfassen `value`, Sprachcompiler führen diese Konvertierung nicht automatisch. Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) wird verwendet. Andernfalls zeigen sie einen Compilerfehler.

 Für Sprachen, die benutzerdefinierten Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Das folgende Beispiel konvertiert die einzelnen Elemente in ein Array von <xref:System.Single> Werte <xref:System.Numerics.BigInteger> Objekte aus, und klicken Sie dann das Ergebnis der jede Konvertierung angezeigt. Beachten Sie, dass jeder Bruchteil Teil einer <xref:System.Single> Wert wird während der Konvertierung abgeschnitten.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NaN" />.  
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.PositiveInfinity" />.
  
- oder -  
Der Wert von <paramref name="value" /> ist <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer als ein anderer angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> stattdessen Instanzmethode. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> größer als der Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> Methode definiert, den Vorgang des größer-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer oder gleich einem anderen angegebenen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> Methode definiert, den Vorgang, der größer als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine implizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen in ein <see cref="T:System.Numerics.BigInteger" />-Objekt.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dezimalstellen der `value` Parameter vor der Konvertierung abgeschnitten.

 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.Byte> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.Int16> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.Int32> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.Int64> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.SByte> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.UInt16> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.UInt32> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die implizite Operatoren nicht unterstützen, die alternative Methode ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Die Überladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> Methode definieren die Typen aus, für die oder aus dem ein Compiler automatisch konvertieren kann eine <xref:System.Numerics.BigInteger> Wert ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic). Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>. Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen aus einer <xref:System.UInt64> Wert eine <xref:System.Numerics.BigInteger> Werts, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu inkrementierende Wert.</param>
        <summary>Inkrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 inkrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Increment%2A> Methode definiert der erhöhungsvorgang für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Einige Sprachen (z. B. Visual Basic), die nicht über ein Inkrement-Operator oder unterstützen keine Überladung von Operatoren können aufrufen, die <xref:System.Numerics.BigInteger.op_Increment%2A> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte sind unveränderlich, die <xref:System.Numerics.BigInteger.op_Increment%2A> Operator erstellt eine neue <xref:System.Numerics.BigInteger> Objekt, dessen Wert eine mehr als die <xref:System.Numerics.BigInteger> durch dargestellte Objekt `value`. Aus diesem Grund wiederholte Aufrufe von <xref:System.Numerics.BigInteger.op_Increment%2A> kann teuer sein.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte ungleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> Methode definiert, den Betrieb der Ungleichheitsoperator zum <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit mit einem der folgenden Methoden testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Instanzmethode, womit die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und ein langer Ganzzahlwert mit Vorzeichen.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Instanzmethode und dessen Wert umkehren.  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl mit Vorzeichen ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> Methode definiert, den Betrieb der Ungleichheitsoperator zum <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit mit einem der folgenden Methoden testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen gibt eine <xref:System.Numerics.BigInteger> und ein langer Ganzzahlwert mit Vorzeichen.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Numerics.BigInteger" />-Objekte über unterschiedliche Werte verfügen.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> Methode definiert, den Betrieb der Ungleichheitsoperator zum <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit mit einem der folgenden Methoden testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> -Methode, die die Beziehung zwischen zwei angibt <xref:System.Numerics.BigInteger> Objekte.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl ohne Vorzeichen ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> Methode definiert, den Betrieb der Ungleichheitsoperator zum <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit mit einem der folgenden Methoden testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen gibt eine <xref:System.Numerics.BigInteger> und eine lange Ganzzahl ohne Vorzeichen-Wert.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> Methode definiert, den Betrieb der Ungleichheitsoperator zum <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit mit einem der folgenden Methoden testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen gibt eine <xref:System.Numerics.BigInteger> und eine lange Ganzzahl ohne Vorzeichen-Wert.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und ihren Wert umkehren.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <c>value</c> nach links verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach links.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach links verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LeftShift%2A> Methode definiert, den Betrieb der bitweise Linksschiebeoperator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Im Gegensatz zu der bitweise Linksschiebe-Operation mit ganzzahligen Primitiven der <xref:System.Numerics.BigInteger.op_LeftShift%2A> Methode behält die Vorzeichen des ursprünglichen <xref:System.Numerics.BigInteger> Wert.  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, können eine bitweise Linksschiebeoperation ausführen, durch Multiplikation `value` von `BigInteger.Pow(2, shift)`. Das folgende Beispiel zeigt, dass die Ergebnisse an die Ergebnisse mit diesem Operator identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als ein zweiter angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> Methode stattdessen. Bei einigen Sprachen können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> Methode definiert, den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als oder gleich einem anderen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Betrieb der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Wenn `left` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Betrieb der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Wenn `right` ist eine <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>, oder <xref:System.UInt32> Wert, wird eine implizite Konvertierung zu einem <xref:System.Int64> Wert, wenn der Vorgang ausgeführt wird.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Betrieb der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Compare%2A> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Betrieb der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> Methode definiert, den Betrieb der kleiner als oder gleich-Operator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> Methode stattdessen. Sie können auch aufrufen, die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> direkt, wie im folgenden Beispiel wird verdeutlicht.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Gibt den Rest aus der Division zweier angegebener <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der Rest, der sich aus der Division ergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Modulus%2A> Methode definiert, den Vorgang des Modulo-Operators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 Die Vorzeichen des durch die Modulo-Vorgang zurückgegebenen Werts hängt das Vorzeichen des `dividend`: Wenn `dividend` positiv ist, wird die Modulo-Operation ein positives Ergebnis zurück, wenn sie negativ ist, gibt die Modulo-Operation ein negatives Ergebnis zurück. Das Verhalten der Modulo-Operation mit <xref:System.Numerics.BigInteger> Werte ist identisch mit den Modulo-Vorgang mit anderen ganzzahligen Typen.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu multiplizierende Wert.</param>
        <param name="right">Der zweite zu multiplizierende Wert.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Numerics.BigInteger" />-Werte.</summary>
        <returns>Das Produkt von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Multiply%2A> Methode definiert, den Betrieb der Multiplikationsoperator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt das bitweise Einerkomplement eines <see cref="T:System.Numerics.BigInteger" />-Werts zurück.</summary>
        <returns>Das bitweise Einerkomplement von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Methode definiert, den Vorgang des bitweisen Einerkomplementoperator für <xref:System.Numerics.BigInteger> Werte. Der bitweise Einerkomplementoperator kehrt jedes bit in einem numerischen Wert. D. h. bits `value` sind 0 werden in das Ergebnis auf 1 festgelegt, und die Bits, die den Wert 1 haben, werden in das Ergebnis auf 0 festgelegt. Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen möglicherweise zum Aufrufen der <xref:System.Numerics.BigInteger.op_OnesComplement%2A> Methode direkt an die eine bitweise Ausführen der Einerkomplementoperation. Zum Beispiel:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <c>value</c> nach rechts verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach rechts.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach rechts verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_RightShift%2A> Methode definiert, den Betrieb der bitweise Rechtsschiebeoperator für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Sprachen, die benutzerdefinierte Operatoren nicht unterstützen, können eine bitweise Rechtsschiebeoperation ausführen, durch Dividieren `value` von `BigInteger.Pow(2, shift)` und Subtrahieren von 1 Mal `shift` für negative Werte. Das folgende Beispiel zeigt, dass die Ergebnisse an die Ergebnisse mit diesem Operator identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Wenn `shift` ist größer als oder gleich der Anzahl von Bits in einem positiven <xref:System.Numerics.BigInteger> Wert das Ergebnis des Vorgangs Verschiebung nach rechts ist <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Wenn `shift` ist größer als die Anzahl der Bits in einem negativen <xref:System.Numerics.BigInteger> Wert das Ergebnis des Vorgangs Verschiebung nach rechts ist <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Subtraction%2A> Methode definiert, den Vorgang des Subtraktionsoperators für <xref:System.Numerics.BigInteger> Werte. Sie können Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen BigInteger-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> Methode definiert die Operation der unäre Negationsoperator (oder der Operator gegenzahl) für <xref:System.Numerics.BigInteger> Werte. Der Vorgang erzeugt einen Wert, der zu 0 (null), wenn sie die ursprüngliche Anzahl hinzugefügt wird. Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.BigInteger.Negate%2A> Methode stattdessen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Das folgende Beispiel veranschaulicht die drei Möglichkeiten, den Wert des Negieren einer <xref:System.Numerics.BigInteger> Objekt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt den Wert des <see cref="T:System.Numerics.BigInteger" />-Operanden zurück. (Das Vorzeichen des Operanden wird nicht geändert.)</summary>
        <returns>Der Wert des <paramref name="value" />-Operanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> Methode definiert, den Vorgang, der den unären-positiv-Operator für <xref:System.Numerics.BigInteger> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss die angegebene Zeichenfolgendarstellung einer Zahl in der folgenden Form sein.  
  
 [*ws*] [*anmelden*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Einem optionalen Vorzeichen. Gültige Zeichen für Vorzeichen hängen von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Der angegebenen Zeichenfolge das `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stil. Es kann keine Gruppentrennzeichen oder die Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Um eine Zeichenfolge mit den Formatierungsinformationen des einer bestimmten Kultur zu analysieren, verwenden die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> Methode.  
  
> [!IMPORTANT]
>  Bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Methode Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der von ausgegeben wurde der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> -Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Hingegen die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen könnten bei der Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Parse%28System.String%29> Methode zum Instanziieren zweier <xref:System.Numerics.BigInteger> Objekte. Jedes Objekt mit einer anderen Zahl multipliziert und ruft dann die <xref:System.Numerics.BigInteger.Compare%2A> Methode, um die Beziehung zwischen den beiden Werten zu ermitteln.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <c>value</c> angeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z.B. Leerzeichen, das positives oder negatives Vorzeichen-Symbol, das Gruppentrennzeichen oder das Dezimaltrennzeichen), die in dürfen die `value` Parameter, damit der Analysevorgang erfolgreich ist. `styles` muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die `style` Parameter stellt diese Methode, die hilfreich beim Überladen `value` enthält die angegebene Zeichenfolgendarstellung eines Hexadezimalwerts, bei der Zahlensystems (dezimal oder hexadezimal) durch Darstellung `value` nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen nicht zulassen möchten, oder ein symbol, um im `value`.  
  
 Abhängig vom Wert `style`, `value` Parameter die folgenden Elemente enthalten:  
  
 [*ws*] [*$*] [*anmelden*] [*Ziffern*,]*Ziffern*[.* Bruchziffern*] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn `style` enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` Parameter kann die folgenden Elemente enthalten:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur. In der aktuellen Kultur Währungssymbol angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Folge von Ziffern von 0 bis 9. Für *Bruchziffern*, nur die Ziffer 0 gültig ist.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. In der aktuellen Kultur Gruppentrennzeichen angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. In der aktuellen Kultur Dezimaltrennzeichen angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag. Nur die Ziffer 0 darf als Nachkommastelle damit der Analysevorgang erfolgreich ist; Wenn *Bruchziffern* enthält eine andere Ziffer, einen <xref:System.FormatException> ausgelöst.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `value`.  
  
|`NumberStyles`-Wert|Elemente in zulässig `value` neben Ziffern|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (.) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, womit Exponentialschreibweise, zusammen mit *Exponenten-Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Group-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *anmelden* am Anfang des `value`, und dem Dezimaltrennzeichen an (*.*) Symbol. Die `value` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Gruppentrennzeichen (*,*), und ein Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Methode Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der von ausgegeben wurde der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> -Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Hingegen die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen könnten bei der Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Im Gegensatz zu den anderen <xref:System.Globalization.NumberStyles> Werte, die ermöglichen, ist jedoch nicht erforderlich, das Vorhandensein bestimmter Stilelemente in `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> Style-Wert bedeutet, dass die einzelnen Zeichen im `value` werden immer als interpretiert hexadezimalen Zeichen. Gültige Hexadezimalwerte Zeichen sind 0-9, A-F und a – f. Die einzigen anderen Flags, die mit kombiniert werden, können die `style` Parameter <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration umfasst einen zusammengesetzter Zahlenstil <xref:System.Globalization.NumberStyles.HexNumber>, die sowohl Leerraumzeichen-Flags enthält.)  
  
> [!NOTE]
>  Wenn `value` ist die Zeichenfolgendarstellung des eine hexadezimale Zahl ist, es kann nicht vorangestellt werden Dekoration (z. B. `0x` oder `&h`) unterscheidet, die sie als hexadezimale Zahl. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -Methode interpretiert `value` als eine negative Zahl, die von zwei der Ergänzung Darstellung verwenden, wenn die ersten zwei hexadezimalen Zeichen größer als oder gleich sind gespeicherte `0x80`. Das heißt, die Methode das höchstwertige Bit des ersten Bytes in interpretiert `value` als Vorzeichenbit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß, als eine positive Zahl ist, in der ersten Ziffer interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie ein negativer Wert, sondern interpretiert entweder `0x080` oder `0x0080` als positiver Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen den hexadezimalen Zeichenfolgen, die negativen und positiven Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das für die aktuelle Systemkultur initialisiert wird. Rufen Sie zum Angeben der Kultur, deren Formatierungsinformationen, damit der Analysevorgang verwendet wird, der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> überladen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -Methode mit mehreren möglichen Werte für die `style` Parameter. Es wird veranschaulicht, wie eine Zeichenfolge als Hexadezimalwert interpretiert werden soll, und das unterbinden Leerzeichen und Symbole anmelden.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> folgt nicht dem mit <see cref="T:System.Globalization.NumberStyles" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>value</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen kulturspezifischen Format in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `value` Parameter muss die angegebene Zeichenfolgendarstellung einer Zahl in der folgenden Form sein:  
  
 [*ws*] [*anmelden*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Einem optionalen Vorzeichen. Gültige Zeichen für Vorzeichen hängen von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der <xref:System.Globalization.NumberFormatInfo> von zurückgegebene Objekt der `provider` des Objekts <xref:System.IFormatProvider.GetFormat%2A> Methode.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Der angegebenen Zeichenfolge das `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stil. Es kann keine Gruppentrennzeichen oder die Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
> [!IMPORTANT]
>  Bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Methode Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der von ausgegeben wurde der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> -Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Hingegen die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen könnten bei der Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode wird aufgerufen, ruft es die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Der <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen über das Format der `value` Parameter. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter, um die benutzerdefinierte Formatierung Informationen, die der Analysevorgang angeben:  
  
-   Sie können übergeben eine <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können die tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der `value` interpretiert basierend auf den <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
   
  
## Examples  
 Die folgenden Beispiele zeigen zwei Möglichkeiten, definieren die Tilde (~) als negativen Vorzeichen für die Formatierung <xref:System.Numerics.BigInteger> Werte. Beachten Sie, dass Sie zum Anzeigen der <xref:System.Numerics.BigInteger> muss Werte im gleichen Format wie die ursprünglichen Zeichenfolgen, Ihren Code Aufrufen der <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> Methode und übergeben sie die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Im erste Beispiel definiert eine Klasse, die implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.IFormatProvider.GetFormat%2A> -Methode zur Rückgabe der <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Ein <xref:System.Numerics.BigInteger> Objekt kann dann durch den folgenden Code instanziiert werden:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Im zweite Beispiel ist einfacher. Sie übergibt den <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen liefert an die `provider` Parameter.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <c>value</c> angeben.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>value</c> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `style` Parameter definiert die Stilelemente (z.B. Leerzeichen, das positives oder negatives Vorzeichen-Symbol, das Gruppentrennzeichen oder das Dezimaltrennzeichen), die in dürfen die `value` Parameter, damit der Analysevorgang erfolgreich ist. `styles` muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Die `style` Parameter stellt diese Methode, die hilfreich beim Überladen `value` enthält die angegebene Zeichenfolgendarstellung eines Hexadezimalwerts, bei der Zahlensystems (dezimal oder hexadezimal) durch Darstellung `value` nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen nicht zulassen möchten, oder ein symbol, um im `value`.  
  
 Abhängig vom Wert `style`, `value` Parameter die folgenden Elemente enthalten:  
  
 [*ws*] [*$*] [*anmelden*] [*Ziffern*,]*Ziffern*[*. Bruchziffern*] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn `style` enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, `value` Parameter die folgenden Elemente enthalten:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der Kultur angegeben, durch die `provider` Parameter. In der aktuellen Kultur Währungssymbol angezeigt werden kann `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Folge von Ziffern von 0 bis 9. Für *Bruchziffern*, nur die Ziffer 0 gültig ist.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. Das Gruppentrennzeichen von der durch den angegebenen Kultur `provider` stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen von der Kultur, die vom angegebenen `provider` stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag. Nur die Ziffer 0 darf als Nachkommastelle damit der Analysevorgang erfolgreich ist; Wenn *Bruchziffern* enthält eine andere Ziffer, einen <xref:System.FormatException> ausgelöst.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit der nur Ziffern (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch sind nicht erforderlich, in der Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `value`.  
  
|NumberStyles-Wert|Elemente in den Wert neben Ziffern zulässig sind|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Die *Ziffern* nur-Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (.) und *Bruchziffern* Elemente.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, das Exponentialschreibweise angibt. zusammen mit *Exponenten-Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Group-Trennzeichen-Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Element, Currency ($).|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *anmelden* am Anfang des `value`, und das Dezimaltrennzeichen (.). Die `value` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`, `sign`, Gruppentrennzeichen (,) und Dezimaltrennzeichen (.) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Methode Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der von ausgegeben wurde der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> -Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Hingegen die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen könnten bei der Verwendung der <xref:System.Numerics.BigInteger.Parse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Im Gegensatz zu den anderen <xref:System.Globalization.NumberStyles> Werte, die ermöglichen, benötigen aber nicht das Vorhandensein bestimmter Stilelemente in `value`, <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> Style-Wert bedeutet, dass die einzelnen Zeichen im `value` werden immer als interpretiert hexadezimalen Zeichen. Gültige Hexadezimalwerte Zeichen sind 0-9, A-F und a – f. Die einzigen anderen Flags, die mit kombiniert werden, können die `style` Parameter <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration umfasst einen zusammengesetzter Zahlenstil <xref:System.Globalization.NumberStyles.HexNumber>, die sowohl Leerraumzeichen-Flags enthält.)  
  
> [!NOTE]
>  Wenn `value` ist die Zeichenfolgendarstellung des eine hexadezimale Zahl ist, es kann nicht vorangestellt werden Dekoration (z. B. `0x` oder `&h`) unterscheidet, die sie als hexadezimale Zahl. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -Methode interpretiert `value` als eine negative Zahl, die von zwei der Ergänzung Darstellung verwenden, wenn die ersten zwei hexadezimalen Zeichen größer als oder gleich sind gespeicherte `0x80`. Das heißt, die Methode das höchstwertige Bit des ersten Bytes in interpretiert `value` als Vorzeichenbit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß, als eine positive Zahl ist, in der ersten Ziffer interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie ein negativer Wert, sondern interpretiert entweder `0x080` oder `0x0080` als positiver Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen den hexadezimalen Zeichenfolgen, die negativen und positiven Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. In der Regel `provider` kann einer der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider> und verwendet die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> Methode zum Instanziieren und Zurückgeben der <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird mehrere Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode, die mit verschiedenen Kombinationen von Werten für die `style` und `provider` Parameter.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Eine Anzahl von einzelnen Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Methode übergeben Sie eine Instanz der folgenden `BigIntegerFormatProvider` -Klasse, die eine Tilde (~) als das negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException">
          <paramref name="value" /> folgt nicht dem mit <paramref name="style" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <c>exponent</c> Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <c>value</c> potenziert werden soll.</param>
        <summary>Potenziert einen <see cref="T:System.Numerics.BigInteger" />-Wert mit einem angegebenen Wert.</summary>
        <returns>Das Ergebnis der Potenzierung von <paramref name="value" /> mit <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Pow%2A> -Methode gibt 1 zurück, wenn der Wert des Parameters Exponent 0 ist oder wenn die Werte von der `value` und `exponent` Parameter 0 sind. Wenn `exponent` 1 ist, die <xref:System.Numerics.BigInteger.Pow%2A> Methodenrückgabe `value`. Wenn `value` ist negativ ist, gibt die Methode ein negatives Ergebnis.  
  
 Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die Verwendung der Potenzierung einer <xref:System.Numerics.BigInteger> Wert und einen Exponenten, dessen Wert von 0 bis 10 reicht.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Wert des <paramref name="exponent" />-Parameters ist negativ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Führt die Ganzzahldivision von zwei <see cref="T:System.Numerics.BigInteger" />-Werten aus und gibt den Rest zurück.</summary>
        <returns>Der Rest aus der Division von <paramref name="dividend" /> durch <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Vorzeichen des Restes werden das Vorzeichen der `dividend` Parameter.  
  
 Die <xref:System.Numerics.BigInteger.Remainder%2A> Methode wird implementiert, für die Sprachen, die benutzerdefinierte Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Division der Modulo-Operator verwenden.  
  
 Bei Bedarf die Methode automatisch implizite Konvertierung von anderen ganzzahligen Typen auf <xref:System.Numerics.BigInteger> Objekte, bevor der Modulo-Vorgang ausgeführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird den Rest aus der <xref:System.Numerics.BigInteger.DivRem%2A> -Methode mit den vom Rest der <xref:System.Numerics.BigInteger.Remainder%2A> Methode, um festzulegen, dass die beiden Methoden einen identischen Rest berechnen.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException">
          <paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zahl ab, die das Vorzeichen (negativ, positiv, oder 0 (null)) des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts angibt.</summary>
        <value>Eine Zahl, die das Vorzeichen des <see cref="T:System.Numerics.BigInteger" />-Objekts angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Anzahl 
 </term><description> Beschreibung  
 </description></listheader><item><term> -1 
 </term><description> Der Wert dieses Objekts ist negativ.  
  
 </description></item><item><term> 0 
 </term><description> Der Wert dieses Objekts ist null (0).  
  
 </description></item><item><term> 1 
 </term><description> Der Wert dieses Objekts ist positiv.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Sign%2A> Eigenschaft entspricht der <xref:System.Math.Sign%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen und gibt das Ergebnis zurück.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die keine benutzerdefinierte Operatoren unterstützen können die <xref:System.Numerics.BigInteger.Subtract%2A> Methode zum Durchführen der Subtraktion mit <xref:System.Numerics.BigInteger> Werte.  
  
 Die <xref:System.Numerics.BigInteger.Subtract%2A> Methode ist ein geeigneter Ersatz für den Subtraktionsoperator, bei der Instanziierung einer <xref:System.Numerics.BigInteger> Variable, indem sie den Unterschied aus der Subtraktion, zuweisen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert einen <see cref="T:System.Numerics.BigInteger" />-Wert in ein Bytearray.</summary>
        <returns>Der Wert des aktuellen, in ein Bytearray konvertierten <see cref="T:System.Numerics.BigInteger" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im Array zurückgegeben, die von dieser Methode werden in little-Endian-Reihenfolge angezeigt. Die niederwertigen Bytes des Wertes vorausgehen, also die höherwertigen Bytes. Das erste Byte des Arrays gibt die ersten acht Bits die <xref:System.Numerics.BigInteger> das zweite Byte-Wert gibt den nächsten acht Bits und So weiter. Beispielsweise wird der Wert von 1024 oder 0 x 0400, wie das folgende Array von zwei Bytes gespeichert:  
  
|Element|Byte-Wert|  
|-------------|----------------|  
|0|0 x 00|  
|1|0x04|  
  
 Negative Werte werden in das Array mit zwei der Ergänzung Ihrer Darstellung in die kompakteste Form möglichen geschrieben. -1 wird beispielsweise als ein einzelnes Byte, dessen Wert, dargestellt `0xFF` statt als ein Array mit mehreren Elementen, z. B. `0xFF`, `0xFF` oder `0xFF`, `0xFF`, `0xFF`, `0xFF`.  
  
 Da Darstellung immer Zweierkomplement interpretiert das höchstwertige Bit der das letzte Byte im Array (das Byte, ab Position <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) als Vorzeichenbit, gibt die Methode ein Bytearray mit der ein zusätzliches Element, dessen Wert 0 (null ist) zurück, mit denen auf unterscheiden Sie positive Werte, die andernfalls interpretiert werden konnte, als trügen ihre Anmelde-Bits festgelegt. Z. B. den Wert 120 oder `0x78` wird als Single-Byte-Array dargestellt: `0x78`. Jedoch 128 oder `0x80`, wird als ein 2-Byte-Array dargestellt: `0x80`, `0x00`.  
  
 Sie können einen Roundtrip eine <xref:System.Numerics.BigInteger> Wert durch die Speicherung in ein Bytearray aus, und klicken Sie dann wiederherstellen mithilfe der <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor.  
  
> [!CAUTION]
>  Wenn Ihr Code den Wert der einzelnen Bytes im Array ändert, von dieser Methode zurückgegeben wird, bevor sie den Wert wiederhergestellt wird, müssen Sie sicherstellen, dass nicht versehentlich das signierte Bit zu ändern. Werden z. B. wenn die Änderungen einen positiven Wert erhöhen, sodass der höchsten Priorität in das letzte Element des Bytearrays bit festgelegt ist, wird Sie einen neuen Byte hinzufügen können, deren Wert 0 (null) bis zum Ende des Arrays ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie bestimmte <xref:System.Numerics.BigInteger> Werte werden in Bytearrays dargestellt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in der "R", oder führen Sie einen Roundtrip, Format der aktuellen Kultur. Wenn Sie ein anderes Format oder die Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert enthält ein negativen Vorzeichen, wenn der Wert negativ ist, und einer Folge von Ziffern zwischen 0 und 9 ohne führende Nullen. Die Minuszeichen werden definiert, indem die <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine <xref:System.Numerics.BigInteger> Wert unter Verwendung des standardmäßigen <xref:System.Numerics.BigInteger.ToString> Methode. Es zeigt auch die zeichenfolgendarstellungen der <xref:System.Numerics.BigInteger> -Wert, der aus der Verwendung von einigen Standardformatbezeichnern ergibt. In den Beispielen werden die Verwendung der Formatierungskonventionen der Kultur En-US angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Methode Formate eine <xref:System.Numerics.BigInteger> Wert in der "R", oder führen Sie einen Roundtrip, formatieren Sie mithilfe der <xref:System.Globalization.NumberFormatInfo> Objekt der angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebene Zeichenfolge enthält. Wenn `provider` ist `null`, <xref:System.Numerics.BigInteger> Wert formatiert wird, mit der <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur. Die einzige Eigenschaft, der die <xref:System.Globalization.NumberFormatInfo> -Objekt, das steuert, die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert mit dem allgemeinen Formatbezeichner <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, der definiert, dass des Zeichens, die die negativen Vorzeichen darstellt.  
  
 Die `provider` Parameter kann einen der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt.  
  
-   Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
   
  
## Examples  
 Das folgende Beispiel instanziiert ein benutzerdefiniertes <xref:System.Globalization.NumberFormatInfo> -Objekt, das die Tilde (~) als negativen Vorzeichen definiert. Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> Methode dann mithilfe des benutzerdefinierten <xref:System.Globalization.NumberFormatInfo> Objekt einen negativen <xref:System.Numerics.BigInteger> Wert.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="format" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%29> Methode Formate eine <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format mithilfe einer <xref:System.Globalization.NumberFormatInfo> Objekt, das die Konventionen der aktuellen Kultur darstellt. Wenn Sie die "R", oder führen Sie einen Roundtrip verwenden möchten, formatieren oder geben Sie eine andere Kultur, verwenden Sie die anderen Überladungen von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString>|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die `format` Parameter kann eine beliebige gültige sein [numerische Standardzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), oder eine beliebige Kombination von [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, den Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekt mit dem Schleifenformatbezeichner ("R") formatiert ist. Wenn `format` jeder andere Wert ist, löst die Methode eine <xref:System.FormatException>.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Unterstützung für die Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Das Format der zurückgegebenen Zeichenfolge richtet sich nach der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Je nachdem auf die `format` -Parameter dieses Objekts steuert, Symbole, z. B. das negativen Vorzeichen, die das Gruppentrennzeichen und das Dezimaltrennzeichen in der Ausgabezeichenfolge. Aufrufen, um Formatierungsinformationen für Kulturen als der aktuellen Kultur zu ermöglichen, die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> überladen.  
  
   
  
## Examples  
 Im folgenden Beispiel initialisiert einen <xref:System.Numerics.BigInteger> Wert und mit jeder Standardformatzeichenfolge und einigen benutzerdefinierten Formatzeichenfolgen angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats und der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts entsprechend den Angaben in den Parametern <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Methode Formate eine <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format mithilfe der <xref:System.Globalization.NumberFormatInfo> Objekt der angegebenen Kultur. Wenn Sie die Roundtrip-Format oder die standardkultureinstellungen verwenden möchten, verwenden Sie alle anderen Überladungen der der <xref:System.Numerics.BigInteger.ToString%2A> -Methode wie folgt:  
  
|Format verwenden|Für die Kultur|Verwenden Sie die Überladung|  
|-------------------|-----------------|----------------------|  
|Round-Trip ("R")-format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString>|  
|Round-Trip ("R")-format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Einem bestimmten format|(Aktueller) Standardkultur|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Die `format` Parameter kann eine beliebige gültige sein [numerische Standardzeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md), oder eine beliebige Kombination von [benutzerdefinierte numerische Formatzeichenfolgen](~/docs/standard/base-types/custom-numeric-format-strings.md). Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, den Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekt mit dem Schleifenformatbezeichner ("R") formatiert ist. Wenn `format` jeder andere Wert ist, löst die Methode eine <xref:System.FormatException>.  
  
 .NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen zur Formatierung ausführlicher beschrieben wird:  
  
-   Weitere Informationen über numerische Formatbezeichner finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).  
  
-   Weitere Informationen zur Unterstützung für die Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebene Zeichenfolge enthält. Wenn die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode wird aufgerufen, ruft es die `provider` des Parameters <xref:System.IFormatProvider.GetFormat%2A> Methode und übergibt sie ein <xref:System.Type> Objekt, das darstellt der <xref:System.Globalization.NumberFormatInfo> Typ. Die <xref:System.IFormatProvider.GetFormat%2A> Methodenrückgabe klicken Sie dann die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Informationen zum Formatieren von bietet die `value` Parameter, wie z. B. das negative Vorzeichen-Symbol, das Gruppentrennzeichen und das Dezimaltrennzeichen. Es gibt drei Möglichkeiten zum Verwenden der `provider` Parameter, um Formatierungsinformationen zum Angeben der <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Methode:  
  
-   Sie können übergeben eine <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Sie können die tatsächlichen übergeben <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Sie können ein benutzerdefiniertes Objekt, das implementiert übergeben <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, die Formatierung der zurückgegebenen Zeichenfolge basiert auf der <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel initialisiert einen <xref:System.Numerics.BigInteger> Wert und zeigt sie an die Konsole, die eine Standardformatzeichenfolge verwenden und ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das die Tilde (~) als negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException">
          <paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <c>value</c> oder null (0), wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <c>value</c>-Parameter <see langword="null" /> ist oder nicht im korrekten Format vorliegt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns>
          <see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Methode entspricht der <xref:System.Numerics.BigInteger.Parse%28System.String%29> -Methode, mit dem Unterschied, dass die It keine Ausnahme auslöst, wenn die Konvertierung schlägt fehl. Diese Methode entfällt die Notwendigkeit, die Ausnahmebehandlung zu verwenden, um das Testen einer <xref:System.FormatException> Wenn `value` ist ungültig und kann nicht erfolgreich analysiert werden kann.  
  
 Die `value` Parameter sollte die Zeichenfolgendarstellung einer ganzen Zahl in der folgenden Form sein:  
  
 [*ws*] [*anmelden*]*Ziffern*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen.|  
|*sign*|Einem optionalen Vorzeichen. Gültige Zeichen für Vorzeichen hängen von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaften der aktuellen Kultur.|  
|*Ziffern*|Eine Sequenz von Dezimalziffern, die im Bereich von 0 bis 9.|  
  
> [!NOTE]
>  Die Zeichenfolge, die gemäß der `value` Parameter darf nicht keine Gruppentrennzeichen oder ein Dezimaltrennzeichen enthalten, und es sind keine Dezimalstellen.  
  
 Die `value` Parameter wird interpretiert, mit der <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stil. Neben der Dezimalstelle dürfen nur führende und nachfolgende Leerzeichen mit einem vorangestellten Plus-oder Minuszeichen. Die Stilelemente mit der kulturspezifischen Formatierungsinformationen explizit zu definieren, die in vorhanden sein können `value`, rufen Sie die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode.  
  
 Die `value` Parameter analysiert wird, mithilfe den Formatierungsinformationen in eine <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Diese Überladung interpretiert alle Ziffern in der `value` Parameter als Dezimalzahlen. Um die angegebene Zeichenfolgendarstellung einer Hexadezimalzahl analysieren möchten, rufen Sie die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> stattdessen die Überladung.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> Methode zum Instanziieren zweier <xref:System.Numerics.BigInteger> Objekte. Wenn die Konvertierung erfolgreich ausgeführt werden, jedes Objekt mit einer anderen Zahl multipliziert und ruft dann die <xref:System.Numerics.BigInteger.Compare%2A> Methode, um die Beziehung zwischen den beiden Objekten zu bestimmen.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl. Die Zeichenfolge wird unter Verwendung des durch <c>style</c> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angibt, die in <c>value</c> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <c>value</c> bereitstellt.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <c>value</c> oder <see cref="P:System.Numerics.BigInteger.Zero" />, wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <c>value</c>-Parameter gleich <see langword="null" /> ist oder nicht in einem Format vorliegt, das mit <c>style</c> kompatibel ist. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturspezifischen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" /> und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich abgeschlossen wurde.</summary>
        <returns>
          <see langword="true" />, wenn der <paramref name="value" />-Parameter erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode entspricht der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> -Methode, mit dem Unterschied, dass die It keine Ausnahme auslöst, wenn die Konvertierung schlägt fehl. Diese Methode entfällt die Notwendigkeit, die Ausnahmebehandlung zu verwenden, um das Testen einer <xref:System.FormatException> Wenn `value` ist ungültig und kann nicht erfolgreich analysiert werden.  
  
 Die `style` Parameter definiert die Stilelemente (z.B. Leerzeichen oder ein positiven oder negativen Vorzeichen), die in dürfen die `value` Parameter, damit der Analysevorgang erfolgreich ist. Es muss eine Kombination von Bitflags aus den <xref:System.Globalization.NumberStyles> Enumeration. Abhängig vom Wert `style`, `value` Parameter die folgenden Elemente enthalten:  
  
 [*ws*] [*$*] [*anmelden*] [*Ziffern*,]*Ziffern*[.* Bruchziffern*] [E [*anmelden*]*Exponenten-Ziffern*] [*ws*]  
  
 Wenn die `style` Parameter enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier>, `value` Parameter die folgenden Elemente enthalten:  
  
 [*ws*]*Hexdigits*[*ws*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung |  
|-------------|-----------------|  
|*ws*|Optionalen Leerzeichen. Leerzeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> Flag oder am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> Flag.|  
|*$*|Eine kulturspezifische Währungssymbol. Seine Position in der Zeichenfolge wird definiert, durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> Eigenschaft der <xref:System.Globalization.NumberFormatInfo> zurückgegebenes Objekt der <xref:System.IFormatProvider.GetFormat%2A> -Methode der der `provider` Parameter. Das Währungssymbol angezeigt werden kann, im `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> Flag.|  
|*sign*|Einem optionalen Vorzeichen. Die Zeichen am Anfang stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> Flag, und es können angezeigt werden, am Ende der `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> Flag. Klammern können verwendet werden, `value` um einen negativen Wert anzugeben, ob `style` enthält die <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> Flag.|  
|*Ziffern*|Eine Folge von Ziffern von 0 bis 9.|  
|*,*|Eine kulturspezifische Gruppentrennzeichen. Das Gruppentrennzeichen von der durch den angegebenen Kultur `provider` stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> Flag.|  
|*.*|Eine kulturspezifische Dezimaltrennzeichen. Das Dezimaltrennzeichen von der durch den angegebenen Kultur `provider` stehen `value` Wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|*fractional_digits*|Ein oder mehrere Vorkommen der Ziffer 0. Bruchziffern können angezeigt werden, `value` nur, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> Flag.|  
|E|Das "e" oder "E"-Zeichen, die angibt, dass der Wert in Exponentialschreibweise (wissenschaftlich) dargestellt wird. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*exponential_digits*|Eine Folge von Ziffern von 0 bis 9. Die `value` Parameter kann eine Zahl in Exponentialschreibweise darstellen, wenn `style` enthält die <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> Flag.|  
|*hexdigits*|Eine Sequenz von hexadezimalen Ziffern von 0 bis f oder 0 bis F.|  
  
> [!NOTE]
> Alle abschließenden NULL (U + 0000)-Zeichen im `s` werden ignoriert, durch den Analysevorgang, unabhängig vom Wert für die `style` Argument.

 Eine Zeichenfolge mit nur Dezimalstellen (Dies entspricht der <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Flag) immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden, jedoch müssen nicht in dieser Eingabezeichenfolge vorhanden sein. Die folgende Tabelle gibt an, wie einzelne <xref:System.Globalization.NumberStyles> Mitglieder Auswirkungen auf die Elemente, die ggf. im `value`.  
  
|Nicht zusammengesetzte `NumberStyles` Werte|Elemente in den Wert neben Ziffern zulässig sind|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Das Dezimaltrennzeichen (*.*) und *Bruchziffern* Elemente. Allerdings *Bruchziffern* müssen bestehen aus nur einer oder mehreren 0-Ziffern oder der Rückgabe der Methode `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das "e" oder "E"-Zeichen, womit Exponentialschreibweise, zusammen mit *Exponenten-Ziffern*. Wenn `value` steht für eine Zahl in Exponentialschreibweise, er darf keine Komponente nicht 0 (null) werden die Dezimalstellen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Die *ws* Element am Anfang des `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Die *ws* Element am Ende der `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Die *anmelden* vor Element *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Die *anmelden* Element an, nach *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Die *anmelden* Element in Form von Klammern, die den numerischen Wert einschließen.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppentrennzeichen (*,*) Element.|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Die Währung (*$*) Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle Elemente. Allerdings `value` keine hexadezimale Zahl oder eine Zahl in Exponentialschreibweise darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Die *ws* Element am Anfang oder Ende des `value`, *anmelden* am Anfang des `value`, und dem Dezimaltrennzeichen an (*.*) Symbol. Die `value` Parameter können Sie auch Exponentialschreibweise.|  
|<xref:System.Globalization.NumberStyles.Number>|Die *ws*, *anmelden*, Gruppentrennzeichen (*,*), und ein Dezimaltrennzeichen (*.*) Elemente.|  
|<xref:System.Globalization.NumberStyles.Any>|Alle Elemente. Allerdings `value` eine hexadezimale Zahl nicht darstellen kann.|  
  
> [!IMPORTANT]
>  Bei Verwendung der <xref:System.Numerics.BigInteger.TryParse%2A> Methode Roundtrip eine Zeichenfolgendarstellung des eine <xref:System.Numerics.BigInteger> -Wert, der von ausgegeben wurde der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, die Sie verwenden sollten die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> -Methode mit dem Formatbezeichner "R" zum Generieren der Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> Wert. Hingegen die Zeichenfolgendarstellung der <xref:System.Numerics.BigInteger> behält nur die 50 signifikantesten Ziffern des ursprünglichen Wert ein, und Daten verloren gehen könnten bei der Verwendung der <xref:System.Numerics.BigInteger.TryParse%2A> Verfahren zum Wiederherstellen der <xref:System.Numerics.BigInteger> Wert.  
  
 Wenn die <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> -Flag wird verwendet, `value` muss ein hexadezimaler Wert sein. Die einzigen anderen Flags, die in vorhanden sein können `style` sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> Enumeration verfügt über ein zusammengesetztes Format, <xref:System.Globalization.NumberStyles.HexNumber>, die sowohl Leerraumzeichen-Flags enthält.)  
  
> [!NOTE]
>  Wenn `value` ist die Zeichenfolgendarstellung des eine hexadezimale Zahl ist, es kann nicht vorangestellt werden Dekoration (z. B. `0x` oder `&h`) unterscheidet, die sie als hexadezimale Zahl. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` ist eine hexadezimale Zeichenfolge, die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> -Methode interpretiert `value` als eine negative Zahl, die von zwei der Ergänzung Darstellung verwenden, wenn die ersten zwei hexadezimalen Zeichen größer als oder gleich sind gespeicherte `0x80`. Das heißt, die Methode das höchstwertige Bit des ersten Bytes in interpretiert `value` als Vorzeichenbit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß, als eine positive Zahl ist, in der ersten Ziffer interpretiert wird `value` muss einen Wert von 0 (null) aufweisen. Die Methode z. B. interpretiert `0x80` wie ein negativer Wert, sondern interpretiert entweder `0x080` oder `0x0080` als positiver Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen den hexadezimalen Zeichenfolgen, die negativen und positiven Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> -Objekt, das kulturspezifische Informationen zum Format von bietet `value`. Die `provider` Parameter kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen für die jeweilige Kultur bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Eine Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgibt.)  
  
-   Ein benutzerdefiniertes Objekt, das implementiert <xref:System.IFormatProvider>. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode instanziiert und gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` ist `null`, <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die Aufrufe von der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode, die mit verschiedenen Kombinationen von Werten für die `style` und `provider` Parameter.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Eine Anzahl von einzelnen Aufrufe der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Methode übergeben Sie eine Instanz der folgenden `BigIntegerFormatProvider` -Klasse, die eine Tilde (~) als das negativen Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException">
          <paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder -  
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" />
        <Parameter Name="isUnsigned" Type="System.Boolean" />
        <Parameter Name="isBigEndian" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="bytesWritten">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl null (0) darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert 0 (null) ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger> von dieser Eigenschaft zurückgegebenen Objekts bietet eine praktische Quelle für ein NULL-Wert für die Verwendung in Zuweisungen und Vergleiche.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>