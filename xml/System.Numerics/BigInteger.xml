<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="e41cffa3a1b13a25652c91a03e7221646dfa1da1" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70525741" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine beliebig große ganze Zahl mit Vorzeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Numerics.BigInteger> Typ ist ein unveränderlicher Typ, der eine beliebig große ganze Zahl darstellt, deren Wert theoretisch keine oberen oder unteren Grenzen hat. <xref:System.Numerics.BigInteger> Die Member des Typs sind eng parallel zu den Membern anderer ganzzahliger Typen ( <xref:System.Int64>die <xref:System.SByte> <xref:System.Byte>Typen <xref:System.UInt16>, <xref:System.UInt32> <xref:System.Int16>, <xref:System.Int32>, <xref:System.UInt64> ,,,, und). Dieser Typ unterscheidet [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]sich von den anderen ganzzahligen Typen in, die über einen Bereich verfügen, der durch ihre `MinValue` -und- `MaxValue` Eigenschaften angegeben wird  
  
> [!NOTE]
>  Da der <xref:System.Numerics.BigInteger> Typ unveränderlich ist (siehe [muability und BigInteger-Struktur](#mutability)) und da er keine oberen oder unteren Grenzen aufweist, kann ein <xref:System.OutOfMemoryException> für jeden Vorgang ausgelöst werden, der bewirkt, <xref:System.Numerics.BigInteger> dass ein Wert zu groß wird.  
  
## <a name="instantiating-a-biginteger-object"></a>Instanziieren eines BigInteger-Objekts  
 Sie können ein <xref:System.Numerics.BigInteger> -Objekt auf verschiedene Weise instanziieren:  
  
-   Sie können das `new` Schlüsselwort verwenden und einen beliebigen ganzzahligen oder Gleit Komma Wert als Parameter für <xref:System.Numerics.BigInteger> den Konstruktor bereitstellen. (Gleit Komma Werte werden abgeschnitten, bevor Sie dem <xref:System.Numerics.BigInteger>zugewiesen werden.) Im folgenden Beispiel wird veranschaulicht, wie das `new` -Schlüsselwort verwendet wird <xref:System.Numerics.BigInteger> , um-Werte zu instanziieren.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Sie können eine <xref:System.Numerics.BigInteger> Variable deklarieren und ihr einen Wert zuweisen, wie es bei jedem beliebigen numerischen Typ der Fall ist, solange dieser Wert ein ganzzahliger Typ ist. Im folgenden Beispiel wird mithilfe der-Zuweisung <xref:System.Numerics.BigInteger> ein Wert aus <xref:System.Int64>einem erstellt.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Sie können einem- <xref:System.Numerics.BigInteger> Objekt einen Dezimal-oder Gleit Komma Wert zuweisen, wenn Sie den Wert umwandeln oder ihn zuerst konvertieren. Im folgenden Beispiel werden ( C#in) und (in Visual Basic) a <xref:System.Double> und ein <xref:System.Decimal> -Wert explizit in eine <xref:System.Numerics.BigInteger>umgewandelt.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Diese Methoden ermöglichen es Ihnen, ein <xref:System.Numerics.BigInteger> -Objekt zu instanziieren, dessen Wert nur im Bereich von einem der vorhandenen numerischen Typen liegt. Sie können ein <xref:System.Numerics.BigInteger> -Objekt instanziieren, dessen Wert den Bereich der vorhandenen numerischen Typen auf eine von drei Arten überschreiten kann:  
  
-   Sie können das `new` Schlüsselwort verwenden und ein Bytearray beliebiger Größe für <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType> den Konstruktor bereitstellen. Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Sie können die- <xref:System.Numerics.BigInteger.Parse%2A> Methode <xref:System.Numerics.BigInteger.TryParse%2A> oder die-Methode zum Konvertieren der Zeichen folgen Darstellung einer <xref:System.Numerics.BigInteger>Zahl in eine-Methode aufzurufen. Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Sie `static` können eine-Methode`Shared` (in Visual Basic <xref:System.Numerics.BigInteger> ) aufzurufen, die einen Vorgang für einen numerischen Ausdruck ausführt und <xref:System.Numerics.BigInteger> ein berechnetes Ergebnis zurückgibt. Im folgenden Beispiel wird dies durch das durch <xref:System.UInt64.MaxValue?displayProperty=nameWithType> führen von Cub und das <xref:System.Numerics.BigInteger>Zuweisen des Ergebnisses zu einem veranschaulicht.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Der nicht initialisierte Wert eines <xref:System.Numerics.BigInteger> ist. <xref:System.Numerics.BigInteger.Zero%2A>  
  
## <a name="performing-operations-on-biginteger-values"></a>Ausführen von Vorgängen für BigInteger-Werte  
 Sie können eine- <xref:System.Numerics.BigInteger> Instanz wie einen beliebigen anderen ganzzahligen Typ verwenden. <xref:System.Numerics.BigInteger>über lädt die standardmäßigen numerischen Operatoren, damit Sie grundlegende mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation, Subtraktion, Negation und unäre Negation durchführen können. Sie können auch die standardmäßigen numerischen Operatoren verwenden, <xref:System.Numerics.BigInteger> um zwei Werte miteinander zu vergleichen. Wie die anderen ganzzahligen <xref:System.Numerics.BigInteger> Typen unterstützt auch die bitweisen `Or` `And`Operatoren,, `XOr`, Left Shift und Right Shift. Für Sprachen, die keine benutzerdefinierten Operatoren unter <xref:System.Numerics.BigInteger> stützen, stellt die Struktur auch äquivalente Methoden zum Durchführen mathematischer Operationen bereit. Dazu zählen <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, und einige andere. <xref:System.Numerics.BigInteger.Subtract%2A>  
  
 Viele Member der <xref:System.Numerics.BigInteger> Struktur entsprechen direkt den Membern der anderen ganzzahligen Typen. Außerdem werden <xref:System.Numerics.BigInteger> von Member wie die folgenden hinzugefügt:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, die einen Wert zurückgibt, der das Vorzeichen eines <xref:System.Numerics.BigInteger> Werts angibt.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, die den absoluten Wert eines <xref:System.Numerics.BigInteger> -Werts zurückgibt.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, die den Quotienten und den Rest eines Divisions Vorgangs zurückgibt.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>Gibt den größten gemeinsamen Divisor von zwei <xref:System.Numerics.BigInteger> Werten zurück.  
  
 Viele dieser zusätzlichen Member entsprechen den Membern der <xref:System.Math> -Klasse, die die Funktionalität zum Arbeiten mit den primitiven numerischen Typen bereitstellt.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Muability und BigInteger-Struktur  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Objekt instanziiert und anschließend der Wert um eins erhöht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Obwohl in diesem Beispiel der Wert des vorhandenen Objekts geändert wird, ist dies nicht der Fall. <xref:System.Numerics.BigInteger>Objekte sind unveränderlich, d. h., der Common Language Runtime erstellt tatsächlich ein neues <xref:System.Numerics.BigInteger> -Objekt und weist ihm einen Wert zu, der größer als der vorherige Wert ist. Dieses neue Objekt wird dann an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Die anderen numerischen Typen in der .NET Framework sind ebenfalls unveränderlich. Da der <xref:System.Numerics.BigInteger> Typ jedoch keine oberen oder unteren Grenzen aufweist, können seine Werte sehr groß werden und eine messbare Auswirkung auf die Leistung haben.  
  
 Obwohl dieser Prozess für den Aufrufer transparent ist, wird eine Leistungs Einbuße verursacht. In einigen Fällen, insbesondere wenn wiederholte Vorgänge in einer Schleife für sehr große <xref:System.Numerics.BigInteger> Werte ausgeführt werden, kann diese Leistungs Einbuße erheblich sein. Beispielsweise wird im folgenden Beispiel ein Vorgang wiederholt bis zu einer Million Male durchgeführt, und ein <xref:System.Numerics.BigInteger> Wert wird bei jeder erfolgreichen Ausführung des Vorgangs um eins erhöht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In einem solchen Fall können Sie die Leistung verbessern, indem Sie alle zwischen Zuweisungen <xref:System.Int32> für eine Variable durchführen. Der endgültige Wert der Variablen kann dann dem <xref:System.Numerics.BigInteger> -Objekt zugewiesen werden, wenn die Schleife beendet wird. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Arbeiten mit Byte Arrays und hexadezimal Zeichenfolgen  
 Wenn Sie Werte <xref:System.Numerics.BigInteger> in Byte Arrays konvertieren oder Byte Arrays in-Werte konvertieren, <xref:System.Numerics.BigInteger> müssen Sie die Reihenfolge der Bytes in Erwägung gezogen. Die <xref:System.Numerics.BigInteger> -Struktur erwartet, dass die einzelnen Bytes in einem Bytearray in Little-Endian-Reihenfolge angezeigt werden (d. h., die niedrigeren Bytes des Werts vor den Bytes höherer Ordnung). Sie können einen Roundtrip für <xref:System.Numerics.BigInteger> einen Wert durchführen <xref:System.Numerics.BigInteger.ToByteArray%2A> , indem Sie die-Methode aufrufen und dann das <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> resultierende Bytearray an den-Konstruktor übergeben, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Zum Instanziieren eines <xref:System.Numerics.BigInteger> Werts aus einem Bytearray, das einen Wert eines anderen ganzzahligen Typs darstellt, können Sie den ganzzahligen Wert an die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode übergeben und dann das resultierende <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Bytearray an den-Konstruktor übergeben. Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Wert aus einem Bytearray instanziiert, der einen <xref:System.Int16> -Wert darstellt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger> -Struktur geht davon aus, dass negative Werte mithilfe der Komplement-Darstellung von zwei gespeichert werden. Da die <xref:System.Numerics.BigInteger> -Struktur einen numerischen Wert ohne festes Länge darstellt, interpretiert <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> der Konstruktor immer das signifikanteste Bit des letzten Bytes im Array als Signier Bit. , Um zu <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> verhindern, dass der Konstruktor die zwei Komplement Darstellung eines negativen Werts mit der Vorzeichen-und Größen Darstellung eines positiven Werts verwechselt, positive Werte, in denen das signifikanteste Bit des letzten Bytes im Bytearray ist. wäre normalerweise festgelegt, sollte ein zusätzliches Byte enthalten, dessen Wert 0 ist. Beispielsweise ist 0xC0 0xbd 0xF 0xFF die Little-de-hexadezimale Darstellung von-1 Million oder 4.293.967.296. Da das signifikanteste Bit des letzten Bytes in diesem Array on ist, wird der Wert des Bytearrays vom <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktor als-1 Million interpretiert. Um einen <xref:System.Numerics.BigInteger> zu instanziieren, dessen Wert positiv ist, muss ein Bytearray, dessen Elemente 0xC0 0xbd 0xF0 0xFF 0x00 lauten, an den-Konstruktor übergeben werden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Byte Arrays, die von <xref:System.Numerics.BigInteger.ToByteArray%2A> der-Methode aus positiven Werten erstellt werden, enthalten dieses zusätzliche Byte mit 0 (null). Aus diesem Grund <xref:System.Numerics.BigInteger> kann die-Struktur erfolgreich Roundtrip-Werte durch Zuweisen der Werte und deren Wiederherstellung in Byte Arrays erreichen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Sie müssen jedoch möglicherweise dieses zusätzliche NULL-Wert-Byte zu Byte Arrays hinzufügen, die dynamisch vom Entwickler erstellt werden oder von Methoden zurückgegeben werden, die ganze Zahlen ohne Vorzeichen in Byte Arrays konvertieren ( <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>z <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>. b <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>., und).  
  
 Bei der Verarbeitung einer hexadezimalen Zeichenfolge <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType> wird <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> von der-Methode und der-Methode angenommen, dass, wenn das signifikanteste Bit des ersten Bytes in der Zeichenfolge festgelegt ist oder die erste hexadezimal Ziffer der Zeichenfolge die unteren vier Bits eines Bytewerts darstellt, der Wert lautet. wird mithilfe der Komplement-Darstellung von zwei dargestellt. Beispielsweise stellen sowohl "FF01" als auch "F01" den Dezimalwert-255 dar. Positive Werte sollten eine führende Null enthalten, um positiv von negativen Werten zu unterscheiden. Die relevanten über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A> -Methode, wenn Sie der Format Zeichenfolge "X" übertragen werden, fügen der zurückgegebenen hexadezimal Zeichenfolge für positive Werte eine führende Null hinzu. Dies ermöglicht das Roundtrip <xref:System.Numerics.BigInteger> von Werten mithilfe der-Methode und <xref:System.Numerics.BigInteger.ToString%2A> <xref:System.Numerics.BigInteger.Parse%2A> der-Methode, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Die hexadezimal Zeichenfolgen, die durch `ToString` den Aufruf der Methoden der anderen ganzzahligen Typen oder der <xref:System.Convert.ToString%2A> über Ladungen der- `toBase` Methode erstellt werden, die einen-Parameter enthalten, geben jedoch nicht das Vorzeichen des Werts oder des Quell Datentyps an, aus dem die hexadezimale Zeichenfolge wurde abgeleitet. Das Instanziieren eines <xref:System.Numerics.BigInteger> Werts aus einer solchen Zeichenfolge erfordert einige zusätzliche Logik. Im folgenden Beispiel wird eine mögliche Implementierung bereitstellt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array der Bytewerte in Little-Endian-Reihenfolge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung der Werte in einem Bytearray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im `value` Array sollten in Little-Endian-Reihenfolge, vom Byte der untersten Reihenfolge bis zum Byte der höchsten Reihenfolge sein. Beispielsweise wird der numerische Wert 1 Billion dargestellt, wie in der folgenden Tabelle dargestellt:  
  
|||  
|-|-|  
|Hexadezimale Zeichenfolge|E8D4A51000|  
|Bytearray (der niedrigste Index zuerst)|00 10 A5 D4 E8 00|  
  
 Die meisten Methoden, die numerische Werte in Byte Arrays konvertieren, <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> wie <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>z. b. und, geben Byte Arrays in Little-Endian-Reihenfolge zurück.  
  
 Der Konstruktor erwartet positive Werte im Bytearray, um die Darstellung der Signierung zu verwenden, und negative Werte, um die zwei Komplement Darstellung zu verwenden. Anders ausgedrückt: Wenn das oberste Bit des Byte `value` der höchsten Reihenfolge festgelegt wird, ist der resultierende <xref:System.Numerics.BigInteger> Wert negativ. Abhängig von der Quelle des Bytearrays kann dies dazu führen, dass ein positiver Wert als negativer Wert fehlinterpretiert wird. Byte Arrays werden in der Regel auf folgende Weise generiert:  
  
-   Durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> -Methode. Da diese Methode ein Bytearray zurückgibt, bei dem das Bit der höchsten Reihenfolge im Array für positive Werte auf 0 (null) festgelegt ist, besteht keine Gefahr, dass ein positiver Wert als negativ interpretiert wird. Nicht geänderte Byte Arrays, die von <xref:System.Numerics.BigInteger.ToByteArray%2A> der-Methode erstellt werden, werden immer erfolgreich ausgeführt, wenn <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Sie an den-Konstruktor übergeben werden.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und übergeben einer Ganzzahl mit Vorzeichen als Parameter. Da ganze Zahlen mit Vorzeichen sowohl die Darstellung von Vorzeichen als auch die Größe und die Komplement Darstellung von zwei verarbeiten, besteht keine Gefahr, dass ein positiver Wert als negativ interpretiert wird.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType> -Methode und übergeben einer Ganzzahl ohne Vorzeichen als Parameter. Da ganze Zahlen ohne Vorzeichen nur durch ihre Größe dargestellt werden, können positive Werte als negative Werte interpretiert werden. Um diese Fehlinterpretation zu verhindern, können Sie am Ende des Arrays einen 0-Byte-Wert hinzufügen. Das Beispiel im nächsten Abschnitt enthält eine Abbildung.  
  
-   Durch das Erstellen eines Bytearrays entweder dynamisch oder statisch, ohne dass notwendigerweise eine der vorherigen Methoden aufgerufen wird, oder durch Ändern eines vorhandenen Bytearrays. Um zu verhindern, dass positive Werte als negative Werte interpretiert werden, können Sie am Ende des Arrays einen 0-Byte-Wert hinzufügen.  
  
 Wenn `value` ein leeres <xref:System.Byte> Array ist, wird das <xref:System.Numerics.BigInteger> neue-Objekt mit einem Wert von <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>initialisiert. Wenn `value` <xref:System.ArgumentNullException>ist `null`, löst der Konstruktor eine aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Objekt aus einem Bytearray mit fünf Elementen instanziiert, dessen Wert {5, 4, 3, 2, 1} ist. Anschließend wird der Wert <xref:System.Numerics.BigInteger> , der als Dezimal-und hexadezimal Zahl dargestellt wird, in der Konsole angezeigt. Durch einen Vergleich des Eingabe Arrays mit der Textausgabe wird klar, warum diese Überladung des <xref:System.Numerics.BigInteger> Klassenkonstruktors ein <xref:System.Numerics.BigInteger> -Objekt erstellt, dessen Wert 4328719365 (oder 0x102030405) ist. Das erste Element des Bytearrays, dessen Wert 5 ist, definiert den Wert des Werts der niedrigsten Reihenfolge des <xref:System.Numerics.BigInteger> Objekts, das 0x05 ist. Das zweite Element des Bytearrays, dessen Wert 4 ist, definiert den Wert des zweiten Bytes des <xref:System.Numerics.BigInteger> -Objekts, das 0x04 ist, usw.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Das folgende Beispiel instanziiert einen positiven und einen negativen <xref:System.Numerics.BigInteger> Wert, übergibt sie an die <xref:System.Numerics.BigInteger.ToByteArray%2A> -Methode und stellt dann die ursprünglichen <xref:System.Numerics.BigInteger> Werte aus dem resultierenden Bytearray wieder her. Beachten Sie, dass die beiden Werte durch identische Byte Arrays dargestellt werden. Der einzige Unterschied besteht darin, dass das wichtigste Bit des letzten Elements im Bytearray ist. Dieses Bit ist festgelegt (der Wert des Bytes ist 0xFF), wenn das Array aus einem negativen <xref:System.Numerics.BigInteger> Wert erstellt wird. Das-Bit ist nicht festgelegt (der Wert des Bytes ist 0), wenn das Array aus einem positiven <xref:System.Numerics.BigInteger> Wert erstellt wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie sichergestellt wird, dass ein positiver Wert nicht fälschlicherweise als negativer Wert instanziiert wird, indem ein Byte mit dem Wert 0 (null) bis zum Ende des Arrays hinzugefügt wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Dezimalzahl.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit einem <see cref="T:System.Decimal" />-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis des Aufrufs dieses Konstruktors ist identisch mit dem expliziten zuweisen <xref:System.Decimal> eines <xref:System.Numerics.BigInteger> Werts zu einer Variablen.  
  
 Der Aufruf dieses Konstruktors kann zu Datenverlusten führen. Alle Bruchteile von `value` werden beim Instanziieren eines <xref:System.Numerics.BigInteger> -Objekts abgeschnitten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> -Konstruktor verwendet wird, um <xref:System.Numerics.BigInteger> ein-Objekt zu instanziieren. Er definiert ein Array von <xref:System.Decimal> -Werten und übergibt dann jeden Wert an den <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29> -Konstruktor. Beachten Sie, <xref:System.Decimal> dass der Wert abgeschnitten wird, anstatt gerundet zu werden, wenn <xref:System.Numerics.BigInteger> er dem-Objekt zugewiesen wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit doppelter Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> - `value` Objekts werden alle Bruchteile des-Parameters abgeschnitten.  
  
 Aufgrund der fehlenden Genauigkeit des-Datentyps kann der <xref:System.Double> Aufruf dieses Konstruktors zu Datenverlusten führen.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der <xref:System.Double> sich aus dem <xref:System.Numerics.BigInteger>expliziten Zuweisen eines Werts zu einem ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29> -Konstruktor verwendet wird, um <xref:System.Numerics.BigInteger> ein-Objekt zu instanziieren. Außerdem wird der Genauigkeits Verlust veranschaulicht, der bei Verwendung des <xref:System.Double> -Datentyps auftreten kann. Einem <xref:System.Double> wird ein großer Wert zugewiesen, der dann einem <xref:System.Numerics.BigInteger> -Objekt zugewiesen wird. Wie die Ausgabe zeigt, beinhaltet diese Zuweisung einen Genauigkeits Verlust. Beide Werte werden dann um eins inkrementiert. Die Ausgabe zeigt, dass <xref:System.Numerics.BigInteger> das-Objekt den geänderten Wert widerspiegelt <xref:System.Double> , während das-Objekt dies nicht tut.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Eine 32-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> -Objekts mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, <xref:System.Int32> der sich aus <xref:System.Numerics.BigInteger>dem Zuweisen eines Werts zu einem ergibt.  
  
 Die <xref:System.Numerics.BigInteger> -Struktur enthält keine Konstruktoren mit einem Parameter vom Typ <xref:System.Byte>, <xref:System.Int16>, <xref:System.SByte>oder <xref:System.UInt16>. Der <xref:System.Int32> -Typ unterstützt jedoch die implizite Konvertierung von 8-Bit-und 16-Bit-Ganzzahlen mit Vorzeichen und ohne Vorzeichen in ganze Zahlen mit Vorzeichen 32 mit Vorzeichen. Daher wird dieser Konstruktor aufgerufen, wenn `value` einer dieser vier integralen Typen ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29> -Konstruktor aufgerufen, um <xref:System.Numerics.BigInteger> Werte aus einem Array von 32-Bit-Ganzzahlen zu instanziieren. Außerdem wird eine implizite Konvertierung verwendet, um jeden ganzzahligen Wert von 32 <xref:System.Numerics.BigInteger> Bit einer Variablen zuzuweisen. Anschließend werden die beiden Werte verglichen, um festzulegen, <xref:System.Numerics.BigInteger> dass die resultierenden Werte identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl mit Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> -Objekts mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, <xref:System.Int64> der sich aus <xref:System.Numerics.BigInteger>dem Zuweisen eines Werts zu einem ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29> -Konstruktor aufgerufen, um <xref:System.Numerics.BigInteger> Werte aus einem Array von 64-Bit-Ganzzahlen zu instanziieren. Außerdem wird eine implizite Konvertierung verwendet, um jeden ganzzahligen Wert von 64 <xref:System.Numerics.BigInteger> Bit einer Variablen zuzuweisen. Anschließend werden die beiden Werte verglichen, um festzulegen, <xref:System.Numerics.BigInteger> dass die resultierenden Werte identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit einfacher Genauigkeit.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> - `value` Objekts werden alle Bruchteile des-Parameters abgeschnitten.  
  
 Aufgrund der fehlenden Genauigkeit des <xref:System.Single> -Datentyps kann das Aufrufen dieses Konstruktors zu Datenverlusten führen.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der <xref:System.Single> sich aus dem <xref:System.Numerics.BigInteger>expliziten Zuweisen eines Werts zu einem ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29> -Konstruktor verwendet wird, um <xref:System.Numerics.BigInteger> ein-Objekt zu instanziieren. Außerdem wird der Genauigkeits Verlust veranschaulicht, der bei Verwendung des <xref:System.Single> -Datentyps auftreten kann. Einem <xref:System.Single> wird ein großer negativer Wert zugewiesen, der dann einem <xref:System.Numerics.BigInteger> -Objekt zugewiesen wird. Wie die Ausgabe zeigt, beinhaltet diese Zuweisung einen Genauigkeits Verlust. Beide Werte werden dann um eins inkrementiert. Die Ausgabe zeigt, dass <xref:System.Numerics.BigInteger> das-Objekt den geänderten Wert widerspiegelt <xref:System.Single> , während das-Objekt dies nicht tut.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Ein 32-Bit-Ganzzahlwert ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, <xref:System.UInt32> der sich aus <xref:System.Numerics.BigInteger>der Zuweisung eines Werts zu einem ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel werden der <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29> -Konstruktor und eine Zuweisungsanweisung verwendet <xref:System.Numerics.BigInteger> , um Werte aus einem Array nicht signierter 32-Bit-Ganzzahlen zu initialisieren. Anschließend werden die beiden Werte verglichen, um zu veranschaulichen, dass die beiden Methoden zum <xref:System.Numerics.BigInteger> Initialisieren eines Werts identische Ergebnisse verursachen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren eines <xref:System.Numerics.BigInteger> mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger> Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, <xref:System.UInt64> der sich aus <xref:System.Numerics.BigInteger>der Zuweisung eines Werts zu einem ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29> -Konstruktor verwendet, um ein <xref:System.Numerics.BigInteger> -Objekt zu instanziieren <xref:System.UInt64.MaxValue>, dessen Wert gleich ist.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="isUnsigned">To be added.</param>
        <param name="isBigEndian">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl.</param>
        <summary>Ruft den absoluten Wert eines <see cref="T:System.Numerics.BigInteger" />-Objekts ab.</summary>
        <returns>Der Absolutbetrag von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der absolute Wert einer Zahl ist die Zahl ohne Vorzeichen, wie in der folgenden Tabelle dargestellt.  
  
|`value`-Parameter|Rückgabewert|  
|-----------------------|------------------|  
|`value`> = 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Die <xref:System.Numerics.BigInteger.Abs%2A> -Methode entspricht <xref:System.Math.Abs%2A?displayProperty=nameWithType> der-Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Abs%2A> -Methode verwendet, <xref:System.Numerics.BigInteger> um einen Wert aus der Komplement-Darstellung von zwei Werten in die Darstellung der-Darstellung zu konvertieren, bevor Sie in eine Datei serialisiert wird. Die Daten in der Datei werden dann deserialisiert und einem neuen <xref:System.Numerics.BigInteger> Objekt zugewiesen.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt das Ergebnis zurück.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die das Überladen von Operatoren oder benutzerdefinierte Operatoren <xref:System.Numerics.BigInteger.Add%2A> nicht unterstützen, können <xref:System.Numerics.BigInteger> die-Methode verwenden, um mithilfe von Werten Addition  
  
 Die <xref:System.Numerics.BigInteger.Add%2A> -Methode ist ein nützlicher Ersatz für den Additions Operator beim Instanziieren <xref:System.Numerics.BigInteger> einer Variablen, indem Sie Ihr eine Summe zuweist, die aus Addition resultiert, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Vergleicht zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt eine ganze Zahl zurück, die angibt, ob der erste Wert kleiner oder größer als der zweite Wert oder gleich dem zweiten Wert ist.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relativen Werte von <paramref name="left" /> und <paramref name="right" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Wert 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="left" /> ist kleiner als <paramref name="right" />.  
  
 </description></item><item><term> Zero 
 </term><description><paramref name="left" /> ist gleich <paramref name="right" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="left" /> ist größer als <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der <xref:System.Numerics.BigInteger> Typ keinen festgelegten Bereich aufweist, werden <xref:System.Numerics.BigInteger> Vergleiche von Werten nicht durch die fehlende Genauigkeit gekennzeichnet, die den Vergleich von Gleit Komma Zahlen kennzeichnet. Im folgenden Beispiel werden zwei <xref:System.Numerics.BigInteger> Werte verglichen, die sich um einen unterscheiden und jeweils 1.896 Ziffern aufweisen. Die <xref:System.Numerics.BigInteger.Compare%2A> -Methode meldet ordnungsgemäß, dass die beiden Werte nicht gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht den Wert dieser Instanz mit einem anderen Wert und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der andere Wert ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl mit Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl mit Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ein <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> <xref:System.Int64> -, -,-, <xref:System.Int16> -,- oder <xref:System.UInt32>  -Wert ist, wird er implizit in einen-Wert konvertiert, wenn die-Methode aufgerufen wird. <xref:System.Int32> <xref:System.Byte> <xref:System.SByte> <xref:System.UInt16>  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Ergebnis des Aufruf der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29> -Methode mit ganzzahligen Werten.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem zweiten <see cref="T:System.Numerics.BigInteger" /> und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese über <xref:System.Numerics.BigInteger.CompareTo%2A> Ladung der-Methode implementiert <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> die-Methode. Sie wird von generischen Auflistungs Objekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29> -Methode verwendet wird, um `StarInfo` eine Liste von-Objekten zu sortieren. Jedes `StarInfo` -Objekt enthält Informationen über den Namen eines Stars und seine Entfernung von der Erde in Meilen. `StarInfo`implementiert die <xref:System.IComparable%601> -Schnittstelle, `StarInfo` die das Sortieren von Objekten nach generischen Auflistungs Klassen ermöglicht. Die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> Implementierung umschließt lediglich einen- <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>Aufruf.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Der folgende Code instanziiert dann vier `StarInfo` -Objekte und speichert Sie in einem <xref:System.Collections.Generic.List%601> generischen-Objekt. Nachdem die <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType> -Methode aufgerufen wurde `StarInfo` , werden-Objekte in der Reihenfolge ihrer Entfernung von der Erde angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die Beziehung der aktuellen Instanz zum <paramref name="obj" />-Parameter angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="obj" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="obj" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="obj" />, oder der <paramref name="obj" />-Parameter ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese über <xref:System.Numerics.BigInteger.CompareTo%2A> Ladung der-Methode implementiert <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType> die-Methode. Sie wird von nicht generischen Auflistungs Objekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
 Der `obj` Parameter muss einer der folgenden sein:  
  
-   Ein Objekt, dessen Lauf Zeittyp <xref:System.Numerics.BigInteger>ist.  
  
-   Eine <xref:System.Object> Variable, deren Wert `null`ist. Wenn der Wert des `obj` -Parameters ist `null`, gibt die Methode 1 zurück, was angibt, dass die aktuelle Instanz `obj`größer als ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> -Methode aufgerufen, <xref:System.Numerics.BigInteger> um einen Wert mit jedem Element in einem Objekt Array zu vergleichen.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> ist keine <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl ohne Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl ohne Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die den relativen Wert dieser Instanz und von <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> Beschreibung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Zero 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen und gibt das Ergebnis zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Divide%2A> -Methode führt eine ganzzahlige Division aus. jeder Rest, der aus der Division resultiert, wird verworfen. Zum Ausführen einer ganzzahligen Division ohne Beibehaltung des Restwerts wird die <xref:System.Numerics.BigInteger.DivRem%2A> -Methode aufgerufen. Um nur den Rest abzurufen, rufen Sie <xref:System.Numerics.BigInteger.Remainder%2A> die-Methode auf.  
  
 Die <xref:System.Numerics.BigInteger.Divide%2A> -Methode kann von Sprachen verwendet werden, die das Überladen von Operatoren nicht unterstützen. Das Verhalten ist mit der Division identisch, die den Divisions Operator verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> -Werten erstellt. Anschließend wird jedes Element als Quotienten in einem Divisions Vorgang verwendet, der die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A> -Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger *  -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <param name="remainder">Die Rückgabe dieser Methode enthält einen <see cref="T:System.Numerics.BigInteger" />-Wert, der den Rest der Division darstellt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen, gibt das Ergebnis zurück und gibt den Rest in einem Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behält sowohl den Quotienten als auch den Rest bei, der sich aus der ganzzahligen Division ergibt. Wenn Sie den Rest nicht interessieren, verwenden Sie die <xref:System.Numerics.BigInteger.Divide%2A> -Methode oder den Divisions Operator. Wenn Sie nur an dem Rest interessiert sind, verwenden Sie die <xref:System.Numerics.BigInteger.Remainder%2A> -Methode.  
  
 Das Vorzeichen des zurückgegebenen `remainder` Werts ist `dividend` mit dem Vorzeichen des Parameters identisch.  
  
 Das Verhalten <xref:System.Numerics.BigInteger.DivRem%2A> der-Methode ist mit <xref:System.Math.DivRem%2A?displayProperty=nameWithType> der der-Methode identisch.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> -Werten erstellt. Anschließend wird jedes Element als Quotienten in einem Divisions Vorgang verwendet, der die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A> -Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Der Wert der 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl mit Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn die 64-Bit-Ganzzahl mit Vorzeichen und die aktuelle Instanz über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn die-Methode aufgerufen wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> müssen Sie die-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Objekt von jedem ganzzahligen Typ mit Ausnahme <xref:System.UInt64>von instanziiert. Anschließend wird die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29> -Methode aufgerufen, um <xref:System.Numerics.BigInteger> den Wert mit dem ursprünglichen ganzzahligen Wert zu vergleichen <xref:System.Numerics.BigInteger> , der an den-Konstruktor übergeben wurde. Wie die Ausgabe zeigt, sind die Werte in jedem Fall gleich.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes <see cref="T:System.Numerics.BigInteger" />-Objekt über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Numerics.BigInteger" />-Objekt und <paramref name="other" /> über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601> -Schnittstelle und führt eine <xref:System.Numerics.BigInteger.Equals%28System.Object%29> etwas bessere Leistung als aus, da der `other` -Parameter nicht <xref:System.Numerics.BigInteger> in ein-Objekt konvertiert werden muss.  
  
 Um die Beziehung zwischen den beiden <xref:System.Numerics.BigInteger> Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, müssen Sie die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen von der Erde mit dem Abstand von Epsilon Indi von Erde verglichen, um zu bestimmen, ob Sie gleich sind. Im Beispiel wird jede Überladung der <xref:System.Numerics.BigInteger.Equals%2A> -Methode verwendet, um auf Gleichheit zu prüfen.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn das <paramref name="obj" />-Argument ein <see cref="T:System.Numerics.BigInteger" />-Objekt darstellt und dessen Wert der aktuellen <see cref="T:System.Numerics.BigInteger" />-Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das `obj` Argument <xref:System.Numerics.BigInteger> kein Wert ist, gibt die Methode zurück `false`. Die-Methode `true` gibt nur `obj` dann zurück <xref:System.Numerics.BigInteger> , wenn eine-Instanz ist, deren Wert gleich der aktuellen Instanz ist.  
  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29> müssen Sie die-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden parallele <xref:System.Object> - <xref:System.Numerics.BigInteger> und-Arrays definiert. Jedes Element eines Arrays hat denselben Wert wie das entsprechende Element des zweiten Arrays. Wie die Ausgabe des Beispiels zeigt, wird die-Instanz im <xref:System.Numerics.BigInteger> -Array nur dann als identisch mit der-Instanz <xref:System.Object> im-Array betrachtet, wenn letztere eine <xref:System.Numerics.BigInteger> ist und ihre Werte gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz und die 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> müssen Sie die-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen von der Erde mit dem Abstand von Epsilon Indi von Erde verglichen, um zu bestimmen, ob Sie gleich sind. Im Beispiel wird jede Überladung der <xref:System.Numerics.BigInteger.Equals%2A> -Methode verwendet, um auf Gleichheit zu prüfen.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <summary>Ruft die Anzahl der Bytes ab, die von <see cref="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" /> und <see cref="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" /> ausgegeben werden.</summary>
        <returns>Die Anzahl der Bytes.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.BigInteger" />-Objekt zurück.</summary>
        <returns>Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Sucht den größten gemeinsamen Divisor von zwei <see cref="T:System.Numerics.BigInteger" />-Werten.</summary>
        <returns>Der größte gemeinsame Divisor von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der größte gemeinsame Divisor ist die größte Zahl, in die <xref:System.Numerics.BigInteger> die beiden Werte aufgeteilt werden können, ohne einen Rest zurückzugeben.  
  
 Wenn der `left` - `right` Parameter und der-Parameter ungleich NULL sind, gibt die-Methode immer mindestens den Wert 1 zurück, da alle Zahlen durch 1 dividiert werden können. Wenn einer der Parameter NULL ist, gibt die Methode den absoluten Wert des Parameters ungleich 0 (null) zurück. Wenn beide Werte NULL sind, gibt die Methode 0 (null) zurück.  
  
> [!NOTE]
>  Das Berechnen des größten gemeinsamen Divisor von sehr großen `left` Werten `right` von und kann sehr zeitaufwändig sein.  
  
 Der von der <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> `left` -Methode zurückgegebene Wert ist unabhängig vom Vorzeichen des-Parameters `right` und des-Parameters immer positiv.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen aufzurufenden <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A> -Methode und die Ausnahmebehandlung, die erforderlich ist, um nützliche Informationen <xref:System.ArgumentOutOfRangeException>zu bereitzustellen. Das Ergebnis gibt an, dass der größte gemeinsame Divisor dieser beiden Zahlen 1 ist.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein praktisches Feature, das angibt, <xref:System.Numerics.BigInteger> ob ein Wert durch zwei gleichmäßig teilbar ist. Dies entspricht dem folgenden Ausdruck:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> -Objekts ist <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>, gibt die-Eigenschaft zurück. `true`  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine wesentlich bessere Leistung als andere Vergleiche mit einer, z `thisBigInteger.Equals(BigInteger.One)`. b..  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, ob <xref:System.Numerics.BigInteger> für einen Wert ein einzelnes Bit festgelegt ist, das nicht NULL ist. Dies bedeutet, dass zurück `true` gegeben wird, wenn der Wert <xref:System.Numerics.BigInteger> des aktuellen-Objekts 1 (d. h. 2<sup>0</sup>) oder eine beliebige größere Potenz von zwei ist. Gibt zurück `false` , wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> -Objekts 0 (null) ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine wesentlich bessere Leistung `BigInteger.Equals(BigInteger.Zero)`als.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Logarithmus der angegebenen Zahl zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Der natürliche Logarithmus (Basis <see langword="e" />) von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value` -Parameter wird als Basis 10 angegeben.  
  
 Der genaue Rückgabewert dieser Methode hängt vom Vorzeichen von `value`ab, wie in der folgenden Tabelle gezeigt.  
  
|Vorzeichen des `value` Parameters|Rückgabewert|  
|-------------------------------|------------------|  
|Positiv|Der natürliche Logarithmus von `value`, d. h. `value`ln oder Log e`value`.|  
|Zero|<xref:System.Double.NegativeInfinity>.|  
|Negativ|<xref:System.Double.NaN>.|  
  
 Um den Logarithmus zur Basis 10 eines <xref:System.Numerics.BigInteger> Werts zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log10%2A> -Methode aufzurufen. Um den Logarithmus einer Zahl in einer anderen Basis zu berechnen, wird <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29> die-Methode aufgerufen.  
  
 Sie können die Quadratwurzel einer Zahl ermitteln, indem Sie die <xref:System.Numerics.BigInteger.Log%2A> -Methode zusammen mit <xref:System.Math.Exp%2A?displayProperty=nameWithType> der-Methode aufrufen. Beachten Sie, dass das <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> Ergebnis ist, wenn das Ergebnis <xref:System.Double.MaxValue?displayProperty=nameWithType>größer als ist. Im folgenden Beispiel wird die Quadratwurzel der einzelnen Elemente in einem Array von <xref:System.Numerics.BigInteger> -Werten berechnet.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Diese Methode entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> -Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der natürliche Logarithmus von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <param name="baseValue">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Der Logarithmus zur Basis <paramref name="baseValue" /> von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value` - `baseValue` Parameter und der-Parameter werden als Basis 10 Zahlen angegeben.  
  
 Der genaue Rückgabewert der-Methode hängt vom Vorzeichen von `value` und vom-Zeichen und-Wert von `baseValue`ab, wie in der folgenden Tabelle gezeigt.  
  
|`value`-Parameter|`baseValue`-Parameter|Rückgabewert|  
|-----------------------|---------------------------|------------------|  
|`value`> 0|(0 < `baseValue` < 1)-oder-(`baseValue` > 1)|logbasevalue (`value`)|  
|`value` < 0|(beliebiger Wert)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue`> 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Um den Logarithmus zur Basis 10 eines <xref:System.Numerics.BigInteger> Werts zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log10%2A> -Methode aufzurufen. Um den natürlichen Logarithmus einer Zahl zu berechnen, wird die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29> -Methode aufgerufen.  
  
 Diese Methode entspricht der <xref:System.Math.Log%2A?displayProperty=nameWithType> -Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das Protokoll von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Der Logarithmus zur Basis 10 von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value` -Parameter wird als Basis 10 angegeben.  
  
 Der genaue Rückgabewert der-Methode hängt vom Vorzeichen von `value`ab, wie in der folgenden Tabelle gezeigt.  
  
|Vorzeichen des value-Parameters|Rückgabewert|  
|-----------------------------|------------------|  
|Positiv|Das Protokoll der Basis 10 `value`von, d. h`value`. Log10.|  
|Zero|<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.|  
|Negativ|<xref:System.Double.NaN?displayProperty=nameWithType>.|  
  
 Um den natürlichen Logarithmus eines <xref:System.Numerics.BigInteger> Werts zu berechnen, wird die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode aufgerufen. Um den Logarithmus einer Zahl in einer anderen Basis zu berechnen, wird <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType> die-Methode aufgerufen.  
  
 Diese Methode entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType> -Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Logarithmus zur Basis 10 von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den größeren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der größere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Max%2A?displayProperty=nameWithType> -Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Max%2A> -Methode verwendet, um die größte Zahl in einem <xref:System.Numerics.BigInteger> Array von-Werten auszuwählen.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den kleineren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Min%2A?displayProperty=nameWithType> -Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Min%2A> -Methode verwendet, um die kleinste Zahl in einem <xref:System.Numerics.BigInteger> Array von-Werten auszuwählen.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl -1 darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert -1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.MinusOne%2A> -Eigenschaft wird verwendet, um <xref:System.Numerics.BigInteger> einen-Wert mit-1 zu vergleichen oder um einem <xref:System.Numerics.BigInteger> -Objekt-1 zuzuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <paramref name="exponent" />. Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <paramref name="value" /> potenziert werden soll.</param>
        <param name="modulus">Die Zahl, durch die <paramref name="value" /> hoch <paramref name="exponent" /> dividiert wird.</param>
        <summary>Führt eine Modulodivision für eine zur Potenz einer anderen Zahl erhobene Zahl aus.</summary>
        <returns>Der Rest nach der Division von <paramref name="value" /><sup>exponent</sup> durch <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ModPow%2A> -Methode wertet den folgenden Ausdruck aus:  
  
 (baseValue ^ Exponent) Mod-Modulo  
  
 Verwenden Sie die <xref:System.Numerics.BigInteger.Pow%2A> -Methode <xref:System.Numerics.BigInteger> , um exponentiell für Werte ohne modulodivision auszuführen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Aufrufen der <xref:System.Numerics.BigInteger.ModPow%2A> -Methode.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> ist ein negativer Wert.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Die erste zu multiplizierende Zahl.</param>
        <param name="right">Die zweite zu multiplizierende Zahl.</param>
        <summary>Gibt das Produkt der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Multiply%2A> -Methode wird für Sprachen implementiert, die das Überladen von Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Multiplikation mit dem Multiplikations Operator. Außerdem ist die <xref:System.Numerics.BigInteger.Multiply%2A> -Methode ein nützlicher Ersatz für den Multiplikations Operator beim Instanziieren <xref:System.Numerics.BigInteger> einer Variablen, indem Sie Ihr ein Produkt zuweist, das sich aus der Multiplikation ergibt, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Bei Bedarf führt diese Methode automatisch eine implizite Konvertierung von anderen ganzzahligen <xref:System.Numerics.BigInteger> Typen in-Objekte durch. Dies wird im Beispiel im nächsten Abschnitt veranschaulicht, in dem die <xref:System.Numerics.BigInteger.Multiply%2A> Methode zwei <xref:System.Int64> Werte übermittelt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird versucht, eine Multiplikation mit zwei langen Ganzzahlen auszuführen. Da das Ergebnis den Bereich einer langen ganzen Zahl überschreitet, <xref:System.OverflowException> wird eine ausgelöst, und <xref:System.Numerics.BigInteger.Multiply%2A> die-Methode wird aufgerufen, um die Multiplikation zu verarbeiten. Beachten Sie C# , dass Sie entweder das `checked` -Schlüsselwort (wie in diesem Beispiel) oder die `/checked+` -Compileroption verwenden müssen, um sicherzustellen, dass bei einem numerischen Überlauf eine Ausnahme ausgelöst wird.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negation erhält den Additiven umgekehrten Wert einer Zahl. Die Additive Umkehrung einer Zahl ist eine Zahl, die den Wert 0 (null) erzeugt, wenn Sie der ursprünglichen Zahl hinzugefügt wird.  
  
 Die <xref:System.Numerics.BigInteger.Negate%2A> -Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen. Das Verhalten ist mit der Negations Operator identisch, die den unären Negations Operator verwendet. Außerdem ist die <xref:System.Numerics.BigInteger.Negate%2A> -Methode ein nützlicher Ersatz für den Negations Operator beim Instanziieren einer <xref:System.Numerics.BigInteger> Variablen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Möglichkeiten veranschaulicht, um den Wert eines <xref:System.Numerics.BigInteger> -Objekts zu negieren.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl 1 darstellt.</summary>
        <value>Ein Objekt, dessen Wert 1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.One%2A> -Eigenschaft wird normalerweise verwendet, <xref:System.Numerics.BigInteger> um einen Wert mit 1 zu vergleichen oder um <xref:System.Numerics.BigInteger> einem-Objekt 1 zuzuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert die Werte von zwei angegebenen <see cref="T:System.Numerics.BigInteger" />-Objekten.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Addition%2A> -Methode definiert den Additions Vorgang <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Add%2A> , können stattdessen die-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="And" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="And" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> -Methode definiert die `And` bitweise-Operation <xref:System.Numerics.BigInteger> für-Werte. Durch die `And` bitweise-Operation wird ein Ergebnisbit nur dann festgelegt, `right` wenn die entsprechenden Bits in `left` und ebenfalls festgelegt sind, wie in der folgenden Tabelle dargestellt.  
  
|Bit in`left`|Bit in`right`|Bit in Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> -Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A> -Methode führt die `And` bitweise-Operation für <xref:System.Numerics.BigInteger> zwei-Werte aus, als wären Sie beide in der Komplement-Darstellung von zwei Elementen mit der Erweiterung für virtuelle Vorzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="Or" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> -Methode definiert die `Or` bitweise-Operation <xref:System.Numerics.BigInteger> für-Werte. Durch die `Or` bitweise-Operation wird ein Ergebnisbit nur dann festgelegt, wenn eine oder beide `right` der entsprechenden Bits in `left` und festgelegt sind, wie in der folgenden Tabelle dargestellt.  
  
|Bit in`left`|Bit in`right`|Bit in Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> -Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A> -Methode führt die `Or` bitweise-Operation für <xref:System.Numerics.BigInteger> zwei-Werte aus, als wären Sie beide in der Komplement-Darstellung von zwei Elementen mit der Erweiterung für virtuelle Vorzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu dekrementierende Wert.</param>
        <summary>Dekrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 dekrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Decrement%2A> -Methode definiert den Dekrement- <xref:System.Numerics.BigInteger> Vorgang für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Subtract%2A> , können stattdessen die-Methode aufzurufen. Beispiel:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Da <xref:System.Numerics.BigInteger> -Objekte unveränderlich sind, erstellt <xref:System.Numerics.BigInteger.op_Decrement%2A> der-Operator ein <xref:System.Numerics.BigInteger> neues-Objekt, dessen Wert eins kleiner <xref:System.Numerics.BigInteger> ist als das `value`durch dargestellte Objekt. Dies bedeutet, dass wiederholte <xref:System.Numerics.BigInteger.op_Decrement%2A> Aufrufe von teuer sein können.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert mit einer Ganzzahldivision.</summary>
        <returns>Das ganzzahlige Ergebnis der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Division%2A> -Methode definiert den Divisions Vorgang <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen <xref:System.Numerics.BigInteger.Divide%2A> , können stattdessen die-Methode aufzurufen.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> -Werten erstellt. Anschließend wird jedes Element als Quotienten in einem Divisions Vorgang verwendet, der die <xref:System.Numerics.BigInteger.Divide%2A> -Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A> -Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode definiert die Gleichheits Vergleichs <xref:System.Numerics.BigInteger> Operation für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen.  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl mit Vorzeichen gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode definiert die Gleichheits Vergleichs <xref:System.Numerics.BigInteger> Operation für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen.  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Werte von zwei <see cref="T:System.Numerics.BigInteger" />-Objekten gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode definiert den Vorgang des Gleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl ohne Vorzeichen gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode definiert die Gleichheits Vergleichs <xref:System.Numerics.BigInteger> Operation für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode definiert die Gleichheits Vergleichs <xref:System.Numerics.BigInteger> Operation für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise exklusive <see langword="Or" />-Operation (<see langword="XOr" />-Operation) für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis einer bitweisen exklusiven `Or` Operation ist `true` , wenn sich die Werte der beiden Bits unterscheiden `false`, andernfalls. In der folgenden Tabelle wird der `Or` exklusive-Vorgang veranschaulicht.  
  
|Bit x in`left`|Bit x in`right`|Rückgabewert|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> -Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A> -Methode führt die bitweise exklusive `Or` Operation für zwei <xref:System.Numerics.BigInteger> -Werte aus, als wären Sie beide in der Komplement-Darstellung eines zwei Werts mit der Erweiterung für virtuelle Vorzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Decimal" />-Objekts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des-para `value` meters werden vor der Konvertierung abgeschnitten.

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Da bei der Konvertierung <xref:System.Decimal> von <xref:System.Numerics.BigInteger> in alle Bruchteile von abgeschnitten werden können, `value`wird diese Konvertierung von sprach Compilern nicht automatisch durchgeführt. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion (z. b. in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>die alternative Methode.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Decimal> - <xref:System.Numerics.BigInteger> Werten in-Objekte konvertiert. Anschließend wird das Ergebnis der einzelnen Konvertierungen angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Decimal> Werts während der Konvertierung abgeschnitten werden.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Double" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des-para `value` meters werden vor der Konvertierung abgeschnitten.

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Da bei der Konvertierung <xref:System.Double> von <xref:System.Numerics.BigInteger> in alle Bruchteile von abgeschnitten werden können, `value`wird diese Konvertierung von sprach Compilern nicht automatisch durchgeführt. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion (z. b. in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>die alternative Methode.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Double> - <xref:System.Numerics.BigInteger> Werten in-Objekte konvertiert. Anschließend wird das Ergebnis der einzelnen Konvertierungen angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Double> Werts während der Konvertierung abgeschnitten werden.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Byte" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Bytewert ohne Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CByte` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.Byte> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.Byte> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Byte> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.Byte> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Decimal" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CDec` (z. b. oder in Visual Basic) verwendet wird.   

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.Decimal> außerhalb des Bereichs des Datentyps liegt. 

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Decimal> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.Decimal> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Double" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Double" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CDbl` (z. b. oder in Visual Basic) verwendet wird.   

 Da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs <xref:System.Double> des Datentyps liegen kann, ist dieser Vorgang eine einschränkende Konvertierung. Wenn die Konvertierung nicht erfolgreich ist, wird keine <xref:System.OverflowException>ausgelöst. <xref:System.Numerics.BigInteger> Stattdessen ist <xref:System.Double.MinValue?displayProperty=nameWithType> der resultierende <xref:System.Double>  Wert, wenn der Wert kleiner als ist. <xref:System.Double.NegativeInfinity?displayProperty=nameWithType> Wenn der <xref:System.Numerics.BigInteger> Wert größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>ist, lautet <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>der <xref:System.Double> resultierende Wert.
 
 Die Konvertierung <xref:System.Numerics.BigInteger> eines in einen <xref:System.Double> kann zu einem Genauigkeits Verlust führen. In einigen Fällen kann der Verlust der Genauigkeit bewirken, dass der Umwandlungs-oder Konvertierungs Vorgang erfolgreich <xref:System.Numerics.BigInteger> ist, auch wenn der Wert außerhalb <xref:System.Double> des Bereichs des Datentyps liegt. Dies wird im folgenden Beispiel veranschaulicht. Er weist zwei <xref:System.Numerics.BigInteger> Variablen den maximalen Wert <xref:System.Double> von zu, erhöht eine <xref:System.Numerics.BigInteger> Variable um 9.999 e291 und testet die beiden Variablen auf Gleichheit. Erwartungsgemäß zeigt der Aufrufe der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode, dass Sie ungleich sind. <xref:System.Numerics.BigInteger> Die Konvertierung des größeren Werts in eine <xref:System.Double> ist jedoch erfolgreich, obwohl der <xref:System.Numerics.BigInteger> Wert jetzt überschreitet <xref:System.Double.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Double> -Werte veranschaulicht.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CShort` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.Int16> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.Int16> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int16> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.Int16> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CInt` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.Int32> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.Int16> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int32> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.Int32> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CLng` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.  

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.Int64> außerhalb des Bereichs des Datentyps liegt. 

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int64> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.Int64> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen 8-Bit-Wert mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen 8-Bit-Wert mit Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int16" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CSByte` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.  

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.SByte> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.SByte> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.SByte> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.SByte> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen Gleitkommawert mit einfacher Genauigkeit konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Gleitkommawert mit einfacher Genauigkeit.</summary>
        <returns>Ein Objekt, das die nächstmögliche Darstellung des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten oder einem Genauigkeits Verlust kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CSng` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs <xref:System.Single> des Datentyps liegen kann, ist dieser Vorgang eine einschränkende Konvertierung. Wenn die Konvertierung nicht erfolgreich ist, wird keine <xref:System.OverflowException>ausgelöst. <xref:System.Numerics.BigInteger> Stattdessen ist <xref:System.Single.MinValue?displayProperty=nameWithType> der resultierende <xref:System.Single>  Wert, wenn der Wert kleiner als ist. <xref:System.Single.NegativeInfinity?displayProperty=nameWithType> Wenn der <xref:System.Numerics.BigInteger> Wert größer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist, lautet <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>der <xref:System.Single> resultierende Wert.

 Die Konvertierung <xref:System.Numerics.BigInteger> eines in einen <xref:System.Single> kann zu einem Genauigkeits Verlust führen. In einigen Fällen kann der Verlust der Genauigkeit bewirken, dass der Umwandlungs-oder Konvertierungs Vorgang erfolgreich <xref:System.Numerics.BigInteger> ist, auch wenn der Wert außerhalb <xref:System.Single> des Bereichs des Datentyps liegt. Dies wird im folgenden Beispiel veranschaulicht. Er weist zwei <xref:System.Numerics.BigInteger> Variablen den maximalen Wert <xref:System.Single> von zu, erhöht eine <xref:System.Numerics.BigInteger> Variable um 9.999 e291 und testet die beiden Variablen auf Gleichheit. Erwartungsgemäß zeigt der Aufrufe der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode, dass Sie ungleich sind. <xref:System.Numerics.BigInteger> Die Konvertierung des größeren Werts in eine <xref:System.Single> ist jedoch erfolgreich, obwohl der <xref:System.Numerics.BigInteger> Wert jetzt überschreitet <xref:System.Single.MaxValue?displayProperty=nameWithType>.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Single> -Werte veranschaulicht.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int32" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CUShort` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.UInt16> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.UInt16> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt16> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.UInt16> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt16.MinValue" /> oder größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int64" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CUInt` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.UInt32> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.UInt32> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt32> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.UInt32> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt32.MinValue" /> oder größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion `CULng` (z. b. oder in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da durch diesen Vorgang eine einschränkende Konvertierung definiert wird, kann <xref:System.OverflowException> eine zur Laufzeit ausgelöst werden <xref:System.Numerics.BigInteger> , wenn der Wert <xref:System.UInt64> außerhalb des Bereichs des Datentyps liegt. Wenn die Konvertierung erfolgreich ist, gibt es im <xref:System.UInt64> resultierenden Wert keinen Genauigkeits Verlust.

## Examples
 Im folgenden Beispiel wird die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt64> -Werte veranschaulicht. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, <xref:System.Numerics.BigInteger> da der Wert <xref:System.UInt64> außerhalb des Bereichs des Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt64.MinValue" /> oder größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Single" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des-para `value` meters werden vor der Konvertierung abgeschnitten.
 
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger> -Methode definieren die Typen, in die bzw. aus denen ein <xref:System.Numerics.BigInteger> -Objekt konvertiert werden kann. Da bei der Konvertierung <xref:System.Single> von <xref:System.Numerics.BigInteger> in alle Bruchteile von abgeschnitten werden können, `value`wird diese Konvertierung von sprach Compilern nicht automatisch durchgeführt. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs `CType` Funktion (z. b. in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>die alternative Methode.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Single> - <xref:System.Numerics.BigInteger> Werten in-Objekte konvertiert. Anschließend wird das Ergebnis der einzelnen Konvertierungen angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Single> Werts während der Konvertierung abgeschnitten werden.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer als ein anderer angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> -Methode definiert den Vorgang des größer-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die Instanzmethode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> größer als der Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> -Methode definiert den Vorgang des größer-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> -Methode definiert den Vorgang des größer-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> -Methode definiert den Vorgang des größer-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A> -Methode definiert den Vorgang des größer-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer oder gleich einem anderen angegebenen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des Operators "größer als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des Operators "größer als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des Operators "größer als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des Operators "größer als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A> -Methode definiert den Vorgang des Operators "größer als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine implizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen in ein <see cref="T:System.Numerics.BigInteger" />-Objekt.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des-para `value` meters werden vor der Konvertierung abgeschnitten.

 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.Byte> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.Int16> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>die alternative Methode.  

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.Int32> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>die alternative Methode.   
 
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.Int64> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.SByte> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.UInt16> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.UInt32> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>die alternative Methode.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger> -Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger> Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht es dem Compiler, Konvertierungen von <xref:System.UInt64> einem <xref:System.Numerics.BigInteger> -Wert in einen-Wert zu behandeln, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu inkrementierende Wert.</param>
        <summary>Inkrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 inkrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Increment%2A> -Methode definiert den Inkrement <xref:System.Numerics.BigInteger> -Vorgang für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Einige Sprachen (z. b. Visual Basic), die keinen Inkrementoperator oder Operator Überladung nicht unterstützen <xref:System.Numerics.BigInteger.op_Increment%2A> , können die Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Da <xref:System.Numerics.BigInteger> -Objekte unveränderlich sind, erstellt <xref:System.Numerics.BigInteger.op_Increment%2A> der-Operator ein <xref:System.Numerics.BigInteger> neues-Objekt, dessen Wert eins mehr <xref:System.Numerics.BigInteger> ist als das `value`durch dargestellte Objekt. Daher können wiederholte Aufrufe <xref:System.Numerics.BigInteger.op_Increment%2A> von teuer sein.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte ungleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Instanzmethode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> -Wert und dem Wert einer langen ganzen Zahl mit Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> Instanzmethode und umkehren ihres Werts.  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl mit Vorzeichen ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und einem Wert mit langer Ganzzahl mit Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> -Methode und umkehren ihres Werts.  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Numerics.BigInteger" />-Objekte über unterschiedliche Werte verfügen.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> -Methode, die die Beziehung zwischen zwei <xref:System.Numerics.BigInteger> -Objekten angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> -Methode und umkehren ihres Werts.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl ohne Vorzeichen ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> -Wert und einem langen ganzzahligen Wert ohne Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und umkehren ihres Werts.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A> -Methode definiert den Vorgang des Ungleichheits Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> -Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> -Wert und einem langen ganzzahligen Wert ohne Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> -Methode und umkehren ihres Werts.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <paramref name="value" /> nach links verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach links.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach links verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LeftShift%2A> -Methode definiert den Vorgang des bitweisen Links Schiebe Operators für <xref:System.Numerics.BigInteger> -Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Im Gegensatz zum bitweisen Left Shift-Vorgang mit ganzzahligen primitiven behält <xref:System.Numerics.BigInteger.op_LeftShift%2A> die Methode das Vorzeichen des ursprünglichen <xref:System.Numerics.BigInteger> Werts bei.  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können einen bitweisen Left Shift-Vorgang `value` ausführen `BigInteger.Pow(2, shift)`, indem Sie mit multiplizieren. Das folgende Beispiel zeigt, dass die Ergebnisse mit den Ergebnissen der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als ein zweiter angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> -Methode definiert den Vorgang des kleiner-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> -Methode definiert den Vorgang des kleiner-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> -Methode definiert den Vorgang des kleiner-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Einige Sprachen können die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> -Methode definiert den Vorgang des kleiner-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A> -Methode definiert den Vorgang des kleiner-als- <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als oder gleich einem anderen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des Operators "kleiner als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Wenn `left` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des Operators "kleiner als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Wenn `right` ein -, <xref:System.Int16>  <xref:System.UInt32> -, <xref:System.Int64>  -,-,-oder-Wert ist, wird er implizit in einen-Wert konvertiert, wenn der Vorgang ausgeführt wird. <xref:System.Int32> <xref:System.SByte> <xref:System.Byte> <xref:System.UInt16>  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des Operators "kleiner als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Compare%2A> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des Operators "kleiner als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A> -Methode definiert den Vorgang des Operators "kleiner als oder gleich" <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> -Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Gibt den Rest aus der Division zweier angegebener <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der Rest, der sich aus der Division ergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Modulus%2A> -Methode definiert den Vorgang des Modulo-Operators <xref:System.Numerics.BigInteger> für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen.  
  
 Das Vorzeichen des Werts, der durch den Modulo-Vorgang zurückgegeben wird, `dividend`hängt vom `dividend` Vorzeichen von ab: Wenn positiv ist, gibt der Modulo-Vorgang ein positives Ergebnis zurück; wenn es negativ ist, gibt der Modulo-Vorgang ein negatives Ergebnis zurück. Das Verhalten des Modulo-Vorgangs mit <xref:System.Numerics.BigInteger> -Werten ist mit dem Modulo-Vorgang mit anderen ganzzahligen Typen identisch.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu multiplizierende Wert.</param>
        <param name="right">Der zweite zu multiplizierende Wert.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Numerics.BigInteger" />-Werte.</summary>
        <returns>Das Produkt von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Multiply%2A> -Methode definiert den Vorgang des Multiplikations <xref:System.Numerics.BigInteger> Operators für-Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt das bitweise Einerkomplement eines <see cref="T:System.Numerics.BigInteger" />-Werts zurück.</summary>
        <returns>Das bitweise Einerkomplement von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> -Methode definiert den Vorgang des bitweisen One-komplementatoroperators für <xref:System.Numerics.BigInteger> -Werte. Der bitweise One-komplementatoroperator kehrt jedes Bit in einem numerischen Wert um. Das heißt, Bits in `value` , die 0 sind, werden im Ergebnis auf 1 festgelegt, und Bits, die 1 sind, werden im Ergebnis auf 0 festgelegt. Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> -Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können die <xref:System.Numerics.BigInteger.op_OnesComplement%2A> -Methode möglicherweise direkt aufzurufen, um eine bitweise Einerkomplement Operation auszuführen. Beispiel:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <paramref name="value" /> nach rechts verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach rechts.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach rechts verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit <xref:System.Numerics.BigInteger.op_RightShift%2A> der-Methode wird der bitweise Right Shift-Operator für <xref:System.Numerics.BigInteger> -Werte definiert. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können einen bitweisen rechts Schiebe Vorgang durch `value` führen `BigInteger.Pow(2, shift)` , indem Sie durch Dividieren `shift` und 1-mal bei negativen Werten subtrahieren. Das folgende Beispiel zeigt, dass die Ergebnisse mit den Ergebnissen der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Wenn `shift` größer oder gleich der Anzahl von Bits in einem positiven <xref:System.Numerics.BigInteger> Wert ist, ist <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>das Ergebnis der Right Shift-Operation. Wenn `shift` größer als die Anzahl der Bits in einem negativen <xref:System.Numerics.BigInteger> Wert ist, ist <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>das Ergebnis der Right Shift-Operation.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Subtraction%2A> -Methode definiert den Vorgang des Subtraktions Operators für <xref:System.Numerics.BigInteger> -Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType> , können stattdessen die-Methode aufzurufen.  
  
 Die äquivalente-Methode für diesen <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>Operator ist.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen BigInteger-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryNegation%2A> -Methode definiert den Vorgang des unären Negations Operators (oder den Additiven umgekehrten Operator <xref:System.Numerics.BigInteger> ) für-Werte. Der-Vorgang erzeugt einen Wert, der 0 (null) ergibt, wenn er der ursprünglichen Zahl hinzugefügt wird. Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Negate%2A> , können stattdessen die-Methode aufzurufen.  
  
 Die äquivalente Methode für diesen Operator ist.<xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel werden drei verschiedene Möglichkeiten veranschaulicht, um den Wert eines <xref:System.Numerics.BigInteger> -Objekts zu negieren.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein Ganzzahlwert.</param>
        <summary>Gibt den Wert des <see cref="T:System.Numerics.BigInteger" />-Operanden zurück. (Das Vorzeichen des Operanden wird nicht geändert.)</summary>
        <returns>Der Wert des <paramref name="value" />-Operanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryPlus%2A> -Methode definiert den Vorgang des unären positiven Operators für <xref:System.Numerics.BigInteger> -Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value` -Parameter sollte die Zeichen folgen Darstellung einer Zahl in der folgenden Form sein.  
  
 [*WS*] [*Sign*] *Ziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> -Eigenschaft und der- <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaft der aktuellen Kultur bestimmt.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Die durch den `value` -Parameter angegebene Zeichenfolge wird mithilfe des <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> -Stils interpretiert. Er darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und er darf keinen Dezimaltrennzeichen enthalten.  
  
 Der `value` -Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType> -Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode, um eine Zeichenfolge mithilfe der Formatierungsinformationen einer bestimmten Kultur zu analysieren.  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A> -Methode zum Roundtrip der Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> eines Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode ausgegeben wurde, sollten Sie <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> die-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung von zu generieren. <xref:System.Numerics.BigInteger> Wert. Andernfalls <xref:System.Numerics.BigInteger> behält die Zeichen folgen Darstellung von nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und die Daten gehen möglicherweise verloren, wenn <xref:System.Numerics.BigInteger.Parse%2A> Sie die-Methode <xref:System.Numerics.BigInteger> zum Wiederherstellen des Werts verwenden.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Parse%28System.String%29> -Methode verwendet, um zwei <xref:System.Numerics.BigInteger> -Objekte zu instanziieren. Jedes Objekt wird mit einer anderen Zahl multipliziert und dann die <xref:System.Numerics.BigInteger.Compare%2A> -Methode aufgerufen, um die Beziehung zwischen den beiden Werten zu bestimmen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <paramref name="value" /> angeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `style` -Parameter definiert die Stilelemente (z. b. Leerzeichen, das positive oder negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen), die `value` im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. `styles`muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> -Enumeration sein. Der `style` -Parameter bewirkt, dass diese Methoden `value` Überladung nützlich ist, wenn die Zeichen folgen Darstellung eines hexadezimalen Werts enthält, wenn das Zahlensystem (Decimal `value` oder hexadezimal), das von dargestellt wird, nur zur Laufzeit bekannt ist oder wenn Sie Sie möchten Leerzeichen oder ein Vorzeichen Symbol in `value`nicht zulassen.  
  
 Abhängig vom Wert von `style`kann der `value` -Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*digits*,]*digits*[. *fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn `style` `value` enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, kann der-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerräume können am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> - <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaft und die-Eigenschaft der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in `value` angezeigt werden, wenn <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> `style` das-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> wenn das-Flag enthält. Klammern können in `value` verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> -Flag einschließt.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Für *fractional_digits*ist nur die Ziffer 0 gültig.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `value` auftreten, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> -Flag enthält. Nur die Ziffer 0 (null) kann als eine Bruch Ziffer angezeigt werden, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Wenn *fractional_digits* eine beliebige andere Ziffer einschließt, <xref:System.FormatException> wird eine ausgelöst.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value` -Parameter kann eine Zahl in Exponentialnotation `style` darstellen, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) `s` in werden vom Analyse-Vorgang unabhängig vom Wert `style` des Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Format entspricht) entspricht, wird immer erfolgreich analysiert. Die meisten der Verb <xref:System.Globalization.NumberStyles> leibenden Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie sich einzelne Member auf die Elemente auswirken `value`, die in vorhanden sein können.  
  
|`NumberStyles`-Wert|In zugelassene `value` Elemente zusätzlich zu Ziffern|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das *digits* -Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (.) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialnotation angibt, zusammen mit *Exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist `value` jedoch nicht möglich, eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `value`, *Signieren* Sie am Anfang `value`von und das Dezimaltrennzeichen (*.*). Der `value` -Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`Elemente `sign`,, Gruppen Trennzeichen (*,*) und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Eine hexadezimale Zahl kann jedoch nicht dargestellt werden `value` .|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A> -Methode zum Roundtrip der Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> eines Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode ausgegeben wurde, sollten Sie <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> die-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung von zu generieren. <xref:System.Numerics.BigInteger> Wert. Andernfalls <xref:System.Numerics.BigInteger> behält die Zeichen folgen Darstellung von nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und die Daten gehen möglicherweise verloren, wenn <xref:System.Numerics.BigInteger.Parse%2A> Sie die-Methode <xref:System.Numerics.BigInteger> zum Wiederherstellen des Werts verwenden.  
  
 Anders als bei <xref:System.Globalization.NumberStyles> den anderen Werten, die das vorhanden sein bestimmter Stilelemente in `value`zulassen, bedeutet der <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> Stil Wert, dass die einzelnen numerischen Zeichen in `value` immer als hexadezimale Zeichen. Gültige hexadezimale Zeichen sind 0-9, a-f und A-f. Die einzigen anderen Flags, die mit dem `style` -Parameter kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> -Enumeration enthält einen zusammengesetzten Zahlen <xref:System.Globalization.NumberStyles.HexNumber>Stil,, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung ( `0x` z. b. oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> , interpretiert `value` die Methode als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden `0x80`hexadezimalen Ziffern größer oder gleich sind. Das heißt, die-Methode interpretiert das Bit des ersten Bytes in `value` der höchsten Reihenfolge als Signier Bit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss `value` die erste Ziffer in den Wert 0 (null) aufweisen. Die-Methode interpretiert `0x80` z. b. als negativen Wert, interpretiert aber entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Der `value` -Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo> -Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Um die Kultur anzugeben, deren Formatierungsinformationen für den Analyse Vorgang verwendet werden, müssen <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Sie die-Überladung aufrufen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> -Methode mit mehreren möglichen Werten für den `style` -Parameter. Es veranschaulicht, wie eine Zeichenfolge als Hexadezimalwert interpretiert wird und wie Leerzeichen und Signierungs Symbole nicht zugelassen werden.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> folgt nicht dem mit <see cref="T:System.Globalization.NumberStyles" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen kulturspezifischen Format in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value` -Parameter sollte die Zeichen folgen Darstellung einer Zahl in der folgenden Form sein:  
  
 [*WS*] [*Sign*] *Ziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> durch die-Eigenschaft und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> die-Eigenschaft des <xref:System.Globalization.NumberFormatInfo> -Objekts bestimmt, das von der <xref:System.IFormatProvider.GetFormat%2A> -Methode des `provider` -Objekts zurückgegeben wird.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Die durch den `value` -Parameter angegebene Zeichenfolge wird mithilfe <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> des-Stils interpretiert. Er darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und er darf keinen Dezimaltrennzeichen enthalten.  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A> -Methode zum Roundtrip der Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> eines Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode ausgegeben wurde, sollten Sie <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> die-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung von zu generieren. <xref:System.Numerics.BigInteger> Wert. Andernfalls <xref:System.Numerics.BigInteger> behält die Zeichen folgen Darstellung von nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und die Daten gehen möglicherweise verloren, wenn <xref:System.Numerics.BigInteger.Parse%2A> Sie die-Methode <xref:System.Numerics.BigInteger> zum Wiederherstellen des Werts verwenden.  
  
 Der `provider` -Parameter ist <xref:System.IFormatProvider> eine Implementierung <xref:System.IFormatProvider.GetFormat%2A> , deren- <xref:System.Globalization.NumberFormatInfo> Methode ein-Objekt zurückgibt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29> -Methode aufgerufen wird, ruft Sie `provider` die- <xref:System.IFormatProvider.GetFormat%2A> Methode des-Parameters <xref:System.Type> auf und übergibt ihr <xref:System.Globalization.NumberFormatInfo> ein-Objekt, das den-Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode gibt dann <xref:System.Globalization.NumberFormatInfo> das-Objekt zurück, das Informationen `value` zum Format des-Parameters bereitstellt. Es gibt drei Möglichkeiten, den `provider` -Parameter zu verwenden, um benutzerdefinierte Formatierungsinformationen für den Analyse Vorgang bereitzustellen:  
  
-   Sie können ein <xref:System.Globalization.CultureInfo> -Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. <xref:System.Globalization.NumberFormatInfo> Die- <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt das-Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche <xref:System.Globalization.NumberFormatInfo> -Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben <xref:System.IFormatProvider>, das implementiert. Die- <xref:System.Globalization.NumberFormatInfo> Methode instanziiert und gibt das Objekt zurück, das Formatierungsinformationen bereitstellt. <xref:System.IFormatProvider.GetFormat%2A>  
  
 `provider` `value` Wenn den Wert <xref:System.Globalization.NumberFormatInfo> hat, wird die Formatierung von basierend auf dem-Objekt der aktuellen Kultur interpretiert. `null`  
  
   
  
## Examples  
 In den folgenden Beispielen werden zwei Möglichkeiten veranschaulicht, um die Tilde (~) als negatives Vorzeichen für <xref:System.Numerics.BigInteger> Formatierungs Werte zu definieren. Beachten Sie, dass der <xref:System.Numerics.BigInteger> Code die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType> -Methode aufrufen und das <xref:System.Globalization.NumberFormatInfo> -Objekt übergeben muss, das Formatierungsinformationen bereitstellt, um die Werte im gleichen Format wie die ursprünglichen Zeichen folgen anzuzeigen.  
  
 Im ersten Beispiel wird eine Klasse definiert, <xref:System.IFormatProvider> die implementiert und <xref:System.IFormatProvider.GetFormat%2A> die-Methode verwendet <xref:System.Globalization.NumberFormatInfo> , um das Objekt zurückzugeben, das Formatierungsinformationen bereitstellt.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Ein <xref:System.Numerics.BigInteger> -Objekt kann dann mit folgendem Code instanziiert werden:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Das zweite Beispiel ist einfacher. Das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt, `provider` wird an den-Parameter übergeben.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <paramref name="value" /> angeben.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `style` -Parameter definiert die Stilelemente (z. b. Leerzeichen, das positive oder negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen), die `value` im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. `styles`muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> -Enumeration sein. Der `style` -Parameter bewirkt, dass diese Methoden `value` Überladung nützlich ist, wenn die Zeichen folgen Darstellung eines hexadezimalen Werts enthält, wenn das Zahlensystem (Decimal `value` oder hexadezimal), das von dargestellt wird, nur zur Laufzeit bekannt ist oder wenn Sie Sie möchten Leerzeichen oder ein Vorzeichen Symbol in `value`nicht zulassen.  
  
 Abhängig vom Wert von `style`kann der `value` -Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*digits*,]*Ziffern*[*. fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn `style` `value` enthält <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>, kann der-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerräume können am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> - <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaft und die-Eigenschaft der Kultur `provider` definiert, die durch den-Parameter angegeben wird. Das Währungssymbol der aktuellen Kultur kann in `value` angezeigt werden, wenn <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> `style` das-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> wenn das-Flag enthält. Klammern können in `value` verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> -Flag einschließt.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Für *fractional_digits*ist nur die Ziffer 0 gültig.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der Kultur, die von `provider` angegeben wird, `value` kann `style` in angezeigt <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> werden, wenn das-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der Kultur, die von `provider` angegeben wird, `value` kann `style` in angezeigt <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> werden, wenn das-Flag enthält. Nur die Ziffer 0 (null) kann als eine Bruch Ziffer angezeigt werden, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Wenn *fractional_digits* eine beliebige andere Ziffer einschließt, <xref:System.FormatException> wird eine ausgelöst.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value` -Parameter kann eine Zahl in Exponentialnotation `style` darstellen, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) `s` in werden vom Analyse-Vorgang unabhängig vom Wert `style` des Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Format entspricht) entspricht, wird immer erfolgreich analysiert. Die meisten der Verb <xref:System.Globalization.NumberStyles> leibenden Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie sich einzelne Member auf die Elemente auswirken `value`, die in vorhanden sein können.  
  
|NumberStyles-Wert|Als Wert zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das *digits* -Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (.) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. zusammen mit *Exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist `value` jedoch nicht möglich, eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `value`, *Signieren* Sie am Anfang `value`von und das Dezimaltrennzeichen (.). Der `value` -Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die `ws`Elemente `sign`,, Gruppen Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Eine hexadezimale Zahl kann jedoch nicht dargestellt werden `value` .|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A> -Methode zum Roundtrip der Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> eines Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode ausgegeben wurde, sollten Sie <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> die-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung von zu generieren. <xref:System.Numerics.BigInteger> Wert. Andernfalls <xref:System.Numerics.BigInteger> behält die Zeichen folgen Darstellung von nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und die Daten gehen möglicherweise verloren, wenn <xref:System.Numerics.BigInteger.Parse%2A> Sie die-Methode <xref:System.Numerics.BigInteger> zum Wiederherstellen des Werts verwenden.  
  
 Anders als bei <xref:System.Globalization.NumberStyles> den anderen Werten, die das vorhanden sein bestimmter Stilelemente in `value`zulassen, bedeutet der <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> Stil Wert, dass die einzelnen numerischen Zeichen in `value` immer als hexadezimale Zeichen. Gültige hexadezimale Zeichen sind 0-9, a-f und A-f. Die einzigen anderen Flags, die mit dem `style` -Parameter kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> -Enumeration enthält einen zusammengesetzten Zahlen <xref:System.Globalization.NumberStyles.HexNumber>Stil,, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung ( `0x` z. b. oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29> , interpretiert `value` die Methode als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden `0x80`hexadezimalen Ziffern größer oder gleich sind. Das heißt, die-Methode interpretiert das Bit des ersten Bytes in `value` der höchsten Reihenfolge als Signier Bit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss `value` die erste Ziffer in den Wert 0 (null) aufweisen. Die-Methode interpretiert `0x80` z. b. als negativen Wert, interpretiert aber entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Der `provider` -Parameter ist <xref:System.IFormatProvider> eine-Implementierung. Die zugehörige- <xref:System.Globalization.NumberFormatInfo> `value`Methode gibt ein-Objekt zurück, das kulturspezifische Informationen zum Format von bereitstellt. <xref:System.IFormatProvider.GetFormat%2A> In der Regel kann eine der folgenden sein: `provider`  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. <xref:System.Globalization.NumberFormatInfo> Die- <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt das Objekt zurück, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt <xref:System.IFormatProvider> , das implementiert <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> und die-Methode verwendet, um das <xref:System.Globalization.NumberFormatInfo> Objekt zu instanziieren, das Formatierungsinformationen bereitstellt.  
  
 Wenn  `provider` den Wert <xref:System.Globalization.NumberFormatInfo> hat, wird das-Objekt für die aktuelle Kultur verwendet. `null`  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> -Methode mithilfe verschiedener Kombinationen von-Werten für den `style` -Parameter und den- `provider` Parameter durchführt.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Eine Reihe einzelner Aufrufe <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> der-Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negatives Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> folgt nicht dem mit <paramref name="style" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <paramref name="exponent" />. Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <paramref name="value" /> potenziert werden soll.</param>
        <summary>Potenziert einen <see cref="T:System.Numerics.BigInteger" />-Wert mit einem angegebenen Wert.</summary>
        <returns>Das Ergebnis der Potenzierung von <paramref name="value" /> mit <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Pow%2A> `value` -Methode gibt 1 zurück, wenn der Wert des Exponent-Parameters 0 ist, oder wenn die Werte `exponent` des-Parameters und des-Parameters 0 sind. Wenn `exponent` den Wert 1 hat <xref:System.Numerics.BigInteger.Pow%2A> , gibt `value`die Methode zurück. Wenn `value` negativ ist, gibt die Methode ein negatives Ergebnis zurück.  
  
 Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType> -Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die exponentialisierung mit <xref:System.Numerics.BigInteger> einem Wert und einem Exponenten, dessen Wert zwischen 0 und 10 liegt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Führt die Ganzzahldivision von zwei <see cref="T:System.Numerics.BigInteger" />-Werten aus und gibt den Rest zurück.</summary>
        <returns>Der Rest aus der Division von <paramref name="dividend" /> durch <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Vorzeichen des Restwerts ist das Vorzeichen des `dividend` Parameters.  
  
 Die <xref:System.Numerics.BigInteger.Remainder%2A> -Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen. Das Verhalten ist mit der Division identisch, wobei der Modulo-Operator verwendet wird.  
  
 Bei Bedarf führt die-Methode automatisch eine implizite Konvertierung von anderen ganzzahligen Typen in <xref:System.Numerics.BigInteger> Objekte aus, bevor Sie den Modulo-Vorgang ausführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Rest <xref:System.Numerics.BigInteger.DivRem%2A> der-Methode mit dem Rest verglichen, der von der <xref:System.Numerics.BigInteger.Remainder%2A> -Methode zurückgegeben wird, um festzulegen, dass die beiden Methoden identische Rest-Methoden berechnen  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zahl ab, die das Vorzeichen (negativ, positiv, oder 0 (null)) des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts angibt.</summary>
        <value>Eine Zahl, die das Vorzeichen des <see cref="T:System.Numerics.BigInteger" />-Objekts angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Anzahl 
 </term><description> Beschreibung 
 </description></listheader><item><term> -1 
 </term><description> Der Wert dieses Objekts ist negativ.  
  
 </description></item><item><term> 0 
 </term><description> Der Wert dieses Objekts ist null (0).  
  
 </description></item><item><term> 1 
 </term><description> Der Wert dieses Objekts ist positiv.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Sign%2A> -Eigenschaft entspricht der <xref:System.Math.Sign%2A?displayProperty=nameWithType> -Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen und gibt das Ergebnis zurück.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen <xref:System.Numerics.BigInteger.Subtract%2A> , können die-Methode verwenden <xref:System.Numerics.BigInteger> , um Subtraktion mithilfe von Werten auszuführen.  
  
 Die <xref:System.Numerics.BigInteger.Subtract%2A> -Methode ist ein nützlicher Ersatz für den Subtraktions Operator beim Instanziieren <xref:System.Numerics.BigInteger> einer Variablen, indem Sie Ihr den Unterschied aus der Subtraktion zuweist, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert einen <see cref="T:System.Numerics.BigInteger" />-Wert in ein Bytearray.</summary>
        <returns>Der Wert des aktuellen, in ein Bytearray konvertierten <see cref="T:System.Numerics.BigInteger" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im Array, die von dieser Methode zurückgegeben werden, werden in Little-in-der-Reihenfolge angezeigt Das heißt, die nieder wertigen Bytes des Werts vor den Bytes höherer Reihenfolge. Das erste Byte des Arrays reflektiert die ersten acht Bits des <xref:System.Numerics.BigInteger> Werts, das zweite Byte zeigt die nächsten acht Bits an usw. Beispielsweise wird der Wert 1024 oder 0x0400 als das folgende Array von zwei Bytes gespeichert:  
  
|Element|Bytewert|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Negative Werte werden in das Array geschrieben, wobei die zwei Komplement Darstellung in der möglichst kompakten Form verwendet wird. Beispielsweise wird-1 als einzelnes Byte dargestellt, dessen Wert anstelle von `0xFF` als Array mit mehreren Elementen ( `0xFF`z `0xFF` . b. oder `0xFF`, `0xFF` `0xFF`,, `0xFF`) ist.  
  
 Da in der zwei Komplement-Darstellung immer das höchste Bit des letzten Bytes im Array (das Byte an der Position <xref:System.Array.Length%2A?displayProperty=nameWithType> `- 1`) als Signier Bit interpretiert wird, gibt die Methode ein Bytearray mit einem zusätzlichen Element zurück, dessen Wert 0 (null) ist. Geben Sie positive Werte eindeutig an, die andernfalls so interpretiert werden können, dass Sie Ihre Signier Bits festgelegt haben. Beispielsweise wird der Wert 120 oder `0x78` als Einzel Byte-Array dargestellt:. `0x78` 128, oder `0x80`, wird jedoch als 2-Byte-Array dargestellt: `0x80`, `0x00`.  
  
 Sie können einen Roundtrip für <xref:System.Numerics.BigInteger> einen Wert durchsetzen, indem Sie ihn in einem Bytearray speichern <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> und dann mit dem-Konstruktor wiederherstellen.  
  
> [!CAUTION]
>  Wenn der Code den Wert einzelner Bytes in dem Array ändert, das von dieser Methode zurückgegeben wird, bevor der Wert wieder hergestellt wird, müssen Sie sicherstellen, dass das Signier Bit nicht versehentlich geändert wird. Wenn die Änderungen z. b. einen positiven Wert erhöhen, sodass das Bit mit der höchsten Ordnung im letzten Element des Byte Arrays festgelegt wird, können Sie ein neues Byte hinzufügen, dessen Wert 0 (null) bis zum Ende des Arrays ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, <xref:System.Numerics.BigInteger> wie einige Werte in Byte Arrays dargestellt werden.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <param name="isBigEndian"><see langword="true" />, um die Bytes in einer Big-Endian-Bytereihenfolge zu schreiben, andernfalls <see langword="false" />.</param>
        <summary>Liefert den Wert dieses <see cref="T:System.Numerics.BigInteger" /> als Bytearray mit der kleinstmöglichen Anzahl von Bytes. Wenn der Wert Null (0) ist, wird ein Array von einem Byte zurückgegeben, dessen Element 0x00 ist.</summary>
        <returns>Der Wert des aktuellen, in ein Bytearray konvertierten <see cref="T:System.Numerics.BigInteger" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der ganzzahlige Wert `33022` kann in vier unterschiedlichen Arrays exportiert werden:

| Eigenschaften                           | Ergebnis                          |
|--------------------------------------|---------------------------------|
| `isUnsigned: false, isBigEndian: false` | `new byte[] { 0xFE, 0x80, 0x00 }` |
| `isUnsigned: false, isBigEndian: true`  | `new byte[] { 0x00, 0x80, 0xFE }` |
| `isUnsigned: true, isBigEndian: false`  | `new byte[] { 0xFE, 0x80 } `      |
| `isUnsigned: true, isBigEndian: true`   | `new byte[] { 0x80, 0xFE }`       |

          ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wenn <paramref name="isUnsigned" /> <see langword="true" /> und <see cref="P:System.Numerics.BigInteger.Sign" /> negativ ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert im Format "R" oder im Roundtrip-Format der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen <xref:System.Numerics.BigInteger.ToString%2A> der-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts enthält ein negatives Vorzeichen, wenn der Wert negativ ist, und eine Folge von Ziffern zwischen 0 und 9 ohne führende Nullen. Das negative Vorzeichen wird durch das <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Wert mit der- <xref:System.Numerics.BigInteger.ToString> Standardmethode angezeigt. Außerdem werden die Zeichen folgen Darstellungen des <xref:System.Numerics.BigInteger> Werts angezeigt, der sich aus der Verwendung einiger Standardformat Bearbeiter ergibt. Die Beispiele werden mithilfe der Formatierungs Konventionen der Kultur "en-US" angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert im "R"-oder Roundtrip-Format unter Verwendung des <xref:System.Globalization.NumberFormatInfo> -Objekts einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen über Ladungen <xref:System.Numerics.BigInteger.ToString%2A> der-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der `provider` -Parameter ist <xref:System.IFormatProvider> eine-Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> zugehörige- <xref:System.Globalization.NumberFormatInfo> Methode gibt ein-Objekt zurück, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebenen Zeichenfolge bereitstellt. `provider` <xref:System.Numerics.BigInteger> Wenn den Wert <xref:System.Globalization.NumberFormatInfo> hat, wird der Wert mithilfe des-Objekts der aktuellen Kultur formatiert. `null` Die einzige Eigenschaft des <xref:System.Globalization.NumberFormatInfo> -Objekts, das die Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> des Werts mit dem allgemeinen Format Bezeichner steuert <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, ist, wodurch das Zeichen definiert wird, das das negative Vorzeichen darstellt.  
  
 Der `provider` Parameter kann eines der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, die Formatierungsinformationen bereitstellt.  
  
-   Das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.  
  
-   Ein benutzerdefiniertes Objekt <xref:System.IFormatProvider>, das implementiert. <xref:System.Globalization.NumberFormatInfo> Die- <xref:System.IFormatProvider.GetFormat%2A> Methode gibt das Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein benutzerdefiniertes <xref:System.Globalization.NumberFormatInfo> -Objekt instanziiert, das die Tilde (~) als negatives Vorzeichen definiert. Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29> -Methode verwendet dann das <xref:System.Globalization.NumberFormatInfo> benutzerdefinierte-Objekt, <xref:System.Numerics.BigInteger> um einen negativen Wert anzuzeigen.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="format" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%29> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format mithilfe <xref:System.Globalization.NumberFormatInfo> eines-Objekts, das die Konventionen der aktuellen Kultur darstellt. Wenn Sie "R" oder "Roundtrip" verwenden möchten, können Sie die anderen über Ladungen <xref:System.Numerics.BigInteger.ToString%2A> der-Methode wie folgt verwenden:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der `format` -Parameter kann eine beliebige gültige [numerische Standard Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md)oder eine beliebige Kombination von [benutzerdefinierten numerischen Format](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen sein. Wenn `format` <xref:System.Numerics.BigInteger> gleich oder ist `null`, wird der Rückgabewert des aktuellen-Objekts mit dem Roundtrip-Format Bezeichner ("R") formatiert. <xref:System.String.Empty?displayProperty=nameWithType> Wenn `format` ein beliebiger anderer Wert ist, löst die <xref:System.FormatException>Methode eine aus.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Unterstützung der Formatierung in der .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Das Format der zurückgegebenen Zeichenfolge wird durch das <xref:System.Globalization.NumberFormatInfo> -Objekt für die aktuelle Kultur bestimmt. Abhängig vom `format` -Parameter steuert dieses-Objekt Symbole wie das negative Vorzeichen, das Gruppen Trennzeichen und das Dezimaltrennzeichen in der Ausgabe Zeichenfolge. Um Formatierungsinformationen für andere Kulturen als die aktuelle Kultur bereitzustellen, <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> müssen Sie die-Überladung aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Wert initialisiert und mit den einzelnen Standardformat Zeichenfolgen und einigen benutzerdefinierten Format Zeichenfolgen angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats und der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts entsprechend den Angaben in den Parametern <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode formatiert einen <xref:System.Numerics.BigInteger> Wert in einem angegebenen Format unter <xref:System.Globalization.NumberFormatInfo> Verwendung des-Objekts einer angegebenen Kultur. Wenn Sie das Roundtrip-Format oder die Standard Kultur Einstellungen verwenden möchten, verwenden Sie die anderen über Ladungen <xref:System.Numerics.BigInteger.ToString%2A> der-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Der `format` -Parameter kann eine beliebige gültige [numerische Standard Zeichenfolge](~/docs/standard/base-types/standard-numeric-format-strings.md)oder eine beliebige Kombination von [benutzerdefinierten numerischen Format](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen sein. Wenn `format` <xref:System.Numerics.BigInteger> gleich oder ist `null`, wird der Rückgabewert des aktuellen-Objekts mit dem Roundtrip-Format Bezeichner ("R") formatiert. <xref:System.String.Empty?displayProperty=nameWithType> Wenn `format` ein beliebiger anderer Wert ist, löst die <xref:System.FormatException>Methode eine aus.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.  
  
-   Weitere Informationen zur Unterstützung der Formatierung in der .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).  
  
 Der `provider` -Parameter ist <xref:System.IFormatProvider> eine-Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A> zugehörige- <xref:System.Globalization.NumberFormatInfo> Methode gibt ein-Objekt zurück, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebenen Zeichenfolge bereitstellt. Wenn die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode aufgerufen wird, ruft Sie `provider` die- <xref:System.IFormatProvider.GetFormat%2A> Methode des-Parameters <xref:System.Type> auf und übergibt ihr <xref:System.Globalization.NumberFormatInfo> ein-Objekt, das den-Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A> -Methode gibt dann <xref:System.Globalization.NumberFormatInfo> das-Objekt zurück, das Informationen `value` zum Formatieren des-Parameters bereitstellt, z. b. das negative Vorzeichen Symbol, das Gruppen Trennzeichen Symbol oder das Dezimaltrennzeichen. Es gibt drei Möglichkeiten, den `provider` -Parameter zu verwenden, um Formatierungsinformationen für die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> -Methode bereitzustellen:  
  
-   Sie können ein <xref:System.Globalization.CultureInfo> -Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. <xref:System.Globalization.NumberFormatInfo> Die- <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt das-Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche <xref:System.Globalization.NumberFormatInfo> -Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben <xref:System.IFormatProvider>, das implementiert. Die- <xref:System.Globalization.NumberFormatInfo> Methode instanziiert und gibt das Objekt zurück, das Formatierungsinformationen bereitstellt. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Wenn  `provider` den Wert <xref:System.Globalization.NumberFormatInfo> hat, basiert die Formatierung der zurückgegebenen Zeichenfolge auf dem-Objekt der aktuellen Kultur. `null`  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> -Wert initialisiert und mithilfe einer Standardformat Zeichenfolge und einem <xref:System.Globalization.NumberFormatInfo> -Objekt, das die Tilde (~) als negatives Vorzeichen definiert, der Konsole angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = null, IFormatProvider provider = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; *  * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">To be added.</param>
        <param name="charsWritten">To be added.</param>
        <param name="format">To be added.</param>
        <param name="provider">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder null (0), wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="value" />-Parameter <see langword="null" /> ist oder nicht im korrekten Format vorliegt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> -Methode ähnelt der <xref:System.Numerics.BigInteger.Parse%28System.String%29> -Methode, mit der Ausnahme, dass keine Ausnahme ausgelöst wird, wenn bei der Konvertierung ein Fehler auftritt. Mit dieser Methode entfällt die Notwendigkeit, die Ausnahmebehandlung zum Testen auf <xref:System.FormatException> einen `value` zu verwenden, wenn ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `value` -Parameter sollte die Zeichen folgen Darstellung einer Dezimalzahl in der folgenden Form sein:  
  
 [*WS*] [*Sign*] *Ziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden von der <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> -Eigenschaft und der- <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> Eigenschaft der aktuellen Kultur bestimmt.|  
|*Ziffern*|Eine Sequenz von Dezimalziffern im Bereich von 0 bis 9.|  
  
> [!NOTE]
>  Die vom `value` -Parameter angegebene Zeichenfolge darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und Sie darf keinen Dezimalteil enthalten.  
  
 Der `value` -Parameter wird mit dem <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> -Stil interpretiert. Zusätzlich zu den Dezimalziffern sind nur führende und nachfolgende Leerzeichen mit einem vorangestellten Zeichen zulässig. Um die Stilelemente mit den kulturspezifischen Formatierungsinformationen, die in `value`vorhanden sein können, explizit zu definieren, müssen Sie die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> -Methode aufzurufen.  
  
 Der `value` -Parameter wird analysiert, indem die Formatierungsinformationen in <xref:System.Globalization.NumberFormatInfo> einem-Objekt für die aktuelle Kultur verwendet werden. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Diese Überladung interpretiert alle Ziffern im `value` -Parameter als Dezimalziffern. Um die Zeichen folgen Darstellung einer hexadezimalen Zahl zu analysieren, müssen <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Sie stattdessen die-Überladung aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29> -Methode verwendet, um zwei <xref:System.Numerics.BigInteger> -Objekte zu instanziieren. Wenn die Konvertierungen erfolgreich sind, wird jedes Objekt mit einer anderen Zahl multipliziert und dann <xref:System.Numerics.BigInteger.Compare%2A> die-Methode aufgerufen, um die Beziehung zwischen den beiden-Objekten zu bestimmen.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="value">To be added.</param>
        <param name="style">To be added.</param>
        <param name="provider">To be added.</param>
        <param name="result">To be added.</param>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider *  -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl. Die Zeichenfolge wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="value" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder <see cref="P:System.Numerics.BigInteger.Zero" />, wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="value" />-Parameter gleich <see langword="null" /> ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturspezifischen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" /> und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich abgeschlossen wurde.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> -Methode ähnelt der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> -Methode, mit der Ausnahme, dass keine Ausnahme ausgelöst wird, wenn bei der Konvertierung ein Fehler auftritt. Mit dieser Methode entfällt die Notwendigkeit, die Ausnahmebehandlung zum Testen auf <xref:System.FormatException> einen `value` zu verwenden, wenn ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `style` -Parameter definiert die Stilelemente (z. b. Leerzeichen oder ein positives oder negatives Zeichen), die `value` im-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> -Enumeration handeln. Abhängig vom Wert von `style`kann der `value` -Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*digits*,]*digits*[. *fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn der `style` -Parameter <xref:System.Globalization.NumberStyles.AllowHexSpecifier>enthält, `value` kann der-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern* [*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|Beschreibung|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> -Flag enthält, oder am Ende `value` von `style` , wenn <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType> das-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A> -Eigenschaft <xref:System.Globalization.NumberFormatInfo> des-Objekts definiert, <xref:System.IFormatProvider.GetFormat%2A> das `provider` von der-Methode des-Parameters zurückgegeben wird. Das Währungssymbol kann in `value` angezeigt werden, wenn <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType> `style` das-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang von `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType> -Flag enthält, und es kann am Ende von `value` angezeigt `style` werden, <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType> wenn das-Flag enthält. Klammern können in `value` verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType> -Flag einschließt.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der Kultur, die `provider` von angegeben wird `value` , `style` kann in <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType> angezeigt werden, wenn das-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der Kultur, die von `provider` angegeben wird, `value` kann `style` in angezeigt <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> werden, wenn das-Flag enthält.|  
|*fractional_digits*|Mindestens ein Vorkommen der Ziffer 0 (null). Bruch Ziffern können nur in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType> -Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value` -Parameter kann eine Zahl in Exponentialnotation `style` darstellen, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Der `value` -Parameter kann eine Zahl in Exponentialnotation `style` darstellen, <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType> wenn das-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) `s` in werden vom Analyse-Vorgang unabhängig vom Wert `style` des Arguments ignoriert.

 Eine Zeichenfolge mit nur Dezimalziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> -Flag entspricht) wird immer erfolgreich analysiert. Die meisten der Verb <xref:System.Globalization.NumberStyles> leibenden Member steuern Elemente, die in dieser Eingabe Zeichenfolge vorhanden sein können, aber nicht vorhanden sein müssen. In der folgenden Tabelle wird angegeben <xref:System.Globalization.NumberStyles> , wie sich einzelne Member auf die Elemente auswirken `value`, die in vorhanden sein können.  
  
|Nicht zusammengesetzte `NumberStyles` Werte|Als Wert zulässige Elemente zusätzlich zu Ziffern|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur Dezimalziffern.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (*.*) und *fractional_digits* Elemente. *Fractional_digits* muss jedoch nur aus einer oder mehreren 0 Ziffern bestehen, oder die Methode gibt zurück `false`.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialnotation angibt, zusammen mit *Exponential_digits*. Wenn `value` eine Zahl in Exponentialnotation darstellt, kann Sie keine Bruchteil-Komponente ungleich 0 (null) aufweisen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende von `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Vorzeichen* Element vor *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element nach *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (*,*).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency (*$*)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. Es ist `value` jedoch nicht möglich, eine hexadezimale Zahl oder eine Zahl in Exponentialnotation darzustellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende von `value`, *Signieren* Sie am Anfang `value`von und das Dezimaltrennzeichen (*.*). Der `value` -Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente *WS*, *Sign*, Group Separator (*,*) und Decimal Point (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Eine hexadezimale Zahl kann jedoch nicht dargestellt werden `value` .|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.TryParse%2A> -Methode zum Roundtrip der Zeichen folgen Darstellung <xref:System.Numerics.BigInteger> eines Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A> -Methode ausgegeben wurde, sollten Sie <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType> die-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung von zu generieren. <xref:System.Numerics.BigInteger> Wert. Andernfalls <xref:System.Numerics.BigInteger> behält die Zeichen folgen Darstellung von nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und die Daten gehen möglicherweise verloren, wenn <xref:System.Numerics.BigInteger.TryParse%2A> Sie die-Methode <xref:System.Numerics.BigInteger> zum Wiederherstellen des Werts verwenden.  
  
 Wenn das <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType> -Flag verwendet wird `value` , muss ein Hexadezimalwert sein. Die einzigen anderen Flags, die in `style` vorhanden sein können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles> -Enumeration verfügt über einen zusammen <xref:System.Globalization.NumberStyles.HexNumber>gesetzten Stil,, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung ( `0x` z. b. oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> , interpretiert `value` die Methode als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden `0x80`hexadezimalen Ziffern größer oder gleich sind. Das heißt, die-Methode interpretiert das Bit des ersten Bytes in `value` der höchsten Reihenfolge als Signier Bit. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss `value` die erste Ziffer in den Wert 0 (null) aufweisen. Die-Methode interpretiert `0x80` z. b. als negativen Wert, interpretiert aber entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Der `provider` -Parameter ist <xref:System.IFormatProvider> eine-Implementierung. Die zugehörige- <xref:System.Globalization.NumberFormatInfo> `value`Methode gibt ein-Objekt zurück, das kulturspezifische Informationen zum Format von bereitstellt. <xref:System.IFormatProvider.GetFormat%2A> Der `provider` Parameter kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo> -Objekt, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. <xref:System.Globalization.NumberFormatInfo> Die- <xref:System.Globalization.CultureInfo.GetFormat%2A> Methode gibt das-Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo> -Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> gibt nur sich selbst zurück.)  
  
-   Ein benutzerdefiniertes Objekt <xref:System.IFormatProvider>, das implementiert. Die- <xref:System.Globalization.NumberFormatInfo> Methode instanziiert und gibt das Objekt zurück, das Formatierungsinformationen bereitstellt. <xref:System.IFormatProvider.GetFormat%2A>  
  
 Wenn  `provider` den Wert <xref:System.Globalization.NumberFormatInfo> hat, wird das-Objekt für die aktuelle Kultur verwendet. `null`  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige Aufrufe der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> -Methode mithilfe verschiedener Kombinationen von-Werten für den `style` -Parameter und den- `provider` Parameter durchführt.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Eine Reihe einzelner Aufrufe <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> der-Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negatives Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
- oder - 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; *  * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1" />
      </Parameters>
      <Docs>
        <param name="destination">Die Zielspanne, in die die resultierenden Bytes geschrieben werden sollen.</param>
        <param name="bytesWritten">Die Anzahl der Bytes, die in <paramref name="destination" /> geschrieben wurden.</param>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <param name="isBigEndian"><see langword="true" />, um die Bytes in einer Big-Endian-Bytereihenfolge zu schreiben, andernfalls <see langword="false" />.</param>
        <summary>Kopiert den Wert dieses <see cref="T:System.Numerics.BigInteger" /> als Little-Endian-Zweierkomplementbytes mit der geringstmöglichen Anzahl von Bytes. Wenn der Wert Null (0) ist, wird nur ein Byte ausgegeben, dessen Element 0x00 ist.</summary>
        <returns><see langword="true" />, wenn die Bytes in <paramref name="destination" /> passen. <see langword="false" />, wenn aufgrund von unzureichendem Speicherplatz nicht alle Bytes geschrieben werden konnten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><paramref name="isUnsigned" /> ist <see langword="true" /> und <see cref="P:System.Numerics.BigInteger.Sign" /> ist negativ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl null (0) darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert 0 (null) ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Numerics.BigInteger> von dieser Eigenschaft zurückgegebene-Objekt stellt eine bequeme Quelle für einen Nullwert zur Verwendung in Zuweisungen und vergleichen dar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
