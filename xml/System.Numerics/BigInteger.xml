<Type Name="BigInteger" FullName="System.Numerics.BigInteger">
  <Metadata><Meta Name="ms.openlocfilehash" Value="a83b499066a003431210b6940c1ec1e2ff9a37c6" /><Meta Name="ms.sourcegitcommit" Value="11d168140aa8fade0768c2a9dde3e3bcacfdfb7d" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="05/27/2020" /><Meta Name="ms.locfileid" Value="83893327" /></Metadata><TypeSignature Language="C#" Value="public struct BigInteger : IComparable, IComparable&lt;System.Numerics.BigInteger&gt;, IEquatable&lt;System.Numerics.BigInteger&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.BigInteger" />
  <TypeSignature Language="VB.NET" Value="Public Structure BigInteger&#xA;Implements IComparable, IComparable(Of BigInteger), IEquatable(Of BigInteger), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class BigInteger : IComparable, IComparable&lt;System::Numerics::BigInteger&gt;, IEquatable&lt;System::Numerics::BigInteger&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type BigInteger = struct&#xA;    interface IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit BigInteger extends System.ValueType implements class System.IComparable, class System.IComparable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IEquatable`1&lt;valuetype System.Numerics.BigInteger&gt;, class System.IFormattable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Numerics" FromVersion="4.0.0.0" To="System.Runtime.Numerics" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
    <TypeForwarding From="netstandard" FromVersion="2.1.0.0" To="System.Runtime.Numerics" ToVersion="5.0.0.0" FrameworkAlternate="net-5.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IComparable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IComparable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.BigInteger&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
      <AttributeName>System.Runtime.CompilerServices.IsReadOnly</AttributeName>
    </Attribute>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Stellt eine beliebig große ganze Zahl mit Vorzeichen dar.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Numerics.BigInteger> Typ ist ein unveränderlicher Typ, der eine beliebig große ganze Zahl darstellt, deren Wert theoretisch keine oberen oder unteren Begrenzungen aufweist. Die Member des <xref:System.Numerics.BigInteger> geben die Typen von anderen ganzzahligen Typen (<xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.Int64>, <xref:System.SByte>, <xref:System.UInt16>, <xref:System.UInt32>und <xref:System.UInt64>) eng an. Dieser Typ unterscheidet sich von den anderen ganzzahligen Typen im [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)], die über einen Bereich verfügen, der durch ihre `MinValue`-und `MaxValue`-Eigenschaften angegeben wird.  
  
> [!NOTE]
>  Da der <xref:System.Numerics.BigInteger> Typ unveränderlich ist (siehe [muability und BigInteger-Struktur](#mutability)) und da er keine oberen oder unteren Grenzen aufweist, kann ein <xref:System.OutOfMemoryException> für jeden Vorgang ausgelöst werden, der bewirkt, dass ein <xref:System.Numerics.BigInteger> Wert zu groß wird.  
  
## <a name="instantiating-a-biginteger-object"></a>Instanziieren eines BigInteger-Objekts  
 Sie können ein <xref:System.Numerics.BigInteger> Objekt auf verschiedene Weise instanziieren:  
  
-   Sie können das `new`-Schlüsselwort verwenden und einen beliebigen ganzzahligen oder Gleit Komma Wert als Parameter für den <xref:System.Numerics.BigInteger>-Konstruktor angeben. (Gleit Komma Werte werden abgeschnitten, bevor Sie dem <xref:System.Numerics.BigInteger>zugewiesen werden.) Im folgenden Beispiel wird veranschaulicht, wie Sie das `new`-Schlüsselwort verwenden, um <xref:System.Numerics.BigInteger> Werte zu instanziieren.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#1)]
     [!code-vb[System.Numerics.BigInteger.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#1)]  
  
-   Sie können eine <xref:System.Numerics.BigInteger> Variable deklarieren und ihr einen Wert wie jeden beliebigen numerischen Typ zuweisen, solange dieser Wert ein ganzzahliger Typ ist. Im folgenden Beispiel wird die Zuweisung verwendet, um einen <xref:System.Numerics.BigInteger> Wert aus einer <xref:System.Int64>zu erstellen.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#2)]
     [!code-vb[System.Numerics.BigInteger.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#2)]  
  
-   Sie können einem <xref:System.Numerics.BigInteger> Objekt einen Dezimal-oder Gleit Komma Wert zuweisen, wenn Sie den Wert umwandeln oder ihn zuerst konvertieren. Im folgenden Beispiel werden ein <xref:System.Double> und C#ein <xref:System.Decimal>-Wert explizit in ein-<xref:System.Numerics.BigInteger>umgewandelt (in) oder konvertiert (in Visual Basic).  
  
     [!code-csharp[System.Numerics.BigInteger.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#3)]
     [!code-vb[System.Numerics.BigInteger.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#3)]  
  
 Diese Methoden ermöglichen es Ihnen, ein <xref:System.Numerics.BigInteger> Objekt zu instanziieren, dessen Wert nur im Bereich von einem der vorhandenen numerischen Typen liegt. Sie können ein <xref:System.Numerics.BigInteger> Objekt instanziieren, dessen Wert den Bereich der vorhandenen numerischen Typen auf eine von drei Arten überschreiten kann:  
  
-   Sie können das `new`-Schlüsselwort verwenden und ein Bytearray beliebiger Größe für den <xref:System.Numerics.BigInteger.%23ctor%2A?displayProperty=nameWithType>-Konstruktor bereitstellen. Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#4)]
     [!code-vb[System.Numerics.BigInteger.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#4)]  
  
-   Sie können die Methoden <xref:System.Numerics.BigInteger.Parse%2A> oder <xref:System.Numerics.BigInteger.TryParse%2A> aufzurufen, um die Zeichen folgen Darstellung einer Zahl in eine <xref:System.Numerics.BigInteger>zu konvertieren. Beispiel:  
  
     [!code-csharp[System.Numerics.BigInteger.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#5)]
     [!code-vb[System.Numerics.BigInteger.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#5)]  
  
-   Sie können eine `static` (`Shared` in Visual Basic) <xref:System.Numerics.BigInteger> Methode aufzurufen, die einen Vorgang für einen numerischen Ausdruck ausführt und ein berechnetes <xref:System.Numerics.BigInteger> Ergebnis zurückgibt. Im folgenden Beispiel wird dies durch das <xref:System.UInt64.MaxValue?displayProperty=nameWithType> und Zuweisen des Ergebnisses zu einem <xref:System.Numerics.BigInteger>bewirkt.  
  
     [!code-csharp[System.Numerics.BigInteger.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/cs/BigInteger_Examples.cs#6)]
     [!code-vb[System.Numerics.BigInteger.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class/vb/BigInteger_Examples.vb#6)]  
  
 Der nicht initialisierte Wert eines <xref:System.Numerics.BigInteger> ist <xref:System.Numerics.BigInteger.Zero%2A>.  
  
## <a name="performing-operations-on-biginteger-values"></a>Ausführen von Vorgängen für BigInteger-Werte  
 Sie können eine <xref:System.Numerics.BigInteger> Instanz verwenden, wie Sie einen beliebigen anderen integralen Typ verwenden würden. <xref:System.Numerics.BigInteger> über lädt die standardmäßigen numerischen Operatoren, damit Sie grundlegende mathematische Operationen wie Addition, Subtraktion, Division, Multiplikation, Subtraktion, Negation und unäre Negation durchführen können. Sie können auch die standardmäßigen numerischen Operatoren verwenden, um zwei <xref:System.Numerics.BigInteger> Werte miteinander zu vergleichen. Wie die anderen ganzzahligen Typen unterstützt <xref:System.Numerics.BigInteger> auch die bitweisen Operatoren `And`, `Or`, `XOr`, Links Schiebe und rechts Schiebe. Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, stellt die <xref:System.Numerics.BigInteger> Struktur auch äquivalente Methoden zum Durchführen mathematischer Operationen bereit. Dazu zählen <xref:System.Numerics.BigInteger.Add%2A>, <xref:System.Numerics.BigInteger.Divide%2A>, <xref:System.Numerics.BigInteger.Multiply%2A>, <xref:System.Numerics.BigInteger.Negate%2A>, <xref:System.Numerics.BigInteger.Subtract%2A>und mehrere andere.  
  
 Viele Member der <xref:System.Numerics.BigInteger> Struktur entsprechen direkt den Membern der anderen ganzzahligen Typen. Außerdem werden von <xref:System.Numerics.BigInteger> Mitglieder wie die folgenden hinzugefügt:  
  
-   <xref:System.Numerics.BigInteger.Sign%2A>, der einen Wert zurückgibt, der das Vorzeichen eines <xref:System.Numerics.BigInteger> Werts angibt.  
  
-   <xref:System.Numerics.BigInteger.Abs%2A>, die den absoluten Wert eines <xref:System.Numerics.BigInteger> Werts zurückgibt.  
  
-   <xref:System.Numerics.BigInteger.DivRem%2A>, die den Quotienten und den Rest eines Divisions Vorgangs zurückgibt.  
  
-   <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>, die den größten gemeinsamen Divisor von zwei <xref:System.Numerics.BigInteger> Werten zurückgibt.  
  
 Viele dieser zusätzlichen Member entsprechen den Membern der <xref:System.Math>-Klasse, die die Funktionalität zum Arbeiten mit den primitiven numerischen Typen bereitstellt.  
  
<a name="mutability"></a>   
## <a name="mutability-and-the-biginteger-structure"></a>Muability und BigInteger-Struktur  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Objekt instanziiert und anschließend der Wert um eins erhöht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#1)]  
  
 Obwohl in diesem Beispiel der Wert des vorhandenen Objekts geändert wird, ist dies nicht der Fall. <xref:System.Numerics.BigInteger> Objekte sind unveränderlich, d. h., der Common Language Runtime erstellt tatsächlich ein neues <xref:System.Numerics.BigInteger> Objekt und weist ihm einen Wert zu, der größer als der vorherige Wert ist. Dieses neue Objekt wird dann an den Aufrufer zurückgegeben.  
  
> [!NOTE]
>  Die anderen numerischen Typen in der .NET Framework sind ebenfalls unveränderlich. Da der <xref:System.Numerics.BigInteger>-Typ jedoch keine oberen oder unteren Grenzen aufweist, können seine Werte sehr groß werden und eine messbare Auswirkung auf die Leistung haben.  
  
 Obwohl dieser Prozess für den Aufrufer transparent ist, wird eine Leistungs Einbuße verursacht. In einigen Fällen, insbesondere wenn wiederholte Vorgänge in einer Schleife für sehr große <xref:System.Numerics.BigInteger> Werte ausgeführt werden, kann diese Leistungs Einbuße erheblich sein. Im folgenden Beispiel wird ein Vorgang wiederholt bis zu einer Million Male ausgeführt, und ein <xref:System.Numerics.BigInteger> Wert wird jedes Mal um eins erhöht, wenn der Vorgang erfolgreich ausgeführt wird.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#12)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#12)]  
  
 In einem solchen Fall können Sie die Leistung verbessern, indem Sie alle zwischen Zuweisungen zu einer <xref:System.Int32> Variablen ausführen. Der endgültige Wert der Variablen kann dann dem <xref:System.Numerics.BigInteger> Objekt zugewiesen werden, wenn die Schleife beendet wird. Dies wird im folgenden Beispiel veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/cs/Mutability_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.Mutability#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.Mutability/vb/Mutability_Examples.vb#3)]  
  
## <a name="working-with-byte-arrays-and-hexadecimal-strings"></a>Arbeiten mit Byte Arrays und hexadezimal Zeichenfolgen  
 Wenn Sie <xref:System.Numerics.BigInteger> Werte in Byte Arrays konvertieren oder wenn Sie Bytearrays in <xref:System.Numerics.BigInteger> Werte konvertieren, müssen Sie die Reihenfolge der Bytes in Erwägung gezogen. Die <xref:System.Numerics.BigInteger> Struktur erwartet, dass die einzelnen Bytes in einem Bytearray in Little-Endian-Reihenfolge angezeigt werden (d. h., die niedrigeren Bytes des Werts vor den Bytes höherer Ordnung). Sie können einen Roundtrip für einen <xref:System.Numerics.BigInteger> Wert durchführen, indem Sie die <xref:System.Numerics.BigInteger.ToByteArray%2A>-Methode aufrufen und dann das resultierende Bytearray an den <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor übergeben, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#1)]  
  
 Zum Instanziieren eines <xref:System.Numerics.BigInteger> Werts aus einem Bytearray, das einen Wert eines anderen ganzzahligen Typs darstellt, können Sie den ganzzahligen Wert an die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>-Methode übergeben und dann das resultierende Bytearray an den <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor übergeben. Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Wert aus einem Bytearray instanziiert, das einen <xref:System.Int16>-Wert darstellt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger>-Struktur geht davon aus, dass negative Werte mithilfe der Komplement-Darstellung von zwei gespeichert werden. Da die <xref:System.Numerics.BigInteger> Struktur einen numerischen Wert ohne eine Länge mit fester Länge darstellt, interpretiert der <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor immer das signifikanteste Bit des letzten Bytes im Array als Signier Bit. Um zu verhindern, dass der <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor die zwei Komplement Darstellung eines negativen Werts mit der Vorzeichen-und Größen Darstellung eines positiven Werts verwechselt, sollten positive Werte, bei denen das höchst wertige Bit des letzten Bytes im Bytearray normalerweise festgelegt wird, ein zusätzliches Byte enthalten, dessen Wert 0 ist. Beispielsweise ist 0xC0 0xbd 0xF 0xFF die Little-de-hexadezimale Darstellung von-1 Million oder 4.293.967.296. Da das signifikanteste Bit des letzten Bytes in diesem Array on ist, wird der Wert des Bytearrays vom <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor als-1 Million interpretiert. Um einen <xref:System.Numerics.BigInteger> zu instanziieren, dessen Wert positiv ist, muss ein Bytearray, dessen Elemente 0xC0 0xbd 0xF0 0xFF 0x00 lauten, an den-Konstruktor übergeben werden. Dies wird anhand des folgenden Beispiels veranschaulicht.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#3)]  
  
 Byte Arrays, die von der <xref:System.Numerics.BigInteger.ToByteArray%2A>-Methode aus positiven Werten erstellt werden, enthalten dieses zusätzliche Byte mit dem Wert NULL. Aus diesem Grund kann die <xref:System.Numerics.BigInteger> Struktur erfolgreich Roundtrip-Werte durch Zuweisen der Werte durch zuweisen und deren Wiederherstellung in Byte Arrays, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#4)]  
  
 Sie müssen jedoch möglicherweise dieses zusätzliche NULL-Wert-Byte zu Byte Arrays hinzufügen, die dynamisch vom Entwickler erstellt werden oder von Methoden zurückgegeben werden, die ganzzahlige Ganzzahlen ohne Vorzeichen in Byte Arrays konvertieren (z. b. <xref:System.BitConverter.GetBytes%28System.UInt16%29?displayProperty=nameWithType>, <xref:System.BitConverter.GetBytes%28System.UInt32%29?displayProperty=nameWithType>und <xref:System.BitConverter.GetBytes%28System.UInt64%29?displayProperty=nameWithType>).  
  
 Beim Auswerten einer hexadezimalen Zeichenfolge wird von den <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29?displayProperty=nameWithType>-und <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29?displayProperty=nameWithType> Methoden angenommen, dass der Wert mithilfe der Komplement-Darstellung zweier Elemente dargestellt wird, wenn das signifikanteste Bit des ersten Bytes in der Zeichenfolge festgelegt ist oder wenn die erste hexadezimal Ziffer der Zeichenfolge die unteren vier Bits eines Bytewerts darstellt. Beispielsweise stellen sowohl "FF01" als auch "F01" den Dezimalwert-255 dar. Positive Werte sollten eine führende Null enthalten, um positiv von negativen Werten zu unterscheiden. Die relevanten über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A> Methode, wenn Sie die Format Zeichenfolge "X" erhalten, fügen der zurückgegebenen hexadezimal Zeichenfolge für positive Werte eine führende Null hinzu. Dies ermöglicht es, <xref:System.Numerics.BigInteger> Werte mithilfe der Methoden <xref:System.Numerics.BigInteger.ToString%2A> und <xref:System.Numerics.BigInteger.Parse%2A> zu Roundtrip, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples.vb#5)]  
  
 Die hexadezimal Zeichenfolgen, die durch Aufrufen der `ToString` Methoden der anderen ganzzahligen Typen oder der über Ladungen der <xref:System.Convert.ToString%2A> Methode erstellt werden, die einen `toBase`-Parameter enthalten, geben jedoch nicht das Vorzeichen des Werts oder den Quell Datentyp an, von dem die hexadezimale Zeichenfolge abgeleitet wurde. Die erfolgreiche Instanziierung eines <xref:System.Numerics.BigInteger> Werts aus einer solchen Zeichenfolge erfordert einige zusätzliche Logik. Im folgenden Beispiel wird eine mögliche Implementierung bereitstellt.  
  
 [!code-csharp[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/cs/ByteAndHex_Examples2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Class.ByteAndHex#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Class.ByteAndHex/vb/ByteAndHex_Examples2.vb#6)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (byte[] value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int8[] value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Byte[])" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Byte())" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(cli::array &lt;System::Byte&gt; ^ value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : byte[] -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.Byte[]" />
      </Parameters>
      <Docs>
        <param name="value">Ein Array der Bytewerte in Little-Endian-Reihenfolge.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung der Werte in einem Bytearray.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im `value` Array sollten in Little-Endian-Reihenfolge, vom Byte der untersten Reihenfolge bis zum Byte der höchsten Reihenfolge sein. Beispielsweise wird der numerische Wert 1 Billion dargestellt, wie in der folgenden Tabelle dargestellt:  
  
|||  
|-|-|  
|Hexadezimale Zeichenfolge|E8D4A51000|  
|Bytearray (der niedrigste Index zuerst)|00 10 A5 D4 E8 00|  
  
 Die meisten Methoden, die numerische Werte in Byte Arrays konvertieren, z. b. <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType> und <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>, geben Byte Arrays in Little-Endian-Reihenfolge zurück.  
  
 Der Konstruktor erwartet positive Werte im Bytearray, um die Darstellung der Signierung zu verwenden, und negative Werte, um die zwei Komplement Darstellung zu verwenden. Anders ausgedrückt: Wenn das-Bit der höchsten Ordnung im `value` mit der höchsten Reihenfolge festgelegt ist, ist der resultierende <xref:System.Numerics.BigInteger> Wert negativ. Abhängig von der Quelle des Bytearrays kann dies dazu führen, dass ein positiver Wert als negativer Wert fehlinterpretiert wird. Byte Arrays werden in der Regel auf folgende Weise generiert:  
  
-   Durch Aufrufen der <xref:System.Numerics.BigInteger.ToByteArray%2A?displayProperty=nameWithType>-Methode. Da diese Methode ein Bytearray zurückgibt, bei dem das Bit der höchsten Reihenfolge im Array für positive Werte auf 0 (null) festgelegt ist, besteht keine Gefahr, dass ein positiver Wert als negativ interpretiert wird. Nicht geänderte Byte Arrays, die von der <xref:System.Numerics.BigInteger.ToByteArray%2A>-Methode erstellt werden, werden immer erfolgreich ausgeführt, wenn Sie an den <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29>-Konstruktor übergeben werden.  
  
-   Durch Aufrufen der <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>-Methode und übergeben einer Ganzzahl mit Vorzeichen als Parameter. Da ganze Zahlen mit Vorzeichen sowohl die Darstellung von Vorzeichen als auch die Größe und die Komplement Darstellung von zwei verarbeiten, besteht keine Gefahr, dass ein positiver Wert als negativ interpretiert wird.  
  
-   Rufen Sie die <xref:System.BitConverter.GetBytes%2A?displayProperty=nameWithType>-Methode auf, und übergeben Sie eine ganze Zahl ohne Vorzeichen als Parameter. Da ganze Zahlen ohne Vorzeichen nur durch ihre Größe dargestellt werden, können positive Werte als negative Werte interpretiert werden. Um diese Fehlinterpretation zu verhindern, können Sie am Ende des Arrays einen 0-Byte-Wert hinzufügen. Das Beispiel im nächsten Abschnitt enthält eine Abbildung.  
  
-   Durch das Erstellen eines Bytearrays entweder dynamisch oder statisch, ohne dass notwendigerweise eine der vorherigen Methoden aufgerufen wird, oder durch Ändern eines vorhandenen Bytearrays. Um zu verhindern, dass positive Werte als negative Werte interpretiert werden, können Sie am Ende des Arrays einen 0-Byte-Wert hinzufügen.  
  
 Wenn `value` ein leeres <xref:System.Byte> Array ist, wird das neue <xref:System.Numerics.BigInteger> Objekt mit dem Wert <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>initialisiert. Wenn `value` `null`ist, löst der Konstruktor eine <xref:System.ArgumentNullException>aus.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Objekt aus einem Bytearray mit fünf Elementen instanziiert, dessen Wert {5, 4, 3, 2, 1} ist. Anschließend wird der <xref:System.Numerics.BigInteger> Wert, der als Dezimal-und hexadezimal Zahl dargestellt wird, in der Konsole angezeigt. Durch einen Vergleich des Eingabe Arrays mit der Textausgabe wird klar, warum diese Überladung des <xref:System.Numerics.BigInteger>-Klassenkonstruktors ein <xref:System.Numerics.BigInteger> Objekt erstellt, dessen Wert 4328719365 (oder 0x102030405) ist. Das erste Element des Bytearrays, dessen Wert 5 ist, definiert den Wert des Werts der untersten Reihenfolge des <xref:System.Numerics.BigInteger> Objekts, das 0x05 ist. Das zweite Element des Bytearrays, dessen Wert 4 ist, definiert den Wert des zweiten Bytes des <xref:System.Numerics.BigInteger> Objekts, das 0x04 ist, usw.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ctors#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#1)]  
  
 Das folgende Beispiel instanziiert einen positiven und einen negativen <xref:System.Numerics.BigInteger> Wert, übergibt sie an die <xref:System.Numerics.BigInteger.ToByteArray%2A>-Methode und stellt dann die ursprünglichen <xref:System.Numerics.BigInteger> Werte aus dem resultierenden Bytearray wieder her. Beachten Sie, dass die beiden Werte durch identische Byte Arrays dargestellt werden. Der einzige Unterschied besteht darin, dass das wichtigste Bit des letzten Elements im Bytearray ist. Dieses Bit ist festgelegt (der Wert des Bytes ist 0xFF), wenn das Array aus einem negativen <xref:System.Numerics.BigInteger> Wert erstellt wird. Das Bit ist nicht festgelegt (der Wert des Bytes ist 0), wenn das Array aus einem positiven <xref:System.Numerics.BigInteger> Wert erstellt wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.ctors#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#2)]  
  
 Im folgenden Beispiel wird veranschaulicht, wie sichergestellt wird, dass ein positiver Wert nicht fälschlicherweise als negativer Wert instanziiert wird, indem ein Byte mit dem Wert 0 (null) bis zum Ende des Arrays hinzugefügt wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ctors#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToByteArray" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Decimal)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Decimal)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : decimal -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Eine Dezimalzahl.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit einem <see cref="T:System.Decimal" />-Wert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis des Aufrufs dieses Konstruktors ist mit dem expliziten Zuweisen eines <xref:System.Decimal> Werts zu einer <xref:System.Numerics.BigInteger> Variablen identisch.  
  
 Der Aufruf dieses Konstruktors kann zu Datenverlusten führen. Alle Bruchteile von `value` werden beim Instanziieren eines <xref:System.Numerics.BigInteger> Objekts abgeschnitten.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>-Konstruktor verwendet wird, um ein <xref:System.Numerics.BigInteger>-Objekt zu instanziieren. Er definiert ein Array von <xref:System.Decimal> Werten und übergibt dann jeden Wert an den <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29>-Konstruktor. Beachten Sie, dass der <xref:System.Decimal> Wert abgeschnitten wird, anstatt gerundet zu werden, wenn er dem <xref:System.Numerics.BigInteger> Objekt zugewiesen wird.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ctors#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(double value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : double -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit doppelter Genauigkeit</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit doppelter Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden beim Instanziieren eines <xref:System.Numerics.BigInteger> Objekts abgeschnitten.  
  
 Aufgrund der fehlenden Genauigkeit des <xref:System.Double>-Datentyps kann das Aufrufen dieses Konstruktors zu Datenverlusten führen.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus dem expliziten Zuweisen eines <xref:System.Double> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29>-Konstruktor verwendet wird, um ein <xref:System.Numerics.BigInteger>-Objekt zu instanziieren. Außerdem wird der Genauigkeits Verlust veranschaulicht, der bei Verwendung des <xref:System.Double>-Datentyps auftreten kann. Einem <xref:System.Double> wird ein großer Wert zugewiesen, der dann einem <xref:System.Numerics.BigInteger> Objekt zugewiesen wird. Wie die Ausgabe zeigt, beinhaltet diese Zuweisung einen Genauigkeits Verlust. Beide Werte werden dann um eins inkrementiert. Die Ausgabe zeigt, dass das <xref:System.Numerics.BigInteger> Objekt den geänderten Wert wieder gibt, während das <xref:System.Double>-Objekt dies nicht bewirkt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#5)]
 [!code-vb[System.Numerics.BigInteger.ctors#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.NegativeInfinity" /> oder <see cref="F:System.Double.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(int value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Ein 32-Bit-Integer mit Vorzeichen</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Genauigkeits Verlust beim Instanziieren eines <xref:System.Numerics.BigInteger> Objekts mithilfe dieses Konstruktors.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus der Zuweisung eines <xref:System.Int32> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
 Die <xref:System.Numerics.BigInteger>-Struktur schließt keine Konstruktoren mit einem Parameter vom Typ "<xref:System.Byte>", "<xref:System.Int16>", "<xref:System.SByte>" oder "<xref:System.UInt16>" ein. Der <xref:System.Int32>-Typ unterstützt jedoch die implizite Konvertierung von 8-Bit-und 16-Bit-Ganzzahlen mit und ohne Vorzeichen in ganzzahlige ganze Zahlen 32 mit Vorzeichen. Daher wird dieser Konstruktor aufgerufen, wenn `value` einem dieser vier integralen Typen entspricht.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29>-Konstruktor aufgerufen, um <xref:System.Numerics.BigInteger> Werte aus einem Array von ganzen Zahlen mit 32 Bit zu instanziieren. Außerdem wird eine implizite Konvertierung verwendet, um jeden 32-Bit-ganzzahligen Wert einer <xref:System.Numerics.BigInteger> Variablen zuzuweisen. Anschließend werden die beiden Werte verglichen, um festzulegen, dass die resultierenden <xref:System.Numerics.BigInteger> Werte identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#6)]
 [!code-vb[System.Numerics.BigInteger.ctors#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#6)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(long value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : int64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Ein 64-Bit-Integer mit Vorzeichen</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Es gibt keinen Genauigkeits Verlust beim Instanziieren eines <xref:System.Numerics.BigInteger> Objekts mithilfe dieses Konstruktors.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus der Zuweisung eines <xref:System.Int64> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29>-Konstruktor aufgerufen, um <xref:System.Numerics.BigInteger> Werte aus einem Array von ganzen Zahlen mit 64 Bit zu instanziieren. Außerdem wird eine implizite Konvertierung verwendet, um jeden 64-Bit-ganzzahligen Wert einer <xref:System.Numerics.BigInteger> Variablen zuzuweisen. Anschließend werden die beiden Werte verglichen, um festzulegen, dass die resultierenden <xref:System.Numerics.BigInteger> Werte identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#7)]
 [!code-vb[System.Numerics.BigInteger.ctors#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#7)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.Single)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As Single)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(float value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : single -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Ein Gleitkommawert mit einfacher Genauigkeit</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung eines Gleitkommawerts mit einfacher Genauigkeit.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden beim Instanziieren eines <xref:System.Numerics.BigInteger> Objekts abgeschnitten.  
  
 Aufgrund der fehlenden Genauigkeit des <xref:System.Single>-Datentyps kann das Aufrufen dieses Konstruktors zu Datenverlusten führen.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus dem expliziten Zuweisen eines <xref:System.Single> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie der <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29>-Konstruktor verwendet wird, um ein <xref:System.Numerics.BigInteger>-Objekt zu instanziieren. Außerdem wird der Genauigkeits Verlust veranschaulicht, der bei Verwendung des <xref:System.Single>-Datentyps auftreten kann. Einem <xref:System.Single> wird ein großer negativer Wert zugewiesen, der dann einem <xref:System.Numerics.BigInteger> Objekt zugewiesen wird. Wie die Ausgabe zeigt, beinhaltet diese Zuweisung einen Genauigkeits Verlust. Beide Werte werden dann um eins inkrementiert. Die Ausgabe zeigt, dass das <xref:System.Numerics.BigInteger> Objekt den geänderten Wert wieder gibt, während das <xref:System.Single>-Objekt dies nicht bewirkt.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#8)]
 [!code-vb[System.Numerics.BigInteger.ctors#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#8)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.NegativeInfinity" /> oder <see cref="F:System.Single.PositiveInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt32)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As UInteger)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint32 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Ein 32-Bit-Ganzzahlwert ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung des Werts einer 32-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren einer <xref:System.Numerics.BigInteger> mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus der Zuweisung eines <xref:System.UInt32> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29>-Konstruktor und eine Zuweisungsanweisung verwendet, um <xref:System.Numerics.BigInteger> Werte aus einem Array nicht signierter 32-Bit-Ganzzahlen zu initialisieren. Anschließend werden die beiden Werte verglichen, um zu veranschaulichen, dass die beiden Methoden zum Initialisieren eines <xref:System.Numerics.BigInteger> Werts identische Ergebnisse verursachen.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#9)]
 [!code-vb[System.Numerics.BigInteger.ctors#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#9)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int64)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ULong)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : uint64 -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger value" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Eine 64-Bit-Ganzzahl ohne Vorzeichen.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur mit dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Instanziieren einer <xref:System.Numerics.BigInteger> mit diesem Konstruktor ist kein Genauigkeits Verlust vorhanden.  
  
 Der <xref:System.Numerics.BigInteger>-Wert, der sich aus dem Aufruf dieses Konstruktors ergibt, ist identisch mit dem Wert, der sich aus der Zuweisung eines <xref:System.UInt64> Werts zu einem <xref:System.Numerics.BigInteger>ergibt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29>-Konstruktor verwendet, um ein <xref:System.Numerics.BigInteger> Objekt zu instanziieren, dessen Wert gleich <xref:System.UInt64.MaxValue>ist.  
  
 [!code-csharp[System.Numerics.BigInteger.ctors#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/cs/Example2.cs#10)]
 [!code-vb[System.Numerics.BigInteger.ctors#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ctors/vb/Example2.vb#10)]  
  
 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public BigInteger (ReadOnlySpan&lt;byte&gt; value, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(valuetype System.ReadOnlySpan`1&lt;unsigned int8&gt; value, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.#ctor(System.ReadOnlySpan{System.Byte},System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (value As ReadOnlySpan(Of Byte), Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false)" />
      <MemberSignature Language="F#" Value="new System.Numerics.BigInteger : ReadOnlySpan&lt;byte&gt; * bool * bool -&gt; System.Numerics.BigInteger" Usage="new System.Numerics.BigInteger (value, isUnsigned, isBigEndian)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine schreibgeschützte Spanne von Bytes, die den BigInteger-Wert darstellen.</param>
        <param name="isUnsigned"><see langword="true" />, um anzugeben, dass <paramref name="value" /> nicht signierte Codierung verwendet. Andernfalls <see langword="false" /> (der Standardwert).</param>
        <param name="isBigEndian"><see langword="true" />, um anzugeben, dass <paramref name="value" /> Big-Endian-Bytereihenfolge verwendet. Andernfalls <see langword="false" /> (der Standardwert).</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Numerics.BigInteger" />-Struktur unter Verwendung der Werte in einer schreibgeschützten Spanne von Bytes und zeigt optional die Signaturcodierung und die Endianness-Bytereihenfolge an.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Abs (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Abs(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Abs(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Abs(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl.</param>
        <summary>Ruft den absoluten Wert eines <see cref="T:System.Numerics.BigInteger" />-Objekts ab.</summary>
        <returns>Der Absolutbetrag von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der absolute Wert einer Zahl ist die Zahl ohne Vorzeichen, wie in der folgenden Tabelle dargestellt.  
  
|`value`-Parameter|Rückgabewert|  
|-----------------------|------------------|  
|`value` > = 0|`value`|  
|`value` < 0|`value` * -1|  
  
 Die <xref:System.Numerics.BigInteger.Abs%2A>-Methode entspricht der <xref:System.Math.Abs%2A?displayProperty=nameWithType>-Methode für die primitiven numerischen Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Abs%2A>-Methode verwendet, um einen <xref:System.Numerics.BigInteger> Wert aus der Komplement-Darstellung von zwei Werten in die-Darstellung der-Darstellung zu konvertieren, bevor Sie in eine Datei serialisiert wird. Die Daten in der Datei werden dann deserialisiert und einem neuen <xref:System.Numerics.BigInteger> Objekt zugewiesen.  
  
 [!code-csharp[System.Numerics.BigInteger.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/cs/Abs1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Abs/vb/Abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Abs(System.SByte)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Add (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Add(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Add(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt das Ergebnis zurück.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die das Überladen von Operatoren oder benutzerdefinierte Operatoren nicht unterstützen, können mit der <xref:System.Numerics.BigInteger.Add%2A>-Methode Addition mithilfe <xref:System.Numerics.BigInteger> Werte durchführen.  
  
 Die <xref:System.Numerics.BigInteger.Add%2A>-Methode ist ein nützlicher Ersatz für den Additions Operator beim Instanziieren einer <xref:System.Numerics.BigInteger> Variablen, indem Sie Ihr eine Summe zuweist, die aus Addition resultiert, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Compare">
      <MemberSignature Language="C#" Value="public static int Compare (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig int32 Compare(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Compare (left As BigInteger, right As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static int Compare(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Compare : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.Compare (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Vergleicht zwei <see cref="T:System.Numerics.BigInteger" />-Werte und gibt eine ganze Zahl zurück, die angibt, ob der erste Wert kleiner oder größer als der zweite Wert oder gleich dem zweiten Wert ist.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die relativen Werte von <paramref name="left" /> und <paramref name="right" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> value 
 </term><description> Bedingung 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description><paramref name="left" /> ist kleiner als <paramref name="right" />.  
  
 </description></item><item><term> Null 
 </term><description><paramref name="left" /> ist gleich <paramref name="right" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description><paramref name="left" /> ist größer als <paramref name="right" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Obwohl der <xref:System.Numerics.BigInteger> Typ keinen festgelegten Bereich aufweist, werden Vergleiche von <xref:System.Numerics.BigInteger> Werten nicht durch die fehlende Genauigkeit gekennzeichnet, die den Vergleich von Gleit Komma Zahlen kennzeichnet. Im folgenden Beispiel werden zwei <xref:System.Numerics.BigInteger> Werte verglichen, die sich durch einen unterscheiden und jeweils 1.896 Ziffern aufweisen. Die <xref:System.Numerics.BigInteger.Compare%2A>-Methode meldet ordnungsgemäß, dass die beiden Werte nicht gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Compare#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/cs/Compare1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Compare#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Compare/vb/Compare1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.CompareTo" />
      </Docs>
    </Member>
    <MemberGroup MemberName="CompareTo">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Vergleicht den Wert dieser Instanz mit einem anderen Wert und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der andere Wert ist oder mit diesem übereinstimmt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As Long) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(long other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : int64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl mit Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl mit Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Null 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>-Methode aufgerufen wird.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht das Ergebnis des Aufruf der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29>-Methode mit ganzzahligen Werten.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#3)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : System.Numerics.BigInteger -&gt; int&#xA;override this.CompareTo : System.Numerics.BigInteger -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable`1.CompareTo(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem zweiten <see cref="T:System.Numerics.BigInteger" /> und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Der Wert einer ganzen Zahl mit Vorzeichen, der die Beziehung dieser Instanz zu <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="other" />.  
  
 </description></item><item><term> Null 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="other" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="other" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Numerics.BigInteger.CompareTo%2A>-Methode implementiert die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType>-Methode. Sie wird von generischen Auflistungs Objekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>-Methode verwendet wird, um eine Liste von `StarInfo` Objekten zu sortieren. Jedes `StarInfo` Objekt enthält Informationen über den Namen eines Stars und seine Entfernung von der Erde in Meilen. `StarInfo` implementiert die <xref:System.IComparable%601>-Schnittstelle, die das Sortieren von `StarInfo` Objekten nach generischen Auflistungs Klassen ermöglicht. Die <xref:System.IComparable%601.CompareTo%2A?displayProperty=nameWithType> Implementierung umschließt lediglich einen Aufruf<xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29>.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#1)]  
  
 Der folgende Code instanziiert dann vier `StarInfo` Objekte und speichert Sie in einem generischen <xref:System.Collections.Generic.List%601>-Objekt. Nachdem die <xref:System.Collections.Generic.List%601.Sort%2A?displayProperty=nameWithType>-Methode aufgerufen wurde, werden `StarInfo` Objekte in der Reihenfolge ihrer Entfernung von der Erde angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example1.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Compare(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="T:System.IComparable`1" />
        <altmember cref="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int32 CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (obj As Object) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual int CompareTo(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="abstract member CompareTo : obj -&gt; int&#xA;override this.CompareTo : obj -&gt; int" Usage="bigInteger.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die Beziehung der aktuellen Instanz zum <paramref name="obj" />-Parameter angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Rückgabewert 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> Kleiner als 0 (null) 
 </term><description> Die aktuelle Instanz ist kleiner als <paramref name="obj" />.  
  
 </description></item><item><term> Null 
 </term><description> Die aktuelle Instanz ist gleich <paramref name="obj" />.  
  
 </description></item><item><term> Größer als 0 (null) 
 </term><description> Die aktuelle Instanz ist größer als <paramref name="obj" />, oder der <paramref name="obj" />-Parameter ist <see langword="null" />.  
  
 </description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Überladung der <xref:System.Numerics.BigInteger.CompareTo%2A>-Methode implementiert die <xref:System.IComparable.CompareTo%2A?displayProperty=nameWithType>-Methode. Sie wird von nicht generischen Auflistungs Objekten verwendet, um die Elemente in der Auflistung zu sortieren.  
  
 Der `obj`-Parameter muss einer der folgenden sein:  
  
-   Ein Objekt, dessen Lauf Zeittyp <xref:System.Numerics.BigInteger>ist.  
  
-   Eine <xref:System.Object> Variable, deren Wert `null`ist. Wenn der Wert des `obj`-Parameters `null`ist, gibt die Methode 1 zurück, was darauf hinweist, dass die aktuelle Instanz größer als `obj`ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>-Methode aufgerufen, um einen <xref:System.Numerics.BigInteger>-Wert mit jedem Element in einem Objekt Array zu vergleichen:  
  
 [!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
 [!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> ist keine <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="T:System.IComparable" />
      </Docs>
    </Member>
    <Member MemberName="CompareTo">
      <MemberSignature Language="C#" Value="public int CompareTo (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 CompareTo(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.CompareTo(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function CompareTo (other As ULong) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int CompareTo(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="member this.CompareTo : uint64 -&gt; int" Usage="bigInteger.CompareTo other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Vergleicht diese Instanz mit einer 64-Bit-Ganzzahl ohne Vorzeichen und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert der 64-Bit-Ganzzahl ohne Vorzeichen ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die den relativen Wert dieser Instanz und von <paramref name="other" /> angibt, wie in der folgenden Tabelle veranschaulicht.
          <list type="table"><listheader><term>Rückgabewert</term><description>BESCHREIBUNG</description></listheader><item><term>Kleiner als 0 (null)</term><description>Die aktuelle Instanz ist kleiner als <paramref name="other" />.</description></item><item><term>Null</term><description>Die aktuelle Instanz ist gleich <paramref name="other" />.</description></item><item><term>Größer als 0 (null)</term><description>Die aktuelle Instanz ist größer als <paramref name="other" />.</description></item></list></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Divide (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Divide(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Divide(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen und gibt das Ergebnis zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Divide%2A>-Methode führt eine ganzzahlige Division aus. jeder Rest, der sich aus der Division ergibt, wird verworfen. Zum Ausführen einer ganzzahligen Division ohne Beibehaltung des Restwerts wird die <xref:System.Numerics.BigInteger.DivRem%2A>-Methode aufgerufen. Um nur den Rest abzurufen, rufen Sie die <xref:System.Numerics.BigInteger.Remainder%2A>-Methode auf.  
  
 Die <xref:System.Numerics.BigInteger.Divide%2A>-Methode kann von Sprachen verwendet werden, die die Operator Überladung nicht unterstützen. Das Verhalten ist mit der Division identisch, die den Divisions Operator verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> Werten erstellt. Anschließend wird jedes Element als Quotienten in einer Divisions Operation verwendet, die die <xref:System.Numerics.BigInteger.Divide%2A>-Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A>-Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="DivRem">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger DivRem (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor, out System.Numerics.BigInteger remainder);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger DivRem(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor, [out] valuetype System.Numerics.BigInteger&amp; remainder) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function DivRem (dividend As BigInteger, divisor As BigInteger, ByRef remainder As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger DivRem(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor, [Runtime::InteropServices::Out] System::Numerics::BigInteger % remainder);" />
      <MemberSignature Language="F#" Value="static member DivRem : System.Numerics.BigInteger * System.Numerics.BigInteger * BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.DivRem (dividend, divisor, remainder)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
        <Parameter Name="remainder" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <param name="remainder">Die Rückgabe dieser Methode enthält einen <see cref="T:System.Numerics.BigInteger" />-Wert, der den Rest der Division darstellt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Dividiert einen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen, gibt das Ergebnis zurück und gibt den Rest in einem Ausgabeparameter zurück.</summary>
        <returns>Der Quotient der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode behält sowohl den Quotienten als auch den Rest bei, der sich aus der ganzzahligen Division ergibt. Wenn Sie keinen Rest für den Rest benötigen, verwenden Sie die <xref:System.Numerics.BigInteger.Divide%2A>-Methode oder den Divisions Operator. Wenn Sie nur am Rest interessiert sind, verwenden Sie die <xref:System.Numerics.BigInteger.Remainder%2A>-Methode.  
  
 Das Vorzeichen des zurückgegebenen `remainder` Werts ist mit dem Vorzeichen des `dividend`-Parameters identisch.  
  
 Das Verhalten der <xref:System.Numerics.BigInteger.DivRem%2A>-Methode ist identisch mit der der <xref:System.Math.DivRem%2A?displayProperty=nameWithType>-Methode.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> Werten erstellt. Anschließend wird jedes Element als Quotienten in einer Divisions Operation verwendet, die die <xref:System.Numerics.BigInteger.Divide%2A>-Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A>-Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (long other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(long other);" />
      <MemberSignature Language="F#" Value="override this.Equals : int64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="other">Der Wert der 64-Bit-Ganzzahl mit Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl mit Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn die 64-Bit-Ganzzahl mit Vorzeichen und die aktuelle Instanz über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn `other` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn die-Methode aufgerufen wird.  
  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, müssen Sie die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger>-Objekt von jedem ganzzahligen Typ mit Ausnahme von <xref:System.UInt64>instanziiert. Anschließend wird die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29>-Methode aufgerufen, um den <xref:System.Numerics.BigInteger>-Wert mit dem ursprünglichen ganzzahligen Wert zu vergleichen, der an den <xref:System.Numerics.BigInteger>-Konstruktor übergeben wurde. Wie die Ausgabe zeigt, sind die Werte in jedem Fall gleich.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals.cpp#1)]
 [!code-csharp[System.Numerics.BigInteger.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.BigInteger other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.BigInteger other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::BigInteger other);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.BigInteger -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="other">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes <see cref="T:System.Numerics.BigInteger" />-Objekt über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn dieses <see cref="T:System.Numerics.BigInteger" />-Objekt und <paramref name="other" /> über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode implementiert die <xref:System.IEquatable%601>-Schnittstelle und bietet eine etwas bessere Leistung als <xref:System.Numerics.BigInteger.Equals%28System.Object%29>, da der `other`-Parameter nicht in ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden muss.  
  
 Um die Beziehung zwischen den beiden <xref:System.Numerics.BigInteger> Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, müssen Sie die <xref:System.Numerics.BigInteger.CompareTo%28System.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen von der Erde mit dem Abstand von Epsilon Indi von Erde verglichen, um zu bestimmen, ob Sie gleich sind. Im Beispiel wird jede Überladung der <xref:System.Numerics.BigInteger.Equals%2A>-Methode verwendet, um auf Gleichheit zu prüfen.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="bigInteger.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn das <paramref name="obj" />-Argument ein <see cref="T:System.Numerics.BigInteger" />-Objekt darstellt und dessen Wert der aktuellen <see cref="T:System.Numerics.BigInteger" />-Instanz entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn das `obj`-Argument kein <xref:System.Numerics.BigInteger> Wert ist, gibt die Methode `false`zurück. Die Methode gibt `true` nur dann zurück, wenn `obj` eine <xref:System.Numerics.BigInteger> Instanz ist, deren Wert gleich der aktuellen Instanz ist.  
  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, müssen Sie die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die parallelen <xref:System.Object> und <xref:System.Numerics.BigInteger> Arrays definiert. Jedes Element eines Arrays hat denselben Wert wie das entsprechende Element des zweiten Arrays. Wie die Ausgabe des Beispiels zeigt, wird die-Instanz im <xref:System.Numerics.BigInteger> Array als gleich der-Instanz im <xref:System.Object> Array betrachtet, nur wenn letztere eine <xref:System.Numerics.BigInteger> ist und ihre Werte gleich sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/Equals_Obj1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/Equals_Obj1.vb#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (ulong other);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool Equals(unsigned int64 other) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Equals(System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (other As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool Equals(System::UInt64 other);" />
      <MemberSignature Language="F#" Value="override this.Equals : uint64 -&gt; bool" Usage="bigInteger.Equals other" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="other" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="other">Die 64-Bit-Ganzzahl ohne Vorzeichen für den Vergleich.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen.</summary>
        <returns><see langword="true" />, wenn die aktuelle Instanz und die 64-Bit-Ganzzahl ohne Vorzeichen über den gleichen Wert verfügen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um die Beziehung zwischen den beiden Objekten zu bestimmen, anstatt nur auf Gleichheit zu testen, müssen Sie die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die ungefähre Entfernung von mehreren Sternen von der Erde mit dem Abstand von Epsilon Indi von Erde verglichen, um zu bestimmen, ob Sie gleich sind. Im Beispiel wird jede Überladung der <xref:System.Numerics.BigInteger.Equals%2A>-Methode verwendet, um auf Gleichheit zu prüfen.  
  
 [!code-cpp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/cpp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cpp/equals2.cpp#2)]
 [!code-csharp[System.Numerics.BigInteger.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/cs/EqualsExample1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Equals/vb/EqualsExample1.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetByteCount">
      <MemberSignature Language="C#" Value="public int GetByteCount (bool isUnsigned = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetByteCount(bool isUnsigned) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetByteCount(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetByteCount (Optional isUnsigned As Boolean = false) As Integer" />
      <MemberSignature Language="F#" Value="member this.GetByteCount : bool -&gt; int" Usage="bigInteger.GetByteCount isUnsigned" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <summary>Ruft die Anzahl der Bytes ab, die von <see cref="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" /> und <see cref="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" /> ausgegeben werden.</summary>
        <returns>Die Anzahl der Bytes.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="bigInteger.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.BigInteger" />-Objekt zurück.</summary>
        <returns>Ein Hashcode in Form einer 32-Bit-Ganzzahl mit Vorzeichen.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GreatestCommonDivisor">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger GreatestCommonDivisor (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger GreatestCommonDivisor(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.GreatestCommonDivisor(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GreatestCommonDivisor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger GreatestCommonDivisor(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member GreatestCommonDivisor : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.GreatestCommonDivisor (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Sucht den größten gemeinsamen Divisor von zwei <see cref="T:System.Numerics.BigInteger" />-Werten.</summary>
        <returns>Der größte gemeinsame Divisor von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der größte gemeinsame Divisor ist die größte Zahl, in der die beiden <xref:System.Numerics.BigInteger> Werte aufgeteilt werden können, ohne einen Rest zurückzugeben.  
  
 Wenn die Parameter `left` und `right` ungleich NULL sind, gibt die Methode immer mindestens den Wert 1 zurück, da alle Zahlen durch 1 dividiert werden können. Wenn einer der Parameter NULL ist, gibt die Methode den absoluten Wert des Parameters ungleich 0 (null) zurück. Wenn beide Werte NULL sind, gibt die Methode 0 (null) zurück.  
  
> [!NOTE]
>  Das Berechnen des größten gemeinsamen Divisor von sehr großen Werten von `left` und `right` kann ein sehr zeitaufwendiger Vorgang sein.  
  
 Der von der <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>-Methode zurückgegebene Wert ist unabhängig vom Vorzeichen des `left`-und `right` Parameters immer positiv.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht einen aufzurufenden <xref:System.Numerics.BigInteger.GreatestCommonDivisor%2A>-Methode und die Ausnahmebehandlung, die erforderlich ist, um nützliche Informationen zu einem <xref:System.ArgumentOutOfRangeException>bereitzustellen. Das Ergebnis gibt an, dass der größte gemeinsame Divisor dieser beiden Zahlen 1 ist.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#10)]
 [!code-vb[System.Numeric.BigInteger.Class#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#10)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsEven">
      <MemberSignature Language="C#" Value="public bool IsEven { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsEven" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsEven" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsEven As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsEven { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsEven : bool" Usage="System.Numerics.BigInteger.IsEven" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine gerade Zahl ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft ist ein praktisches Feature, das angibt, ob ein <xref:System.Numerics.BigInteger> Wert durch zwei gleichmäßig teilbar ist. Dies entspricht dem folgenden Ausdruck:  
  
```csharp   
value % 2 == 0;  
```  
  
```vb  
value Mod 2 = 0  
```  
  
 Wenn der Wert des aktuellen <xref:System.Numerics.BigInteger> Objekts <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>ist, gibt die-Eigenschaft `true`zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsOne">
      <MemberSignature Language="C#" Value="public bool IsOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsOne" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsOne As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsOne { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsOne : bool" Usage="System.Numerics.BigInteger.IsOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.One" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine wesentlich bessere Leistung als andere Vergleiche mit einer, z. b. `thisBigInteger.Equals(BigInteger.One)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
      </Docs>
    </Member>
    <Member MemberName="IsPowerOfTwo">
      <MemberSignature Language="C#" Value="public bool IsPowerOfTwo { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsPowerOfTwo" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsPowerOfTwo As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsPowerOfTwo { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsPowerOfTwo : bool" Usage="System.Numerics.BigInteger.IsPowerOfTwo" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts eine Potenz von Zwei ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bestimmt, ob für einen <xref:System.Numerics.BigInteger> Wert ein einzelnes Bit festgelegt ist, das nicht NULL ist. Dies bedeutet, dass `true` zurückgegeben wird, wenn der Wert des aktuellen <xref:System.Numerics.BigInteger>-Objekts 1 (d. h. 2<sup>0</sup>) oder eine beliebige größere Potenz von zwei ist. Es wird `false` zurückgegeben, wenn der Wert des aktuellen <xref:System.Numerics.BigInteger>-Objekts 0 (null) ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="IsZero">
      <MemberSignature Language="C#" Value="public bool IsZero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsZero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.IsZero" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsZero As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsZero { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsZero : bool" Usage="System.Numerics.BigInteger.IsZero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, ob der Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist.</summary>
        <value><see langword="true" />, wenn der Wert des <see cref="T:System.Numerics.BigInteger" />-Objekts <see cref="P:System.Numerics.BigInteger.Zero" /> ist, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft bietet eine wesentlich bessere Leistung als `BigInteger.Equals(BigInteger.Zero)`.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt den Logarithmus der angegebenen Zahl zurück.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren Logarithmus bestimmt werden soll.</param>
        <summary>Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) der angegebenen Zahl zurück.</summary>
        <returns>Der natürliche Logarithmus (Basis <see langword="e" />) von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter wird als Basis 10-Nummer angegeben.  
  
 Der genaue Rückgabewert dieser Methode hängt vom Vorzeichen `value`ab, wie in der folgenden Tabelle gezeigt.  
  
|Vorzeichen von `value`-Parameter|Rückgabewert|  
|-------------------------------|------------------|  
|Positiv|Der natürliche Logarithmus von `value`; Das heißt, ln `value`oder Log e`value`.|  
|Null|[https://login.microsoftonline.com/consumers/](<xref:System.Double.NegativeInfinity>).|  
|Negativ|[https://login.microsoftonline.com/consumers/](<xref:System.Double.NaN>).|  
  
 Um den Logarithmus zur Basis 10 eines <xref:System.Numerics.BigInteger> Werts zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log10%2A>-Methode aufzurufen. Um den Logarithmus einer Zahl in einer anderen Basis zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29>-Methode aufzurufen.  
  
 Sie können die Quadratwurzel einer Zahl ermitteln, indem Sie die <xref:System.Numerics.BigInteger.Log%2A>-Methode zusammen mit der <xref:System.Math.Exp%2A?displayProperty=nameWithType>-Methode aufrufen. Beachten Sie, dass das Ergebnis <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> ist, wenn das Ergebnis größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>ist. Im folgenden Beispiel wird die Quadratwurzel der einzelnen Elemente in einem Array von <xref:System.Numerics.BigInteger> Werten berechnet.  
  
 [!code-csharp[System.Numerics.BigInteger.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.biginteger.log/cs/log1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.biginteger.log/vb/log1.vb#1)]
  
 Diese Methode entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>-Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der natürliche Logarithmus von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static double Log (System.Numerics.BigInteger value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log(valuetype System.Numerics.BigInteger value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log(System.Numerics.BigInteger,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As BigInteger, baseValue As Double) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log(System::Numerics::BigInteger value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.BigInteger * double -&gt; double" Usage="System.Numerics.BigInteger.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <param name="baseValue">Die Basis des Logarithmus.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl bezüglich einer angegebenen Basis zurück.</summary>
        <returns>Der Logarithmus zur Basis <paramref name="baseValue" /> von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Parameter "`value`" und "`baseValue`" werden als Basis 10 Zahlen angegeben.  
  
 Der genaue Rückgabewert der Methode hängt vom Vorzeichen `value` und vom Vorzeichen und Wert `baseValue`ab, wie in der folgenden Tabelle gezeigt.  
  
|`value`-Parameter|`baseValue`-Parameter|Rückgabewert|  
|-----------------------|---------------------------|------------------|  
|`value` > 0|(0 < `baseValue` < 1)-oder-(`baseValue` > 1)|logbasevalue (`value`)|  
|`value` < 0|(beliebiger Wert)|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` < 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = 0|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` != 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = <xref:System.Double.NaN?displayProperty=nameWithType>|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|(beliebiger Wert)|`baseValue` = 1|<xref:System.Double.NaN?displayProperty=nameWithType>|  
|`value` = 0|0 < `baseValue` < 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 0|`baseValue` > 1|<xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|  
|`value` = 1|`baseValue` = 0|0|  
|`value` = 1|`baseValue` = <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>|0|  
  
 Um den Logarithmus zur Basis 10 eines <xref:System.Numerics.BigInteger> Werts zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log10%2A>-Methode aufzurufen. Um den natürlichen Logarithmus einer Zahl zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29>-Methode abrufen.  
  
 Diese Methode entspricht der <xref:System.Math.Log%2A?displayProperty=nameWithType>-Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Das Protokoll von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static double Log10 (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Log10(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Log10(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Log10(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zahl, deren Logarithmus gesucht wird.</param>
        <summary>Gibt den Logarithmus einer angegebenen Zahl zur Basis 10 zurück.</summary>
        <returns>Der Logarithmus zur Basis 10 von <paramref name="value" />, wie in der Tabelle im Abschnitt "Hinweise" veranschaulicht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter wird als Basis 10-Nummer angegeben.  
  
 Der genaue Rückgabewert der-Methode hängt vom Vorzeichen `value`ab, wie in der folgenden Tabelle gezeigt.  
  
|Vorzeichen des value-Parameters|Rückgabewert|  
|-----------------------------|------------------|  
|Positiv|Das Protokoll der Basis 10 von `value`; Das heißt, log10`value`.|  
|Null|[https://login.microsoftonline.com/consumers/](<xref:System.Double.NegativeInfinity?displayProperty=nameWithType>).|  
|Negativ|[https://login.microsoftonline.com/consumers/](<xref:System.Double.NaN?displayProperty=nameWithType>).|  
  
 Um den natürlichen Logarithmus eines <xref:System.Numerics.BigInteger> Werts zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode aufzurufen. Um den Logarithmus einer Zahl in einer anderen Basis zu berechnen, müssen Sie die <xref:System.Numerics.BigInteger.Log%28System.Numerics.BigInteger%2CSystem.Double%29?displayProperty=nameWithType>-Methode aufzurufen.  
  
 Diese Methode entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType>-Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException">Der Logarithmus zur Basis 10 von <paramref name="value" /> liegt außerhalb des Bereichs des <see cref="T:System.Double" />-Datentyps.</exception>
      </Docs>
    </Member>
    <Member MemberName="Max">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Max (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Max(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Max (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Max(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Max : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Max (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den größeren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der größere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Max%2A?displayProperty=nameWithType>-Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Max%2A>-Methode verwendet, um die größte Zahl in einem Array von <xref:System.Numerics.BigInteger> Werten auszuwählen.  
  
 [!code-csharp[System.Numerics.BigInteger.Max#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/cs/Max1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Max#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Max/vb/Max1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Min">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Min (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Min(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Min(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Min (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Min(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Min : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Min (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt den kleineren der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der kleinere der Parameter <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode entspricht der <xref:System.Math.Min%2A?displayProperty=nameWithType>-Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Min%2A>-Methode verwendet, um die kleinste Zahl in einem Array von <xref:System.Numerics.BigInteger> Werten auszuwählen.  
  
 [!code-csharp[System.Numerics.BigInteger.Min#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/cs/Min1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Min#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Min/vb/Min1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Max(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="MinusOne">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger MinusOne { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger MinusOne" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.MinusOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property MinusOne As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger MinusOne { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.MinusOne : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.MinusOne" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl -1 darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert -1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.MinusOne%2A>-Eigenschaft wird zum Vergleichen eines <xref:System.Numerics.BigInteger> Werts mit-1 oder zum Zuweisen von-1 zu einem <xref:System.Numerics.BigInteger>-Objekt verwendet.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.One" />
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
      </Docs>
    </Member>
    <Member MemberName="ModPow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger ModPow (System.Numerics.BigInteger value, System.Numerics.BigInteger exponent, System.Numerics.BigInteger modulus);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger ModPow(valuetype System.Numerics.BigInteger value, valuetype System.Numerics.BigInteger exponent, valuetype System.Numerics.BigInteger modulus) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ModPow(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ModPow (value As BigInteger, exponent As BigInteger, modulus As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger ModPow(System::Numerics::BigInteger value, System::Numerics::BigInteger exponent, System::Numerics::BigInteger modulus);" />
      <MemberSignature Language="F#" Value="static member ModPow : System.Numerics.BigInteger * System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.ModPow (value, exponent, modulus)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Numerics.BigInteger" />
        <Parameter Name="modulus" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <paramref name="exponent" />. Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <paramref name="value" /> potenziert werden soll.</param>
        <param name="modulus">Die Zahl, durch die <paramref name="value" /> hoch <paramref name="exponent" /> dividiert wird.</param>
        <summary>Führt eine Modulodivision für eine zur Potenz einer anderen Zahl erhobene Zahl aus.</summary>
        <returns>Der Rest nach der Division von <paramref name="value" /><sup>exponent</sup> durch <paramref name="modulus" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ModPow%2A>-Methode wertet den folgenden Ausdruck aus:  
  
 (baseValue ^ Exponent) Mod-Modulo  
  
 Verwenden Sie die <xref:System.Numerics.BigInteger.Pow%2A>-Methode, um die <xref:System.Numerics.BigInteger> Werte ohne modulodivision zu verwenden.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie die <xref:System.Numerics.BigInteger.ModPow%2A>-Methode aufrufen.  
  
 [!code-csharp[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/cs/ModPow1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ModPow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ModPow/vb/ModPow1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="modulus" /> ist 0 (null).</exception>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> ist ein negativer Wert.</exception>
        <altmember cref="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Multiply (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Multiply(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Die erste zu multiplizierende Zahl.</param>
        <param name="right">Die zweite zu multiplizierende Zahl.</param>
        <summary>Gibt das Produkt der beiden <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Multiply%2A>-Methode wird für Sprachen implementiert, die das Überladen von Operatoren nicht unterstützen. Das Verhalten ist identisch mit der Multiplikation mit dem Multiplikations Operator. Außerdem ist die <xref:System.Numerics.BigInteger.Multiply%2A>-Methode ein nützlicher Ersatz für den Multiplikations Operator beim Instanziieren einer <xref:System.Numerics.BigInteger> Variablen, indem Sie Ihr ein Produkt zuweist, das sich aus der Multiplikation ergibt, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#1)]  
  
 Bei Bedarf führt diese Methode automatisch eine implizite Konvertierung von anderen ganzzahligen Typen in <xref:System.Numerics.BigInteger> Objekte durch. Dies wird im Beispiel im nächsten Abschnitt veranschaulicht, in dem die <xref:System.Numerics.BigInteger.Multiply%2A>-Methode zwei <xref:System.Int64> Werte übermittelt wird.  
  
   
  
## Examples  
 Im folgenden Beispiel wird versucht, eine Multiplikation mit zwei langen Ganzzahlen auszuführen. Da das Ergebnis den Bereich einer langen ganzen Zahl überschreitet, wird eine <xref:System.OverflowException> ausgelöst, und die <xref:System.Numerics.BigInteger.Multiply%2A>-Methode wird aufgerufen, um die Multiplikation zu verarbeiten. Beachten Sie C# , dass Sie entweder das `checked`-Schlüsselwort (wie in diesem Beispiel) oder die `/checked+`-Compileroption verwenden müssen, um sicherzustellen, dass bei einem numerischen Überlauf eine Ausnahme ausgelöst wird.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#7)]
 [!code-vb[System.Numeric.BigInteger.Class#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#7)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Negate (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Negate(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Negate(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Negate(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Negation erhält den Additiven umgekehrten Wert einer Zahl. Die Additive Umkehrung einer Zahl ist eine Zahl, die den Wert 0 (null) erzeugt, wenn Sie der ursprünglichen Zahl hinzugefügt wird.  
  
 Die <xref:System.Numerics.BigInteger.Negate%2A>-Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen. Das Verhalten ist mit der Negations Operator identisch, die den unären Negations Operator verwendet. Außerdem ist die <xref:System.Numerics.BigInteger.Negate%2A>-Methode ein nützlicher Ersatz für den Negations Operator beim Instanziieren einer <xref:System.Numerics.BigInteger> Variablen, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#4)]  
  
   
  
## Examples  
 Im folgenden Beispiel werden drei Möglichkeiten veranschaulicht, um den Wert eines <xref:System.Numerics.BigInteger> Objekts zu negieren.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger One { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger One" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property One As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger One { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.One : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.One" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl 1 darstellt.</summary>
        <value>Ein Objekt, dessen Wert 1 ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.One%2A>-Eigenschaft wird normalerweise verwendet, um einen <xref:System.Numerics.BigInteger>-Wert mit 1 zu vergleichen oder um einem <xref:System.Numerics.BigInteger>-Objekt 1 zuzuweisen.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsOne" />
        <altmember cref="P:System.Numerics.BigInteger.MinusOne" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Addition(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Addition(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu addierende Wert.</param>
        <param name="right">Der zweite zu addierende Wert.</param>
        <summary>Addiert die Werte von zwei angegebenen <see cref="T:System.Numerics.BigInteger" />-Objekten.</summary>
        <returns>Die Summe von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Addition%2A>-Methode definiert den Additions Vorgang für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#12](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#12)]
 [!code-vb[System.Numeric.BigInteger.Class#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#12)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Add%2A>-Methode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Add(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseAnd">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &amp; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseAnd(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseAnd(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator And (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &amp;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &amp;&amp;&amp; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left &amp;&amp;&amp; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="And" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="And" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>-Methode wird der bitweise `And` Vorgang für <xref:System.Numerics.BigInteger> Werte definiert. Der bitweise `And` Vorgang legt nur dann ein Ergebnisbit fest, wenn die entsprechenden Bits in `left` und `right` ebenfalls festgelegt sind, wie in der folgenden Tabelle dargestellt.  
  
|Bit in `left`|Bit in `right`|Bit in Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|0|  
|1|1|1|  
|0|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>-Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Operators#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#1)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseAnd%2A>-Methode führt die bitweise `And` Operation für zwei <xref:System.Numerics.BigInteger>-Werte aus, als wären Sie beide in der Komplement-Darstellung mit dem virtuellen Vorzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_BitwiseOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator | (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_BitwiseOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_BitwiseOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Or (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator |(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ||| ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ||| right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise <see langword="Or" />-Operation für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>-Methode wird der bitweise `Or` Vorgang für <xref:System.Numerics.BigInteger> Werte definiert. Der bitweise `Or` Vorgang legt nur dann ein Ergebnisbit fest, wenn eine oder beide der entsprechenden Bits in `left` und `right` festgelegt sind, wie in der folgenden Tabelle dargestellt.  
  
|Bit in `left`|Bit in `right`|Bit in Ergebnis|  
|-------------------|--------------------|-------------------|  
|0|0|0|  
|1|0|1|  
|1|1|1|  
|0|1|1|  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>-Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Operators#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#2)]  
  
 Die <xref:System.Numerics.BigInteger.op_BitwiseOr%2A>-Methode führt die bitweise `Or` Operation für zwei <xref:System.Numerics.BigInteger>-Werte aus, als wären Sie beide in der Komplement-Darstellung mit dem virtuellen Vorzeichen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Decrement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator -- (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Decrement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Decrement (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator --(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Decrement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Decrement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu dekrementierende Wert.</param>
        <summary>Dekrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 dekrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Decrement%2A>-Methode definiert den Dekrement-Vorgang für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#17)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Subtract%2A>-Methode aufzurufen. Beispiel:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Operators#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#3)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte unveränderlich sind, erstellt der <xref:System.Numerics.BigInteger.op_Decrement%2A>-Operator ein neues <xref:System.Numerics.BigInteger> Objekt, dessen Wert eins kleiner ist als das durch `value`dargestellte <xref:System.Numerics.BigInteger> Objekt. Dies bedeutet, dass wiederholte Aufrufe an <xref:System.Numerics.BigInteger.op_Decrement%2A> teuer sein können.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator / (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Division(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator /(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend / divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Dividiert einen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert durch einen anderen angegebenen <see cref="T:System.Numerics.BigInteger" />-Wert mit einer Ganzzahldivision.</summary>
        <returns>Das ganzzahlige Ergebnis der Division.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Division%2A>-Methode definiert den Divisions Vorgang für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#13)]
 [!code-vb[System.Numeric.BigInteger.Class#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#13)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Divide%2A>-Methode abrufen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Divide%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel wird ein Array von <xref:System.Numerics.BigInteger> Werten erstellt. Anschließend wird jedes Element als Quotienten in einer Divisions Operation verwendet, die die <xref:System.Numerics.BigInteger.Divide%2A>-Methode, den Divisions Operator (/) und die <xref:System.Numerics.BigInteger.DivRem%2A>-Methode verwendet.  
  
 [!code-csharp[System.Numerics.BigInteger.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/cs/Divide1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Divide/vb/Divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.Divide(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Equality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei Werte gleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Int64%2CSystem.Numerics.BigInteger%29>-Methode definiert die Gleichheits Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Operators#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#4)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> Instanzmethode aufzurufen.  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl mit Vorzeichen gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Int64%29>-Methode definiert die Gleichheits Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#5)]
 [!code-vb[System.Numerics.BigInteger.Operators#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#5)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> Instanzmethode aufzurufen.  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob die Werte von zwei <see cref="T:System.Numerics.BigInteger" />-Objekten gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>-Methode definiert den Vorgang des Gleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#19)]
 [!code-vb[System.Numeric.BigInteger.Class#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#19)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType> Instanzmethode aufzurufen.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Equals" />
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und der Wert einer langen ganzen Zahl ohne Vorzeichen gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.Numerics.BigInteger%2CSystem.UInt64%29>-Methode definiert die Gleichheits Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#6)]
 [!code-vb[System.Numerics.BigInteger.Operators#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#6)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> Instanzmethode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Equality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob der Wert einer langen ganzen Zahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert gleich sind.</summary>
        <returns><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Equality%28System.UInt64%2CSystem.Numerics.BigInteger%29>-Methode definiert die Gleichheits Vergleichsoperation für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#7)]
 [!code-vb[System.Numerics.BigInteger.Operators#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#7)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType> Instanzmethode aufzurufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Inequality" />
      </Docs>
    </Member>
    <Member MemberName="op_ExclusiveOr">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ^ (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_ExclusiveOr(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_ExclusiveOr(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Xor (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ^(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( ^^^ ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left ^^^ right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste Wert.</param>
        <param name="right">Der zweite Wert.</param>
        <summary>Führt eine bitweise exklusive <see langword="Or" />-Operation (<see langword="XOr" />-Operation) für zwei <see cref="T:System.Numerics.BigInteger" />-Werte aus.</summary>
        <returns>Das Ergebnis der bitweisen <see langword="Or" />-Operation.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Ergebnis einer bitweisen exklusiven `Or` Operation ist `true`, wenn sich die Werte der beiden Bits unterscheiden. Andernfalls ist es `false`. In der folgenden Tabelle wird der exklusive `Or` Vorgang veranschaulicht.  
  
|Bit x in `left`|Bit x in `right`|Rückgabewert|  
|---------------------|----------------------|------------------|  
|0|0|0|  
|0|1|1|  
|1|0|1|  
|1|1|0|  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>-Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#8)]
 [!code-vb[System.Numerics.BigInteger.Operators#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#8)]  
  
 Die <xref:System.Numerics.BigInteger.op_ExclusiveOr%2A>-Methode führt den bitweisen exklusiven `Or` Vorgang für zwei <xref:System.Numerics.BigInteger> Werte aus, als ob Sie beide in der Komplement-Darstellung mit dem virtuellen Vorzeichen wären.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Decimal" />-Objekts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden vor der Konvertierung abgeschnitten.

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Decimal> in <xref:System.Numerics.BigInteger> das Abschneiden eines Bruchteils von `value`einschließen kann, führen sprach Compiler diese Konvertierung nicht automatisch durch. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Decimal%29?displayProperty=nameWithType>.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Decimal>-Werten in <xref:System.Numerics.BigInteger>-Objekte konvertiert und dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Decimal> Werts während der Konvertierung abgeschnitten werden.   

 [!code-csharp[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#1)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Double)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Double) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(double value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : double -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Double" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden vor der Konvertierung abgeschnitten.

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Double> in <xref:System.Numerics.BigInteger> das Abschneiden eines Bruchteils von `value`einschließen kann, führen sprach Compiler diese Konvertierung nicht automatisch durch. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Double%29?displayProperty=nameWithType>.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Double>-Werten in <xref:System.Numerics.BigInteger>-Objekte konvertiert und dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Double> Werts während der Konvertierung abgeschnitten werden.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#2)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#2)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Double.NaN" />, <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator byte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Byte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Byte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Byte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; byte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Byte" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Bytewert ohne Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CByte` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Byte> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.Byte> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Byte> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Byte> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#1)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Byte.MinValue" /> oder größer als <see cref="F:System.Byte.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator decimal (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Decimal op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Decimal" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Decimal" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Decimal(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; decimal" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Decimal</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Decimal" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Decimal" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CDec` in Visual Basic) verwendet wird.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Decimal> Datentyps liegt. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Decimal> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Decimal> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#2)]  

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Decimal.MinValue" /> oder größer als <see cref="F:System.Decimal.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator double (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Double" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator double(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; double" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Double" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen <see cref="T:System.Double" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CDbl` in Visual Basic) verwendet wird.   

 Da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Double> Datentyps liegen kann, ist dieser Vorgang eine einschränkende Konvertierung. Wenn die Konvertierung nicht erfolgreich ist, wird keine <xref:System.OverflowException>ausgelöst. Wenn der <xref:System.Numerics.BigInteger> Wert jedoch kleiner als <xref:System.Double.MinValue?displayProperty=nameWithType>ist, wird der resultierende <xref:System.Double> Wert <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>. Wenn der <xref:System.Numerics.BigInteger> Wert größer als <xref:System.Double.MaxValue?displayProperty=nameWithType>ist, wird der resultierende <xref:System.Double> Wert <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.
 
 Die Konvertierung einer <xref:System.Numerics.BigInteger> in eine <xref:System.Double> kann zu einem Genauigkeits Verlust führen. In einigen Fällen kann der Verlust der Genauigkeit bewirken, dass der Umwandlungs-oder Konvertierungs Vorgang erfolgreich ist, auch wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Double> Datentyps liegt. Dies wird im folgenden Beispiel veranschaulicht. Er weist zwei <xref:System.Numerics.BigInteger> Variablen den maximalen Wert einer <xref:System.Double> zu, erhöht eine <xref:System.Numerics.BigInteger> Variable durch 9.999 e291 und testet die beiden Variablen auf Gleichheit. Erwartungsgemäß zeigt der-<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode, dass Sie ungleich sind. Allerdings ist die Konvertierung des größeren <xref:System.Numerics.BigInteger> Werts zurück in eine <xref:System.Double> erfolgreich, obwohl der <xref:System.Numerics.BigInteger> Wert jetzt <xref:System.Double.MaxValue?displayProperty=nameWithType>überschreitet.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#4)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#4)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Double> Werte.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator short (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Short" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator short(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CShort` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int16> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.Int16> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int16> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int16> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#4)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int16.MinValue" /> oder größer als <see cref="F:System.Int16.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator int (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator int(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CInt` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.   

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int32> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.Int32> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int32> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int32> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#5)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int32.MinValue" /> oder größer als <see cref="F:System.Int32.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator long (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Int64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator long(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; int64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl mit Vorzeichen.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CLng` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int64> Datentyps liegt. 

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Int64> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Int64> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#6)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.Int64.MinValue" /> oder größer als <see cref="F:System.Int64.MaxValue" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator sbyte (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname int8 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.SByte" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As SByte" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::SByte(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; sbyte" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.SByte</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen 8-Bit-Wert mit Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen 8-Bit-Wert mit Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int16" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CSByte` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.  

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.SByte> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.SByte> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.SByte> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.SByte> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#7)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.SByte.MinValue" /> oder größer als <see cref="F:System.SByte.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int16" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator float (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname float32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.Single" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Single" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator float(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; single" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Single</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen Gleitkommawert mit einfacher Genauigkeit konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in einen Gleitkommawert mit einfacher Genauigkeit.</summary>
        <returns>Ein Objekt, das die nächstmögliche Darstellung des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten oder einem Genauigkeits Verlust kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CSng` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Single> Datentyps liegen kann, ist dieser Vorgang eine einschränkende Konvertierung. Wenn die Konvertierung nicht erfolgreich ist, wird keine <xref:System.OverflowException>ausgelöst. Wenn der <xref:System.Numerics.BigInteger> Wert jedoch kleiner als <xref:System.Single.MinValue?displayProperty=nameWithType>ist, wird der resultierende <xref:System.Single> Wert <xref:System.Single.NegativeInfinity?displayProperty=nameWithType>. Wenn der <xref:System.Numerics.BigInteger> Wert größer als <xref:System.Single.MaxValue?displayProperty=nameWithType>ist, wird der resultierende <xref:System.Single> Wert <xref:System.Single.PositiveInfinity?displayProperty=nameWithType>.

 Die Konvertierung einer <xref:System.Numerics.BigInteger> in eine <xref:System.Single> kann zu einem Genauigkeits Verlust führen. In einigen Fällen kann der Verlust der Genauigkeit bewirken, dass der Umwandlungs-oder Konvertierungs Vorgang erfolgreich ist, auch wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Single> Datentyps liegt. Dies wird im folgenden Beispiel veranschaulicht. Er weist zwei <xref:System.Numerics.BigInteger> Variablen den maximalen Wert einer <xref:System.Single> zu, erhöht eine <xref:System.Numerics.BigInteger> Variable durch 9.999 e291 und testet die beiden Variablen auf Gleichheit. Erwartungsgemäß zeigt der-<xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode, dass Sie ungleich sind. Allerdings ist die Konvertierung des größeren <xref:System.Numerics.BigInteger> Werts zurück in eine <xref:System.Single> erfolgreich, obwohl der <xref:System.Numerics.BigInteger> Wert jetzt <xref:System.Single.MaxValue?displayProperty=nameWithType>überschreitet.   
    
 [!code-csharp[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#5)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#5)]   



## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.Single> Werte.   
     
 [!code-csharp[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ushort (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int16 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt16" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UShort" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt16(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint16" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt16</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 16-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 16-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int32" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CUShort` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt16> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.UInt16> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt16> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt16> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#9)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#9)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt16.MinValue" /> oder größer als <see cref="F:System.UInt16.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int32" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator uint (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int32 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt32" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As UInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt32(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint32" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 32-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 32-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Int64" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CUInt` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt32> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.UInt32> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt32> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt32> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#10)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#10)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt32.MinValue" /> oder größer als <see cref="F:System.UInt32.MaxValue" />.</exception>
        <altCompliant cref="T:System.Int64" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator ulong (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname unsigned int64 op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Numerics.BigInteger)~System.UInt64" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As ULong" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::UInt64(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; uint64" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.UInt64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in eine 64-Bit-Ganzzahl ohne Vorzeichen konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Objekts in den Wert einer 64-Bit-Ganzzahl ohne Vorzeichen.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` oder `CULng` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.    

 Da dieser Vorgang eine einschränkende Konvertierung definiert, kann er eine <xref:System.OverflowException> zur Laufzeit auslösen, wenn der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt64> Datentyps liegt. Es gibt keinen Genauigkeits Verlust im resultierenden <xref:System.UInt64> Wert, wenn die Konvertierung erfolgreich ist.

## Examples
 Das folgende Beispiel veranschaulicht die Konvertierung von <xref:System.Numerics.BigInteger> in <xref:System.UInt64> Werte. Außerdem wird eine <xref:System.OverflowException> behandelt, die ausgelöst wird, da der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.UInt64> Datentyps liegt.   
    
 [!code-csharp[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/cs/System.Numeric.BigInteger.Explicit.cs#11)]   
 [!code-vb[System.Numeric.BigInteger.Explicit#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Explicit/vb/System.Numeric.BigInteger.Explicit.vb#11)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist kleiner als <see cref="F:System.UInt64.MinValue" /> oder größer als <see cref="F:System.UInt64.MaxValue" />.</exception>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.BigInteger (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Explicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Explicit(System.Single)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Single) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::BigInteger(float value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : single -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine explizite Konvertierung eines <see cref="T:System.Single" />-Werts in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden vor der Konvertierung abgeschnitten.
 
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Explicit(System.Decimal)~System.Numerics.BigInteger>-Methode definieren die Typen, für die bzw. aus denen ein <xref:System.Numerics.BigInteger> Objekt konvertiert werden kann. Da die Konvertierung von <xref:System.Single> in <xref:System.Numerics.BigInteger> das Abschneiden eines Bruchteils von `value`einschließen kann, führen sprach Compiler diese Konvertierung nicht automatisch durch. Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` in Visual Basic) verwendet wird. Andernfalls wird ein Compilerfehler angezeigt.

 Für Sprachen, die keine benutzerdefinierten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Single%29?displayProperty=nameWithType>.


## Examples
 Im folgenden Beispiel werden die einzelnen Elemente in einem Array von <xref:System.Single>-Werten in <xref:System.Numerics.BigInteger>-Objekte konvertiert und dann das Ergebnis jeder Konvertierung angezeigt. Beachten Sie, dass alle Bruchteile eines <xref:System.Single> Werts während der Konvertierung abgeschnitten werden.
 
 [!code-csharp[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/cs/Explicit1.cs#3)]   
 [!code-vb[System.Numerics.BigInteger.Explicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Explicit/vb/Explicit1.vb#3)]   

 ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException"><paramref name="value" /> ist <see cref="F:System.Single.NaN" />, <see cref="F:System.Single.PositiveInfinity" /> oder <see cref="F:System.Single.NegativeInfinity" />.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer als ein anderer angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#9)]
 [!code-vb[System.Numerics.BigInteger.Operators#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#9)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Instanzmethode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Int64%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#10)]  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" /> größer als der Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#11)]
 [!code-vb[System.Numerics.BigInteger.Operators#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#11)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Int64%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#12](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#12)]  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#20](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#20)]
 [!code-vb[System.Numeric.BigInteger.Class#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#20)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#21)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#13](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#13)]
 [!code-vb[System.Numerics.BigInteger.Operators#13](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#13)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.Numerics.BigInteger%2CSystem.UInt64%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#14)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThan">
      <MemberSignature Language="C#" Value="public static bool operator &gt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThan%2A>-Methode definiert den Vorgang des Operators "größer als" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#15](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#15)]
 [!code-vb[System.Numerics.BigInteger.Operators#15](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#15)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThan%28System.UInt64%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#16)]  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_GreaterThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert größer oder gleich einem anderen angegebenen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des Operators "größer als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#17](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#17)]
 [!code-vb[System.Numerics.BigInteger.Operators#17](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#17)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#18](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#18)]  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des Operators "größer als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#19](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#19)]
 [!code-vb[System.Numerics.BigInteger.Operators#19](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#19)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#20](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#20)]  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des Operators "größer als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#22](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#22)]
 [!code-vb[System.Numeric.BigInteger.Class#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#22)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#23)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo(System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert größer als der oder gleich dem Wert einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des Operators "größer als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#21](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#21)]
 [!code-vb[System.Numerics.BigInteger.Operators#21](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#21)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#22](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#22)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <Member MemberName="op_GreaterThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &gt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_GreaterThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_GreaterThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &gt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &gt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &gt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen größer als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> größer als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%2A>-Methode definiert den Vorgang des Operators "größer als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#23](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#23)]
 [!code-vb[System.Numerics.BigInteger.Operators#23](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#23)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_GreaterThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#24](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#24)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_GreaterThan" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Definiert eine implizite Konvertierung zwischen einem <see cref="T:System.Numerics.BigInteger" />-Objekt und einem anderen Typ.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen in ein <see cref="T:System.Numerics.BigInteger" />-Objekt.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Alle Bruchteile des `value`-Parameters werden vor der Konvertierung abgeschnitten.

 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.Byte>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#1)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.Int16>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#2)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.  

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.Int32>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#3)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int64%29?displayProperty=nameWithType>.   
 
 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.Int64>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#4)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.SByte)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 8-Bit-Ganzzahl mit Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.Int32%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.SByte>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#5)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#5)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.#ctor(System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt16)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.UInt16>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#6)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#6)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int32)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt32)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt32%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.UInt32>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#7)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#7)]   

 ]]></format>
        </remarks>
        <altCompliant cref="M:System.Numerics.BigInteger.op_Implicit(System.Int64)~System.Numerics.BigInteger" />
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.BigInteger (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Implicit(System.UInt64)~System.Numerics.BigInteger" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::BigInteger(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, der in einen <see cref="T:System.Numerics.BigInteger" /> konvertiert werden soll.</param>
        <summary>Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in einen <see cref="T:System.Numerics.BigInteger" />-Wert.  
  
Diese API ist nicht CLS-kompatibel. Die kompatible Alternative ist <see cref="T:System.Double" />.</summary>
        <returns>Ein Objekt, das den Wert des <paramref name="value" />-Parameters enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Für Sprachen, die keine impliziten Operatoren unterstützen, ist die alternative Methode <xref:System.Numerics.BigInteger.%23ctor%28System.UInt64%29?displayProperty=nameWithType>.   

 Die über Ladungen der <xref:System.Numerics.BigInteger.op_Implicit(System.Byte)~System.Numerics.BigInteger>-Methode definieren die Typen, für die ein Compiler einen <xref:System.Numerics.BigInteger>-Wert automatisch ohne einen expliziten Umwandlungs Operator (in C#) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann. Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen. Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem <xref:System.UInt64>-Wert in einen <xref:System.Numerics.BigInteger> Wert, wie im folgenden Beispiel gezeigt.   
   
 [!code-csharp[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/cs/Implicit1.cs#8)]   
 [!code-vb[System.Numeric.BigInteger.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Implicit/vb/Implicit1.vb#8)]   

 ]]></format>
        </remarks>
        <altCompliant cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="op_Increment">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ++ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Increment(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Increment(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared op_Increment (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ++(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Increment : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_Increment value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu inkrementierende Wert.</param>
        <summary>Inkrementiert einen <see cref="T:System.Numerics.BigInteger" />-Wert um 1.</summary>
        <returns>Der um 1 inkrementierte Wert des <paramref name="value" />-Parameters.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Increment%2A>-Methode definiert den Inkrement-Vorgang für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#24](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#24)]  
  
 Einige Sprachen (z. b. Visual Basic), die keinen Inkrementoperator oder Operator Überladung nicht unterstützen, können die <xref:System.Numerics.BigInteger.op_Increment%2A>-Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#25)]  
  
 Da <xref:System.Numerics.BigInteger> Objekte unveränderlich sind, erstellt der <xref:System.Numerics.BigInteger.op_Increment%2A>-Operator ein neues <xref:System.Numerics.BigInteger> Objekt, dessen Wert eins mehr ist als das durch `value`dargestellte <xref:System.Numerics.BigInteger> Objekt. Daher können wiederholte Aufrufe von <xref:System.Numerics.BigInteger.op_Increment%2A> teuer sein.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Add%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Decrement(System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Inequality">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei numerische Werte ungleich sind.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : int64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#25](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#25)]
 [!code-vb[System.Numerics.BigInteger.Operators#25](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#25)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType> Instanzmethode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und einem Wert mit langer Ganzzahl mit Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType> Instanzmethode und umkehren ihres Werts.  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * int64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl mit Vorzeichen ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#26)]
 [!code-vb[System.Numerics.BigInteger.Operators#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#26)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und einem Wert mit langer Ganzzahl mit Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Int64%29?displayProperty=nameWithType>-Methode und umkehren ihres Werts.  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob zwei <see cref="T:System.Numerics.BigInteger" />-Objekte über unterschiedliche Werte verfügen.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#26](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#26)]
 [!code-vb[System.Numeric.BigInteger.Class#26](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#26)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>-Methode, die die Beziehung zwischen zwei <xref:System.Numerics.BigInteger> Objekten angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.Numerics.BigInteger%29?displayProperty=nameWithType>-Methode und umkehren ihres Werts.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert und eine 64-Bit-Ganzzahl ohne Vorzeichen ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#27)]
 [!code-vb[System.Numerics.BigInteger.Operators#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#27)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und einem langen ganzzahligen Wert ohne Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>-Methode und umkehren ihres Werts.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Inequality(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen und ein <see cref="T:System.Numerics.BigInteger" />-Wert ungleich sind.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Inequality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#28](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#28)]
 [!code-vb[System.Numerics.BigInteger.Operators#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#28)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können mit einem der folgenden Verfahren auf Ungleichheit testen:  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode, die die Beziehung zwischen einem <xref:System.Numerics.BigInteger> und einem langen ganzzahligen Wert ohne Vorzeichen angibt.  
  
-   Aufrufen der <xref:System.Numerics.BigInteger.Equals%28System.UInt64%29?displayProperty=nameWithType>-Methode und umkehren ihres Werts.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_Equality" />
      </Docs>
    </Member>
    <Member MemberName="op_LeftShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &lt;&lt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_LeftShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;&lt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &lt;&lt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &lt;&lt;&lt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &lt;&lt;&lt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <paramref name="value" /> nach links verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach links.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach links verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LeftShift%2A>-Methode definiert den Vorgang des bitweisen Links Schiebe Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#29)]
 [!code-vb[System.Numerics.BigInteger.Operators#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#29)]  
  
> [!NOTE]
>  Im Gegensatz zum bitweisen Left Shift-Vorgang mit ganzzahligen primitiven behält die <xref:System.Numerics.BigInteger.op_LeftShift%2A>-Methode das Vorzeichen des ursprünglichen <xref:System.Numerics.BigInteger> Werts bei.  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können einen bitweisen Left Shift-Vorgang ausführen, indem Sie `value` mit `BigInteger.Pow(2, shift)`multiplizieren. Das folgende Beispiel zeigt, dass die Ergebnisse mit den Ergebnissen der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#30](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#30)]
 [!code-vb[System.Numerics.BigInteger.Operators#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#30)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThan">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als ein zweiter angegebener Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A>-Methode definiert den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#31)]
 [!code-vb[System.Numerics.BigInteger.Operators#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#31)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_LessThan%28System.Int64%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#32)]  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A>-Methode definiert den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#33](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#33)]
 [!code-vb[System.Numerics.BigInteger.Operators#33](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#33)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Int64%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#34](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#34)]  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als ein anderer <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A>-Methode definiert den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#27](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#27)]
 [!code-vb[System.Numeric.BigInteger.Class#27](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#27)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Compare%2A?displayProperty=nameWithType>-Methode aufzurufen. Einige Sprachen können auch die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29> Methode direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#28](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#28)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als eine 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A>-Methode definiert den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#35](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#35)]
 [!code-vb[System.Numerics.BigInteger.Operators#35](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#35)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThan%28System.Numerics.BigInteger%2CSystem.UInt64%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#36](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#36)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThan">
      <MemberSignature Language="C#" Value="public static bool operator &lt; (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThan(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThan(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt; (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt; ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt; right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner als <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThan%2A>-Methode definiert den Vorgang des kleiner-als-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#37](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#37)]
 [!code-vb[System.Numerics.BigInteger.Operators#37](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#37)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThan%28System.UInt64%2CSystem.Numerics.BigInteger%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#38](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#38)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThanOrEqual" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_LessThanOrEqual">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt einen Wert zurück, der angibt, ob ein angegebener Wert kleiner als oder gleich einem anderen Wert ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (long left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Int64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As Long, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(long left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : int64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Int64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl mit Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des Operators "kleiner als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#39](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#39)]
 [!code-vb[System.Numerics.BigInteger.Operators#39](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#39)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Int64%2CSystem.Numerics.BigInteger%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#40](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#40)]  
  
 Wenn `left` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, long right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As Long) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, long right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * int64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl mit Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des Operators "kleiner als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#41](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#41)]
 [!code-vb[System.Numerics.BigInteger.Operators#41](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#41)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Int64%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#42](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#42)]  
  
 Wenn `right` ein <xref:System.Byte>, <xref:System.Int16>, <xref:System.Int32>, <xref:System.SByte>, <xref:System.UInt16>oder <xref:System.UInt32> Wert ist, wird er implizit in einen <xref:System.Int64> Wert konvertiert, wenn der Vorgang ausgeführt wird.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.Int64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner oder gleich einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des Operators "kleiner als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#29](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#29)]
 [!code-vb[System.Numeric.BigInteger.Class#29](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#29)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Compare%2A>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numeric.BigInteger.Class#30](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#30)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Compare%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (System.Numerics.BigInteger left, ulong right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(valuetype System.Numerics.BigInteger left, unsigned int64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.Numerics.BigInteger,System.UInt64)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As BigInteger, right As ULong) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::Numerics::BigInteger left, System::UInt64 right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : System.Numerics.BigInteger * uint64 -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob ein <see cref="T:System.Numerics.BigInteger" />-Wert kleiner als oder gleich einer 64-Bit-Ganzzahl ohne Vorzeichen ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des Operators "kleiner als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#43](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#43)]
 [!code-vb[System.Numerics.BigInteger.Operators#43](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#43)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.Numerics.BigInteger%2CSystem.UInt64%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#44](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#44)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_LessThanOrEqual">
      <MemberSignature Language="C#" Value="public static bool operator &lt;= (ulong left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_LessThanOrEqual(unsigned int64 left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_LessThanOrEqual(System.UInt64,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &lt;= (left As ULong, right As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator &lt;=(System::UInt64 left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( &lt;= ) : uint64 * System.Numerics.BigInteger -&gt; bool" Usage="left &lt;= right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.UInt64" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu vergleichende Wert.</param>
        <param name="right">Der zweite zu vergleichende Wert.</param>
        <summary>Gibt einen Wert zurück, der angibt, ob eine 64-Bit-Ganzzahl ohne Vorzeichen kleiner als ein oder gleich einem <see cref="T:System.Numerics.BigInteger" />-Wert ist.</summary>
        <returns><see langword="true" />, wenn <paramref name="left" /> kleiner oder gleich <paramref name="right" /> ist, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%2A>-Methode definiert den Vorgang des Operators "kleiner als oder gleich" für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#45](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/Operator1.cs#45)]
 [!code-vb[System.Numerics.BigInteger.Operators#45](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#45)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>-Methode aufzurufen. Sie können die <xref:System.Numerics.BigInteger.op_LessThanOrEqual%28System.UInt64%2CSystem.Numerics.BigInteger%29>-Methode auch direkt aufzurufen, wie im folgenden Beispiel gezeigt.  
  
 [!code-vb[System.Numerics.BigInteger.Operators#46](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#46)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.CompareTo%28System.UInt64%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.op_LessThan" />
      </Docs>
    </Member>
    <Member MemberName="op_Modulus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator % (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Modulus(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Mod (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator %(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member ( % ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="dividend % divisor" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Gibt den Rest aus der Division zweier angegebener <see cref="T:System.Numerics.BigInteger" />-Werte zurück.</summary>
        <returns>Der Rest, der sich aus der Division ergibt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Modulus%2A>-Methode definiert den Vorgang des Modulo-Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#31](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#31)]
 [!code-vb[System.Numeric.BigInteger.Class#31](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#31)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Remainder%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 Das Vorzeichen des Werts, der durch den Modulo-Vorgang zurückgegeben wird, hängt vom Vorzeichen des `dividend`ab: Wenn `dividend` positiv ist, gibt der Modulo-Vorgang ein positives Ergebnis zurück. Wenn Sie negativ ist, gibt der Modulo-Vorgang ein negatives Ergebnis zurück. Das Verhalten des Modulo-Vorgangs mit <xref:System.Numerics.BigInteger>-Werten ist mit dem Modulo-Vorgang mit anderen ganzzahligen Typen identisch.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Remainder%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.op_Division(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator * (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Multiply(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator *(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der erste zu multiplizierende Wert.</param>
        <param name="right">Der zweite zu multiplizierende Wert.</param>
        <summary>Multipliziert zwei angegebene <see cref="T:System.Numerics.BigInteger" />-Werte.</summary>
        <returns>Das Produkt von <paramref name="left" /> und <paramref name="right" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Multiply%2A>-Methode definiert den Vorgang des Multiplikations Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#11](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#11)]
 [!code-vb[System.Numeric.BigInteger.Class#11](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#11)]  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Multiply(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_OnesComplement">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator ~ (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_OnesComplement(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_OnesComplement(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator Not (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator ~(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_OnesComplement : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.op_OnesComplement value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein ganzzahliger Wert.</param>
        <summary>Gibt das bitweise Einerkomplement eines <see cref="T:System.Numerics.BigInteger" />-Werts zurück.</summary>
        <returns>Das bitweise Einerkomplement von <paramref name="value" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A>-Methode definiert den Vorgang des bitweisen einerkomplementoperators für <xref:System.Numerics.BigInteger> Werte. Der bitweise One-komplementatoroperator kehrt jedes Bit in einem numerischen Wert um. Das heißt, Bits in `value`, die 0 sind, werden im Ergebnis auf 1 festgelegt, und Bits, die 1 sind, werden im Ergebnis auf 0 festgelegt. Die <xref:System.Numerics.BigInteger.op_OnesComplement%2A>-Methode ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/cs/OnesComplement1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.OnesComplement#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/OnesComplement1.vb#1)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können möglicherweise die <xref:System.Numerics.BigInteger.op_OnesComplement%2A>-Methode direkt aufzurufen, um einen bitweisen Einfügevorgang auszuführen. Beispiel:  
  
 [!code-vb[System.Numerics.BigInteger.OnesComplement#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OnesComplement/vb/onescomplement2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_RightShift">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator &gt;&gt; (System.Numerics.BigInteger value, int shift);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_RightShift(valuetype System.Numerics.BigInteger value, int32 shift) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_RightShift(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator &gt;&gt; (value As BigInteger, shift As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator &gt;&gt;(System::Numerics::BigInteger value, int shift);" />
      <MemberSignature Language="F#" Value="static member ( &gt;&gt;&gt; ) : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="value &gt;&gt;&gt; shift" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="shift" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Der Wert, dessen Bits verschoben werden sollen.</param>
        <param name="shift">Die Anzahl der Bits, um die <paramref name="value" /> nach rechts verschoben werden soll.</param>
        <summary>Verschiebt einen <see cref="T:System.Numerics.BigInteger" />-Wert um eine angegebene Anzahl von Bits nach rechts.</summary>
        <returns>Ein Wert, der um die angegebene Anzahl von Bits nach rechts verschoben wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Mit der <xref:System.Numerics.BigInteger.op_RightShift%2A>-Methode wird der bitweise Right Shift-Operator für <xref:System.Numerics.BigInteger> Werte definiert. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#47](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#47)]
 [!code-vb[System.Numerics.BigInteger.Operators#47](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#47)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können einen bitweisen rechts Verschiebungs Vorgang durchführen, indem Sie `value` durch `BigInteger.Pow(2, shift)` Dividieren und `shift` für negative Werte. Das folgende Beispiel zeigt, dass die Ergebnisse mit den Ergebnissen der Verwendung dieses Operators identisch sind.  
  
 [!code-csharp[System.Numerics.BigInteger.Operators#48](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/cs/RightShift1.cs#48)]
 [!code-vb[System.Numerics.BigInteger.Operators#48](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Operators/vb/Operator1.vb#48)]  
  
 Wenn `shift` größer oder gleich der Anzahl von Bits in einem positiven <xref:System.Numerics.BigInteger> Wert ist, wird das Ergebnis der nach rechts Verschiebungs Operation <xref:System.Numerics.BigInteger.Zero%2A?displayProperty=nameWithType>. Wenn `shift` größer als die Anzahl der Bits in einem negativen <xref:System.Numerics.BigInteger> Wert ist, wird das Ergebnis der Right Shift-Operation <xref:System.Numerics.BigInteger.MinusOne%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_LeftShift(System.Numerics.BigInteger,System.Int32)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_Subtraction(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen <see cref="T:System.Numerics.BigInteger" />-Wert.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_Subtraction%2A>-Methode definiert den Vorgang des Subtraktions Operators für <xref:System.Numerics.BigInteger> Werte. Dies ermöglicht Code wie den folgenden:  
  
 [!code-csharp[System.Numeric.BigInteger.Class#14](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#14)]
 [!code-vb[System.Numeric.BigInteger.Class#14](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#14)]  
  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Subtract%2A?displayProperty=nameWithType>-Methode aufzurufen.  
  
 Die äquivalente Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Subtract%28System.Numerics.BigInteger%2CSystem.Numerics.BigInteger%29?displayProperty=nameWithType>.]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator - (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryNegation(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryNegation(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator -(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Der zu negierende Wert.</param>
        <summary>Negiert einen angegebenen BigInteger-Wert.</summary>
        <returns>Das Ergebnis des <paramref name="value" />-Parameters, multipliziert mit -1.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryNegation%2A>-Methode definiert den Vorgang des unären Negations Operators (oder den Additiven umgekehrten Operator) für <xref:System.Numerics.BigInteger> Werte. Der-Vorgang erzeugt einen Wert, der 0 (null) ergibt, wenn er der ursprünglichen Zahl hinzugefügt wird. Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.BigInteger.Negate%2A>-Methode aufzurufen.  
  
 Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.BigInteger.Negate%28System.Numerics.BigInteger%29?displayProperty=nameWithType>  
  
## Examples  
 Im folgenden Beispiel werden drei verschiedene Möglichkeiten veranschaulicht, den Wert eines <xref:System.Numerics.BigInteger> Objekts zu negieren.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#16](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#16)]
 [!code-vb[System.Numeric.BigInteger.Class#16](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#16)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_UnaryPlus">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger operator + (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.BigInteger op_UnaryPlus(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.op_UnaryPlus(System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (value As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger operator +(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member ( ~+ ) : System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="+ value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value">Ein ganzzahliger Wert.</param>
        <summary>Gibt den Wert des <see cref="T:System.Numerics.BigInteger" />-Operanden zurück. (Das Vorzeichen des Operanden wird nicht geändert.)</summary>
        <returns>Der Wert des <paramref name="value" />-Operanden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.op_UnaryPlus%2A>-Methode definiert den Vorgang des unären positiven Operators für <xref:System.Numerics.BigInteger> Werte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Parse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value);" />
      <MemberSignature Language="F#" Value="static member Parse : string -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die die zu konvertierende Zahl enthält.</param>
        <summary>Wandelt die angegebene Zeichenfolgendarstellung einer Zahl in ihre <see cref="T:System.Numerics.BigInteger" />-Entsprechung um.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter sollte die Zeichen folgen Darstellung einer Zahl in der folgenden Form sein.  
  
 [*WS*] [*Sign*] *Ziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> der aktuellen Kultur bestimmt.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Die durch den `value`-Parameter angegebene Zeichenfolge wird mithilfe des <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stils interpretiert. Er darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und er darf keinen Dezimaltrennzeichen enthalten.  
  
 Der `value`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo?displayProperty=nameWithType>-Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>. Verwenden Sie die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode, um eine Zeichenfolge mithilfe der Formatierungsinformationen einer bestimmten Kultur zu analysieren.  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode zum Roundtrip der Zeichen folgen Darstellung eines <xref:System.Numerics.BigInteger> Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A>-Methode ausgegeben wurde, sollten Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts zu generieren. Andernfalls behält die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und Daten gehen verloren, wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode verwenden, um den <xref:System.Numerics.BigInteger> Wert wiederherzustellen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.Parse%28System.String%29>-Methode verwendet, um zwei <xref:System.Numerics.BigInteger>-Objekte zu instanziieren. Jedes Objekt wird mit einer anderen Zahl multipliziert, und dann wird die <xref:System.Numerics.BigInteger.Compare%2A>-Methode aufgerufen, um die Beziehung zwischen den beiden Werten zu bestimmen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Parse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <paramref name="value" /> angeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, das positive oder negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen), die im `value`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. `styles` muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration sein. Der `style`-Parameter macht diese Methoden Überladung nützlich, wenn `value` die Zeichen folgen Darstellung eines hexadezimalen Werts enthält, wenn das von `value` dargestellte Zahlensystem (Decimal oder hexadezimal) nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen oder ein Vorzeichen Symbol in `value`nicht zulassen möchten.  
  
 Abhängig vom Wert `style`kann der `value` Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*Ziffern*,] *Ziffern*[. *fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn `style` <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>enthält, kann der `value`-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der aktuellen Kultur definiert. Das Währungssymbol der aktuellen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `value` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Bei *fractional_digits*ist nur die Ziffer 0 gültig.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der aktuellen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der aktuellen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält. Nur die Ziffer 0 (null) kann als eine Bruch Ziffer angezeigt werden, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Wenn *fractional_digits* eine beliebige andere Ziffer einschließt, wird eine <xref:System.FormatException> ausgelöst.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht), wird immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie sich einzelne <xref:System.Globalization.NumberStyles> Elemente auf die Elemente auswirken, die in `value`vorhanden sein können.  
  
|Wert vom Typ `NumberStyles`|In `value` zulässige Elemente zusätzlich zu Ziffern|  
|--------------------------|---------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das *digits* -Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (.) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialnotation angibt, sowie *Exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `value` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `value`, Signieren am Anfang `value`und das Dezimal *Trennzeichen* (*.*). Der `value`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Gruppen Trennzeichen (*,*) und Dezimaltrennzeichen (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `value` keine hexadezimal Zahl darstellen.|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode zum Roundtrip der Zeichen folgen Darstellung eines <xref:System.Numerics.BigInteger> Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A>-Methode ausgegeben wurde, sollten Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts zu generieren. Andernfalls behält die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und Daten gehen verloren, wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode verwenden, um den <xref:System.Numerics.BigInteger> Wert wiederherzustellen.  
  
 Anders als bei den anderen <xref:System.Globalization.NumberStyles> Werten, die das vorhanden sein bestimmter Stilelemente in `value`zulassen, bedeutet der <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>-Stilwert, dass die einzelnen numerischen Zeichen in `value` immer als hexadezimale Zeichen interpretiert werden. Gültige hexadezimale Zeichen sind 0-9, a-f und A-f. Die einzigen anderen Flags, die mit dem `style`-Parameter kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles>-Enumeration enthält einen zusammengesetzten Zahlen Stil, <xref:System.Globalization.NumberStyles.HexNumber>, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung (z. b. `0x` oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist, interpretiert die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode `value` als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden hexadezimalen Ziffern größer oder gleich `0x80`sind. Dies bedeutet, dass die-Methode das oberste Bit des ersten Bytes in `value` als Signier Bit interpretiert. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss die erste Ziffer in `value` den Wert 0 (null) aufweisen. Beispielsweise interpretiert die-Methode `0x80` als negativen Wert, interpretiert jedoch entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Der `value`-Parameter wird mithilfe der Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt analysiert, das für die aktuelle System Kultur initialisiert wird. Um die Kultur anzugeben, deren Formatierungsinformationen für den Analyse Vorgang verwendet werden, müssen Sie die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29> Überladung aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel werden Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode mit mehreren möglichen Werten für den `style`-Parameter veranschaulicht. Es veranschaulicht, wie eine Zeichenfolge als Hexadezimalwert interpretiert wird und wie Leerzeichen und Signierungs Symbole nicht zugelassen werden.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#5)]
 [!code-vb[System.Numeric.BigInteger.Parse#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#5)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
Oder 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> folgt nicht dem mit <see cref="T:System.Globalization.NumberStyles" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen kulturspezifischen Format in die <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `value`-Parameter sollte die Zeichen folgen Darstellung einer Zahl in der folgenden Form sein:  
  
 [*WS*] [*Sign*] *Ziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> des <xref:System.Globalization.NumberFormatInfo> Objekts bestimmt, das von der <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider` Objekts zurückgegeben wird.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9. Alle führenden Nullen werden ignoriert.|  
  
> [!NOTE]
>  Die durch den `value`-Parameter angegebene Zeichenfolge wird mithilfe des <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stils interpretiert. Er darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und er darf keinen Dezimaltrennzeichen enthalten.  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode zum Roundtrip der Zeichen folgen Darstellung eines <xref:System.Numerics.BigInteger> Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A>-Methode ausgegeben wurde, sollten Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts zu generieren. Andernfalls behält die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und Daten gehen verloren, wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode verwenden, um den <xref:System.Numerics.BigInteger> Wert wiederherzustellen.  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung, deren <xref:System.IFormatProvider.GetFormat%2A>-Methode ein <xref:System.Globalization.NumberFormatInfo> Objekt zurückgibt, das kulturspezifische Formatierungsinformationen bereitstellt. Wenn die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.IFormatProvider%29>-Methode aufgerufen wird, ruft Sie die <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters auf und übergibt ihr ein <xref:System.Type> Objekt, das den <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt dann das <xref:System.Globalization.NumberFormatInfo>-Objekt zurück, das Informationen zum Format des `value`-Parameters bereitstellt. Es gibt drei Möglichkeiten, den `provider`-Parameter zu verwenden, um benutzerdefinierte Formatierungsinformationen für den Analyse Vorgang bereitzustellen:  
  
-   Sie können ein <xref:System.Globalization.CultureInfo> Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche <xref:System.Globalization.NumberFormatInfo> Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null`ist, wird die Formatierung der `value` basierend auf dem <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur interpretiert.  
  
   
  
## Examples  
 In den folgenden Beispielen werden zwei Möglichkeiten zum Definieren der Tilde (~) als ein negatives Vorzeichen zum Formatieren von <xref:System.Numerics.BigInteger> Werten gezeigt. Beachten Sie, dass der Code die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29?displayProperty=nameWithType>-Methode aufrufen und das <xref:System.Globalization.NumberFormatInfo> Objekt übergeben muss, das Formatierungsinformationen bereitstellt, um die <xref:System.Numerics.BigInteger> Werte im gleichen Format wie die ursprünglichen Zeichen folgen anzuzeigen.  
  
 Im ersten Beispiel wird eine Klasse definiert, die <xref:System.IFormatProvider> implementiert und die <xref:System.IFormatProvider.GetFormat%2A>-Methode verwendet, um das <xref:System.Globalization.NumberFormatInfo> Objekt zurückzugeben, das Formatierungsinformationen bereitstellt.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#2)]
 [!code-vb[System.Numeric.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#2)]  
  
 Ein <xref:System.Numerics.BigInteger>-Objekt kann dann mit folgendem Code instanziiert werden:  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#3)]
 [!code-vb[System.Numeric.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#3)]  
  
 Das zweite Beispiel ist einfacher. Sie übergibt das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt, an den `provider`-Parameter.  
  
 [!code-csharp[System.Numeric.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/cs/System.Numeric.BigInteger.Parse.cs#4)]
 [!code-vb[System.Numeric.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Parse/vb/System.Numeric.BigInteger.Parse.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> weist nicht das richtige Format auf.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style = System.Globalization.NumberStyles.Integer, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As ReadOnlySpan(Of Char), Optional style As NumberStyles = System.Globalization.NumberStyles.Integer, Optional provider As IFormatProvider = null) As BigInteger" />
      <MemberSignature Language="F#" Value="static member Parse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Eine schreibgeschützte Spanne von Zeichen, die die zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <paramref name="value" /> angeben.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Konvertiert die-Darstellung einer Zahl, die in der angegebenen schreibgeschützten Spanne von Zeichen enthalten ist, in einem angegebenen Stil in die jeweilige <see cref="T:System.Numerics.BigInteger" />-Entsprechung.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, das positive oder negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen), die im `value`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. `styles` muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration sein. Der `style`-Parameter macht diese Methoden Überladung nützlich, wenn `value` die Darstellung eines hexadezimalen Werts enthält, wenn das Zahlensystem (Decimal oder hexadezimal), das von `value` dargestellt wird, nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen oder ein Vorzeichen Symbol in `value`nicht zulassen möchten.

Abhängig vom Wert `style`kann der `value` Parameter die folgenden Elemente enthalten:

[*WS*] [*$*] [*Sign*] [*Ziffern*,] *Ziffern*[*. fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]

Wenn `style` <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>enthält, kann der `value`-Parameter die folgenden Elemente enthalten:

[*WS*] *Hexziffern*[*WS*]

Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in `value` wird durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> der Kultur definiert, die durch den `provider`-Parameter angegeben wird. Das Währungssymbol der aktuellen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `value` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Bei *fractional_digits*ist nur die Ziffer 0 gültig.|
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der durch `provider` angegebenen Kultur kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der Kultur, die von `provider` festgelegt wird, kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält. Nur die Ziffer 0 (null) kann als eine Bruch Ziffer angezeigt werden, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Wenn *fractional_digits* eine beliebige andere Ziffer einschließt, wird eine <xref:System.FormatException> ausgelöst.|
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|

> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

Eine `value` mit nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Format entspricht) wird immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden sind, jedoch in `value`nicht vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie sich einzelne <xref:System.Globalization.NumberStyles> Elemente auf die Elemente auswirken, die in `value`vorhanden sein können.

|NumberStyles-Wert|Als Wert zulässige Elemente zusätzlich zu Ziffern|
|------------------------|-------------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None>|Nur das *digits* -Element.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (.) und die Elemente der *Bruch Ziffern* .|
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. zusammen mit *Exponential_digits*.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `value`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `value`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `value`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `value`.|
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (,).|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `value` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `value`, Signieren am Anfang `value`und das Dezimal *Trennzeichen* (.). Der `value`-Parameter kann auch die Exponentialnotation verwenden.|
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Gruppen Trennzeichen (,) und Dezimaltrennzeichen (.).|
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `value` keine hexadezimal Zahl darstellen.|

Anders als bei den anderen <xref:System.Globalization.NumberStyles> Werten, die das vorhanden sein bestimmter Stilelemente in `value`zulassen, bedeutet der <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>-Stilwert, dass die einzelnen numerischen Zeichen in `value` immer als hexadezimale Zeichen interpretiert werden. Gültige hexadezimale Zeichen sind 0-9, a-f und A-f. Die einzigen anderen Flags, die mit dem `style`-Parameter kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles>-Enumeration enthält einen zusammengesetzten Zahlen Stil, <xref:System.Globalization.NumberStyles.HexNumber>, der beide Leerzeichen enthält.)


Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format von `value`bereitstellt. In der Regel kann `provider` eine der folgenden sein:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo>-Objekt zurück, das numerische Formatierungsinformationen bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo>-Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)

-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider> implementiert und die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A>-Methode zum Instanziieren und Zurückgeben des <xref:System.Globalization.NumberFormatInfo> Objekts verwendet, das Formatierungsinformationen bereitstellt.

Wenn `provider` `null`ist, wird das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur verwendet.

            ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
Oder 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> folgt nicht dem mit <paramref name="style" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Parse">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Parse (string value, System.Globalization.NumberStyles style, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Parse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Parse(System.String,System.Globalization.NumberStyles,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Parse (value As String, style As NumberStyles, provider As IFormatProvider) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Parse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="static member Parse : string * System.Globalization.NumberStyles * IFormatProvider -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Parse (value, style, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="value">Eine Zeichenfolge, die eine zu konvertierende Zahl enthält.</param>
        <param name="style">Eine bitweise Kombination der Enumerationswerte, die das zulässige Format von <paramref name="value" /> angeben.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturabhängigen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" />.</summary>
        <returns>Ein Wert, der der im <paramref name="value" />-Parameter angegebenen Zahl entspricht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen, das positive oder negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen), die im `value`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. `styles` muss eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration sein. Der `style`-Parameter macht diese Methoden Überladung nützlich, wenn `value` die Zeichen folgen Darstellung eines hexadezimalen Werts enthält, wenn das von `value` dargestellte Zahlensystem (Decimal oder hexadezimal) nur zur Laufzeit bekannt ist oder wenn Sie Leerzeichen oder ein Vorzeichen Symbol in `value`nicht zulassen möchten.  
  
 Abhängig vom Wert `style`kann der `value` Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*Ziffern*,] *Ziffern*[*. fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn `style` <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>enthält, kann der `value`-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyNegativePattern%2A?displayProperty=nameWithType>-und <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A?displayProperty=nameWithType> Eigenschaften der Kultur definiert, die durch den `provider`-Parameter angegeben wird. Das Währungssymbol der aktuellen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `value` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*Ziffern*<br /><br /> *fractional_digits*<br /><br /> *exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Bei *fractional_digits*ist nur die Ziffer 0 gültig.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der durch `provider` angegebenen Kultur kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der Kultur, die von `provider` festgelegt wird, kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält. Nur die Ziffer 0 (null) kann als eine Bruch Ziffer angezeigt werden, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Wenn *fractional_digits* eine beliebige andere Ziffer einschließt, wird eine <xref:System.FormatException> ausgelöst.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge, die nur Ziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType> Stil entspricht), wird immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die möglicherweise vorhanden sind, jedoch nicht in der Eingabe Zeichenfolge vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie sich einzelne <xref:System.Globalization.NumberStyles> Elemente auf die Elemente auswirken, die in `value`vorhanden sein können.  
  
|NumberStyles-Wert|Als Wert zulässige Elemente zusätzlich zu Ziffern|  
|------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur das *digits* -Element.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Die Dezimaltrennzeichen (.) und die Elemente der *Bruch Ziffern* .|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialschreibweise angibt. zusammen mit *Exponential_digits*.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Sign* -Element am Anfang `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element am Ende `value`.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (,).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency ($)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `value` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `value`, Signieren am Anfang `value`und das Dezimal *Trennzeichen* (.). Der `value`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente `ws`, `sign`, Gruppen Trennzeichen (,) und Dezimaltrennzeichen (.).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `value` keine hexadezimal Zahl darstellen.|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode zum Roundtrip der Zeichen folgen Darstellung eines <xref:System.Numerics.BigInteger> Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A>-Methode ausgegeben wurde, sollten Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts zu generieren. Andernfalls behält die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und Daten gehen verloren, wenn Sie die <xref:System.Numerics.BigInteger.Parse%2A>-Methode verwenden, um den <xref:System.Numerics.BigInteger> Wert wiederherzustellen.  
  
 Anders als bei den anderen <xref:System.Globalization.NumberStyles> Werten, die das vorhanden sein bestimmter Stilelemente in `value`zulassen, bedeutet der <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>-Stilwert, dass die einzelnen numerischen Zeichen in `value` immer als hexadezimale Zeichen interpretiert werden. Gültige hexadezimale Zeichen sind 0-9, a-f und A-f. Die einzigen anderen Flags, die mit dem `style`-Parameter kombiniert werden können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles>-Enumeration enthält einen zusammengesetzten Zahlen Stil, <xref:System.Globalization.NumberStyles.HexNumber>, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung (z. b. `0x` oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist, interpretiert die <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%29>-Methode `value` als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden hexadezimalen Ziffern größer oder gleich `0x80`sind. Dies bedeutet, dass die-Methode das oberste Bit des ersten Bytes in `value` als Signier Bit interpretiert. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss die erste Ziffer in `value` den Wert 0 (null) aufweisen. Beispielsweise interpretiert die-Methode `0x80` als negativen Wert, interpretiert jedoch entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/ParseHex1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.Parse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/ParseHex1.vb#3)]  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format von `value`bereitstellt. In der Regel kann `provider` eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die numerische Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo>-Objekt zurück, das numerische Formatierungsinformationen bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo>-Objekt, das Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)  
  
-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider> implementiert und die <xref:System.Globalization.NumberFormatInfo.GetFormat%2A>-Methode zum Instanziieren und Zurückgeben des <xref:System.Globalization.NumberFormatInfo> Objekts verwendet, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null`ist, wird das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden mehrere Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode mithilfe verschiedener Kombinationen von Werten für die Parameter `style` und `provider` durchführt.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.Parse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#2)]  
  
 Eine Reihe einzelner Aufrufe der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negatives Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.Parse#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/cs/Parse1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.Parse#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Parse/vb/Parse1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
Oder 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <exception cref="T:System.FormatException"><paramref name="value" /> folgt nicht dem mit <paramref name="style" /> angegebenen Eingabemuster.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.TryParse" />
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Pow (System.Numerics.BigInteger value, int exponent);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Pow(valuetype System.Numerics.BigInteger value, int32 exponent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Pow(System.Numerics.BigInteger,System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As BigInteger, exponent As Integer) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Pow(System::Numerics::BigInteger value, int exponent);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.BigInteger * int -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Pow (value, exponent)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
        <Parameter Name="exponent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value">Die Zahl, deren <paramref name="exponent" />. Potenz berechnet werden soll.</param>
        <param name="exponent">Der Exponent, mit dem <paramref name="value" /> potenziert werden soll.</param>
        <summary>Potenziert einen <see cref="T:System.Numerics.BigInteger" />-Wert mit einem angegebenen Wert.</summary>
        <returns>Das Ergebnis der Potenzierung von <paramref name="value" /> mit <paramref name="exponent" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Pow%2A>-Methode gibt 1 zurück, wenn der Wert des Exponent-Parameters 0 ist, oder wenn die Werte der Parameter `value` und `exponent` 0 sind. Wenn `exponent` 1 ist, gibt die <xref:System.Numerics.BigInteger.Pow%2A>-Methode `value`zurück. Wenn `value` negativ ist, gibt die Methode ein negatives Ergebnis zurück.  
  
 Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType>-Methode für primitive numerische Typen.  
  
   
  
## Examples  
 Das folgende Beispiel veranschaulicht die exponentialisierung mithilfe eines <xref:System.Numerics.BigInteger> Werts und eines Exponenten, dessen Wert zwischen 0 und 10 liegt.  
  
 [!code-csharp[System.Numeric.BigInteger.Class#32](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/cs/BigInteger_Examples.cs#32)]
 [!code-vb[System.Numeric.BigInteger.Class#32](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.Class/vb/BigInteger_Examples.vb#32)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="exponent" /> ist ein negativer Wert.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remainder">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Remainder (System.Numerics.BigInteger dividend, System.Numerics.BigInteger divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Remainder(valuetype System.Numerics.BigInteger dividend, valuetype System.Numerics.BigInteger divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Remainder(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Remainder (dividend As BigInteger, divisor As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Remainder(System::Numerics::BigInteger dividend, System::Numerics::BigInteger divisor);" />
      <MemberSignature Language="F#" Value="static member Remainder : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Remainder (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.BigInteger" />
        <Parameter Name="divisor" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="dividend">Der zu dividierende Wert.</param>
        <param name="divisor">Der Wert, durch den dividiert werden soll.</param>
        <summary>Führt die Ganzzahldivision von zwei <see cref="T:System.Numerics.BigInteger" />-Werten aus und gibt den Rest zurück.</summary>
        <returns>Der Rest aus der Division von <paramref name="dividend" /> durch <paramref name="divisor" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Vorzeichen des Restwerts ist das Vorzeichen des `dividend`-Parameters.  
  
 Die <xref:System.Numerics.BigInteger.Remainder%2A>-Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen. Das Verhalten ist mit der Division identisch, wobei der Modulo-Operator verwendet wird.  
  
 Bei Bedarf führt die Methode automatisch eine implizite Konvertierung von anderen ganzzahligen Typen in <xref:System.Numerics.BigInteger> Objekte aus, bevor Sie den Modulo-Vorgang ausführt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird der Rest der <xref:System.Numerics.BigInteger.DivRem%2A>-Methode mit dem Rest verglichen, der von der <xref:System.Numerics.BigInteger.Remainder%2A>-Methode zurückgegeben wird, um festzulegen, dass die beiden Methoden identische Rest-Methoden berechnen.  
  
 [!code-csharp[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/cs/Remainder1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.Remainder#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.Remainder/vb/Remainder1.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.DivideByZeroException"><paramref name="divisor" /> ist 0 (null).</exception>
        <altmember cref="M:System.Numerics.BigInteger.DivRem(System.Numerics.BigInteger,System.Numerics.BigInteger,System.Numerics.BigInteger@)" />
        <altmember cref="M:System.Numerics.BigInteger.op_Modulus(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="Sign">
      <MemberSignature Language="C#" Value="public int Sign { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 Sign" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Sign" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Sign As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int Sign { int get(); };" />
      <MemberSignature Language="F#" Value="member this.Sign : int" Usage="System.Numerics.BigInteger.Sign" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zahl ab, die das Vorzeichen (negativ, positiv, oder 0 (null)) des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts angibt.</summary>
        <value>Eine Zahl, die das Vorzeichen des <see cref="T:System.Numerics.BigInteger" />-Objekts angibt, wie in der folgenden Tabelle veranschaulicht.  
  
 <list type="table"><listheader><term> Number 
 </term><description> BESCHREIBUNG 
 </description></listheader><item><term> -1 
 </term><description> Der Wert dieses Objekts ist negativ.  
  
 </description></item><item><term> 0 
 </term><description> Der Wert dieses Objekts ist null (0).  
  
 </description></item><item><term> 1 
 </term><description> Der Wert dieses Objekts ist positiv.  
  
 </description></item></list></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.Sign%2A>-Eigenschaft entspricht der <xref:System.Math.Sign%2A?displayProperty=nameWithType>-Methode für die primitiven numerischen Typen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Subtract (System.Numerics.BigInteger left, System.Numerics.BigInteger right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.BigInteger Subtract(valuetype System.Numerics.BigInteger left, valuetype System.Numerics.BigInteger right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.Subtract(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As BigInteger, right As BigInteger) As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::BigInteger Subtract(System::Numerics::BigInteger left, System::Numerics::BigInteger right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.BigInteger * System.Numerics.BigInteger -&gt; System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.BigInteger" />
        <Parameter Name="right" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="left">Der Wert, von dem subtrahiert werden soll (der Minuend).</param>
        <param name="right">Der Wert, der subtrahiert werden soll (der Subtrahend).</param>
        <summary>Subtrahiert einen <see cref="T:System.Numerics.BigInteger" />-Wert von einem anderen und gibt das Ergebnis zurück.</summary>
        <returns>Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können die <xref:System.Numerics.BigInteger.Subtract%2A>-Methode verwenden, um Subtraktion mithilfe <xref:System.Numerics.BigInteger> Werte auszuführen.  
  
 Die <xref:System.Numerics.BigInteger.Subtract%2A>-Methode ist ein nützlicher Ersatz für den Subtraktions Operator beim Instanziieren einer <xref:System.Numerics.BigInteger> Variablen, indem Sie Ihr den Unterschied aus der Subtraktion zuweist, wie im folgenden Beispiel gezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/cs/Multiply1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.OperationMethods#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.OperationMethods/vb/Multiply1.vb#3)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.BigInteger.op_Subtraction(System.Numerics.BigInteger,System.Numerics.BigInteger)" />
      </Docs>
    </Member>
    <Member MemberName="System.IComparable.CompareTo">
      <MemberSignature Language="C#" Value="int IComparable.CompareTo (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance int32 System.IComparable.CompareTo(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.System#IComparable#CompareTo(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Function CompareTo (obj As Object) As Integer Implements IComparable.CompareTo" />
      <MemberSignature Language="C++ CLI" Value=" virtual int System.IComparable.CompareTo(System::Object ^ obj) = IComparable::CompareTo;" />
      <MemberSignature Language="F#" Value="abstract member System.IComparable.CompareTo : obj -&gt; int&#xA;override this.System.IComparable.CompareTo : obj -&gt; int" Usage="bigInteger.System.IComparable.CompareTo obj" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IComparable.CompareTo(System.Object)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" Index="0" FrameworkAlternate="dotnet-uwp-10.0;netcore-1.0;netcore-1.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6" />
      </Parameters>
      <Docs>
        <param name="obj">Das zu vergleichende Objekt.</param>
        <summary>Vergleicht diese Instanz mit einem angegebenen Objekt und gibt eine ganze Zahl zurück, die angibt, ob der Wert dieser Instanz kleiner oder größer als der Wert des angegebenen Objekts ist oder mit diesem übereinstimmt.</summary>
        <returns>Eine ganze Zahl mit Vorzeichen, die die Beziehung der aktuellen Instanz zum <paramref name="obj" />-Parameter angibt, wie in der folgenden Tabelle veranschaulicht.
          <list type="table"><listheader><term> Rückgabewert</term><description> BESCHREIBUNG</description></listheader><item><term> Kleiner als 0 (null)</term><description> Die aktuelle Instanz ist kleiner als <paramref name="obj" />.</description></item><item><term> Null</term><description> Die aktuelle Instanz ist gleich <paramref name="obj" />.</description></item><item><term> Größer als 0 (null)</term><description> Die aktuelle Instanz ist größer als <paramref name="obj" />, oder der <paramref name="obj" />-Parameter ist <see langword="null" />.</description></item></list></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 Der `obj`-Parameter muss einer der folgenden sein:

-   Ein Objekt, dessen Lauf Zeittyp <xref:System.Numerics.BigInteger>ist.

-   Eine <xref:System.Object> Variable, deren Wert `null`ist. Wenn der Wert des `obj`-Parameters `null`ist, gibt die Methode 1 zurück, was darauf hinweist, dass die aktuelle Instanz größer als `obj`ist.

## Examples

Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.CompareTo%28System.Object%29>-Methode aufgerufen, um einen <xref:System.Numerics.BigInteger>-Wert mit jedem Element in einem Objekt Array zu vergleichen:

[!code-csharp[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/cs/Example2.cs#4)]
[!code-vb[System.Numerics.BigInteger.CompareTo#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.CompareTo/vb/Example2.vb#4)]

 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="obj" /> ist keine <see cref="T:System.Numerics.BigInteger" />.</exception>
        <altmember cref="M:System.Numerics.BigInteger.CompareTo(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray () As Byte()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Byte&gt; ^ ToByteArray();" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : unit -&gt; byte[]" Usage="bigInteger.ToByteArray " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert einen <see cref="T:System.Numerics.BigInteger" />-Wert in ein Bytearray.</summary>
        <returns>Der Wert des aktuellen, in ein Bytearray konvertierten <see cref="T:System.Numerics.BigInteger" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die einzelnen Bytes im Array, die von dieser Methode zurückgegeben werden, werden in Little-in-der-Reihenfolge angezeigt Das heißt, die nieder wertigen Bytes des Werts vor den Bytes höherer Reihenfolge. Das erste Byte des Arrays reflektiert die ersten acht Bits des <xref:System.Numerics.BigInteger> Werts, das zweite Byte die nächsten acht Bits usw. Beispielsweise wird der Wert 1024 oder 0x0400 als das folgende Array von zwei Bytes gespeichert:  
  
|Element|Bytewert|  
|-------------|----------------|  
|0|0x00|  
|1|0x04|  
  
 Negative Werte werden in das Array geschrieben, wobei die zwei Komplement Darstellung in der möglichst kompakten Form verwendet wird. Beispielsweise wird-1 als einzelnes Byte dargestellt, dessen Wert anstelle von als Array mit mehreren Elementen `0xFF` wird, z. b. `0xFF`, `0xFF` oder `0xFF`, `0xFF`, `0xFF``0xFF`.  
  
 Da in der zwei Komplement-Darstellung immer das höchste Bit des letzten Bytes im Array (das Byte an der Position <xref:System.Array.Length%2A?displayProperty=nameWithType>`- 1`) als Signier Bit interpretiert wird, gibt die Methode ein Bytearray mit einem zusätzlichen Element zurück, dessen Wert 0 (null) ist, um positive Werte zu unterscheiden, die andernfalls so interpretiert werden können, dass Sie Ihre Signier Bits festgelegt haben. Beispielsweise wird der Wert 120 oder `0x78` als Einzel Byte-Array dargestellt: `0x78`. 128 oder `0x80`wird jedoch als ein 2-Byte-Array dargestellt: `0x80`, `0x00`.  
  
 Sie können einen Roundtrip für einen <xref:System.Numerics.BigInteger> Wert durchsetzen, indem Sie ihn in einem Bytearray speichern und dann mithilfe des <xref:System.Numerics.BigInteger.%23ctor%28System.Byte%5B%5D%29> Konstruktors wiederherstellen.  
  
> [!CAUTION]
>  Wenn der Code den Wert einzelner Bytes in dem Array ändert, das von dieser Methode zurückgegeben wird, bevor der Wert wieder hergestellt wird, müssen Sie sicherstellen, dass das Signier Bit nicht versehentlich geändert wird. Wenn die Änderungen z. b. einen positiven Wert erhöhen, sodass das Bit mit der höchsten Ordnung im letzten Element des Byte Arrays festgelegt wird, können Sie ein neues Byte hinzufügen, dessen Wert 0 (null) bis zum Ende des Arrays ist.  
  
   
  
## Examples  
 Im folgenden Beispiel wird veranschaulicht, wie einige <xref:System.Numerics.BigInteger> Werte in Byte Arrays dargestellt werden.  
  
 [!code-csharp[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/cs/ToByteArray1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToByteArray#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToByteArray/vb/ToByteArray1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToByteArray">
      <MemberSignature Language="C#" Value="public byte[] ToByteArray (bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance unsigned int8[] ToByteArray(bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToByteArray(System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToByteArray (Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Byte()" />
      <MemberSignature Language="F#" Value="member this.ToByteArray : bool * bool -&gt; byte[]" Usage="bigInteger.ToByteArray (isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Byte[]</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <param name="isBigEndian"><see langword="true" />, um die Bytes in einer Big-Endian-Bytereihenfolge zu schreiben, andernfalls <see langword="false" />.</param>
        <summary>Liefert den Wert dieses <see cref="T:System.Numerics.BigInteger" /> als Bytearray mit der kleinstmöglichen Anzahl von Bytes. Wenn der Wert Null (0) ist, wird ein Array von einem Byte zurückgegeben, dessen Element 0x00 ist.</summary>
        <returns>Der Wert des aktuellen, in ein Bytearray konvertierten <see cref="T:System.Numerics.BigInteger" />-Objekts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Der ganzzahlige Wert `33022` kann in vier verschiedene Arrays exportiert werden:

| Eigenschaften                           | Ergebnis                          |
|--------------------------------------|---------------------------------|
| `isUnsigned: false, isBigEndian: false` | `new byte[] { 0xFE, 0x80, 0x00 }` |
| `isUnsigned: false, isBigEndian: true`  | `new byte[] { 0x00, 0x80, 0xFE }` |
| `isUnsigned: true, isBigEndian: false`  | `new byte[] { 0xFE, 0x80 } `      |
| `isUnsigned: true, isBigEndian: true`   | `new byte[] { 0x80, 0xFE }`       |

          ]]></format>
        </remarks>
        <exception cref="T:System.OverflowException">Wenn <paramref name="isUnsigned" /><see langword="true" /> und <see cref="P:System.Numerics.BigInteger.Sign" /> negativ ist.</exception>
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="bigInteger.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString>-Methode formatiert einen <xref:System.Numerics.BigInteger>-Wert im Format "R" oder im Roundtrip-Format der aktuellen Kultur. Wenn Sie ein anderes Format oder eine andere Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%2A>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts enthält ein negatives Vorzeichen, wenn der Wert negativ ist, und eine Folge von Ziffern zwischen 0 und 9 ohne führende Nullen. Das negative Vorzeichen wird durch das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur definiert.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Wert mit der <xref:System.Numerics.BigInteger.ToString>-Standardmethode angezeigt. Außerdem werden die Zeichen folgen Darstellungen des <xref:System.Numerics.BigInteger> Werts angezeigt, der sich aus der Verwendung einiger Standardformat Bearbeiter ergibt. Die Beispiele werden mithilfe der Formatierungs Konventionen der Kultur "en-US" angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#1)]  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="bigInteger.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="provider" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>-Methode formatiert einen <xref:System.Numerics.BigInteger> Wert im "R"-oder Roundtrip-Format mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt einer angegebenen Kultur. Wenn Sie ein anderes Format oder die aktuelle Kultur angeben möchten, verwenden Sie die anderen über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebenen Zeichenfolge bereitstellt. Wenn `provider` `null`ist, wird der <xref:System.Numerics.BigInteger> Wert mithilfe des <xref:System.Globalization.NumberFormatInfo> Objekts der aktuellen Kultur formatiert. Die einzige Eigenschaft des <xref:System.Globalization.NumberFormatInfo> Objekts, das die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts mit dem allgemeinen Format Bezeichner steuert, ist <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType>, der das Zeichen definiert, das das negative Vorzeichen darstellt.  
  
 Der `provider`-Parameter kann eines der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die Formatierungsinformationen bereitstellt.  
  
-   Das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.  
  
-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein benutzerdefiniertes <xref:System.Globalization.NumberFormatInfo> Objekt instanziiert, das die Tilde (~) als negatives Vorzeichen definiert. Die <xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>-Methode verwendet dann das benutzerdefinierte <xref:System.Globalization.NumberFormatInfo>-Objekt, um einen negativen <xref:System.Numerics.BigInteger> Wert anzuzeigen.  
  
 [!code-csharp[System.Numeric.BigInteger.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/cs/System.Numeric.BigInteger.ToString.cs#1)]
 [!code-vb[System.Numeric.BigInteger.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.ToString/vb/System.Numeric.BigInteger.ToString.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="bigInteger.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts im durch den <paramref name="format" />-Parameter angegebenen Format.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%29>-Methode formatiert einen <xref:System.Numerics.BigInteger>-Wert in einem angegebenen Format mithilfe eines <xref:System.Globalization.NumberFormatInfo> Objekts, das die Konventionen der aktuellen Kultur darstellt. Wenn Sie "R" oder "Roundtrip" verwenden möchten, geben Sie eine andere Kultur an, und verwenden Sie die anderen über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>|  
  
 Der `format`-Parameter kann eine beliebige gültige [numerische Standard Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings)oder eine beliebige Kombination aus [benutzerdefinierten numerischen Format](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen sein. Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`ist, wird der Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekts mit dem roundtripformatspezifizierer ("R") formatiert. Wenn `format` einen anderen Wert hat, löst die Methode eine <xref:System.FormatException>aus.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Unterstützung der Formatierung in der .NET Framework finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Das Format der zurückgegebenen Zeichenfolge wird durch das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur bestimmt. Abhängig vom `format`-Parameter steuert dieses Objekt Symbole wie das negative Vorzeichen, das Gruppen Trennzeichen und das Dezimaltrennzeichen in der Ausgabe Zeichenfolge. Um Formatierungsinformationen für andere Kulturen als die aktuelle Kultur bereitzustellen, müssen Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29> Überladung aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Wert initialisiert und mithilfe der Standardformat Zeichenfolge und einiger benutzerdefinierter Format Zeichenfolgen angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="bigInteger.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</param>
        <summary>Konvertiert den numerischen Wert des aktuellen <see cref="T:System.Numerics.BigInteger" />-Objekts unter Verwendung des angegebenen Formats und der angegebenen kulturspezifischen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung.</summary>
        <returns>Die Zeichenfolgendarstellung des aktuellen <see cref="T:System.Numerics.BigInteger" />-Werts entsprechend den Angaben in den Parametern <paramref name="format" /> und <paramref name="provider" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>-Methode formatiert einen <xref:System.Numerics.BigInteger>-Wert in einem angegebenen Format unter Verwendung des <xref:System.Globalization.NumberFormatInfo>-Objekts einer angegebenen Kultur. Wenn Sie das Roundtrip-Format oder die Standard Kultur Einstellungen verwenden möchten, verwenden Sie die anderen über Ladungen der <xref:System.Numerics.BigInteger.ToString%2A>-Methode wie folgt:  
  
|So verwenden Sie das Format|Für Kultur|Verwenden der Überladung|  
|-------------------|-----------------|----------------------|  
|Roundtrip-Format ("R")|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString>|  
|Roundtrip-Format ("R")|Eine bestimmte Kultur|<xref:System.Numerics.BigInteger.ToString%28System.IFormatProvider%29>|  
|Ein bestimmtes Format|Standard Kultur (aktuell)|<xref:System.Numerics.BigInteger.ToString%28System.String%29>|  
  
 Der `format`-Parameter kann eine beliebige gültige [numerische Standard Zeichenfolge](/dotnet/standard/base-types/standard-numeric-format-strings)oder eine beliebige Kombination aus [benutzerdefinierten numerischen Format](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen sein. Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`ist, wird der Rückgabewert des aktuellen <xref:System.Numerics.BigInteger> Objekts mit dem roundtripformatspezifizierer ("R") formatiert. Wenn `format` einen anderen Wert hat, löst die Methode eine <xref:System.FormatException>aus.  
  
 Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Formatierungs Themen ausführlicher beschrieben wird:  
  
-   Weitere Informationen zu numerischen Format Bezeichnerzeichen finden Sie unter [Standard mäßige Zahlenformat](/dotnet/standard/base-types/standard-numeric-format-strings) Zeichenfolgen und [benutzerdefinierte Zahlenformat](/dotnet/standard/base-types/custom-numeric-format-strings)Zeichenfolgen.  
  
-   Weitere Informationen zur Unterstützung der Formatierung in der .NET Framework finden Sie unter [Formatieren von Typen](/dotnet/standard/base-types/formatting-types).  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format der von dieser Methode zurückgegebenen Zeichenfolge bereitstellt. Wenn die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>-Methode aufgerufen wird, ruft Sie die <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters auf und übergibt ihr ein <xref:System.Type> Objekt, das den <xref:System.Globalization.NumberFormatInfo> Typ darstellt. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt dann das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Informationen zum Formatieren des `value` Parameters bereitstellt, z. b. das negative Vorzeichen Symbol, das Gruppen Trennzeichen oder das Dezimaltrennzeichen. Es gibt drei Möglichkeiten, den `provider`-Parameter zu verwenden, um Formatierungsinformationen für die <xref:System.Numerics.BigInteger.ToString%28System.String%2CSystem.IFormatProvider%29>-Methode bereitzustellen:  
  
-   Sie können ein <xref:System.Globalization.CultureInfo> Objekt übergeben, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Sie können das tatsächliche <xref:System.Globalization.NumberFormatInfo> Objekt übergeben, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)  
  
-   Sie können ein benutzerdefiniertes Objekt übergeben, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null`ist, basiert die Formatierung der zurückgegebenen Zeichenfolge auf dem <xref:System.Globalization.NumberFormatInfo>-Objekt der aktuellen Kultur.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein <xref:System.Numerics.BigInteger> Wert initialisiert und mithilfe einer Standardformat Zeichenfolge und eines <xref:System.Globalization.NumberFormatInfo> Objekts, das die Tilde (~) als negatives Vorzeichen definiert, der Konsole angezeigt.  
  
 [!code-csharp[System.Numerics.BigInteger.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/cs/ToString1.cs#4)]
 [!code-vb[System.Numerics.BigInteger.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.ToString/vb/ToString1.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</exception>
        <related type="Article" href="/dotnet/standard/base-types/standard-numeric-format-strings">Standardmäßige Zahlenformatzeichenfolgen</related>
        <related type="Article" href="/dotnet/standard/base-types/custom-numeric-format-strings">Benutzerdefinierte Zahlenformatzeichenfolgen</related>
      </Docs>
    </Member>
    <Member MemberName="TryFormat">
      <MemberSignature Language="C#" Value="public bool TryFormat (Span&lt;char&gt; destination, out int charsWritten, ReadOnlySpan&lt;char&gt; format = default, IFormatProvider provider = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryFormat(valuetype System.Span`1&lt;char&gt; destination, [out] int32&amp; charsWritten, valuetype System.ReadOnlySpan`1&lt;char&gt; format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryFormat(System.Span{System.Char},System.Int32@,System.ReadOnlySpan{System.Char},System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryFormat (destination As Span(Of Char), ByRef charsWritten As Integer, Optional format As ReadOnlySpan(Of Char) = null, Optional provider As IFormatProvider = null) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryFormat : Span&lt;char&gt; * int * ReadOnlySpan&lt;char&gt; * IFormatProvider -&gt; bool" Usage="bigInteger.TryFormat (destination, charsWritten, format, provider)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="charsWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="format" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Die Spanne von Zeichen, in die diese Instanz geschrieben werden soll.</param>
        <param name="charsWritten">Enthält bei der Rückgabe der Methode die Länge der Spanne als Anzahl der Zeichen.</param>
        <param name="format">Eine schreibgeschützte Spanne von Zeichen, die das Format für den Formatierungsvorgang angibt.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <summary>Formatiert diese BigInteger-Instanz in eine Spanne von Zeichen.</summary>
        <returns><see langword="true" />, wenn der Formatierungsvorgang erfolgreich ist, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="TryParse">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Die Darstellung einer Zahl als schreibgeschützte Spanne von Zeichen.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder null (0), wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="value" />-Parameter eine leere Zeichenspanne ist oder nicht im richtigen Format vorliegt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Darstellung einer Zahl, die in der angegebenen schreibgeschützten Zeichenspanne enthalten ist, in ihre Entsprechung <see cref="T:System.Numerics.BigInteger" /> zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich war.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="Overload:System.Numerics.BigInteger.Parse" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder null (0), wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="value" />-Parameter <see langword="null" /> ist oder nicht im korrekten Format vorliegt. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>-Methode ähnelt der <xref:System.Numerics.BigInteger.Parse%28System.String%29>-Methode, mit der Ausnahme, dass keine Ausnahme ausgelöst wird, wenn bei der Konvertierung ein Fehler auftritt. Diese Methode entfällt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `value` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `value`-Parameter sollte die Zeichen folgen Darstellung einer Dezimalzahl in der folgenden Form sein:  
  
 [*WS*] [*Sign*] *Ziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum.|  
|*sign*|Ein optionales Vorzeichen. Gültige Zeichen werden durch die Eigenschaften <xref:System.Globalization.NumberFormatInfo.NegativeSign%2A?displayProperty=nameWithType> und <xref:System.Globalization.NumberFormatInfo.PositiveSign%2A?displayProperty=nameWithType> der aktuellen Kultur bestimmt.|  
|*Ziffern*|Eine Sequenz von Dezimalziffern im Bereich von 0 bis 9.|  
  
> [!NOTE]
>  Die vom `value`-Parameter angegebene Zeichenfolge darf keine Gruppen Trennzeichen oder Dezimaltrennzeichen enthalten, und Sie darf keinen Dezimalteil enthalten.  
  
 Der `value`-Parameter wird mithilfe des <xref:System.Globalization.NumberStyles.Integer?displayProperty=nameWithType> Stils interpretiert. Zusätzlich zu den Dezimalziffern sind nur führende und nachfolgende Leerzeichen mit einem vorangestellten Zeichen zulässig. Um die Stilelemente mit den kulturspezifischen Formatierungsinformationen, die in `value`vorhanden sein können, explizit zu definieren, müssen Sie die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>-Methode aufzurufen.  
  
 Der `value`-Parameter wird analysiert, indem die Formatierungsinformationen in einem <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur verwendet werden. Weitere Informationen finden Sie unter <xref:System.Globalization.NumberFormatInfo.CurrentInfo%2A?displayProperty=nameWithType>.  
  
 Diese Überladung interpretiert alle Ziffern im `value`-Parameter als Dezimalziffern. Um die Zeichen folgen Darstellung einer hexadezimalen Zahl zu analysieren, müssen Sie stattdessen die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29> Überladung aufrufen.  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Numerics.BigInteger%40%29>-Methode verwendet, um zwei <xref:System.Numerics.BigInteger>-Objekte zu instanziieren. Wenn die Konvertierungen erfolgreich sind, wird jedes Objekt mit einer anderen Zahl multipliziert und dann die <xref:System.Numerics.BigInteger.Compare%2A>-Methode aufgerufen, um die Beziehung zwischen den beiden Objekten zu bestimmen.  
  
 [!code-csharp[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/cs/System.Numeric.BigInteger.TryParse.cs#1)]
 [!code-vb[System.Numeric.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numeric.BigInteger.TryParse/vb/System.Numeric.BigInteger.TryParse.vb#1)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" /></exception>
        <altmember cref="M:System.Numerics.BigInteger.ToString(System.String)" />
        <altmember cref="Overload:System.Numerics.BigInteger.Parse" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (ReadOnlySpan&lt;char&gt; value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(valuetype System.ReadOnlySpan`1&lt;char&gt; value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.ReadOnlySpan{System.Char},System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As ReadOnlySpan(Of Char), style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(ReadOnlySpan&lt;char&gt; value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : ReadOnlySpan&lt;char&gt; * System.Globalization.NumberStyles * IFormatProvider * BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.ReadOnlySpan&lt;System.Char&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="provider" Type="System.IFormatProvider" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value">Die Darstellung einer Zahl als schreibgeschützte Spanne von Zeichen.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="value" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder <see cref="P:System.Numerics.BigInteger.Zero" />, wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der Parameter <paramref name="value" /> eine leere Zeichenspanne ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Versucht, die Zeichenfolgendarstellung einer Zahl in deren <see cref="T:System.Numerics.BigInteger" />-Entsprechung zu konvertieren, und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich durchgeführt wurde.</summary>
        <returns><see langword="true" />, wenn <paramref name="value" /> erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

Diese Überladung ähnelt der <xref:System.Numerics.BigInteger.Parse(System.ReadOnlySpan%7BSystem.Char%7D,System.Globalization.NumberStyles,System.IFormatProvider)>-Methode, mit der Ausnahme, dass keine Ausnahme ausgelöst wird, wenn bei der Konvertierung ein Fehler auftritt. Diese Methode entfällt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `value` ungültig ist und nicht erfolgreich analysiert werden kann.

Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen oder ein positives oder negatives Zeichen), die im `value`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Abhängig vom Wert `style`kann der `value` Parameter die folgenden Elemente enthalten:

[*WS*] [*$*] [*Sign*] [*Ziffern*,] *Ziffern*[. *fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]

Wenn der `style`-Parameter <xref:System.Globalization.NumberStyles.AllowHexSpecifier>enthält, kann der `value`-Parameter die folgenden Elemente enthalten:

[*WS*] *Hexziffern*[*WS*]

Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.

|Element|BESCHREIBUNG|
|-------------|-----------------|
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, oder am Ende `value`, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in `value` wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A>-Eigenschaft des <xref:System.Globalization.NumberFormatInfo> Objekts definiert, das von der <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters zurückgegeben wird. Das Währungssymbol kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `value` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9.|
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der durch `provider` angegebenen Kultur kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der durch `provider` angegebenen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|
|*fractional_digits*|Mindestens ein Vorkommen der Ziffer 0 (null). Bruch Ziffern können nur in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|
|*exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|

> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

|Nicht zusammengesetzte `NumberStyles` Werte|Als Wert zulässige Elemente zusätzlich zu Ziffern|
|------------------------------------------|-------------------------------------------------------|
|<xref:System.Globalization.NumberStyles.None>|Nur Dezimalziffern.|
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Der Dezimaltrennzeichen (*.*) und *fractional_digits* Elemente. *Fractional_digits* müssen jedoch nur aus einer oder mehreren 0 Ziffern bestehen, oder die Methode gibt `false`zurück.|
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialnotation angibt, sowie *Exponential_digits*. Wenn `value` eine Zahl in Exponentialschreibweise darstellt, kann Sie keine Bruchteil-Komponente ungleich 0 (null) aufweisen.|
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `value`.|
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `value`.|
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Vorzeichen* Element vor *Ziffern*.|
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element nach *Ziffern*.|
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (*,*).|
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency (*$*)-Element.|
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `value` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `value`, Signieren am Anfang `value`und das Dezimal *Trennzeichen* (*.*). Der `value`-Parameter kann auch die Exponentialnotation verwenden.|
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente *WS*, *Sign*, Group Separator (*,*) und Decimal Point (*.*).|
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `value` keine hexadezimal Zahl darstellen.|

Wenn das <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>-Flag verwendet wird, muss `value` ein Hexadezimalwert sein. Die einzigen anderen Flags, die in `style` vorhanden sein können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles>-Enumeration verfügt über einen zusammengesetzten Stil, <xref:System.Globalization.NumberStyles.HexNumber>, der beide Leerzeichen enthält.)

Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format von `value`bereitstellt. Der `provider`-Parameter kann eine der folgenden sein:

-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.

-   Ein <xref:System.Globalization.NumberFormatInfo>-Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)

-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.

Wenn `provider` `null`ist, wird das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur verwendet.

          ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
Oder 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.Parse" />
      </Docs>
    </Member>
    <Member MemberName="TryParse">
      <MemberSignature Language="C#" Value="public static bool TryParse (string value, System.Globalization.NumberStyles style, IFormatProvider provider, out System.Numerics.BigInteger result);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool TryParse(string value, valuetype System.Globalization.NumberStyles style, class System.IFormatProvider provider, [out] valuetype System.Numerics.BigInteger&amp; result) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryParse(System.String,System.Globalization.NumberStyles,System.IFormatProvider,System.Numerics.BigInteger@)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function TryParse (value As String, style As NumberStyles, provider As IFormatProvider, ByRef result As BigInteger) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool TryParse(System::String ^ value, System::Globalization::NumberStyles style, IFormatProvider ^ provider, [Runtime::InteropServices::Out] System::Numerics::BigInteger % result);" />
      <MemberSignature Language="F#" Value="static member TryParse : string * System.Globalization.NumberStyles * IFormatProvider * BigInteger -&gt; bool" Usage="System.Numerics.BigInteger.TryParse (value, style, provider, result)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.String" />
        <Parameter Name="style" Type="System.Globalization.NumberStyles" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
        <Parameter Name="result" Type="System.Numerics.BigInteger" RefType="out" />
      </Parameters>
      <Docs>
        <param name="value">Die Zeichenfolgendarstellung einer Zahl. Die Zeichenfolge wird unter Verwendung des durch <paramref name="style" /> angegebenen Formats interpretiert.</param>
        <param name="style">Eine bitweise Kombination von Enumerationswerten, die die Stilelemente angeben, die in <paramref name="value" /> vorhanden sein können. Ein häufig angegebener Wert ist <see cref="F:System.Globalization.NumberStyles.Integer" />.</param>
        <param name="provider">Ein Objekt, das kulturspezifische Formatierungsinformationen zu <paramref name="value" /> bereitstellt.</param>
        <param name="result">Die Rückgabe dieser Methode enthält die <see cref="T:System.Numerics.BigInteger" />-Entsprechung der Zahl in <paramref name="value" />, oder <see cref="P:System.Numerics.BigInteger.Zero" />, wenn die Konvertierung nicht ausgeführt werden konnte. Die Konvertierung schlägt fehl, wenn der <paramref name="value" />-Parameter gleich <see langword="null" /> ist oder nicht in einem Format vorliegt, das mit <paramref name="style" /> kompatibel ist. Dieser Parameter wird nicht initialisiert übergeben.</param>
        <summary>Konvertiert die Zeichenfolgendarstellung einer Zahl in einem angegebenen Stil und kulturspezifischen Format in das entsprechende <see cref="T:System.Numerics.BigInteger" /> und gibt einen Wert zurück, der angibt, ob die Konvertierung erfolgreich abgeschlossen wurde.</summary>
        <returns><see langword="true" />, wenn der <paramref name="value" />-Parameter erfolgreich konvertiert wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>-Methode ähnelt der <xref:System.Numerics.BigInteger.Parse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%29>-Methode, mit der Ausnahme, dass keine Ausnahme ausgelöst wird, wenn bei der Konvertierung ein Fehler auftritt. Diese Methode entfällt, dass die Ausnahmebehandlung verwendet werden muss, um auf eine <xref:System.FormatException> zu testen, wenn `value` ungültig ist und nicht erfolgreich analysiert werden kann.  
  
 Der `style`-Parameter definiert die Stilelemente (z. b. Leerzeichen oder ein positives oder negatives Zeichen), die im `value`-Parameter zulässig sind, damit der Analyse Vorgang erfolgreich ausgeführt werden kann. Dabei muss es sich um eine Kombination von Bitflags aus der <xref:System.Globalization.NumberStyles> Enumeration handeln. Abhängig vom Wert `style`kann der `value` Parameter die folgenden Elemente enthalten:  
  
 [*WS*] [*$*] [*Sign*] [*Ziffern*,] *Ziffern*[. *fractional_digits*] [E [*Sign*]*Exponential_digits*] [*WS*]  
  
 Wenn der `style`-Parameter <xref:System.Globalization.NumberStyles.AllowHexSpecifier>enthält, kann der `value`-Parameter die folgenden Elemente enthalten:  
  
 [*WS*] *Hexziffern*[*WS*]  
  
 Elemente in eckigen Klammern ([ und ]) sind optional. In der folgenden Tabelle wird jedes Element beschrieben.  
  
|Element|BESCHREIBUNG|  
|-------------|-----------------|  
|*ws*|Optionaler Leerraum. Leerraum kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType>-Flag enthält, oder am Ende `value`, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>-Flag enthält.|  
|*$*|Ein kulturspezifisches Währungssymbol. Die Position in der Zeichenfolge wird durch die <xref:System.Globalization.NumberFormatInfo.CurrencyPositivePattern%2A>-Eigenschaft des <xref:System.Globalization.NumberFormatInfo> Objekts definiert, das von der <xref:System.IFormatProvider.GetFormat%2A>-Methode des `provider`-Parameters zurückgegeben wurde. Das Währungssymbol kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowCurrencySymbol?displayProperty=nameWithType>-Flag enthält.|  
|*sign*|Ein optionales Vorzeichen. Das Vorzeichen kann am Anfang der `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowLeadingSign?displayProperty=nameWithType>-Flag enthält, und es kann am Ende `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowTrailingSign?displayProperty=nameWithType>-Flag enthält. In `value` können Klammern verwendet werden, um einen negativen Wert anzugeben, wenn `style` das <xref:System.Globalization.NumberStyles.AllowParentheses?displayProperty=nameWithType>-Flag enthält.|  
|*Ziffern*|Eine Sequenz von Ziffern zwischen 0 und 9.|  
|*,*|Ein kulturspezifisches Gruppen Trennzeichen. Das Gruppen Trennzeichen der durch `provider` angegebenen Kultur kann in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowThousands?displayProperty=nameWithType>-Flag enthält.|  
|*.*|Ein kulturspezifisches Dezimaltrennzeichen. Das Dezimaltrennzeichen der durch `provider` angegebenen Kultur kann in `value` vorkommen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|*fractional_digits*|Mindestens ein Vorkommen der Ziffer 0 (null). Bruch Ziffern können nur in `value` angezeigt werden, wenn `style` das <xref:System.Globalization.NumberStyles.AllowDecimalPoint?displayProperty=nameWithType>-Flag enthält.|  
|E|Das Zeichen "e" oder "e", das angibt, dass der Wert in exponentieller Notation (Scientific) dargestellt wird. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*exponential_digits*|Eine Sequenz von Ziffern zwischen 0 und 9. Der `value`-Parameter kann eine Zahl in Exponentialnotation darstellen, wenn `style` das <xref:System.Globalization.NumberStyles.AllowExponent?displayProperty=nameWithType>-Flag enthält.|  
|*Hexziffern*|Eine Sequenz von hexadezimalen Ziffern zwischen 0 und f oder 0 bis f.|  
  
> [!NOTE]
> Alle abschließenden NUL-Zeichen (U + 0000) in `s` werden vom Analyse-Vorgang unabhängig vom Wert des `style` Arguments ignoriert.

 Eine Zeichenfolge mit nur Dezimalziffern (die dem <xref:System.Globalization.NumberStyles.None?displayProperty=nameWithType>-Flag entspricht) wird immer erfolgreich analysiert. Die meisten der verbleibenden <xref:System.Globalization.NumberStyles> Member steuern Elemente, die in dieser Eingabe Zeichenfolge vorhanden sein können, aber nicht vorhanden sein müssen. In der folgenden Tabelle wird angegeben, wie sich einzelne <xref:System.Globalization.NumberStyles> Elemente auf die Elemente auswirken, die in `value`vorhanden sein können.  
  
|Nicht zusammengesetzte `NumberStyles` Werte|Als Wert zulässige Elemente zusätzlich zu Ziffern|  
|------------------------------------------|-------------------------------------------------------|  
|<xref:System.Globalization.NumberStyles.None>|Nur Dezimalziffern.|  
|<xref:System.Globalization.NumberStyles.AllowDecimalPoint>|Der Dezimaltrennzeichen (*.*) und *fractional_digits* Elemente. *Fractional_digits* müssen jedoch nur aus einer oder mehreren 0 Ziffern bestehen, oder die Methode gibt `false`zurück.|  
|<xref:System.Globalization.NumberStyles.AllowExponent>|Das Zeichen "e" oder "e", das die Exponentialnotation angibt, sowie *Exponential_digits*. Wenn `value` eine Zahl in Exponentialschreibweise darstellt, kann Sie keine Bruchteil-Komponente ungleich 0 (null) aufweisen.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingWhite>|Das *WS* -Element am Anfang `value`.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingWhite>|Das *WS* -Element am Ende `value`.|  
|<xref:System.Globalization.NumberStyles.AllowLeadingSign>|Das *Vorzeichen* Element vor *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowTrailingSign>|Das *Sign* -Element nach *Ziffern*.|  
|<xref:System.Globalization.NumberStyles.AllowParentheses>|Das *Vorzeichen* Element in der Form von Klammern, das den numerischen Wert einschließt.|  
|<xref:System.Globalization.NumberStyles.AllowThousands>|Das Gruppen Trennzeichen (*,*).|  
|<xref:System.Globalization.NumberStyles.AllowCurrencySymbol>|Das Currency (*$*)-Element.|  
|<xref:System.Globalization.NumberStyles.Currency>|Alle-Elemente. `value` kann jedoch keine hexadezimal Zahl oder eine Zahl in Exponentialnotation darstellen.|  
|<xref:System.Globalization.NumberStyles.Float>|Das *WS* -Element am Anfang oder Ende `value`, Signieren am Anfang `value`und das Dezimal *Trennzeichen* (*.*). Der `value`-Parameter kann auch die Exponentialnotation verwenden.|  
|<xref:System.Globalization.NumberStyles.Number>|Die Elemente *WS*, *Sign*, Group Separator (*,*) und Decimal Point (*.*).|  
|<xref:System.Globalization.NumberStyles.Any>|Alle-Elemente. Allerdings kann `value` keine hexadezimal Zahl darstellen.|  
  
> [!IMPORTANT]
>  Wenn Sie die <xref:System.Numerics.BigInteger.TryParse%2A>-Methode zum Roundtrip der Zeichen folgen Darstellung eines <xref:System.Numerics.BigInteger> Werts verwenden, der von der <xref:System.Numerics.BigInteger.ToString%2A>-Methode ausgegeben wurde, sollten Sie die <xref:System.Numerics.BigInteger.ToString%28System.String%29?displayProperty=nameWithType>-Methode mit dem Format Bezeichner "R" verwenden, um die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> Werts zu generieren. Andernfalls behält die Zeichen folgen Darstellung des <xref:System.Numerics.BigInteger> nur die 50 signifikantesten Ziffern des ursprünglichen Werts bei, und Daten gehen verloren, wenn Sie die <xref:System.Numerics.BigInteger.TryParse%2A>-Methode verwenden, um den <xref:System.Numerics.BigInteger> Wert wiederherzustellen.  
  
 Wenn das <xref:System.Globalization.NumberStyles.AllowHexSpecifier?displayProperty=nameWithType>-Flag verwendet wird, muss `value` ein Hexadezimalwert sein. Die einzigen anderen Flags, die in `style` vorhanden sein können, sind <xref:System.Globalization.NumberStyles.AllowLeadingWhite?displayProperty=nameWithType> und <xref:System.Globalization.NumberStyles.AllowTrailingWhite?displayProperty=nameWithType>. (Die <xref:System.Globalization.NumberStyles>-Enumeration verfügt über einen zusammengesetzten Stil, <xref:System.Globalization.NumberStyles.HexNumber>, der beide Leerzeichen enthält.)  
  
> [!NOTE]
>  Wenn `value` die Zeichen folgen Darstellung einer hexadezimalen Zahl ist, kann Ihr keine Ergänzung (z. b. `0x` oder `&h`) vorangestellt werden, die Sie als hexadezimale Zahl unterscheidet. Dies bewirkt, dass die Konvertierung fehlschlägt.  
  
 Wenn `value` eine hexadezimale Zeichenfolge ist, interpretiert die <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>-Methode `value` als eine negative Zahl, die mit der zwei Komplement-Darstellung gespeichert wird, wenn die ersten beiden hexadezimalen Ziffern größer oder gleich `0x80`sind. Dies bedeutet, dass die-Methode das oberste Bit des ersten Bytes in `value` als Signier Bit interpretiert. Um sicherzustellen, dass eine hexadezimale Zeichenfolge ordnungsgemäß als positive Zahl interpretiert wird, muss die erste Ziffer in `value` den Wert 0 (null) aufweisen. Beispielsweise interpretiert die-Methode `0x80` als negativen Wert, interpretiert jedoch entweder `0x080` oder `0x0080` als positiven Wert. Das folgende Beispiel veranschaulicht den Unterschied zwischen hexadezimalen Zeichen folgen, die negative und positive Werte darstellen.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParseHex1.cs#1)]
 [!code-vb[System.Numerics.BigInteger.TryParse#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParseHex1.vb#1)]  
  
 Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format von `value`bereitstellt. Der `provider`-Parameter kann eine der folgenden sein:  
  
-   Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die Formatierungsinformationen bereitstellt. Die <xref:System.Globalization.CultureInfo.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das numerische Formatierungsinformationen für diese Kultur bereitstellt.  
  
-   Ein <xref:System.Globalization.NumberFormatInfo>-Objekt, das numerische Formatierungsinformationen bereitstellt. (Die Implementierung von <xref:System.Globalization.NumberFormatInfo.GetFormat%2A> nur sich selbst zurückgegeben.)  
  
-   Ein benutzerdefiniertes Objekt, das <xref:System.IFormatProvider>implementiert. Die <xref:System.IFormatProvider.GetFormat%2A>-Methode instanziiert und gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.  
  
 Wenn `provider` `null`ist, wird das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur verwendet.  
  
   
  
## Examples  
 Im folgenden Beispiel werden einige Aufrufe der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>-Methode mithilfe verschiedener Kombinationen von Werten für die Parameter `style` und `provider` durchführt.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#2)]
 [!code-vb[System.Numerics.BigInteger.TryParse#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#2)]  
  
 Eine Reihe einzelner Aufrufe der <xref:System.Numerics.BigInteger.TryParse%28System.String%2CSystem.Globalization.NumberStyles%2CSystem.IFormatProvider%2CSystem.Numerics.BigInteger%40%29>-Methode übergibt eine Instanz der folgenden `BigIntegerFormatProvider` Klasse, die eine Tilde (~) als negatives Vorzeichen definiert.  
  
 [!code-csharp[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/cs/TryParse1.cs#3)]
 [!code-vb[System.Numerics.BigInteger.TryParse#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.Numerics.BigInteger.TryParse/vb/TryParse1.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentException"><paramref name="style" /> ist kein <see cref="T:System.Globalization.NumberStyles" />-Wert.  
  
Oder 
 <paramref name="style" /> schließt das <see cref="F:System.Globalization.NumberStyles.AllowHexSpecifier" />-Flag oder <see cref="F:System.Globalization.NumberStyles.HexNumber" />-Flag mit einem anderen Wert ein.</exception>
        <altmember cref="Overload:System.Numerics.BigInteger.ToString" />
        <altmember cref="Overload:System.Numerics.BigInteger.Parse" />
      </Docs>
    </Member>
    <Member MemberName="TryWriteBytes">
      <MemberSignature Language="C#" Value="public bool TryWriteBytes (Span&lt;byte&gt; destination, out int bytesWritten, bool isUnsigned = false, bool isBigEndian = false);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool TryWriteBytes(valuetype System.Span`1&lt;unsigned int8&gt; destination, [out] int32&amp; bytesWritten, bool isUnsigned, bool isBigEndian) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.BigInteger.TryWriteBytes(System.Span{System.Byte},System.Int32@,System.Boolean,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Function TryWriteBytes (destination As Span(Of Byte), ByRef bytesWritten As Integer, Optional isUnsigned As Boolean = false, Optional isBigEndian As Boolean = false) As Boolean" />
      <MemberSignature Language="F#" Value="member this.TryWriteBytes : Span&lt;byte&gt; * int * bool * bool -&gt; bool" Usage="bigInteger.TryWriteBytes (destination, bytesWritten, isUnsigned, isBigEndian)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="destination" Type="System.Span&lt;System.Byte&gt;" Index="0" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="bytesWritten" Type="System.Int32" RefType="out" Index="1" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isUnsigned" Type="System.Boolean" Index="2" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
        <Parameter Name="isBigEndian" Type="System.Boolean" Index="3" FrameworkAlternate="netcore-2.1;netcore-2.2;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="destination">Die Zielspanne, in die die resultierenden Bytes geschrieben werden sollen.</param>
        <param name="bytesWritten">Die Anzahl der Bytes, die in <paramref name="destination" /> geschrieben wurden.</param>
        <param name="isUnsigned"><see langword="true" />, um die Codierung ohne Vorzeichen zu verwenden, andernfalls <see langword="false" />.</param>
        <param name="isBigEndian"><see langword="true" />, um die Bytes in einer Big-Endian-Bytereihenfolge zu schreiben, andernfalls <see langword="false" />.</param>
        <summary>Kopiert den Wert dieses <see cref="T:System.Numerics.BigInteger" /> als Little-Endian-Zweierkomplementbytes mit der geringstmöglichen Anzahl von Bytes. Wenn der Wert Null (0) ist, wird nur ein Byte ausgegeben, dessen Element 0x00 ist.</summary>
        <returns><see langword="true" />, wenn die Bytes in <paramref name="destination" /> passen. <see langword="false" />, wenn aufgrund von unzureichendem Speicherplatz nicht alle Bytes geschrieben werden konnten.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.OverflowException"><paramref name="isUnsigned" /> ist <see langword="true" /> und <see cref="P:System.Numerics.BigInteger.Sign" /> ist negativ.</exception>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static System.Numerics.BigInteger Zero { get; }" />
      <MemberSignature Language="ILAsm" Value=".property valuetype System.Numerics.BigInteger Zero" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.BigInteger.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Zero As BigInteger" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Numerics::BigInteger Zero { System::Numerics::BigInteger get(); };" />
      <MemberSignature Language="F#" Value="member this.Zero : System.Numerics.BigInteger" Usage="System.Numerics.BigInteger.Zero" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.BigInteger</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die Zahl null (0) darstellt.</summary>
        <value>Eine ganze Zahl, deren Wert 0 (null) ist.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das <xref:System.Numerics.BigInteger> Objekt, das von dieser Eigenschaft zurückgegeben wird, stellt eine bequeme Quelle für einen Nullwert zur Verwendung in Zuweisungen und vergleichen dar.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.BigInteger.IsZero" />
      </Docs>
    </Member>
  </Members>
</Type>
