<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="92d6253d7331fe92483192ad180c35e4f23d432f" /><Meta Name="ms.sourcegitcommit" Value="b0947fed0227b6b2e292d7efb43705b488b130aa" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="04/29/2020" /><Meta Name="ms.locfileid" Value="82500569" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="dotnet-uwp-10.0;net-5.0;netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netcore-2.2;netcore-3.0;netcore-3.1;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;netstandard-2.1" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
    <AssemblyVersion>4.1.2.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
    <AssemblyVersion>2.1.0.0</AssemblyVersion>
  </AssemblyInfo>
  <TypeForwardingChain>
    <TypeForwarding From="System.Numerics" FromVersion="4.0.0.0" To="System.Runtime.Numerics" ToVersion="0.0.0.0" FrameworkAlternate="dotnet-uwp-10.0" />
  </TypeForwardingChain>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="e2c92-101">Stellt eine komplexe Zahl dar.</span><span class="sxs-lookup"><span data-stu-id="e2c92-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-102">Eine komplexe Zahl ist eine Zahl, die einen reellen und einen imaginären Zahlen Teil umfasst.</span><span class="sxs-lookup"><span data-stu-id="e2c92-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="e2c92-103">Eine komplexe Zahl z wird normalerweise in der Form z = x + Yi geschrieben, *wobei x* und *y* reelle Zahlen sind *und die* imaginäre Einheit mit der Eigenschaft *i*<sup>2</sup> =-1 ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="e2c92-104">Der reelle Teil der komplexen Zahl wird durch *x*dargestellt, und der Imaginärteil der komplexen Zahl wird durch *y*dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="e2c92-105">Der <xref:System.Numerics.Complex>-Typ verwendet beim Instanziieren und bearbeiten komplexer Zahlen das kartesische Koordinatensystem (Real, imaginär).</span><span class="sxs-lookup"><span data-stu-id="e2c92-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="e2c92-106">Eine komplexe Zahl kann als Punkt in einem zweidimensionalen Koordinatensystem dargestellt werden, das als komplexe Ebene bezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="e2c92-107">Der reelle Teil der komplexen Zahl wird auf der x-Achse (der horizontalen Achse) positioniert, und der Imaginärteil wird auf der y-Achse (der vertikalen Achse) positioniert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="e2c92-108">Jeder Punkt in der komplexen Ebene kann auch basierend auf seinem absoluten Wert mithilfe des Polarkoordinaten Systems ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="e2c92-109">In Polarkoordinaten ist ein Punkt durch zwei Zahlen gekennzeichnet:</span><span class="sxs-lookup"><span data-stu-id="e2c92-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="e2c92-110">Die Größe, die die Entfernung des Punkts vom Ursprung (d. h. 0, 0 oder der Punkt ist, an dem sich die x-Achse und die y-Achse überschneiden).</span><span class="sxs-lookup"><span data-stu-id="e2c92-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="e2c92-111">Die Phase, bei der es sich um den Winkel zwischen der reellen Achse und der Linie handelt, die vom Ursprung bis zum Punkt gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="e2c92-112">Instanziieren einer komplexen Zahl</span><span class="sxs-lookup"><span data-stu-id="e2c92-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="e2c92-113">Sie können einer komplexen Zahl einen Wert auf eine der folgenden Weisen zuweisen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="e2c92-114">Durch Übergeben von zwei <xref:System.Double> Werten an den Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="e2c92-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="e2c92-115">Der erste Wert stellt den reellen Teil der komplexen Zahl dar, und der zweite Wert stellt den imaginären Teil dar.</span><span class="sxs-lookup"><span data-stu-id="e2c92-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="e2c92-116">Diese Werte stellen die Position der komplexen Zahl im zweidimensionalen kartesischen Koordinatensystem dar.</span><span class="sxs-lookup"><span data-stu-id="e2c92-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="e2c92-117">Durch Aufrufen der statischen (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>-Methode, um eine komplexe Zahl aus den Polarkoordinaten zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="e2c92-118">Durch Zuweisen eines <xref:System.Byte>-, <xref:System.SByte>-, <xref:System.Int16>-, <xref:System.UInt16>-, <xref:System.Int32>-, <xref:System.UInt32>-, <xref:System.Int64>-, <xref:System.UInt64>-, <xref:System.Single>-oder <xref:System.Double>-Werts zu einem <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="e2c92-119">Der Wert wird der reelle Teil der komplexen Zahl, und sein imaginärer Teil ist 0.</span><span class="sxs-lookup"><span data-stu-id="e2c92-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="e2c92-120">Durch umwandeln (in C#) oder konvertieren (in Visual Basic) eines <xref:System.Decimal> oder <xref:System.Numerics.BigInteger> Werts in ein <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="e2c92-121">Der Wert wird der reelle Teil der komplexen Zahl, und sein imaginärer Teil ist 0.</span><span class="sxs-lookup"><span data-stu-id="e2c92-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="e2c92-122">Durch Zuweisen der komplexen Zahl, die von einer Methode oder einem Operator zurückgegeben wird, zu einem <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="e2c92-123"><xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> ist beispielsweise eine statische Methode, die eine komplexe Zahl zurückgibt, die die Summe aus zwei komplexen Zahlen ist, und der <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> Operator Fügt zwei komplexe Zahlen hinzu und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="e2c92-124">Im folgenden Beispiel wird jede dieser fünf Möglichkeiten zum Zuweisen eines Werts zu einer komplexen Zahl veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="e2c92-125">Vorgänge mit komplexen Zahlen</span><span class="sxs-lookup"><span data-stu-id="e2c92-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="e2c92-126">Die <xref:System.Numerics.Complex> Struktur in der .NET Framework umfasst Elemente, die die folgenden Funktionen bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="e2c92-127">Methoden zum Vergleichen von zwei komplexen Zahlen, um zu bestimmen, ob Sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="e2c92-128">Operatoren zum Ausführen von arithmetischen Operationen für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="e2c92-129">mit <xref:System.Numerics.Complex>-Operatoren können Sie Addition, Subtraktion, Multiplikation, Division und unäre Negation mit komplexen Zahlen durchführen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="e2c92-130">Methoden zum Ausführen von anderen numerischen Operationen für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="e2c92-131">Zusätzlich zu den vier grundlegenden arithmetischen Vorgängen können Sie eine komplexe Zahl zu einer angegebenen Potenz machen, die Quadratwurzel einer komplexen Zahl Suchen und den absoluten Wert einer komplexen Zahl abrufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="e2c92-132">Methoden zum Ausführen von serigonometrischen Vorgängen für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="e2c92-133">Beispielsweise können Sie den Tangens eines Winkels berechnen, der durch eine komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="e2c92-134">Beachten Sie, dass Sie den Wert eines vorhandenen <xref:System.Numerics.Complex> Objekts nicht ändern können, da die Eigenschaften <xref:System.Numerics.Complex.Real%2A> und <xref:System.Numerics.Complex.Imaginary%2A> schreibgeschützt sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="e2c92-135">Alle Methoden, die einen Vorgang für eine <xref:System.Numerics.Complex> Zahl ausführen, wenn Ihr Rückgabewert vom Typ <xref:System.Numerics.Complex>ist, geben eine neue <xref:System.Numerics.Complex> Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="e2c92-136">Genauigkeit und komplexe Zahlen</span><span class="sxs-lookup"><span data-stu-id="e2c92-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="e2c92-137">Die Real-und Imaginärteile einer komplexen Zahl werden durch zwei Gleit Komma Werte mit doppelter Genauigkeit dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="e2c92-138">Dies bedeutet, dass <xref:System.Numerics.Complex> Werte, wie z. b. Gleit Komma Werte mit doppelter Genauigkeit, die Genauigkeit aufgrund von numerischen Vorgängen verlieren können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="e2c92-139">Dies bedeutet, dass strikte Vergleiche auf Gleichheit von zwei <xref:System.Numerics.Complex> Werten möglicherweise fehlschlagen, auch wenn der Unterschied zwischen den beiden Werten auf einen Genauigkeits Verlust zurückzuführen ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="e2c92-140">Weitere Informationen finden Sie unter <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="e2c92-141">Wenn Sie z. b. eine exponentiierung des Logarithmus einer Zahl durchführen, sollte die ursprüngliche Zahl zurückgegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="e2c92-142">In einigen Fällen kann der Verlust der Genauigkeit von Gleit Komma Werten geringfügige Unterschiede zwischen den beiden Werten verursachen, wie im folgenden Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="e2c92-143">Entsprechend erzeugt das folgende Beispiel, das die Quadratwurzel einer <xref:System.Numerics.Complex> Zahl berechnet, etwas andere Ergebnisse für die 32-Bit-und ia64-Versionen des .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="e2c92-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="e2c92-144">Komplexe Zahlen, unendlich und Nan</span><span class="sxs-lookup"><span data-stu-id="e2c92-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="e2c92-145">Die reellen und imaginären Teile einer komplexen Zahl werden durch <xref:System.Double>-Werte dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="e2c92-146">Der reale oder imaginäre Teil einer komplexen Zahl kann nicht nur von <xref:System.Double.MinValue?displayProperty=nameWithType> bis <xref:System.Double.MaxValue?displayProperty=nameWithType>reichen, sondern auch den Wert <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>oder <xref:System.Double.NaN?displayProperty=nameWithType>haben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>und <xref:System.Double.NaN?displayProperty=nameWithType> alle in jedem arithmetischen oder drei ometrischen Vorgang weitergegeben werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="e2c92-148">Im folgenden Beispiel erzeugt die Division durch <xref:System.Numerics.Complex.Zero> eine komplexe Zahl, deren reelle und imaginäre Teile <xref:System.Double.NaN?displayProperty=nameWithType>werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-149">Folglich erzeugt die Durchführung der Multiplikation mit diesem Wert auch eine komplexe Zahl, deren reelle und imaginäre Teile <xref:System.Double.NaN?displayProperty=nameWithType>werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-150">Analog dazu erzeugt eine Multiplikation, bei der der Bereich des <xref:System.Double> Typs überläuft, eine komplexe Zahl, deren Realteil <xref:System.Double.NaN?displayProperty=nameWithType> und dessen imaginärer Teil <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-151">Die anschließende Durchführung der Division mit dieser komplexen Zahl gibt eine komplexe Zahl zurück, deren Realteil <xref:System.Double.NaN?displayProperty=nameWithType> und dessen imaginärer Teil <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="e2c92-152">Mathematische Operationen mit komplexen Zahlen, die ungültig sind oder einen Überlauf des Bereichs des <xref:System.Double> Datentyps verursachen, lösen keine Ausnahme aus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="e2c92-153">Stattdessen geben Sie unter den folgenden Bedingungen eine <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>oder <xref:System.Double.NaN?displayProperty=nameWithType> zurück:</span><span class="sxs-lookup"><span data-stu-id="e2c92-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="e2c92-154">Die Division einer positiven Zahl durch Null gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e2c92-155">Jeder Vorgang, der die obere Grenze des <xref:System.Double> Datentyps überschreitet, gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e2c92-156">Die Division einer negativen Zahl durch Null gibt <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e2c92-157">Jeder Vorgang, der die untere Grenze des <xref:System.Double> Datentyps überschreitet, gibt <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e2c92-158">Die Division von NULL durch Null gibt <xref:System.Double.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="e2c92-159">Jeder Vorgang, der für Operanden ausgeführt wird, deren Werte <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>oder <xref:System.Double.NaN?displayProperty=nameWithType> sind, gibt je nach dem jeweiligen Vorgang <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>oder <xref:System.Double.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="e2c92-160">Beachten Sie, dass dies für alle Zwischenberechnungen gilt, die von einer Methode ausgeführt werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="e2c92-161">Beispielsweise verwendet die Multiplikation von `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` die Formel (AC-BD) + (AD + BC) i.</span><span class="sxs-lookup"><span data-stu-id="e2c92-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="e2c92-162">Die Berechnung der realen Komponente, die sich aus der Multiplikation ergibt, wertet den Ausdruck 9e308 \* 2,5-9e308 \* 3,5 aus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="e2c92-163">Jede zwischen Multiplikation in diesem Ausdruck gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>zurück, und der Versuch, <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> von <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> zu subtrahieren, gibt <xref:System.Double.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="e2c92-164">Formatieren einer komplexen Zahl</span><span class="sxs-lookup"><span data-stu-id="e2c92-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="e2c92-165">Standardmäßig ist die Zeichen folgen Darstellung einer komplexen Zahl das Formular `(`*echten*`,` *imaginär`)`* , wobei *real* und *imaginär* die Zeichen folgen Darstellungen der <xref:System.Double> Werte sind, die die reellen und imaginären Komponenten der komplexen Zahl bilden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="e2c92-166">Einige über Ladungen der <xref:System.Numerics.Complex.ToString%2A>-Methode ermöglichen die Anpassung der Zeichen folgen Darstellungen dieser <xref:System.Double> Werte, um die Formatierungs Konventionen einer bestimmten Kultur widerzuspiegeln oder in einem bestimmten Format zu erscheinen, das durch eine standardmäßige oder benutzerdefinierte numerische Format Zeichenfolge definiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="e2c92-167">(Weitere Informationen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.)</span><span class="sxs-lookup"><span data-stu-id="e2c92-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="e2c92-168">Eine der gängigeren Methoden zum Ausdrücken der Zeichen folgen Darstellung einer komplexen Zahl hat die Form a + BI, wobei a die echte Komponente der komplexen Zahl und b die imaginäre Komponente der komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="e2c92-169">Beim elektroengineering wird eine komplexe Zahl am häufigsten als + Bj ausgedrückt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="e2c92-170">Sie können die Zeichen folgen Darstellung einer komplexen Zahl in einer dieser beiden Formen zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="e2c92-171">Definieren Sie zu diesem Zweck einen benutzerdefinierten Format Anbieter, indem Sie die <xref:System.ICustomFormatter>-und <xref:System.IFormatProvider> Schnittstellen implementieren und dann die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="e2c92-172">Im folgenden Beispiel wird eine `ComplexFormatter` Klasse definiert, die eine komplexe Zahl als Zeichenfolge in Form von a + bi oder a + Bj darstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="e2c92-173">Im folgenden Beispiel wird dann dieser benutzerdefinierte Formatierer verwendet, um die Zeichen folgen Darstellung einer komplexen Zahl anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="e2c92-174">Der reelle Teil der komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="e2c92-175">Der imaginäre Teil der komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-176">Initialisiert eine neue Instanz der <see cref="T:System.Numerics.Complex" />-Struktur mit den angegebenen reellen und imaginären Werten.</span><span class="sxs-lookup"><span data-stu-id="e2c92-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-177">Die `real`-oder `imaginary` Argumente können die Genauigkeit verlieren, wenn Sie Datentypen sind, für die eine explizite Umwandlung in <xref:System.Double>erforderlich ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-178">Im folgenden Beispiel werden zwei komplexe Zahlen instanziiert und dann zusätzlich, Subtraktion, Multiplikation und Divisions Vorgänge verwendet.</span><span class="sxs-lookup"><span data-stu-id="e2c92-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-179">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-180">Ruft den absoluten Wert (oder die Größenordnung) einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="e2c92-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-181">Der Absolutbetrag von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-182">Der absolute Wert einer komplexen Zahl entspricht der <xref:System.Numerics.Complex.Magnitude%2A>-Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="e2c92-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="e2c92-183">Der absolute Wert einer reellen Zahl a + BI wird wie folgt berechnet:</span><span class="sxs-lookup"><span data-stu-id="e2c92-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="e2c92-184">Wenn b = 0, ist das Ergebnis 0 (null).</span><span class="sxs-lookup"><span data-stu-id="e2c92-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="e2c92-185">Wenn ein > b ist, ist das Ergebnis ein \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="e2c92-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="e2c92-186">Wenn b >, ist das Ergebnis b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="e2c92-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="e2c92-187">Wenn die Berechnung des absoluten Werts zu einem Überlauf führt, gibt die Methode entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-188">Wenn die <xref:System.Numerics.Complex.Real%2A>-Eigenschaft oder die <xref:System.Numerics.Complex.Imaginary%2A>-Eigenschaft <xref:System.Double.NaN?displayProperty=nameWithType> ist und die andere Eigenschaft weder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> noch <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Double.NaN?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-189">Im folgenden Beispiel wird der absolute Wert einer komplexen Zahl berechnet und veranschaulicht, dass Sie dem Wert der <xref:System.Numerics.Complex.Magnitude%2A>-Eigenschaft entspricht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-190">Eine komplexe Zahl, die einen Kosinus darstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="e2c92-191">Gibt den Winkel zurück, der der Arkuskosinus der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-192">Der Winkel im Bogenmaß, der der Arkuskosinus von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-193">Die <xref:System.Numerics.Complex.Acos%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Acos%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-194">Die <xref:System.Numerics.Complex.Acos%2A>-Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="e2c92-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="e2c92-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="e2c92-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="e2c92-196">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Acos%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="e2c92-197">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Acos%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Cos%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <Docs>
        <summary><span data-ttu-id="e2c92-198">Fügt eine angegebene Zahl einer anderen angegebenen Zahl hinzu. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-198">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="e2c92-199">Die <xref:System.Numerics.Complex.Add%2A>-Methoden ermöglichen das Ausführen von Additions Vorgängen, die komplexe Zahlen umfassen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-199">The <xref:System.Numerics.Complex.Add%2A> methods allow performing addition operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="e2c92-200">Wenn der Methodenaufrufe einen Überlauf in der reellen oder imaginären Komponente ergibt, ist der Wert der Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-200">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e2c92-201">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können die <xref:System.Numerics.Complex.Add%2A>-Methode verwenden, um eine Addition mit komplexen Zahlen auszuführen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-201">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  

 <span data-ttu-id="e2c92-202">Die <xref:System.Numerics.Complex.Add%2A> Methoden, die einen Double-Wert erhalten, sind effizienter als die Methoden, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-202">The <xref:System.Numerics.Complex.Add%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>
  
## Examples  

 <span data-ttu-id="e2c92-203">Im folgenden Beispiel wird die Addition mit komplexen Zahlen veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-203">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-204">Der reelle Wert mit doppelter Genauigkeit, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-204">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-205">Der komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-205">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-206">Fügt einer komplexen Zahl eine reelle Zahl mit doppelter Genauigkeit hinzu und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-206">Adds a double-precision real number to a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-207">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-207">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="e2c92-208">Das Hinzufügen einer reellen Zahl (die als komplexe Zahl a + 0i angesehen werden kann) und einer komplexen Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-208">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="e2c92-209">(a + c) + di</span><span class="sxs-lookup"><span data-stu-id="e2c92-209">(a + c) + di</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-210">Der komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-210">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-211">Der reelle Wert mit doppelter Genauigkeit, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-211">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-212">Fügt einer reellen Zahl mit doppelter Genauigkeit eine komplexe Zahl hinzu und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-212">Adds a complex number to a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-213">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-213">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[
## Remarks
<span data-ttu-id="e2c92-214">Das Hinzufügen einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-214">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-215">(a + c) + BI</span><span class="sxs-lookup"><span data-stu-id="e2c92-215">(a + c) + bi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-216">Die erste zu addierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-216">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-217">Die zweite zu addierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-217">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-218">Addiert zwei komplexe Zahlen und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-218">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-219">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-219">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-220">Das Hinzufügen einer komplexen Zahl, a + BI und einer zweiten komplexen Zahl (c + di), hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-220">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="e2c92-221">(a + c) + (b + d) i.</span><span class="sxs-lookup"><span data-stu-id="e2c92-221">(a + c) + (b + d)i.</span></span>  

  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-222">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-222">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-223">Gibt den Winkel zurück, der der Arkussinus der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-223">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-224">Der Winkel, der der Arkussinus von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-224">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-225">Die <xref:System.Numerics.Complex.Asin%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Asin%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-225">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-226">Die <xref:System.Numerics.Complex.Asin%2A>-Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="e2c92-226">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="e2c92-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* Wert + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One>-Wert \* Wert))</span><span class="sxs-lookup"><span data-stu-id="e2c92-227">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="e2c92-228">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Asin%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-228">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="e2c92-229">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Asin%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Sin%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-229">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-230">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-230">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-231">Gibt den Winkel zurück, der der Arkustangens der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-231">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-232">Der Winkel, der der Arkustangens von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-232">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-233">Die <xref:System.Numerics.Complex.Atan%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Atan%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-233">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-234">Die <xref:System.Numerics.Complex.Atan%2A>-Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="e2c92-234">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="e2c92-235">(<xref:System.Numerics.Complex.ImaginaryOne>/New Complex (2.0, 0,0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* Wert)-<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* Wert))</span><span class="sxs-lookup"><span data-stu-id="e2c92-235">(<xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value))</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="e2c92-236">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Atan%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-236">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="e2c92-237">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Atan%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Tan%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-237">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-238">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-238">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-239">Berechnet die konjugierte Zahl einer komplexen Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-239">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-240">Die konjugierte Zahl von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-240">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-241">Die konjugierte Zahl einer komplexen Zahl kehrt das Vorzeichen der imaginären Komponente um. Das heißt, dass Sie die unäre Negation auf die imaginäre Komponente anwendet.</span><span class="sxs-lookup"><span data-stu-id="e2c92-241">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="e2c92-242">Wenn a + BI eine komplexe Zahl ist, ist die konjugierte Zahl a-BI.</span><span class="sxs-lookup"><span data-stu-id="e2c92-242">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-243">Im folgenden Beispiel wird die konjugierte Zahl zweier komplexer Zahlen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-243">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-244">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-244">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-245">Gibt den Kosinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-245">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-246">Der Kosinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-246">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-247">Die <xref:System.Numerics.Complex.Cos%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Cos%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-247">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-248">Die <xref:System.Numerics.Complex.Cos%2A>-Methode verwendet die folgende Formel, um den Kosinus der komplexen Zahl a + BI zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-248">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="e2c92-249">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="e2c92-249">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-250">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Acos%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-250">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="e2c92-251">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Acos%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Cos%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-251">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-252">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-252">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-253">Gibt den Hyperbelkosinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-253">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-254">Der Hyperbelkosinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-254">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-255">Die <xref:System.Numerics.Complex.Cosh%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Cosh%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-255">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-256">Die <xref:System.Numerics.Complex.Cosh%2A>-Methode verwendet die folgende Formel, um den hyperbolischen Kosinus der komplexen Zahl a + BI zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-256">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="e2c92-257">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="e2c92-257">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Divide">
      <Docs>
        <summary><span data-ttu-id="e2c92-258">Dividiert eine angegebene Zahl durch eine andere angegebene Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-258">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[
          
## Remarks
 <span data-ttu-id="e2c92-259">Die <xref:System.Numerics.Complex.Divide%2A>-Methoden ermöglichen das Ausführen von Divisions Vorgängen, die komplexe Zahlen einschließen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-259">The <xref:System.Numerics.Complex.Divide%2A> methods allow performing division operations that involve complex numbers.</span></span> 
  
 <span data-ttu-id="e2c92-260">Wenn die Berechnung des Quotienten zu einem Überlauf in der realen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-260">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e2c92-261">Die <xref:System.Numerics.Complex.Divide%2A>-Methode kann von Sprachen verwendet werden, die keine benutzerdefinierten Operatoren unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-261">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="e2c92-262">Das Verhalten ist mit der Division identisch, die den Divisions Operator verwendet.</span><span class="sxs-lookup"><span data-stu-id="e2c92-262">Its behavior is identical to division using the division operator.</span></span>  

 <span data-ttu-id="e2c92-263">Die <xref:System.Numerics.Complex.Divide%2A> Methoden, die einen Double-Wert erhalten, sind effizienter als die Methoden, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-263">The <xref:System.Numerics.Complex.Divide%2A> methods that receive one double are more efficient than the methods that receive two complex numbers.</span></span>

## Examples  
 <span data-ttu-id="e2c92-264">Im folgenden Beispiel wird eine komplexe Zahl durch jedes Element in einem Array komplexer Zahlen dividiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-264">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
   
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (double dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(float64 dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Double, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(double dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="e2c92-265">Die reelle Zahl mit doppelter Genauigkeit, die dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-265">The double-precision real number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="e2c92-266">Die komplexe Zahl, durch die dividiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-266">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-267">Dividiert eine reelle Zahl mit doppelter Genauigkeit durch eine komplexe Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-267">Divides one double-precision real number by a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-268">Der Quotient der Division.</span><span class="sxs-lookup"><span data-stu-id="e2c92-268">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="e2c92-269">Die Division einer reellen Zahl (die als komplexe Zahl a + 0i betrachtet werden kann) und eine komplexe Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-269">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

 <span data-ttu-id="e2c92-270">(AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-270">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, double divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, float64 divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, double divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="divisor" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="e2c92-271">Die zu dividierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-271">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="e2c92-272">Die reelle Zahl mit doppelter Genauigkeit, durch die dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-272">The double-precision real number to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-273">Dividiert eine komplexe Zahl durch eine reelle Zahl mit doppelter Genauigkeit und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-273">Divides one complex number by a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-274">Der Quotient der Division.</span><span class="sxs-lookup"><span data-stu-id="e2c92-274">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="e2c92-275">Die Division einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i angesehen werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-275">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

 <span data-ttu-id="e2c92-276">(AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-276">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="e2c92-277">Die zu dividierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-277">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="e2c92-278">Die komplexe Zahl, durch die dividiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-278">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-279">Dividiert eine komplexe Zahl durch eine andere komplexe Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-279">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-280">Der Quotient der Division.</span><span class="sxs-lookup"><span data-stu-id="e2c92-280">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-281">Die Division einer komplexen Zahl, a + BI, durch eine zweite komplexe Zahl, Zahl, c + di, hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-281">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="e2c92-282">((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-282">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
    
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-283">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-283">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-284">Die zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-284">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="e2c92-285">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine angegebene komplexe Zahl den gleichen Wert haben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-285">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="e2c92-286"><see langword="true" />, wenn die komplexe Zahl und <paramref name="value" /> den gleichen Wert haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-286"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-287">Die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>-Methode stellt die <xref:System.IEquatable%601> Implementierung für die <xref:System.Numerics.Complex> Struktur bereit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-287">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="e2c92-288">Sie führt eine etwas bessere Leistung als <xref:System.Numerics.Complex.Equals%28System.Object%29> Methode aus, da der Parameter nicht in eine komplexe Zahl konvertiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="e2c92-288">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="e2c92-289">Zwei komplexe Zahlen sind gleich, wenn Ihre tatsächlichen Teile gleich sind und ihre imaginären Teile gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-289">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="e2c92-290">Die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>-Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="e2c92-290">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="e2c92-291">Verwenden Sie die <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />-Methode mit Vorsicht, da zwei Werte, die scheinbar gleichwertig sind, aufgrund der unterschiedlichen Genauigkeit Ihrer reellen und imaginären Komponenten als ungleich betrachtet werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-291">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="e2c92-292">Im folgenden Beispiel wird berichtet, dass <c>(3,33333, 0,142857)</c> und <c>(10/3, 1/7)</c> nicht gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-292">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="e2c92-293">[! Code-csharp[System. Numerics. Complex. ist mit # 4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! Code-vb[System. Numerics. Complex. ist mit # 4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="e2c92-293">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="e2c92-294">Eine empfohlene Verfahren besteht darin, eine akzeptable Rand Unterschied zwischen den beiden Werten definieren (z. B. 01 % einer der Werte reellen und imaginären Komponenten) statt Vergleichen der Werte hinsichtlich ihrer Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-294">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="e2c92-295">Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf einen Unterschied in der Genauigkeit zurückzuführen, und daher sind die Werte wahrscheinlich gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-295">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="e2c92-296">Im folgenden Beispiel wird diese Technik verwendet, um die beiden komplexen Werte zu vergleichen, die im vorherigen Codebeispiel als ungleich festgestellt wurden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-296">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="e2c92-297">Es findet die beiden komplexen Zahlen, die gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-297">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="e2c92-298">[! Code-csharp[System. Numerics. Complex. ist mit # 5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! Code-vb[System. Numerics. Complex. ist mit # 5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="e2c92-298">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="e2c92-299">Das zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-299">The object to compare.</span></span></param>
        <summary><span data-ttu-id="e2c92-300">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-300">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="e2c92-301"><see langword="true" />, wenn der <paramref name="obj" />-Parameter ein <see cref="T:System.Numerics.Complex" />-Objekt oder ein Typ ist, der die implizite Konvertierung in ein <see cref="T:System.Numerics.Complex" />-Objekt unterstützt, und der Wert gleich dem aktuellen <see cref="T:System.Numerics.Complex" />-Objekt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-301"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-302">Zwei komplexe Zahlen sind gleich, wenn Ihre tatsächlichen Teile gleich sind und ihre imaginären Teile gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-302">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="e2c92-303">Die <xref:System.Numerics.Complex.Equals%28System.Object%29>-Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="e2c92-303">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="e2c92-304">Wenn der `obj`-Parameter kein <xref:System.Numerics.Complex> Objekt ist, aber ein Datentyp ist, für den eine implizite Konvertierung definiert ist, konvertiert die <xref:System.Numerics.Complex.Equals%28System.Object%29>-Methode `obj` in ein <xref:System.Numerics.Complex> Objekt, dessen realpart gleich dem Wert von `obj` und dessen imaginärer Teil gleich NULL ist, bevor der Vergleich durchführt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-304">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="e2c92-305">Dies wird im folgenden Beispiel veranschaulicht, indem ermittelt wird, ob eine komplexe Zahl und ein Gleit Komma Wert mit doppelter Genauigkeit gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-305">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="e2c92-306">Verwenden Sie die <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />-Methode mit Vorsicht, da zwei Werte, die scheinbar gleichwertig sind, aufgrund der unterschiedlichen Genauigkeit Ihrer reellen und imaginären Komponenten als ungleich betrachtet werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-306">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="e2c92-307">Das Problem kann verstärkt werden, wenn <paramref name="obj" /> vor der Durchführung des Vergleichs in eine <see cref="T:System.Double" /> konvertiert werden muss.</span><span class="sxs-lookup"><span data-stu-id="e2c92-307">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="e2c92-308">Im folgenden Beispiel wird eine komplexe Zahl verglichen, deren reelle Komponente einem <see cref="T:System.Single" /> Wert mit diesem <see cref="T:System.Single" /> Wert entspricht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-308">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="e2c92-309">Wie die Ausgabe zeigt, gibt der Vergleich für Gleichheit <see langword="False" />zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-309">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="e2c92-310">[! Code-csharp[System. Numerics. Complex. ist mit # 8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! Code-vb[System. Numerics. Complex. ist mit # 8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="e2c92-310">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="e2c92-311">Eine empfohlene Verfahren besteht darin, eine akzeptable Rand Unterschied zwischen den beiden Werten definieren (z. B. 01 % einer der Werte reellen und imaginären Komponenten) statt Vergleichen der Werte hinsichtlich ihrer Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-311">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="e2c92-312">Wenn der absolute Wert des Unterschieds zwischen den beiden Werten kleiner oder gleich diesem Rand ist, ist der Unterschied wahrscheinlich auf einen Unterschied in der Genauigkeit zurückzuführen, und daher sind die Werte wahrscheinlich gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-312">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="e2c92-313">Im folgenden Beispiel wird diese Technik verwendet, um die beiden Werte zu vergleichen, die im vorherigen Codebeispiel als ungleich festgestellt wurden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-313">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="e2c92-314">Sie finden Sie nun als gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-314">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="e2c92-315">[! Code-csharp[System. Numerics. Complex. ist mit # 7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! Code-vb[System. Numerics. Complex. ist mit # 7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="e2c92-315">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-316">Eine komplexe Zahl, die einen Exponenten angibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-316">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="e2c92-317">Gibt <see langword="e" /> potenziert mit einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-317">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-318">Die Zahl <see langword="e" /> hoch <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-318">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-319">Verwenden Sie die <xref:System.Numerics.Complex.Pow%2A>-Methode, um die Fähigkeiten von anderen Basen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-319">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="e2c92-320">Die <xref:System.Numerics.Complex.Exp%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Exp%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-320">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="e2c92-321"><xref:System.Numerics.Complex.Exp%2A> ist die Umkehrung von <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-321"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-322">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Exp%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-322">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="e2c92-323">Es zeigt, dass bei einem gewissen Mangel an Genauigkeit des <xref:System.Double> Datentyps der Wert, der von der <xref:System.Numerics.Complex.Log%2A>-Methode an die <xref:System.Numerics.Complex.Exp%2A>-Methode zurückgegeben wird, den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-323">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="e2c92-324">Die Größe, die die Entfernung vom Ursprung (dem Schnittpunkt der x-Achse mit der y-Achse) zur Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-324">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="e2c92-325">Die Phase, d. h. der Winkel von der Linie zur horizontalen Achse, gemessen im Bogenmaß.</span><span class="sxs-lookup"><span data-stu-id="e2c92-325">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="e2c92-326">Erstellt eine komplexe Zahl aus den Polarkoordinaten eines Punkts.</span><span class="sxs-lookup"><span data-stu-id="e2c92-326">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="e2c92-327">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-327">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-328">Die <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode instanziiert eine komplexe Zahl, die auf den Polarkoordinaten basiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-328">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="e2c92-329">Da es mehrere Darstellungen eines Punkts auf einer komplexen Ebene gibt, wird der Rückgabewert der <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode normalisiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-329">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="e2c92-330">Die Größe wird zu einer positiven Zahl normalisiert, und die Phase wird auf einen Wert im Bereich von-<xref:System.Math.PI> <xref:System.Math.PI>normalisiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-330">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="e2c92-331">Folglich sind die Werte der <xref:System.Numerics.Complex.Phase%2A>-und <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaften der resultierenden komplexen Zahl möglicherweise nicht mit den ursprünglichen Werten der Parameter `magnitude` und `phase` identisch.</span><span class="sxs-lookup"><span data-stu-id="e2c92-331">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="e2c92-332">Um einen Wert von Grad in Bogenmaß für den `phase`-Parameter zu konvertieren, Multiplizieren Sie ihn mit <xref:System.Math.PI?displayProperty=nameWithType>/180.</span><span class="sxs-lookup"><span data-stu-id="e2c92-332">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-333">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode verwendet, um eine komplexe Zahl auf der Grundlage der Polarkoordinaten zu instanziieren und dann den Wert der <xref:System.Numerics.Complex.Magnitude%2A>-und <xref:System.Numerics.Complex.Phase%2A> Eigenschaften anzeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-333">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e2c92-334">Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.Complex" />-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-334">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="e2c92-335">Ein Hashcode in Form einer 32-Bit-Ganzzahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-335">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-336">Ruft die imaginäre Komponente des aktuellen <see cref="T:System.Numerics.Complex" />-Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="e2c92-336">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="e2c92-337">Die imaginäre Komponente einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-337">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-338">Wenn eine komplexe Zahl a + BI ist, gibt die <xref:System.Numerics.Complex.Imaginary%2A>-Eigenschaft den Wert von b zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-338">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-339">Im folgenden Beispiel wird ein Array von <xref:System.Numerics.Complex>-Objekten instanziiert, und die reellen und imaginären Komponenten der einzelnen Elemente werden in der Form a + BI angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-339">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-340">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 0 und einer imaginären Zahl gleich 1 zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-340">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e2c92-341">Im folgenden Beispiel wird ein <xref:System.Numerics.Complex> Wert mit der <xref:System.Numerics.Complex.ImaginaryOne>-Eigenschaft instanziiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-341">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="e2c92-342">Anschließend wird dieser Wert mit einem anderen Wert verglichen, der durch Aufrufen des <xref:System.Numerics.Complex> Konstruktors mit einem reellen Teil gleich NULL und einem imaginären Teil, der gleich eins ist, instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-342">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="e2c92-343">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-343">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="Infinity">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Infinity;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Infinity" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Infinity" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Infinity As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Infinity;" />
      <MemberSignature Language="F#" Value=" staticval mutable Infinity : System.Numerics.Complex" Usage="System.Numerics.Complex.Infinity" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-344">Stellt Unendlichkeit als komplexe Zahl dar.</span><span class="sxs-lookup"><span data-stu-id="e2c92-344">Represents infinity as a complex number.</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsFinite">
      <MemberSignature Language="C#" Value="public static bool IsFinite (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsFinite(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsFinite(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsFinite (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsFinite(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsFinite : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsFinite value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-345">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-345">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-346">Bestimmt, ob die angegebene komplexe Zahl endlich ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-346">Determines whether the specified complex number is finite.</span></span></summary>
        <returns><span data-ttu-id="e2c92-347"><see langword="true" />, wenn sowohl der reelle als auch der imaginäre Teil endlich ist (null, subnormal oder normal); andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-347"><see langword="true" /> if both, the real and imaginary parts are finite (zero, subnormal or normal); otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsInfinity">
      <MemberSignature Language="C#" Value="public static bool IsInfinity (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsInfinity(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsInfinity(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsInfinity (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsInfinity(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsInfinity : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsInfinity value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-348">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-348">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-349">Gibt einen Wert zurück, der angibt, ob die angegebene komplexe Zahl als unendlich ausgewertet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-349">Returns a value indicating whether the specified complex number evaluates to infinity.</span></span></summary>
        <returns><span data-ttu-id="e2c92-350"><see langword="true" />, wenn entweder der reelle oder der imaginäre Teil <see cref="F:System.Double.PositiveInfinity" /> oder <see cref="F:System.Double.NegativeInfinity" /> lautet; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-350"><see langword="true" /> if either, the real or imaginary part are <see cref="F:System.Double.PositiveInfinity" /> or <see cref="F:System.Double.NegativeInfinity" />; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="IsNaN">
      <MemberSignature Language="C#" Value="public static bool IsNaN (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool IsNaN(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.IsNaN(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function IsNaN (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool IsNaN(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member IsNaN : System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.IsNaN value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-351">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-351">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-352">Gibt einen Wert zurück, der angibt, ob die angegebene komplexe Instanz keine Zahl ist (NaN).</span><span class="sxs-lookup"><span data-stu-id="e2c92-352">Returns a value that indicates whether the specified complex instance is not a number (NaN).</span></span></summary>
        <returns><span data-ttu-id="e2c92-353"><see langword="true" />, wenn der angegebene Wert weder endlich noch unendlich ist; andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-353"><see langword="true" /> if the specified value is not finite nor infinite; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-354">Gibt den Logarithmus einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-354">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-355">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-355">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-356">Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-356">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-357">Der natürliche Logarithmus (zur Basis <see langword="e" />) von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-357">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-358">Die <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-358">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-359">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Log%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-359">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="e2c92-360">Es zeigt, dass bei einem gewissen Mangel an Genauigkeit des <xref:System.Double> Datentyps der Wert, der von der <xref:System.Numerics.Complex.Log%2A>-Methode an die <xref:System.Numerics.Complex.Exp%2A>-Methode zurückgegeben wird, den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-360">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-361">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-361">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="e2c92-362">Die Basis des Logarithmus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-362">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="e2c92-363">Gibt den Logarithmus einer angegebenen komplexen Zahl zu einer angegebenen Basis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-363">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="e2c92-364">Der Logarithmus von <paramref name="value" /> zur Basis <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-364">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-365">Die <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-365">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-366">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-366">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-367">Gibt den Logarithmus einer angegebenen komplexen Zahl zur Basis 10 zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-367">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-368">Der Logarithmus zur Basis 10 von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-368">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-369">Die <xref:System.Numerics.Complex.Log10%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-369">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-370">Ruft die Größenordnung (oder den absoluten Wert) einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="e2c92-370">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="e2c92-371">Die Größe der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="e2c92-371">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-372">Die <xref:System.Numerics.Complex.Magnitude%2A>-Eigenschaft entspricht dem absoluten Wert einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-372">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="e2c92-373">Sie gibt den Abstand vom Ursprung (die Schnittmenge der x-Achse und die y-Achse im kartesischen Koordinatensystem) zu dem zweidimensionalen Punkt an, der durch eine komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-373">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="e2c92-374">Der absolute Wert wird wie folgt berechnet:</span><span class="sxs-lookup"><span data-stu-id="e2c92-374">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="e2c92-375">&#124;a + BI &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span><span class="sxs-lookup"><span data-stu-id="e2c92-375">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="e2c92-376">Wenn die Berechnung des absoluten Werts zu einem Überlauf führt, gibt diese Eigenschaft entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-376">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="e2c92-377">Die Eigenschaften <xref:System.Numerics.Complex.Magnitude%2A> und <xref:System.Numerics.Complex.Phase%2A> definieren die Position eines Punkts, der eine komplexe Zahl im Polarkoordinaten System darstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-377">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="e2c92-378">Sie können eine komplexe Zahl auf Grundlage ihrer Polarkoordinaten anstelle der kartesischen Koordinaten instanziieren, indem Sie die <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-378">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-379">Im folgenden Beispiel wird der absolute Wert einer komplexen Zahl berechnet und veranschaulicht, dass Sie dem Wert der <xref:System.Numerics.Complex.Magnitude%2A>-Eigenschaft entspricht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-379">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Multiply">
      <Docs>
        <summary><span data-ttu-id="e2c92-380">Multipliziert eine angegebene Zahl mit einer anderen angegebenen Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-380">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-381">Die <xref:System.Numerics.Complex.Multiply%2A>-Methoden ermöglichen das Ausführen von Multiplikations Vorgängen mit komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-381">The <xref:System.Numerics.Complex.Multiply%2A> methods allow performing multiplication operations that involve complex numbers.</span></span>

<span data-ttu-id="e2c92-382">Wenn die Multiplikation zu einem Überlauf in der reellen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-382">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
 
<span data-ttu-id="e2c92-383">Die <xref:System.Numerics.Complex.Multiply%2A>-Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-383">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="e2c92-384">Das Verhalten ist identisch mit der Multiplikation mit dem Multiplikations Operator.</span><span class="sxs-lookup"><span data-stu-id="e2c92-384">Its behavior is identical to multiplication using the multiplication operator.</span></span>  

  
## Examples  

<span data-ttu-id="e2c92-385">Im folgenden Beispiel wird eine komplexe Zahl von jedem Element in einem Array komplexer Zahlen multipliziert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-385">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
[!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
[!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-386">Die reelle Zahl mit doppelter Genauigkeit, mit der multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-386">The double-precision real number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-387">Die komplexe Zahl, mit der multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-387">The complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-388">Gibt das Produkt einer reellen Zahl mit doppelter Genauigkeit und einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-388">Returns the product of a double-precision real number and a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-389">Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="e2c92-389">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

 <span data-ttu-id="e2c92-390">Die Multiplikation einer reellen Zahl (die als komplexe Zahl a + 0i betrachtet werden kann) und eine komplexe Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-390">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>
 
 <span data-ttu-id="e2c92-391">AC + ADI</span><span class="sxs-lookup"><span data-stu-id="e2c92-391">ac + adi</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-392">Die komplexe Zahl, mit der multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-392">The complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-393">Die reelle Zahl mit doppelter Genauigkeit, mit der multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-393">The double-precision real number to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-394">Gibt das Produkt einer komplexen Zahl und einer reellen Zahl mit doppelter Genauigkeit zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-394">Returns the product of a complex number and a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-395">Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="e2c92-395">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-396">Die Multiplikation einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-396">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-397">AC + BCI</span><span class="sxs-lookup"><span data-stu-id="e2c92-397">ac + bci</span></span>
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-398">Die erste zu multiplizierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-398">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-399">Die zweite zu multiplizierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-399">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-400">Gibt das Produkt zweier komplexer Zahlen zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-400">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="e2c92-401">Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="e2c92-401">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-402">Die Multiplikation einer komplexen Zahl, a + BI und einer zweiten komplexen Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-402">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="e2c92-403">(AC-BD) + (AD + BC) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-403">(ac - bd) + (ad + bc)i</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="NaN">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex NaN;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex NaN" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.NaN" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NaN As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex NaN;" />
      <MemberSignature Language="F#" Value=" staticval mutable NaN : System.Numerics.Complex" Usage="System.Numerics.Complex.NaN" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-404">Stellt eine komplexe Instanz dar, die keine Zahl ist (NaN).</span><span class="sxs-lookup"><span data-stu-id="e2c92-404">Represents a complex instance that is not a number (NaN).</span></span></summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-405">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-405">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-406">Gibt die additive Inverse einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-406">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-407">Das Ergebnis der <see cref="P:System.Numerics.Complex.Real" />- und <see cref="P:System.Numerics.Complex.Imaginary" />-Komponenten des <paramref name="value" />-Parameters multipliziert mit -1.</span><span class="sxs-lookup"><span data-stu-id="e2c92-407">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-408">Die Additive Umkehrung einer komplexen Zahl ist eine komplexe Zahl, die den Wert <xref:System.Numerics.Complex.Zero> erzeugt, wenn Sie der ursprünglichen komplexen Zahl hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-408">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number.</span></span> <span data-ttu-id="e2c92-409">Diese Methode gibt eine komplexe Zahl zurück, in der die reellen und imaginären Komponenten der ursprünglichen komplexen Zahl mit-1 multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-409">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="e2c92-410">Die <xref:System.Numerics.Complex.Negate%2A>-Methode wird für Sprachen implementiert, die keine benutzerdefinierten Operatoren unterstützen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-410">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="e2c92-411">Das Verhalten ist mit der Negations Operator (unärer Negations Operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>) identisch.</span><span class="sxs-lookup"><span data-stu-id="e2c92-411">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-412">Im folgenden Beispiel wird die Additive Umkehrung der einzelnen Elemente in einem Array komplexer Zahlen abgerufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-412">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-413">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 1 und einer imaginären Zahl gleich 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-413">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="e2c92-414">Im folgenden Beispiel wird ein <xref:System.Numerics.Complex> Wert mit der <xref:System.Numerics.Complex.One>-Eigenschaft instanziiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-414">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="e2c92-415">Anschließend wird dieser Wert mit einem anderen Wert verglichen, der durch Aufrufen des <xref:System.Numerics.Complex> Konstruktors mit einem reellen und einem imaginären Teil gleich NULL instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-415">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="e2c92-416">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-416">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Addition">
      <Docs>
        <summary><span data-ttu-id="e2c92-417">Fügt eine angegebene Zahl einer anderen angegebenen Zahl hinzu. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-417">Adds a specified number to another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-418">Der <xref:System.Numerics.Complex.op_Addition%2A>-Operator ermöglicht das Ausführen von Additions Vorgängen, die komplexe Zahlen umfassen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-418">The <xref:System.Numerics.Complex.op_Addition%2A> operator allows performing addition operations that involve complex numbers.</span></span> <span data-ttu-id="e2c92-419">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-419">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
[!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]

<span data-ttu-id="e2c92-420">Wenn die Addition zu einem Überlauf in der reellen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-420">If the addition results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e2c92-421">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Add%2A> äquivalente Gruppe von Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-421">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="e2c92-422">Die <xref:System.Numerics.Complex.op_Addition%2A>-Operatoren, die einen Double-Wert empfangen, sind effizienter als die Operatoren, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-422">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="e2c92-423">Im folgenden Beispiel wird die Addition mit komplexen Zahlen veranschaulicht:</span><span class="sxs-lookup"><span data-stu-id="e2c92-423">The following example illustrates addition with complex numbers:</span></span>

[!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
[!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-424">Der reelle Wert mit doppelter Genauigkeit, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-424">The double-precision real value to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-425">Der komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-425">The complex value to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-426">Fügt einer komplexen Zahl eine reelle Zahl mit doppelter Genauigkeit hinzu.</span><span class="sxs-lookup"><span data-stu-id="e2c92-426">Adds a double-precision real number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-427">Die Summe von <paramref name="left" /> und <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-427">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-428">Das Hinzufügen einer reellen Zahl (die als komplexe Zahl a + 0i angesehen werden kann) und einer komplexen Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-428">The addition of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="e2c92-429">(a + c) + di</span><span class="sxs-lookup"><span data-stu-id="e2c92-429">(a + c) + di</span></span>

<span data-ttu-id="e2c92-430">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-430">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-431">Der komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-431">The complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-432">Der reelle Wert mit doppelter Genauigkeit, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-432">The double-precision real value to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-433">Fügt einer reellen Zahl mit doppelter Genauigkeit eine komplexe Zahl hinzu.</span><span class="sxs-lookup"><span data-stu-id="e2c92-433">Adds a complex number to a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-434">Die Summe von <paramref name="left" /> und <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-434">The sum of <paramref name="left" /> and <paramref name="right" /> as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-435">Das Hinzufügen einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-435">The addition of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-436">(a + c) + BI</span><span class="sxs-lookup"><span data-stu-id="e2c92-436">(a + c) + bi</span></span>

<span data-ttu-id="e2c92-437">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-437">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-438">Der erste komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-438">The first complex value to add.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-439">Der zweite komplexe Wert, der hinzugefügt werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-439">The second complex value to add.</span></span></param>
        <summary><span data-ttu-id="e2c92-440">Addiert zwei komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-440">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="e2c92-441">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-441">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-442">Das Hinzufügen einer komplexen Zahl, a + BI und einer zweiten komplexen Zahl (c + di), hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-442">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="e2c92-443">(a + c) + (b + d) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-443">(a + c) + (b + d)i</span></span>

<span data-ttu-id="e2c92-444">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-444">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Division">
      <Docs>
        <summary><span data-ttu-id="e2c92-445">Dividiert eine angegebene Zahl durch eine andere angegebene Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-445">Divides a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-446">Der <xref:System.Numerics.Complex.op_Division%2A>-Operator ermöglicht das Ausführen von Divisions Vorgängen, die komplexe Zahlen einschließen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-446">The <xref:System.Numerics.Complex.op_Division%2A> operator allows performing division operations that involve complex numbers.</span></span> <span data-ttu-id="e2c92-447">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-447">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
[!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]

<span data-ttu-id="e2c92-448">Wenn die Division zu einem Überlauf in der reellen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-448">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e2c92-449">Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen, können stattdessen die <xref:System.Numerics.Complex.Divide%2A> äquivalente Gruppe von Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-449">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> equivalent group of method instead.</span></span>

<span data-ttu-id="e2c92-450">Die <xref:System.Numerics.Complex.op_Division%2A>-Operatoren, die einen Double-Wert empfangen, sind effizienter als die Operatoren, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-450">The <xref:System.Numerics.Complex.op_Division%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-451">Der reelle Wert mit doppelter Genauigkeit, der dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-451">The double-precision real value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-452">Der komplexe Wert, durch den dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-452">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-453">Dividiert eine angegebene reelle Zahl mit doppelter Genauigkeit durch eine angegebene komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-453">Divides a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-454">Das Ergebnis der Division von <paramref name="left" /> durch <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-454">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-455">Die Division einer reellen Zahl (die als komplexe Zahl a + 0i betrachtet werden kann) und eine komplexe Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-455">The division of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="e2c92-456">(AC/(c<sup>2</sup> + d<sup>2</sup>)) + (AD/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-456">(ac / (c<sup>2</sup> + d<sup>2</sup>)) + (ad / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="e2c92-457">Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen, können stattdessen die <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> äquivalente Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-457">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-458">Der komplexe Wert, der dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-458">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-459">Der reelle Wert mit doppelter Genauigkeit, durch den dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-459">The double-precision real value to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-460">Dividiert eine angegebene komplexe Zahl durch eine reelle Zahl mit doppelter Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-460">Divides a specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-461">Das Ergebnis der Division von <paramref name="left" /> durch <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-461">The result of dividing <paramref name="left" /> by <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-462">Die Division einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i angesehen werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-462">The division of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-463">(AC/c<sup>2</sup>) + (BC/c<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-463">(ac / c<sup>2</sup>) + (bc / c<sup>2</sup>)i</span></span>

<span data-ttu-id="e2c92-464">Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen, können stattdessen die <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> äquivalente Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-464">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-465">Der komplexe Wert, der dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-465">The complex value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-466">Der komplexe Wert, durch den dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-466">The complex value to divide by.</span></span></param>
        <summary><span data-ttu-id="e2c92-467">Dividiert eine angegebene komplexe Zahl durch eine andere angegebene komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-467">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-468">Das Ergebnis der Division von <paramref name="left" /> durch <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-468">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-469">Die Division einer komplexen Zahl, a + BI und einer zweiten komplexen Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-469">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="e2c92-470">((AC + BD)/(c<sup>2</sup> + d<sup>2</sup>)) + ((BC-AD)/(c<sup>2</sup> + d<sup>2</sup>) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-470">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>

<span data-ttu-id="e2c92-471">Sprachen, die keine benutzerdefinierten Operatoren und Operator Überladung unterstützen, können stattdessen die <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> äquivalente Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-471">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-472">Die erste zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-472">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-473">Die zweite zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-473">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="e2c92-474">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-474">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="e2c92-475"><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-475"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-476">Die <xref:System.Numerics.Complex.op_Equality%2A>-Methode definiert den Vorgang des Gleichheits Operators für <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="e2c92-476">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="e2c92-477">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-477">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="e2c92-478">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-478">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="e2c92-479">Zwei komplexe Zahlen sind gleich, wenn Ihre tatsächlichen Teile gleich sind und ihre imaginären Teile gleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-479">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="e2c92-480">Die <xref:System.Numerics.Complex.op_Equality%2A>-Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="e2c92-480">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="e2c92-481">Beachten Sie, dass zwei komplexe Zahlen, die scheinbar gleichwertig sind, aufgrund von Unterschieden in der Genauigkeit als ungleich angesehen werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-481">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="e2c92-482">Weitere Informationen und eine mögliche Problem Umgehung finden Sie in der <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>-Methode.</span><span class="sxs-lookup"><span data-stu-id="e2c92-482">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="e2c92-483">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="e2c92-483">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-484">Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Numerics.Complex" />-Objekt und einem anderen Typ.</span><span class="sxs-lookup"><span data-stu-id="e2c92-484">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-485">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-485">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-486">Definiert eine explizite Konvertierung eines <see cref="T:System.Decimal" />-Werts in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-486">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-487">Eine komplexe Zahl mit einer reellen Komponente gleich <paramref name="value" /> und einer imaginären Komponente gleich 0.</span><span class="sxs-lookup"><span data-stu-id="e2c92-487">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-488">Explizite Konvertierungs Operatoren definieren Typen, die in ein <xref:System.Numerics.Complex> Objekt konvertiert werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-488">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="e2c92-489">Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-489">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="e2c92-490">Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` in Visual Basic) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-490">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="e2c92-491">Andernfalls wird ein Compilerfehler angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-491">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="e2c92-492">Die Konvertierung eines <xref:System.Decimal> Werts in den Realteil einer komplexen Zahl kann zu einem Genauigkeits Verlust führen, da eine <xref:System.Double>, die der <xref:System.Numerics.Complex.Real%2A> Eigenschaft der komplexen Zahl entspricht, weniger signifikante Ziffern als eine <xref:System.Decimal>hat.</span><span class="sxs-lookup"><span data-stu-id="e2c92-492">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="e2c92-493">Das folgende Beispiel veranschaulicht die explizite Konvertierung von <xref:System.Decimal> Werten in <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="e2c92-493">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-494">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-494">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-495">Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Werts in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-495">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-496">Eine komplexe Zahl mit einer reellen Komponente gleich <paramref name="value" /> und einer imaginären Komponente gleich 0.</span><span class="sxs-lookup"><span data-stu-id="e2c92-496">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-497">Explizite Konvertierungs Operatoren definieren Typen, die in ein <xref:System.Numerics.Complex> Objekt konvertiert werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-497">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="e2c92-498">Sprach Compiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlusten kommen kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-498">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="e2c92-499">Stattdessen wird die Konvertierung nur dann durchgeführt, wenn ein Umwandlungs C#Operator (in) oder eine Konvertierungs Funktion (z. b. `CType` in Visual Basic) verwendet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-499">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="e2c92-500">Andernfalls wird ein Compilerfehler angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-500">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="e2c92-501">Die Konvertierung eines <xref:System.Numerics.BigInteger> Werts in den Realteil einer komplexen Zahl kann zu einem Genauigkeits Verlust führen, da eine <xref:System.Double>, die der <xref:System.Numerics.Complex.Real%2A> Eigenschaft der komplexen Zahl entspricht, weniger signifikante Ziffern als eine <xref:System.Numerics.BigInteger>hat.</span><span class="sxs-lookup"><span data-stu-id="e2c92-501">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="e2c92-502">Wenn die Konvertierung nicht erfolgreich ist, weil der <xref:System.Numerics.BigInteger> Wert außerhalb des Bereichs des <xref:System.Double> Typs liegt, löst der Vorgang keinen <xref:System.OverflowException>aus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-502">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="e2c92-503">Wenn `value` kleiner als <xref:System.Double.MinValue>ist, ist das Ergebnis eine komplexe Zahl, bei der der <xref:System.Numerics.Complex.Real%2A>-Eigenschafts Wert <xref:System.Double.NegativeInfinity>entspricht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-503">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="e2c92-504">Wenn `value` größer als <xref:System.Double.MaxValue>ist, ist das Ergebnis eine komplexe Zahl, bei der der <xref:System.Numerics.Complex.Real%2A>-Eigenschafts Wert <xref:System.Double.PositiveInfinity>entspricht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-504">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="e2c92-505">Das folgende Beispiel veranschaulicht die explizite Konvertierung von <xref:System.Numerics.BigInteger> Werten in <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="e2c92-505">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-506">Definiert eine implizite Konvertierung zwischen einem <see cref="T:System.Numerics.Complex" />-Objekt und einem anderen Typ.</span><span class="sxs-lookup"><span data-stu-id="e2c92-506">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-507">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-507">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-508">Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-508">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-509">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-509">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-510">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-510">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-511">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-511">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-512">Diese Überladung ermöglicht es dem Compiler, Konvertierungen eines <xref:System.Byte> Werts in eine komplexe Zahl zu behandeln, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-512">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-513">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil dem <xref:System.Byte> Wert entspricht und dessen imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-513">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-514">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-514">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-515">Definiert eine implizite Konvertierung einer Gleitkommazahl mit doppelter Genauigkeit in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-515">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-516">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-516">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-517">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-517">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-518">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-518">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-519">Diese Überladung ermöglicht es dem Compiler, Konvertierungen eines <xref:System.Double> Werts in eine komplexe Zahl zu behandeln, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-519">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-520">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil dem <xref:System.Double> Wert entspricht und dessen imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-520">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-521">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-521">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-522">Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-522">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-523">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-523">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-524">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-524">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-525">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-525">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-526">Diese Überladung ermöglicht dem Compiler, Konvertierungen von einer 16-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl zu konvertieren, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-526">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-527">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil der 16-Bit-Ganzzahl mit Vorzeichen entspricht und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-527">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-528">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-528">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-529">Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-529">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-530">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-530">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-531">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-531">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-532">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-532">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-533">Diese Überladung ermöglicht es dem Compiler, Konvertierungen von einer signierten 32-Bit-Ganzzahl in eine komplexe Zahl zu behandeln, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-533">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-534">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil der signierten 32-Bit-Ganzzahl entspricht und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-534">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-535">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-535">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-536">Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-536">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-537">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-537">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-538">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-538">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-539">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-539">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-540">Diese Überladung ermöglicht es dem Compiler, Konvertierungen von einer signierten 64-Bit-Ganzzahl in eine komplexe Zahl zu behandeln, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-540">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-541">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil der signierten 64-Bit-Ganzzahl entspricht und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-541">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-542">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-542">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-543">Definiert eine implizite Konvertierung eines Bytewerts mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-543">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="e2c92-544">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="e2c92-544">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="e2c92-545">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-545">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-546">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-546">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-547">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-547">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-548">Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einem signierten Byte in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-548">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-549">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil gleich dem signierten Byte und dessen Imaginärteil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-549">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-550">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-550">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-551">Definiert eine implizite Konvertierung einer Gleitkommazahl mit einfacher Genauigkeit in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-551">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-552">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-552">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-553">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-553">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-554">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-554">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-555">Diese Überladung ermöglicht es dem Compiler, Konvertierungen eines <xref:System.Single> Werts in eine komplexe Zahl zu behandeln, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-555">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-556">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil dem <xref:System.Single> Wert entspricht und dessen imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-556">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-557">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-557">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-558">Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-558">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="e2c92-559">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="e2c92-559">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="e2c92-560">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-560">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-561">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-561">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-562">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-562">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-563">Diese Überladung ermöglicht es dem Compiler, Konvertierungen von einer 16-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl zu konvertieren, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-563">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-564">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil der 16-Bit-Ganzzahl ohne Vorzeichen entspricht und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-564">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-565">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-565">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-566">Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-566">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="e2c92-567">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="e2c92-567">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="e2c92-568">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-568">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-569">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-569">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-570">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-570">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-571">Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einer Ganzzahl 32 ohne Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-571">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-572">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil gleich der Ganzzahl 32 ohne Vorzeichen ist und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-572">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2;dotnet-uwp-10.0;netcore-3.0;netstandard-2.1;netcore-3.1;net-5.0">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-573">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-573">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-574">Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-574">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="e2c92-575">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="e2c92-575">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="e2c92-576">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="e2c92-576">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-577">Die über Ladungen des <xref:System.Numerics.Complex.op_Implicit%2A>-Operators definieren die Typen, aus denen ein Compiler ein <xref:System.Numerics.Complex>-Objekt automatisch ohne einen expliziten Umwandlungs Operator C#(in) oder einen-Konvertierungs Funktion (in Visual Basic) konvertieren kann.</span><span class="sxs-lookup"><span data-stu-id="e2c92-577">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="e2c92-578">Sie sind erweiternde Konvertierungen, die keinen Datenverlust verursachen und keine <xref:System.OverflowException>auslösen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-578">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="e2c92-579">Diese Überladung ermöglicht dem Compiler das Verarbeiten von Konvertierungen von einer Ganzzahl 64 ohne Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-579">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="e2c92-580">Beachten Sie, dass das Ergebnis der Konvertierung eine komplexe Zahl ist, deren Realteil gleich der Ganzzahl 64 ohne Vorzeichen ist und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-580">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-581">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-581">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-582">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-582">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="e2c92-583">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="e2c92-583">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="e2c92-584"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-584"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-585">Die <xref:System.Numerics.Complex.op_Equality%2A>-Methode definiert den Vorgang des Ungleichheits Operators für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-585">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="e2c92-586">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-586">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="e2c92-587">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können auf Ungleichheit testen, indem Sie die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>-Methode aufrufen und deren Wert umkehren.</span><span class="sxs-lookup"><span data-stu-id="e2c92-587">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="e2c92-588">Beachten Sie, dass zwei komplexe Zahlen, die scheinbar gleichwertig sind, aufgrund von Unterschieden in der Genauigkeit als ungleich angesehen werden können.</span><span class="sxs-lookup"><span data-stu-id="e2c92-588">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="e2c92-589">Eine mögliche Lösung besteht darin, zurückgibt, eine Vergleichsmethode implementiert `true` nur, wenn der Unterschied zwischen den zwei reellen und imaginären Teile der komplexen Zahlen einen bestimmten Schwellenwert überschreitet (z. B. 01 % des Werts der realen oder imaginären Komponente des einer der komplexen Zahlen).</span><span class="sxs-lookup"><span data-stu-id="e2c92-589">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="e2c92-590">Weitere Informationen finden Sie unter der Methode <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-590">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Multiply">
      <Docs>
        <summary><span data-ttu-id="e2c92-591">Multipliziert eine angegebene Zahl mit einer anderen angegebenen Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-591">Multiplies a specified number by another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-592">Der <xref:System.Numerics.Complex.op_Multiply%2A>-Operator ermöglicht das Ausführen von Multiplikations Vorgängen mit komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-592">The <xref:System.Numerics.Complex.op_Multiply%2A> operator allows performing multiplication operations that involve complex numbers.</span></span> <span data-ttu-id="e2c92-593">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-593">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
[!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]

<span data-ttu-id="e2c92-594">Wenn die Multiplikation zu einem Überlauf in der reellen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-594">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e2c92-595">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Multiply%2A> äquivalente Gruppe von Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-595">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="e2c92-596">Die <xref:System.Numerics.Complex.op_Multiply%2A>-Operatoren, die einen Double-Wert empfangen, sind effizienter als die Operatoren, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-596">The <xref:System.Numerics.Complex.op_Multiply%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-597">Der reelle Wert mit doppelter Genauigkeit, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-597">The double-precision real value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-598">Der komplexe Wert, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-598">The complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-599">Multipliziert eine angegebene reelle Zahl mit doppelter Genauigkeit durch eine angegebene komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-599">Multiplies a specified double-precision real number by a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-600">Das Produkt von <paramref name="left" /> und <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-600">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-601">Die Multiplikation einer reellen Zahl (die als komplexe Zahl a + 0i betrachtet werden kann) und eine komplexe Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-601">The multiplication of a real number (which can be regarded as the complex number a + 0i) and a complex number (c + di) takes the following form:</span></span>

<span data-ttu-id="e2c92-602">AC + ADI</span><span class="sxs-lookup"><span data-stu-id="e2c92-602">ac + adi</span></span>

<span data-ttu-id="e2c92-603">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-603">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>


          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-604">Der komplexe Wert, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-604">The complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-605">Der reelle Wert mit doppelter Genauigkeit, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-605">The double-precision real value to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-606">Multipliziert die angegebene komplexe Zahl durch eine angegebene reelle Zahl mit doppelter Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-606">Multiplies the specified complex number by a specified double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-607">Das Produkt von <paramref name="left" /> und <paramref name="right" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-607">The product of <paramref name="left" /> and <paramref name="right" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-608">Die Multiplikation einer komplexen Zahl (a + BI) und einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-608">The multiplication of a complex number (a + bi) and a real number (which can be regarded as the complex number c + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-609">AC + BCI</span><span class="sxs-lookup"><span data-stu-id="e2c92-609">ac + bci</span></span>

<span data-ttu-id="e2c92-610">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-610">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-611">Der erste komplexe Wert, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-611">The first complex value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-612">Der zweite komplexe Wert, mit dem multipliziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-612">The second complex value to multiply.</span></span></param>
        <summary><span data-ttu-id="e2c92-613">Multipliziert zwei angegebene komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-613">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="e2c92-614">Das Produkt von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-614">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-615">Die Multiplikation einer komplexen Zahl, a + BI und einer zweiten komplexen Zahl (c + di) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-615">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>

<span data-ttu-id="e2c92-616">(AC-BD) + (AD + BC) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-616">(ac - bd) + (ad + bc)i</span></span>

<span data-ttu-id="e2c92-617">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> äquivalente-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-617">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent method instead.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Subtraction">
      <Docs>
        <summary><span data-ttu-id="e2c92-618">Subtrahiert eine angegebene Zahl von einer anderen angegebenen Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-618">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-619">Der <xref:System.Numerics.Complex.op_Subtraction%2A>-Operator ermöglicht das Ausführen von Subtraktions Vorgängen, die komplexe Zahlen einschließen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-619">The <xref:System.Numerics.Complex.op_Subtraction%2A> operator allows performing subtraction operations that involve complex numbers.</span></span> <span data-ttu-id="e2c92-620">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-620">It enables code such as the following:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
[!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]

<span data-ttu-id="e2c92-621">Wenn die Subtraktion zu einem Überlauf in der realen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-621">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e2c92-622">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Subtract%2A> äquivalente Gruppe von Methoden aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-622">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> equivalent group of methods instead.</span></span>

<span data-ttu-id="e2c92-623">Die <xref:System.Numerics.Complex.op_Addition%2A>-Operatoren, die einen Double-Wert empfangen, sind effizienter als die Operatoren, die zwei komplexe Zahlen empfangen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-623">The <xref:System.Numerics.Complex.op_Addition%2A> operators that receive one double are more efficient than the operators that receive two Complex numbers.</span></span>

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-624">Der reelle Wert mit doppelter Genauigkeit, von dem subtrahiert werden soll (Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-624">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-625">Der komplexe Wert, der subtrahiert werden soll (Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-625">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-626">Subtrahiert eine komplexe Zahl von einer reellen Zahl mit doppelter Genauigkeit.</span><span class="sxs-lookup"><span data-stu-id="e2c92-626">Subtracts a complex number from a double-precision real number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-627">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-627">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-628">Die Subtraktion einer komplexen Zahl (c + di) von einer reellen Zahl (die als komplexe Zahl a + 0i angesehen werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-628">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-629">(a-c)-di</span><span class="sxs-lookup"><span data-stu-id="e2c92-629">(a - c) - di</span></span>

<span data-ttu-id="e2c92-630">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-630">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-631">Der komplexe Wert, von dem subtrahiert werden soll (Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-631">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-632">Der reelle Wert mit doppelter Genauigkeit, der subtrahiert werden soll (Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-632">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-633">Subtrahiert eine reelle Zahl mit doppelter Genauigkeit von einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-633">Subtracts a double-precision real number from a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-634">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-634">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-635">Die Subtraktion einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) aus einer komplexen Zahl (a + BI) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-635">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="e2c92-636">(a-c) + BI</span><span class="sxs-lookup"><span data-stu-id="e2c92-636">(a - c) + bi</span></span>

<span data-ttu-id="e2c92-637">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-637">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-638">Der Wert, von dem subtrahiert werden soll (der Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-638">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-639">Der Wert, der subtrahiert werden soll (der Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-639">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-640">Subtrahiert eine komplexe Zahl von einer anderen komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-640">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-641">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-641">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-642">Die Subtraktion einer komplexen Zahl (c + di) von einer anderen komplexen Zahl (a + BI) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-642">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="e2c92-643">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-643">(a - c) + (b - d)i</span></span>

<span data-ttu-id="e2c92-644">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-644">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> method instead.</span></span>
 
          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-645">Der zu negierende Wert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-645">The value to negate.</span></span></param>
        <summary><span data-ttu-id="e2c92-646">Gibt die additive Inverse einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-646">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-647">Das Ergebnis der <see cref="P:System.Numerics.Complex.Real" />- und <see cref="P:System.Numerics.Complex.Imaginary" />-Komponenten des <paramref name="value" />-Parameters multipliziert mit -1.</span><span class="sxs-lookup"><span data-stu-id="e2c92-647">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-648">Mit der <xref:System.Numerics.Complex.op_UnaryNegation%2A>-Methode wird der Vorgang des unären Negations Operators (Additives Inverse) für komplexe Zahlen definiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-648">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="e2c92-649">Dies ermöglicht Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="e2c92-649">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="e2c92-650">Die resultierende komplexe Zahl erzeugt den Wert <xref:System.Numerics.Complex.Zero>, wenn Sie der ursprünglichen komplexen Zahl hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-650">The resulting complex number produces a value of <xref:System.Numerics.Complex.Zero> when it is added to the original complex number.</span></span> <span data-ttu-id="e2c92-651">Sprachen, die keine benutzerdefinierten Operatoren unterstützen, können stattdessen die <xref:System.Numerics.Complex.Negate%2A>-Methode aufzurufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-651">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="e2c92-652">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="e2c92-652">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-653">Ruft die Phase einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="e2c92-653">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="e2c92-654">Die Phase einer komplexen Zahl im Bogenmaß.</span><span class="sxs-lookup"><span data-stu-id="e2c92-654">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-655">Für eine komplexe Zahl a + BI wird die Phase als <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a) berechnet.</span><span class="sxs-lookup"><span data-stu-id="e2c92-655">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="e2c92-656">Sie können eine komplexe Zahl anhand ihrer kartesischen Koordinaten auf der komplexen Ebene oder den Polarkoordinaten identifizieren.</span><span class="sxs-lookup"><span data-stu-id="e2c92-656">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="e2c92-657">Die Phase (Argument) einer komplexen Zahl ist der Winkel der reellen Achse einer Linie, die vom Ursprungs Punkt (der Schnittpunkt der x-Achse und der y-Achse) bis zu dem durch die komplexe Zahl dargestellten Punkt gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-657">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="e2c92-658">Die Größe (dargestellt durch die <xref:System.Numerics.Complex.Magnitude%2A>-Eigenschaft) ist der Abstand zwischen dem Ursprungs Punkt und dem Punkt, der durch die komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-658">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="e2c92-659">Sie können eine komplexe Zahl auf Grundlage ihrer Polarkoordinaten anstelle der kartesischen Koordinaten instanziieren, indem Sie die <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode aufrufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-659">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="e2c92-660">Um die Phase von Bogenmaß in Grad zu konvertieren, Multiplizieren Sie Sie um 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-660">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-661">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.FromPolarCoordinates%2A>-Methode verwendet, um eine komplexe Zahl auf der Grundlage der Polarkoordinaten zu instanziieren und dann den Wert ihrer <xref:System.Numerics.Complex.Magnitude%2A>-und <xref:System.Numerics.Complex.Phase%2A> Eigenschaften anzeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-661">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-662">Gibt eine komplexe Zahl potenziert mit einem angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-662">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-663">Eine komplexe Zahl, die mit einem Exponenten potenziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-663">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="e2c92-664">Eine Gleitkommazahl mit doppelter Genauigkeit, die einen Exponenten darstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-664">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="e2c92-665">Gibt eine angegebene komplexe Zahl potenziert mit einem als Gleitkommazahl mit doppelter Genauigkeit angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-665">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-666">Die komplexe Zahl <paramref name="value" /> potenziert mit <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-666">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-667">Wenn `value` gleich <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> ist, gibt die Methode <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-667">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-668">Bei anderen Werten, wenn `power` 0 ist, gibt die Methode <xref:System.Numerics.Complex.One?displayProperty=nameWithType>zurück, und wenn `power` 1 ist, wird `value`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-668">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="e2c92-669">Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType>-Methode für primitive numerische Typen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-669">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-670">Das folgende Beispiel veranschaulicht die exponentialisierung mit einer komplexen Zahl und einem Exponenten, dessen Wert zwischen-1 und 10 liegt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-670">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-671">Eine komplexe Zahl, die mit einem Exponenten potenziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="e2c92-671">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="e2c92-672">Eine komplexe Zahl, die einen Exponenten angibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-672">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="e2c92-673">Gibt eine komplexe Zahl potenziert mit einem durch eine komplexe Zahl angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-673">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-674">Die komplexe Zahl <paramref name="value" /> potenziert mit <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-674">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-675">Ruft die reelle Komponente des aktuellen <see cref="T:System.Numerics.Complex" />-Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="e2c92-675">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="e2c92-676">Die reelle Komponente einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-676">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-677">Wenn eine komplexe Zahl a + BI ist, gibt die <xref:System.Numerics.Complex.Real%2A>-Eigenschaft den Wert von zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-677">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-678">Im folgenden Beispiel wird ein Array von <xref:System.Numerics.Complex>-Objekten instanziiert, und die reellen und imaginären Komponenten der einzelnen Elemente werden in der Form a + BI angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-678">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-679">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-679">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-680">Gibt den Kehrwert einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-680">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-681">Der Kehrwert von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-681">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-682">Der gegenseitige oder Multiplikations Umkehr Wert einer Zahl *x* ist eine Zahl *y* , wobei *x* multipliziert mit *y* 1 ergibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-682">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="e2c92-683">Die gegenseitige Zahl einer komplexen Zahl ist die komplexe Zahl, die <xref:System.Numerics.Complex.One?displayProperty=nameWithType> erzeugt, wenn die beiden Zahlen multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-683">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="e2c92-684">Wenn eine komplexe Zahl durch a + BI dargestellt wird, wird die gegenseitige durch den Ausdruck a/(a<sup>2</sup>+ b<sup>2</sup>) +-b/(a<sup>2</sup> + b<sup>2</sup>) dargestellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-684">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="e2c92-685">Wenn value <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>ist, gibt die Methode <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-685">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="e2c92-686">Andernfalls wird das Ergebnis des Ausdrucks <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-686">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-687">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Reciprocal%2A>-Methode verwendet, um die gegenseitigen Werte mehrerer komplexer Zahlen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-687">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="e2c92-688">Außerdem wird veranschaulicht, dass das Ergebnis der Multiplikation einer komplexen Zahl durch die gegenseitige <xref:System.Numerics.Complex.One?displayProperty=nameWithType>ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-688">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-689">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-689">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-690">Gibt den Sinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-690">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-691">Der Sinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-691">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-692">Die <xref:System.Numerics.Complex.Sin%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Sin%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-692">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-693">Die <xref:System.Numerics.Complex.Sin%2A>-Methode verwendet die folgende Formel, um den Sinus der komplexen Zahl a + BI zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-693">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="e2c92-694">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="e2c92-694">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-695">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Sin%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-695">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="e2c92-696">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Asin%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Sin%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-696">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-697">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-697">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-698">Gibt den Hyperbelsinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-698">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-699">Der Hyperbelsinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-699">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-700">Die <xref:System.Numerics.Complex.Sinh%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Sinh%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-700">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-701">Die <xref:System.Numerics.Complex.Sinh%2A>-Methode verwendet die folgende Formel, um den hyperbolischen Sinus der komplexen Zahl a + BI zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-701">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="e2c92-702">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="e2c92-702">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-703">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-703">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-704">Gibt die Quadratwurzel einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-704">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-705">Die Quadratwurzel von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-705">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-706">Die Quadratwurzel der komplexen Zahl `value` wird mit der folgenden Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="e2c92-706">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="e2c92-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2,0)</span><span class="sxs-lookup"><span data-stu-id="e2c92-707"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="e2c92-708">Die <xref:System.Numerics.Complex.Sqrt%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-708">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Subtract">
      <Docs>
        <summary><span data-ttu-id="e2c92-709">Subtrahiert eine angegebene Zahl von einer anderen angegebenen Zahl. Hierbei ist mindestens eine Zahl eine komplexe Zahl, und die andere kann eine reelle Zahl mit doppelter Genauigkeit sein. Anschließend wird das Ergebnis zurückgegeben.</span><span class="sxs-lookup"><span data-stu-id="e2c92-709">Subtracts a specified number from another specified number, where at least one of them is a complex number, and the other could be a double-precision real number, and returns the result.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-710">Die <xref:System.Numerics.Complex.Subtract%2A>-Methode lässt Subtraktions Vorgänge zu, die komplexe Zahlen einschließen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-710">The <xref:System.Numerics.Complex.Subtract%2A> method allows subtraction operations that involve complex numbers.</span></span>

<span data-ttu-id="e2c92-711">Wenn die Subtraktion zu einem Überlauf in der realen oder imaginären Komponente führt, ist der Wert dieser Komponente entweder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="e2c92-711">If the subtraction results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>

<span data-ttu-id="e2c92-712">Sprachen, die benutzerdefinierte Operatoren unterstützen, können auch die <xref:System.Numerics.Complex.op_Subtraction%2A> äquivalente Gruppe von Operatoren verwenden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-712">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%2A> equivalent group of operators too.</span></span>

<span data-ttu-id="e2c92-713">Die <xref:System.Numerics.Complex.Subtract%2A> Methoden, die einen Double-Wert empfangen, sind effizienter als die Methode, die zwei komplexe Zahlen empfängt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-713">The <xref:System.Numerics.Complex.Subtract%2A> methods that receive one double are more efficient than the method that receive two Complex numbers.</span></span>

## Examples

<span data-ttu-id="e2c92-714">Im folgenden Beispiel wird jede komplexe Zahl in einem Array von einer komplexen Zahl subtrahiert:</span><span class="sxs-lookup"><span data-stu-id="e2c92-714">The following example subtracts each complex number in an array from a complex number:</span></span>

[!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
[!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]

          ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (double left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(float64 left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Double,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Double, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(double left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : double * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Double" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Numerics.Complex" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-715">Der reelle Wert mit doppelter Genauigkeit, von dem subtrahiert werden soll (Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-715">The double-precision real value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-716">Der komplexe Wert, der subtrahiert werden soll (Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-716">The complex value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-717">Subtrahiert eine komplexe Zahl von einer reellen Zahl mit doppelter Genauigkeit und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-717">Subtracts one complex number from a double-precision real number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-718">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-718">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-719">Die Subtraktion einer komplexen Zahl (c + di) von einer reellen Zahl (die als komplexe Zahl a + 0i angesehen werden kann) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-719">The subtraction of a complex number (c + di) from a real number (which can be regarded as the complex number a + 0i) takes the following form:</span></span>

<span data-ttu-id="e2c92-720">(a-c)-di</span><span class="sxs-lookup"><span data-stu-id="e2c92-720">(a - c) - di</span></span>

<span data-ttu-id="e2c92-721">Sprachen, die benutzerdefinierte Operatoren unterstützen, können auch den <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> entsprechenden Operator verwenden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-721">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Double%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Double,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, double right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, float64 right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, double right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" Index="0" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
        <Parameter Name="right" Type="System.Double" Index="1" FrameworkAlternate="netcore-3.0;netcore-3.1;net-5.0" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-722">Der komplexe Wert, von dem subtrahiert werden soll (Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-722">The complex value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-723">Der reelle Wert mit doppelter Genauigkeit, der subtrahiert werden soll (Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-723">The double-precision real value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-724">Subtrahiert eine reelle Zahl mit doppelter Genauigkeit von einer komplexen Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-724">Subtracts one double-precision real number from a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-725">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" /> als komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-725">The result of subtracting <paramref name="right" /> from <paramref name="left" />, as a complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-726">Die Subtraktion einer reellen Zahl (die als komplexe Zahl c + 0i betrachtet werden kann) aus einer komplexen Zahl (a + BI) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-726">The subtraction of a real number (which can be regarded as the complex number c + 0i) from a complex number (a + bi) takes the following form:</span></span>

<span data-ttu-id="e2c92-727">(a-c) + BI</span><span class="sxs-lookup"><span data-stu-id="e2c92-727">(a - c) + bi</span></span>

<span data-ttu-id="e2c92-728">Sprachen, die benutzerdefinierte Operatoren unterstützen, können auch den <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> entsprechenden Operator verwenden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-728">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Double%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="e2c92-729">Der Wert, von dem subtrahiert werden soll (der Minuend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-729">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="e2c92-730">Der Wert, der subtrahiert werden soll (der Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="e2c92-730">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="e2c92-731">Subtrahiert eine komplexe Zahl von einer anderen komplexen Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-731">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="e2c92-732">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-732">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[

## Remarks

<span data-ttu-id="e2c92-733">Die Subtraktion einer komplexen Zahl (c + di) von einer anderen komplexen Zahl (a + BI) hat die folgende Form:</span><span class="sxs-lookup"><span data-stu-id="e2c92-733">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>

<span data-ttu-id="e2c92-734">(a-c) + (b-d) i</span><span class="sxs-lookup"><span data-stu-id="e2c92-734">(a - c) + (b - d)i</span></span>

<span data-ttu-id="e2c92-735">Sprachen, die benutzerdefinierte Operatoren unterstützen, können auch den <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> entsprechenden Operator verwenden.</span><span class="sxs-lookup"><span data-stu-id="e2c92-735">Languages that support custom operators can use the <xref:System.Numerics.Complex.op_Subtraction%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType> equivalent operator too.</span></span>

          ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-736">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-736">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-737">Gibt den Tangens der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-737">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-738">Der Tangens von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-738">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-739">Die <xref:System.Numerics.Complex.Tan%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Tan%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-739">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-740">Die <xref:System.Numerics.Complex.Tan%2A>-Methode verwendet die folgende Formel, um den Tangens der komplexen Zahl `value`zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-740">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="e2c92-741"><xref:System.Numerics.Complex.Sin%2A>(`value`)/<xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="e2c92-741"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-742">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Tan%2A>-Methode veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="e2c92-742">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="e2c92-743">Es zeigt, dass die Übergabe des von der <xref:System.Numerics.Complex.Atan%2A>-Methode zurückgegebenen Werts an die <xref:System.Numerics.Complex.Tan%2A> Methode den ursprünglichen <xref:System.Numerics.Complex> Wert zurückgibt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-743">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="e2c92-744">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="e2c92-744">A complex number.</span></span></param>
        <summary><span data-ttu-id="e2c92-745">Gibt den Hyperbeltangens der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-745">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="e2c92-746">Der Hyperbeltangens von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-746">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-747">Die <xref:System.Numerics.Complex.Tanh%2A>-Methode für komplexe Zahlen entspricht der <xref:System.Math.Tanh%2A?displayProperty=nameWithType>-Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-747">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="e2c92-748">Die <xref:System.Numerics.Complex.Tanh%2A>-Methode verwendet die folgende Formel, um den hyperbolischen Tangens der komplexen Zahl `value`zu berechnen:</span><span class="sxs-lookup"><span data-stu-id="e2c92-748">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="e2c92-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`)/<xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="e2c92-749"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="e2c92-750">Konvertiert den Wert einer komplexen Zahl in die entsprechende Zeichenfolgendarstellung.</span><span class="sxs-lookup"><span data-stu-id="e2c92-750">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="e2c92-751">Konvertiert den Wert der aktuellen komplexen Zahl in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-751">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="e2c92-752">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-752">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-753">Die standardmäßige Zeichen folgen Darstellung einer komplexen Zahl zeigt die Zahl mithilfe der kartesischen Koordinaten in der Form `(`*eines*`,` *b* -`)`an, wobei *a* der reelle Teil der komplexen Zahl und *b* der imaginäre Teil ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-753">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="e2c92-754">*A* und *b* werden mit dem allgemeinen Format Bezeichner ("G") und den Konventionen der aktuellen System Kultur formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-754">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-755">Im folgenden Beispiel wird die Zeichen folgen Darstellung mehrerer komplexer Zahlen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-755">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="e2c92-756">Die Ausgabe verwendet die Formatierungs Konventionen der Kultur Englisch-USA ("en-US"), bei der es sich in diesem Fall um die aktuelle System Kultur handelt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-756">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="e2c92-757">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-757">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="e2c92-758">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-758">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="e2c92-759">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form entsprechend dem Wert von <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-759">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-760">Die Zeichen folgen Darstellung der komplexen Zahl, die von dieser Methode zurückgegeben wird, zeigt die Zahl mithilfe der kartesischen Koordinaten in der Form `(`*eines*`,` *b* -`)`an, wobei *a* der reelle Teil der komplexen Zahl und *b* der imaginäre Teil ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-760">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="e2c92-761">*A* und *b* werden mit dem allgemeinen Format Bezeichner ("G") und den Konventionen der durch `provider`definierten Kultur formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-761">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="e2c92-762">Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung.</span><span class="sxs-lookup"><span data-stu-id="e2c92-762">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="e2c92-763">Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format der reellen und imaginären Zahlen in der zurückgegebenen Zeichenfolge bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-763">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="e2c92-764">Wenn `provider` `null`ist, wird die zurückgegebene Zeichenfolge mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt der aktuellen Kultur formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-764">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="e2c92-765">Der `provider`-Parameter kann eines der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="e2c92-765">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="e2c92-766">Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die Formatierungsinformationen liefert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-766">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="e2c92-767">Das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-767">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="e2c92-768">Ein benutzerdefiniertes Objekt, das die <xref:System.IFormatProvider>-Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-768">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="e2c92-769">Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-769">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-770">Im folgenden Beispiel wird die Zeichen folgen Darstellung mehrerer komplexer Zahlen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-770">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="e2c92-771">Das Ergebnis verwendet die Formatierungs Konventionen der Kulturen Englisch-USA ("en-US") und Französisch-Frankreich ("fr-FR").</span><span class="sxs-lookup"><span data-stu-id="e2c92-771">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="e2c92-772">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-772">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="e2c92-773">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung des angegebenen Formats für die reellen und imaginären Teile in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-773">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="e2c92-774">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-774">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-775">Die Zeichen folgen Darstellung der komplexen Zahl, die von dieser Methode zurückgegeben wird, zeigt die Zahl mithilfe der kartesischen Koordinaten in der Form `(`*eines*`,` *b* -`)`an, wobei *a* der reelle Teil der komplexen Zahl und *b* der imaginäre Teil ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-775">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="e2c92-776">*A* und *b* werden mithilfe der Format Zeichenfolge formatiert, die durch `format`angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-776">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="e2c92-777">Der `format`-Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner oder eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-777">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="e2c92-778">Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`ist, werden die reellen und imaginären Teile der komplexen Zahl mit dem allgemeinen Format Bezeichner ("G") formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-778">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="e2c92-779">Wenn `format` einen anderen Wert hat, löst die Methode eine <xref:System.FormatException>aus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-779">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="e2c92-780">Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Themen ausführlicher beschrieben wird:</span><span class="sxs-lookup"><span data-stu-id="e2c92-780">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="e2c92-781">Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-781">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="e2c92-782">Weitere Informationen zum Formatieren im .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="e2c92-782">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="e2c92-783">Das Format der zurückgegebenen Zeichenfolge wird durch das <xref:System.Globalization.NumberFormatInfo>-Objekt für die aktuelle Kultur bestimmt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-783">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="e2c92-784">Abhängig vom `format`-Parameter steuert dieses Objekt Symbole wie das negative Vorzeichen, das Gruppen Trennzeichen und das Dezimaltrennzeichen in der Ausgabe Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-784">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="e2c92-785">Um Formatierungsinformationen für andere Kulturen als die aktuelle Kultur bereitzustellen, müssen Sie die <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> Überladung aufrufen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-785">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-786">Im folgenden Beispiel wird eine komplexe Zahl initialisiert und mithilfe mehrerer Standardformat Zeichenfolgen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-786">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="e2c92-787"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-787"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="e2c92-788">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e2c92-788">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="e2c92-789">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e2c92-789">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="e2c92-790">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-790">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="e2c92-791">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-791">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="e2c92-792">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen für die reellen und imaginären Teile in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="e2c92-792">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="e2c92-793">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form entsprechend den Werten von <paramref name="format" /> und <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="e2c92-793">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-794">Die Zeichen folgen Darstellung der komplexen Zahl, die von dieser Methode zurückgegeben wird, zeigt die Zahl mithilfe der kartesischen Koordinaten in der Form `(`*eines*`,` *b* -`)`an, wobei *a* der reelle Teil der komplexen Zahl und *b* der imaginäre Teil ist.</span><span class="sxs-lookup"><span data-stu-id="e2c92-794">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="e2c92-795">*A* und *b* werden mithilfe der Format Zeichenfolge formatiert, die durch `format`angegeben wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-795">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="e2c92-796">Der `format`-Parameter kann ein beliebiger gültiger numerischer Standardformat Bezeichner oder eine beliebige Kombination von benutzerdefinierten numerischen Format Bezeichnern sein.</span><span class="sxs-lookup"><span data-stu-id="e2c92-796">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="e2c92-797">Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`ist, werden die reellen und imaginären Teile der komplexen Zahl mit dem allgemeinen Format Bezeichner ("G") formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-797">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="e2c92-798">Wenn `format` einen anderen Wert hat, löst die Methode eine <xref:System.FormatException>aus.</span><span class="sxs-lookup"><span data-stu-id="e2c92-798">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="e2c92-799">Der .NET Framework bietet umfassende Formatierungs Unterstützung, die in den folgenden Themen ausführlicher beschrieben wird:</span><span class="sxs-lookup"><span data-stu-id="e2c92-799">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="e2c92-800">Weitere Informationen zu numerischen Format Zeichenfolgen finden Sie unter [Standard mäßige Zahlenformat](~/docs/standard/base-types/standard-numeric-format-strings.md) Zeichenfolgen und [benutzerdefinierte Zahlenformat](~/docs/standard/base-types/custom-numeric-format-strings.md)Zeichenfolgen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-800">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="e2c92-801">Weitere Informationen zum Formatieren im .NET Framework finden Sie unter [Formatieren von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="e2c92-801">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="e2c92-802">Der `provider`-Parameter ist eine <xref:System.IFormatProvider> Implementierung.</span><span class="sxs-lookup"><span data-stu-id="e2c92-802">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="e2c92-803">Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt ein <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das kulturspezifische Informationen zum Format der reellen und imaginären Zahlen in der zurückgegebenen Zeichenfolge bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-803">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="e2c92-804">Abhängig vom `format`-Parameter steuert dieses Objekt Symbole wie das negative Vorzeichen, das Gruppen Trennzeichen und das Dezimaltrennzeichen in der Ausgabe Zeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-804">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="e2c92-805">Wenn `provider` `null`ist, wird die zurückgegebene Zeichenfolge mit dem <xref:System.Globalization.NumberFormatInfo>-Objekt der aktuellen Kultur formatiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-805">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="e2c92-806">Der `provider`-Parameter kann eines der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="e2c92-806">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="e2c92-807">Ein <xref:System.Globalization.CultureInfo>-Objekt, das die Kultur darstellt, die Formatierungsinformationen liefert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-807">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="e2c92-808">Das <xref:System.Globalization.NumberFormatInfo> Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-808">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="e2c92-809">Ein benutzerdefiniertes Objekt, das die <xref:System.IFormatProvider>-Schnittstelle implementiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-809">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="e2c92-810">Die <xref:System.IFormatProvider.GetFormat%2A>-Methode gibt das <xref:System.Globalization.NumberFormatInfo> Objekt zurück, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="e2c92-810">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-811">Im folgenden Beispiel wird ein Array komplexer Zahlen erstellt und jede mithilfe mehrerer Standardformat Zeichenfolgen sowie <xref:System.Globalization.CultureInfo> Objekten angezeigt, die die Kulturen Englisch-USA ("en-US") und Französisch-Frankreich ("fr-FR") darstellen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-811">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="e2c92-812"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="e2c92-812"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="e2c92-813">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e2c92-813">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="e2c92-814">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="e2c92-814">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
        <AssemblyVersion>4.1.2.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
        <AssemblyVersion>2.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="e2c92-815">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 0 und einer imaginären Zahl gleich 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="e2c92-815">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="e2c92-816">Die <xref:System.Numerics.Complex.Zero>-Eigenschaft wird am häufigsten verwendet, um einen <xref:System.Numerics.Complex>-Wert mit 0 (null) zu vergleichen.</span><span class="sxs-lookup"><span data-stu-id="e2c92-816">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="e2c92-817">Im folgenden Beispiel wird ein <xref:System.Numerics.Complex> Wert mit der <xref:System.Numerics.Complex.Zero>-Eigenschaft instanziiert.</span><span class="sxs-lookup"><span data-stu-id="e2c92-817">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="e2c92-818">Anschließend wird dieser Wert mit einem anderen Wert verglichen, der durch Aufrufen des <xref:System.Numerics.Complex> Konstruktors mit einem reellen Teil gleich NULL und einem imaginären Teil gleich 0 (null) instanziiert wird.</span><span class="sxs-lookup"><span data-stu-id="e2c92-818">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="e2c92-819">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="e2c92-819">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>
