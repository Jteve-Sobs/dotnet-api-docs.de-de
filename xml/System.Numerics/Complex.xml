<Type Name="Complex" FullName="System.Numerics.Complex">
  <Metadata><Meta Name="ms.openlocfilehash" Value="91e3f8eb255ecea49f114ef22b5e0be3116e0a0f" /><Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="12/01/2018" /><Meta Name="ms.locfileid" Value="52737034" /></Metadata><TypeSignature Language="C#" Value="public struct Complex : IEquatable&lt;System.Numerics.Complex&gt;, IFormattable" />
  <TypeSignature Language="ILAsm" Value=".class public sequential ansi serializable sealed beforefieldinit Complex extends System.ValueType implements class System.IEquatable`1&lt;valuetype System.Numerics.Complex&gt;, class System.IFormattable" />
  <TypeSignature Language="DocId" Value="T:System.Numerics.Complex" />
  <TypeSignature Language="VB.NET" Value="Public Structure Complex&#xA;Implements IEquatable(Of Complex), IFormattable" />
  <TypeSignature Language="C++ CLI" Value="public value class Complex : IEquatable&lt;System::Numerics::Complex&gt;, IFormattable" />
  <TypeSignature Language="F#" Value="type Complex = struct&#xA;    interface IFormattable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Numerics</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.0.0</AssemblyVersion>
    <AssemblyVersion>4.1.1.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Numerics</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>netstandard</AssemblyName>
    <AssemblyVersion>2.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.ValueType</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IEquatable&lt;System.Numerics.Complex&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IFormattable</InterfaceName>
    </Interface>
  </Interfaces>
  <Attributes>
    <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0">
      <AttributeName>System.Serializable</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary><span data-ttu-id="b9077-101">Stellt eine komplexe Zahl dar.</span><span class="sxs-lookup"><span data-stu-id="b9077-101">Represents a complex number.</span></span></summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-102">Eine komplexe Zahl ist eine Zahl, die mit einem reellen und einem imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-102">A complex number is a number that comprises a real number part and an imaginary number part.</span></span> <span data-ttu-id="b9077-103">Eine komplexe Zahl Z hat in der Regel die Form Z = X + Yi, in dem *x* und *y* werden reelle Zahlen und *ich* die imaginäre Einheit ist, die die Eigenschaft weist *i* <sup>2</sup> =-1.</span><span class="sxs-lookup"><span data-stu-id="b9077-103">A complex number z is usually written in the form z = x + yi, where *x* and *y* are real numbers, and *i* is the imaginary unit that has the property *i*<sup>2</sup> = -1.</span></span> <span data-ttu-id="b9077-104">Durch den Realteil der komplexen Zahl dargestellt *x*, und der imaginäre Teil der komplexen Zahl wird durch *y*.</span><span class="sxs-lookup"><span data-stu-id="b9077-104">The real part of the complex number is represented by *x*, and the imaginary part of the complex number is represented by *y*.</span></span>  
  
 <span data-ttu-id="b9077-105">Die <xref:System.Numerics.Complex> Typ verwendet, der kartesischen Koordinatensystem (real-imaginär) beim Instanziieren und Bearbeitung komplexer Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-105">The <xref:System.Numerics.Complex> type uses the Cartesian coordinate system (real, imaginary) when instantiating and manipulating complex numbers.</span></span> <span data-ttu-id="b9077-106">Als Punkt in einem zweidimensionalen Koordinatensystem, bekannt als der komplexen Ebene, kann eine komplexe Zahl dargestellt werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-106">A complex number can be represented as a point in a two-dimensional coordinate system, which is known as the complex plane.</span></span> <span data-ttu-id="b9077-107">Der reelle Teil der komplexen Zahl auf der x-Achse (die horizontale Achse) positioniert ist, und der imaginäre Teil befindet sich auf der y-Achse (vertikalen Achse).</span><span class="sxs-lookup"><span data-stu-id="b9077-107">The real part of the complex number is positioned on the x-axis (the horizontal axis), and the imaginary part is positioned on the y-axis (the vertical axis).</span></span>  
  
 <span data-ttu-id="b9077-108">Einem beliebigen Zeitpunkt in der komplexen Ebene kann auch basierend auf der Absolute Wert ist, verwenden das System Polarkoordinate ausgedrückt werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-108">Any point in the complex plane can also be expressed based on its absolute value, by using the polar coordinate system.</span></span> <span data-ttu-id="b9077-109">In den Polarkoordinaten ist ein Punkt von zwei Zahlen gekennzeichnet:</span><span class="sxs-lookup"><span data-stu-id="b9077-109">In polar coordinates, a point is characterized by two numbers:</span></span>  
  
-   <span data-ttu-id="b9077-110">Seine Größe, d. h. die Entfernung des Punkts aus dem Ursprung (d. h. 0,0 oder der Punkt, an dem die x-Achse und y-Achse schneiden).</span><span class="sxs-lookup"><span data-stu-id="b9077-110">Its magnitude, which is the distance of the point from the origin (that is, 0,0, or the point at which the x-axis and the y-axis intersect).</span></span>  
  
-   <span data-ttu-id="b9077-111">Die Phase, in der der Winkel zwischen der reellen Achse und die Zeile, die vom Ursprung zum Punkt gezeichnet wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-111">Its phase, which is the angle between the real axis and the line drawn from the origin to the point.</span></span>  
  
## <a name="instantiating-a-complex-number"></a><span data-ttu-id="b9077-112">Instanziieren einer komplexen Zahl</span><span class="sxs-lookup"><span data-stu-id="b9077-112">Instantiating a Complex Number</span></span>  
 <span data-ttu-id="b9077-113">Sie können eine komplexe Zahl in einem der folgenden Methoden einen Wert zuweisen:</span><span class="sxs-lookup"><span data-stu-id="b9077-113">You can assign a value to a complex number in one of the following ways:</span></span>  
  
-   <span data-ttu-id="b9077-114">Durch Übergeben von zwei <xref:System.Double> Werte an den Konstruktor.</span><span class="sxs-lookup"><span data-stu-id="b9077-114">By passing two <xref:System.Double> values to its constructor.</span></span> <span data-ttu-id="b9077-115">Der erste Wert entspricht dem Realteil der komplexen Zahl und der zweite Wert dar, des imaginären Teils.</span><span class="sxs-lookup"><span data-stu-id="b9077-115">The first value represents the real part of the complex number, and the second value represents its imaginary part.</span></span> <span data-ttu-id="b9077-116">Diese Werte stellen die Position der komplexen Zahl in der zweidimensionalen kartesisches Koordinatensystem dar.</span><span class="sxs-lookup"><span data-stu-id="b9077-116">These values represent the position of the complex number in the two-dimensional Cartesian coordinate system.</span></span>  
  
-   <span data-ttu-id="b9077-117">Durch Aufrufen der statischen (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> Methode, um eine komplexe Zahl aus den Polarkoordinaten zu erstellen.</span><span class="sxs-lookup"><span data-stu-id="b9077-117">By calling the static (`Shared` in Visual Basic) <xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType> method to create a complex number from its polar coordinates.</span></span>  
  
-   <span data-ttu-id="b9077-118">Durch Zuweisen einer <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, oder <xref:System.Double> -Werts in einen <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-118">By assigning a <xref:System.Byte>, <xref:System.SByte>, <xref:System.Int16>, <xref:System.UInt16>, <xref:System.Int32>, <xref:System.UInt32>, <xref:System.Int64>, <xref:System.UInt64>, <xref:System.Single>, or <xref:System.Double> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b9077-119">Der Wert wird dem reellen Teil der komplexen Zahl und imaginäre Teil entspricht 0.</span><span class="sxs-lookup"><span data-stu-id="b9077-119">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="b9077-120">Umwandlung (in c#) oder konvertieren (in Visual Basic) eine <xref:System.Decimal> oder <xref:System.Numerics.BigInteger> -Werts in einen <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-120">By casting (in C#) or converting (in Visual Basic) a <xref:System.Decimal> or <xref:System.Numerics.BigInteger> value to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b9077-121">Der Wert wird dem reellen Teil der komplexen Zahl und imaginäre Teil entspricht 0.</span><span class="sxs-lookup"><span data-stu-id="b9077-121">The value becomes the real part of the complex number, and its imaginary part equals 0.</span></span>  
  
-   <span data-ttu-id="b9077-122">Durch Zuweisen der komplexen Zahl, die von einer Methode oder der Operator zurückgegeben wird ein <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-122">By assigning the complex number that is returned by a method or operator to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b9077-123">Z. B. <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> ist eine statische Methode, die eine komplexe Zahl zurückgibt, die die Summe zweier komplexer Zahlen, und die <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> Operator addiert zwei komplexe Zahlen und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-123">For example, <xref:System.Numerics.Complex.Add%2A?displayProperty=nameWithType> is a static method that returns a complex number that is the sum of two complex numbers, and the <xref:System.Numerics.Complex.op_Addition%2A?displayProperty=nameWithType> operator adds two complex numbers and returns the result.</span></span>  
  
 <span data-ttu-id="b9077-124">Das folgende Beispiel zeigt jede dieser fünf Methoden Zuweisung eines Werts in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-124">The following example demonstrates each of these five ways of assigning a value to a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/create1.cs#2)]
 [!code-vb[System.Numerics.Complex.Class#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/create1.vb#2)]  
  
## <a name="operations-with-complex-numbers"></a><span data-ttu-id="b9077-125">Operationen mit komplexen Zahlen</span><span class="sxs-lookup"><span data-stu-id="b9077-125">Operations with Complex Numbers</span></span>  
 <span data-ttu-id="b9077-126">Die <xref:System.Numerics.Complex> Struktur in .NET Framework enthält Member, die die folgende Funktionalität bereitstellen:</span><span class="sxs-lookup"><span data-stu-id="b9077-126">The <xref:System.Numerics.Complex> structure in the .NET Framework includes members that provide the following functionality:</span></span>  
  
-   <span data-ttu-id="b9077-127">Methoden zum Vergleichen von zwei komplexen Zahlen, um festzustellen, ob diese gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-127">Methods to compare two complex numbers to determine whether they are equal.</span></span>  
  
-   <span data-ttu-id="b9077-128">Operatoren, die arithmetische Operationen für komplexe Zahlen durchführen.</span><span class="sxs-lookup"><span data-stu-id="b9077-128">Operators to perform arithmetic operations on complex numbers.</span></span> <span data-ttu-id="b9077-129"><xref:System.Numerics.Complex> Operatoren können Sie zum Ausführen der Addition, Subtraktion, Multiplikation, Division und unäre Negation mit komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-129"><xref:System.Numerics.Complex> operators enable you to perform addition, subtraction, multiplication, division, and unary negation with complex numbers.</span></span>  
  
-   <span data-ttu-id="b9077-130">Methoden zum Ausführen von anderen numerischen Operations für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-130">Methods to perform other numerical operations on complex numbers.</span></span> <span data-ttu-id="b9077-131">Zusätzlich zu den vier grundlegenden arithmetischen Operationen können Sie eine komplexen Zahl mit einem bestimmten Exponenten auslösen, ermittelt die Quadratwurzel einer komplexen Zahl und rufen Sie den absoluten Wert einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-131">In addition to the four basic arithmetic operations, you can raise a complex number to a specified power, find the square root of a complex number, and get the absolute value of a complex number.</span></span>  
  
-   <span data-ttu-id="b9077-132">Methoden für trigonometrische Operationen für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-132">Methods to perform trigonometric operations on complex numbers.</span></span> <span data-ttu-id="b9077-133">Beispielsweise können Sie den Tangens eines Winkels, dargestellt durch eine komplexe Zahl berechnen.</span><span class="sxs-lookup"><span data-stu-id="b9077-133">For example, you can calculate the tangent of an angle represented by a complex number.</span></span>  
  
 <span data-ttu-id="b9077-134">Beachten Sie, dass, weil die <xref:System.Numerics.Complex.Real%2A> und <xref:System.Numerics.Complex.Imaginary%2A> Eigenschaften sind schreibgeschützt, Sie können nicht den Wert eines vorhandenen ändern <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-134">Note that, because the <xref:System.Numerics.Complex.Real%2A> and  <xref:System.Numerics.Complex.Imaginary%2A> properties are read-only, you cannot modify the value of an existing <xref:System.Numerics.Complex> object.</span></span>  <span data-ttu-id="b9077-135">Alle Methoden, die für einen Vorgang ausführen einer <xref:System.Numerics.Complex> Zahl ist, wenn deren Rückgabewert vom Typ <xref:System.Numerics.Complex>, ein neues zurückgeben <xref:System.Numerics.Complex> Anzahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-135">All methods that perform an operation on a <xref:System.Numerics.Complex> number, if their return value is of type <xref:System.Numerics.Complex>, return a new <xref:System.Numerics.Complex> number.</span></span>  
  
## <a name="precision-and-complex-numbers"></a><span data-ttu-id="b9077-136">Genauigkeit und komplexe Zahlen</span><span class="sxs-lookup"><span data-stu-id="b9077-136">Precision and Complex Numbers</span></span>  
 <span data-ttu-id="b9077-137">Die reellen und imaginären Teile einer komplexen Zahl werden durch zwei Werte für Gleitkommazahlen mit doppelter Genauigkeit dargestellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-137">The real and imaginary parts of a complex number are represented by two double-precision floating-point values.</span></span> <span data-ttu-id="b9077-138">Dies bedeutet, dass <xref:System.Numerics.Complex> Werte, wie Werte für Gleitkommazahlen mit doppelter Genauigkeit, abnehmen können aufgrund von numerischen.</span><span class="sxs-lookup"><span data-stu-id="b9077-138">This means that <xref:System.Numerics.Complex> values, like double-precision floating-point values, can lose precision as a result of numerical operations.</span></span> <span data-ttu-id="b9077-139">Dies bedeutet, dass strenge Vergleiche auf Gleichheit zweier <xref:System.Numerics.Complex> Werte möglicherweise nicht bestehen, auch wenn der Unterschied zwischen den beiden Werten aufgrund einer verringerten Genauigkeit ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-139">This means that strict comparisons for equality of two <xref:System.Numerics.Complex> values may fail, even if the difference between the two values is due to a loss of precision.</span></span> <span data-ttu-id="b9077-140">Weitere Informationen finden Sie unter <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="b9077-140">For more information, see <xref:System.Double>.</span></span>  
  
 <span data-ttu-id="b9077-141">Beispielsweise sollte die Potenzierung der Logarithmus einer Zahl die ursprüngliche Anzahl zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="b9077-141">For example, performing exponentiation on the logarithm of a number should return the original number.</span></span> <span data-ttu-id="b9077-142">In einigen Fällen kann zum Verlust der Genauigkeit von Gleitkommawerten jedoch geringfügige Unterschiede zwischen den beiden Werten, führen, wie im folgende Beispiel veranschaulicht.</span><span class="sxs-lookup"><span data-stu-id="b9077-142">However, in some cases, the loss of precision of floating-point values can cause slight differences between the two values, as the following example illustrates.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#5)]
 [!code-vb[System.Numerics.Complex.Class#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#5)]  
  
 <span data-ttu-id="b9077-143">Auf ähnliche Weise das folgende Beispiel, das berechnet die Quadratwurzel einer <xref:System.Numerics.Complex> Zahl ist, etwas andere Ergebnisse erzeugt, auf dem 32-Bit- und IA64-Versionen von .NET Framework.</span><span class="sxs-lookup"><span data-stu-id="b9077-143">Similarly, the following example, which calculates the square root of a <xref:System.Numerics.Complex> number, produces slightly different results on the 32-bit and IA64 versions of the .NET Framework.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/precision1.cs#6)]
 [!code-vb[System.Numerics.Complex.Class#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/precision1.vb#6)]  
  
## <a name="complex-numbers-infinity-and-nan"></a><span data-ttu-id="b9077-144">Komplexe Zahlen unendlich und NaN</span><span class="sxs-lookup"><span data-stu-id="b9077-144">Complex Numbers, Infinity, and NaN</span></span>  
 <span data-ttu-id="b9077-145">Durch die reellen und imaginären Teile einer komplexen Zahl dargestellt werden <xref:System.Double> Werte.</span><span class="sxs-lookup"><span data-stu-id="b9077-145">The real and imaginary parts of a complex number are represented by <xref:System.Double> values.</span></span> <span data-ttu-id="b9077-146">Neben den im Bereich von <xref:System.Double.MinValue?displayProperty=nameWithType> zu <xref:System.Double.MaxValue?displayProperty=nameWithType>, kann der realen oder imaginäre Teil einer komplexen Zahl den Wert der haben <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, oder <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-146">In addition to ranging from <xref:System.Double.MinValue?displayProperty=nameWithType> to <xref:System.Double.MaxValue?displayProperty=nameWithType>, the real or imaginary part of a complex number can have a value of <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, und <xref:System.Double.NaN?displayProperty=nameWithType> bei jedem Vorgang arithmetischen oder trigonometrische übertragen werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-147"><xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, and <xref:System.Double.NaN?displayProperty=nameWithType> all propagate in any arithmetic or trigonometric operation.</span></span>  
  
 <span data-ttu-id="b9077-148">Im folgenden Beispiel, Division durch <xref:System.Numerics.Complex.Zero> erzeugt eine komplexe Zahl, deren tatsächliche und imaginäre Teile beide sind <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-148">In the following example, division by <xref:System.Numerics.Complex.Zero> produces a complex number whose real and imaginary parts are both <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-149">Daher Multiplikation mit diesem Wert erzeugt außerdem eine komplexe Zahl, deren tatsächliche und imaginäre Teile sind <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-149">As a result, performing multiplication with this value also produces a complex number whose real and imaginary parts are <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-150">Auf ähnliche Weise Ausführen einer Multiplikation, die den Bereich der Ganzzahlarithmetik die <xref:System.Double> Typ erzeugt, eine komplexen Zahl, deren reeller Teil <xref:System.Double.NaN?displayProperty=nameWithType> und deren imaginärer Teil <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-150">Similarly, performing a multiplication that overflows the range of the <xref:System.Double> type produces a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-151">Ausführung einer Division mit diese komplexe Zahl eine komplexen Zahl, deren reeller Teil, gibt <xref:System.Double.NaN?displayProperty=nameWithType> und deren imaginärer Teil <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-151">Subsequently performing division with this complex number returns a complex number whose real part is <xref:System.Double.NaN?displayProperty=nameWithType> and whose imaginary part is <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/nan1.cs#3)]
 [!code-vb[System.Numerics.Complex.Class#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/nan1.vb#3)]  
  
 <span data-ttu-id="b9077-152">Mathematische Operationen mit komplexen Zahlen, die ungültig sind oder dieser Überlauf des Bereichs von, der <xref:System.Double> -Datentyp ist keine Ausnahme ausgelöst.</span><span class="sxs-lookup"><span data-stu-id="b9077-152">Mathematical operations with complex numbers that are invalid or that overflow the range of the <xref:System.Double> data type do not throw an exception.</span></span> <span data-ttu-id="b9077-153">Stattdessen, die sie zurückgeben einer <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, oder <xref:System.Double.NaN?displayProperty=nameWithType> unter den folgenden Bedingungen:</span><span class="sxs-lookup"><span data-stu-id="b9077-153">Instead, they return a <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> under the following conditions:</span></span>  
  
-   <span data-ttu-id="b9077-154">Der Division einer positiven Zahl durch 0 (null) gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-154">The division of a positive number by zero returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b9077-155">Jeder Vorgang, der die obere Grenze der Ganzzahlarithmetik die <xref:System.Double> Datentyp gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-155">Any operation that overflows the upper bound of the <xref:System.Double> data type returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b9077-156">Der Division einer negativen Zahl durch 0 (null) gibt <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-156">The division of a negative number by zero returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b9077-157">Jeder Vorgang, der die untere Grenze der Ganzzahlarithmetik die <xref:System.Double> Datentyp gibt <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-157">Any operation that overflows the lower bound of the <xref:System.Double> data type returns <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b9077-158">Gibt zurück, die Division von 0 (null) durch null <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-158">The division of a zero by zero returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
-   <span data-ttu-id="b9077-159">Jeder Vorgang, der für Operanden ausgeführt wird, dessen Werte <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, oder <xref:System.Double.NaN?displayProperty=nameWithType> gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, oder <xref:System.Double.NaN?displayProperty=nameWithType>, abhängig von den jeweiligen Vorgang.</span><span class="sxs-lookup"><span data-stu-id="b9077-159">Any operation that is performed on operands whose values are <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType> returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, or <xref:System.Double.NaN?displayProperty=nameWithType>, depending on the specific operation.</span></span>  
  
 <span data-ttu-id="b9077-160">Beachten Sie, dass dies für alle von einer Methode ausgeführten zwischenberechnungen gilt.</span><span class="sxs-lookup"><span data-stu-id="b9077-160">Note that this applies to any intermediate calculations performed by a method.</span></span> <span data-ttu-id="b9077-161">Z. B. die Multiplikation von `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` verwendet die Formel (Ac - bd) + (Ad + bc) ich.</span><span class="sxs-lookup"><span data-stu-id="b9077-161">For example, the multiplication of `new Complex(9e308, 9e308) and new Complex(2.5, 3.5)` uses the formula (ac - bd) + (ad + bc)i.</span></span> <span data-ttu-id="b9077-162">Die Berechnung der realen Komponente, die aus der Multiplikation ausgewertet wird, den Ausdruck 9e308 \* 2.5 – 9e308 \* 3.5.</span><span class="sxs-lookup"><span data-stu-id="b9077-162">The calculation of the real component that results from the multiplication evaluates the expression 9e308 \* 2.5 - 9e308 \* 3.5.</span></span> <span data-ttu-id="b9077-163">Jede Multiplikation in diesem Ausdruck gibt <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, und der Versuch, subtrahieren Sie <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> aus <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> gibt <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-163">Each intermediate multiplication in this expression returns <xref:System.Double.PositiveInfinity?displayProperty=nameWithType>, and the attempt to subtract <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> from <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
## <a name="formatting-a-complex-number"></a><span data-ttu-id="b9077-164">Formatieren einer komplexen Zahl</span><span class="sxs-lookup"><span data-stu-id="b9077-164">Formatting a Complex Number</span></span>  
 <span data-ttu-id="b9077-165">In der Standardeinstellung die angegebene Zeichenfolgendarstellung einer komplexen Zahl hat das Format `(` *echte* `,` *imaginären*`)`, wobei *echte* und *imaginären* sind die zeichenfolgendarstellungen der <xref:System.Double> Werten, die komplexe Zahl des reellen und imaginären Komponenten bilden.</span><span class="sxs-lookup"><span data-stu-id="b9077-165">By default, the string representation of a complex number takes the form `(`*real*`,` *imaginary*`)`, where *real* and *imaginary* are the string representations of the <xref:System.Double> values that form the complex number's real and imaginary components.</span></span> <span data-ttu-id="b9077-166">Einige Überladungen der <xref:System.Numerics.Complex.ToString%2A> Methode ermöglichen die Anpassung der die Zeichenfolgendarstellung dieser <xref:System.Double> Werte entsprechend die Formatierungskonventionen einer bestimmten Kultur oder in einem bestimmten Format, die durch eine standardmäßige oder benutzerdefinierte numerische definierten angezeigt werden Formatzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-166">Some overloads of the <xref:System.Numerics.Complex.ToString%2A> method allow customization of the string representations of these <xref:System.Double> values to reflect the formatting conventions of a particular culture or to appear in a particular format defined by a standard or custom numeric format string.</span></span> <span data-ttu-id="b9077-167">(Weitere Informationen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span><span class="sxs-lookup"><span data-stu-id="b9077-167">(For more information, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).)</span></span>  
  
 <span data-ttu-id="b9077-168">Einer der gängigeren Methoden auszudrücken, die angegebene Zeichenfolgendarstellung einer komplexen Zahl hat das Format a + Bi, wobei einer der komplexen Zahl, reelle Komponente, und b ist die komplexe Zahl die imaginäre Komponente.</span><span class="sxs-lookup"><span data-stu-id="b9077-168">One of the more common ways of expressing the string representation of a complex number takes the form a + bi, where a is the complex number's real component, and b is the complex number's imaginary component.</span></span> <span data-ttu-id="b9077-169">In der Elektrotechnik, eine komplexe Zahl ausgedrückt wird, am häufigsten als eine + Bj.</span><span class="sxs-lookup"><span data-stu-id="b9077-169">In electrical engineering, a complex number is most commonly expressed as a + bj.</span></span> <span data-ttu-id="b9077-170">Sie können die angegebene Zeichenfolgendarstellung einer komplexen Zahl in einem der folgenden zwei Arten zurückgeben.</span><span class="sxs-lookup"><span data-stu-id="b9077-170">You can return the string representation of a complex number in either of these two forms.</span></span> <span data-ttu-id="b9077-171">Zu diesem Zweck definieren Sie einen benutzerdefinierten Formatanbieters durch das Implementieren der <xref:System.ICustomFormatter> und <xref:System.IFormatProvider> Schnittstellen, und rufen Sie dann die <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-171">To do this, define a custom format provider by implementing the <xref:System.ICustomFormatter> and <xref:System.IFormatProvider> interfaces, and then call the <xref:System.String.Format%28System.IFormatProvider%2CSystem.String%2CSystem.Object%5B%5D%29?displayProperty=nameWithType> method.</span></span>  
  
 <span data-ttu-id="b9077-172">Das folgende Beispiel definiert eine `ComplexFormatter` -Klasse, die eine komplexe Zahl, als Zeichenfolge in Form von entweder darstellt a + Bi oder ein + Bj.</span><span class="sxs-lookup"><span data-stu-id="b9077-172">The following example defines a `ComplexFormatter` class that represents a complex number as a string in the form of either a + bi or a + bj.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#1)]
 [!code-vb[System.Numerics.Complex.Class#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#1)]  
  
 <span data-ttu-id="b9077-173">Im folgende Beispiel verwendet dann diese benutzerdefinierten Formatierer, um die angegebene Zeichenfolgendarstellung einer komplexen Zahl anzuzeigen.</span><span class="sxs-lookup"><span data-stu-id="b9077-173">The following example then uses this custom formatter to display the string representation of a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Class#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.class/cs/customfmt1.cs#4)]
 [!code-vb[System.Numerics.Complex.Class#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.class/vb/customfmt1.vb#4)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Complex (double real, double imaginary);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(float64 real, float64 imaginary) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.#ctor(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (real As Double, imaginary As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Complex(double real, double imaginary);" />
      <MemberSignature Language="F#" Value="new System.Numerics.Complex : double * double -&gt; System.Numerics.Complex" Usage="new System.Numerics.Complex (real, imaginary)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="real" Type="System.Double" />
        <Parameter Name="imaginary" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="real"><span data-ttu-id="b9077-174">Der reelle Teil der komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-174">The real part of the complex number.</span></span></param>
        <param name="imaginary"><span data-ttu-id="b9077-175">Der imaginäre Teil der komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-175">The imaginary part of the complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-176">Initialisiert eine neue Instanz der <see cref="T:System.Numerics.Complex" />-Struktur mit den angegebenen reellen und imaginären Werten.</span><span class="sxs-lookup"><span data-stu-id="b9077-176">Initializes a new instance of the <see cref="T:System.Numerics.Complex" /> structure using the specified real and imaginary values.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-177">Die `real` oder `imaginary` Argumente mit einfacher Genauigkeit verlieren möglicherweise, wenn sie Datentypen sind, die eine explizite Umwandlung in erfordern <xref:System.Double>.</span><span class="sxs-lookup"><span data-stu-id="b9077-177">The `real` or `imaginary` arguments may lose precision if they are data types that require an explicit cast to <xref:System.Double>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-178">Im folgenden Beispiel zwei komplexe Zahlen instanziiert und verwendet sie dann in die Vorgänge für Addition, Subtraktion, Multiplikation und Division.</span><span class="sxs-lookup"><span data-stu-id="b9077-178">The following example instantiates two complex numbers, and then uses them in addition, subtraction, multiplication, and division operations.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ctor#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.ctor/cs/ctor1.cs#1)]
 [!code-vb[System.Numerics.Complex.ctor#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.ctor/vb/ctor1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Abs">
      <MemberSignature Language="C#" Value="public static double Abs (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig float64 Abs(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Abs (value As Complex) As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static double Abs(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Abs : System.Numerics.Complex -&gt; double" Usage="System.Numerics.Complex.Abs value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-179">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-179">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-180">Ruft den absoluten Wert (oder die Größenordnung) einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-180">Gets the absolute value (or magnitude) of a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-181">Der Absolutbetrag von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-181">The absolute value of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-182">Der Absolute Wert einer komplexen Zahl entspricht der <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-182">The absolute value of a complex number is equivalent to its <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span> <span data-ttu-id="b9077-183">Der Absolute Wert einer reellen Zahl eine + Bi ist wie folgt berechnet:</span><span class="sxs-lookup"><span data-stu-id="b9077-183">The absolute value of a real number a + bi is calculated as follows:</span></span>  
  
-   <span data-ttu-id="b9077-184">Wenn b = 0, das Ergebnis ist 0.</span><span class="sxs-lookup"><span data-stu-id="b9077-184">If b = 0, the result is 0.</span></span>  
  
-   <span data-ttu-id="b9077-185">Wenn eine > b, um das Ergebnis ist eine \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b9077-185">If a > b, the result is a \*<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + b<sup>2</sup>/a<sup>2</sup>).</span></span>  
  
-   <span data-ttu-id="b9077-186">Wenn b > ein, das Ergebnis ist "b" \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b9077-186">If b > a, the result is b \* <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(1 + a<sup>2</sup>/b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="b9077-187">Wenn die Berechnung des absoluten Werts zu einem Überlauf führt, gibt die Methode <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-187">If the calculation of the absolute value results in an overflow, the method returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-188">Wenn entweder die <xref:System.Numerics.Complex.Real%2A> oder <xref:System.Numerics.Complex.Imaginary%2A> Eigenschaft <xref:System.Double.NaN?displayProperty=nameWithType> und die andere Eigenschaft ist weder <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> noch <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Double.NaN?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-188">If either the <xref:System.Numerics.Complex.Real%2A> or <xref:System.Numerics.Complex.Imaginary%2A> property is <xref:System.Double.NaN?displayProperty=nameWithType> and the other property is neither <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> nor <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>, the method returns <xref:System.Double.NaN?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-189">Das folgende Beispiel berechnet den absoluten Wert einer komplexen Zahl und zeigt, dass sie den Wert der entspricht der <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-189">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <Member MemberName="Acos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Acos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Acos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Acos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Acos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Acos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Acos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-190">Eine komplexe Zahl, die einen Kosinus darstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-190">A complex number that represents a cosine.</span></span></param>
        <summary><span data-ttu-id="b9077-191">Gibt den Winkel zurück, der der Arkuskosinus der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-191">Returns the angle that is the arc cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-192">Der Winkel im Bogenmaß, der der Arkuskosinus von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-192">The angle, measured in radians, which is the arc cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-193">Die <xref:System.Numerics.Complex.Acos%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Acos%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-193">The <xref:System.Numerics.Complex.Acos%2A> method for complex numbers corresponds to the <xref:System.Math.Acos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-194">Die <xref:System.Numerics.Complex.Acos%2A> Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="b9077-194">The <xref:System.Numerics.Complex.Acos%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b9077-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span><span class="sxs-lookup"><span data-stu-id="b9077-195">(-<xref:System.Numerics.Complex.ImaginaryOne>) \* <xref:System.Numerics.Complex.Log%2A>(`value` + <xref:System.Numerics.Complex.ImaginaryOne>\*<xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - `value` \* `value`)))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="b9077-196">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Acos%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-196">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="b9077-197">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Acos%2A> Methode, um die <xref:System.Numerics.Complex.Cos%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-197">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Acos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Add (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Add(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Add (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Add(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Add : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Add (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-198">Die erste zu addierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-198">The first complex number to add.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-199">Die zweite zu addierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-199">The second complex number to add.</span></span></param>
        <summary><span data-ttu-id="b9077-200">Addiert zwei komplexe Zahlen und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-200">Adds two complex numbers and returns the result.</span></span></summary>
        <returns><span data-ttu-id="b9077-201">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-201">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-202">Das Hinzufügen einer komplexen Zahl ist, a + Bi, und eine zweite komplexe Zahl, die c + di, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-202">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-203">(a + C) + (b + d) ich.</span><span class="sxs-lookup"><span data-stu-id="b9077-203">(a + c) + (b + d)i.</span></span>  
  
 <span data-ttu-id="b9077-204">Wenn die Methode Ergebnisse zu einem Überlauf entweder in der realen oder imaginären Komponente aufrufen, ist der Wert der Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-204">If the method call results in an overflow in either the real or imaginary component, the value of the component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-205">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können die <xref:System.Numerics.Complex.Add%2A> Methode, um Addition mit komplexen Zahlen durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="b9077-205">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Add%2A> method to perform addition with complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-206">Das folgende Beispiel veranschaulicht die Addition mit komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-206">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add1.cs#1)]
 [!code-vb[System.Numerics.Complex.Add#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Asin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Asin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Asin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Asin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Asin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Asin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Asin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Asin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-207">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-207">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-208">Gibt den Winkel zurück, der der Arkussinus der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-208">Returns the angle that is the arc sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-209">Der Winkel, der der Arkussinus von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-209">The angle which is the arc sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-210">Die <xref:System.Numerics.Complex.Asin%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Asin%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-210">The <xref:System.Numerics.Complex.Asin%2A> method for complex numbers corresponds to the <xref:System.Math.Asin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-211">Die <xref:System.Numerics.Complex.Asin%2A> Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="b9077-211">The <xref:System.Numerics.Complex.Asin%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b9077-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* Wert + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> -Wert \* Wert))</span><span class="sxs-lookup"><span data-stu-id="b9077-212">-<xref:System.Numerics.Complex.ImaginaryOne> \* <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.ImaginaryOne> \* value + <xref:System.Numerics.Complex.Sqrt%2A>(<xref:System.Numerics.Complex.One> - value \* value))</span></span>    
  
   
  
## Examples  
 <span data-ttu-id="b9077-213">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Asin%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-213">The following example illustrates the <xref:System.Numerics.Complex.Asin%2A> method.</span></span> <span data-ttu-id="b9077-214">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Asin%2A> Methode, um die <xref:System.Numerics.Complex.Sin%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-214">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Asin(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Atan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Atan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Atan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Atan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Atan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Atan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Atan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-215">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-215">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-216">Gibt den Winkel zurück, der der Arkustangens der angegebenen komplexen Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-216">Returns the angle that is the arc tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-217">Der Winkel, der der Arkustangens von <paramref name="value" /> ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-217">The angle that is the arc tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-218">Die <xref:System.Numerics.Complex.Atan%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Atan%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-218">The <xref:System.Numerics.Complex.Atan%2A> method for complex numbers corresponds to the <xref:System.Math.Atan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-219">Die <xref:System.Numerics.Complex.Atan%2A> Methode verwendet die folgende Formel:</span><span class="sxs-lookup"><span data-stu-id="b9077-219">The <xref:System.Numerics.Complex.Atan%2A> method uses the following formula:</span></span>  
  
 <span data-ttu-id="b9077-220"><xref:System.Numerics.Complex.ImaginaryOne> / Neue komplexe (2.0, 0,0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One>  -  <xref:System.Numerics.Complex.ImaginaryOne> \* Wert)- <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* Wert)</span><span class="sxs-lookup"><span data-stu-id="b9077-220"><xref:System.Numerics.Complex.ImaginaryOne> / new Complex(2.0, 0.0)) \* (<xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> - <xref:System.Numerics.Complex.ImaginaryOne> \* value) - <xref:System.Numerics.Complex.Log%2A>(<xref:System.Numerics.Complex.One> + ImaginaryOne \* value)</span></span>   
  
   
  
## Examples  
 <span data-ttu-id="b9077-221">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Atan%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-221">The following example illustrates the <xref:System.Numerics.Complex.Atan%2A> method.</span></span> <span data-ttu-id="b9077-222">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Atan%2A> Methode, um die <xref:System.Numerics.Complex.Tan%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-222">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Atan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Conjugate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Conjugate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Conjugate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Conjugate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Conjugate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Conjugate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Conjugate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Conjugate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-223">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-223">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-224">Berechnet die konjugierte Zahl einer komplexen Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-224">Computes the conjugate of a complex number and returns the result.</span></span></summary>
        <returns><span data-ttu-id="b9077-225">Die konjugierte Zahl von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-225">The conjugate of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-226">Die konjugierte Zahl einer komplexen Zahl kehrt das Zeichen die imaginäre Komponente; unäre Negation werden, also auf die imaginäre Komponente angewendet.</span><span class="sxs-lookup"><span data-stu-id="b9077-226">The conjugate of a complex number inverts the sign of the imaginary component; that is, it applies unary negation to the imaginary component.</span></span> <span data-ttu-id="b9077-227">Wenn eine + Bi ist eine komplexe Zahl, deren konjugierte Zahl einer: Bi.</span><span class="sxs-lookup"><span data-stu-id="b9077-227">If a + bi is a complex number, its conjugate is a - bi.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-228">Das folgende Beispiel zeigt die konjugierte Zahl von zwei komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-228">The following example displays the conjugate of two complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Conjugate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.conjugate/cs/conjugate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Conjugate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.conjugate/vb/conjugate1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Cos">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cos (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cos(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cos(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cos (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cos(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cos : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cos value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-229">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-229">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-230">Gibt den Kosinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-230">Returns the cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-231">Der Kosinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-231">The cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-232">Die <xref:System.Numerics.Complex.Cos%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Cos%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-232">The <xref:System.Numerics.Complex.Cos%2A> method for complex numbers corresponds to the <xref:System.Math.Cos%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-233">Die <xref:System.Numerics.Complex.Cos%2A> Methode anhand der folgende Formel berechnet den Kosinus der komplexen Zahl a + Bi:</span><span class="sxs-lookup"><span data-stu-id="b9077-233">The <xref:System.Numerics.Complex.Cos%2A> method uses the following formula to calculate the cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b9077-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b),-(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span><span class="sxs-lookup"><span data-stu-id="b9077-234">(<xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Cosh%2A>(b), -(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Sinh%2A>(b)))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-235">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Acos%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-235">The following example illustrates the <xref:System.Numerics.Complex.Acos%2A> method.</span></span> <span data-ttu-id="b9077-236">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Acos%2A> Methode, um die <xref:System.Numerics.Complex.Cos%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-236">It shows that passing the value returned by the <xref:System.Numerics.Complex.Acos%2A> method to the <xref:System.Numerics.Complex.Cos%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Acos#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.acos/cs/acos1.cs#1)]
 [!code-vb[System.Numerics.Complex.Acos#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.acos/vb/acos1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Acos(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Cos(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Cosh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Cosh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Cosh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Cosh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Cosh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Cosh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Cosh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Cosh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-237">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-237">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-238">Gibt den Hyperbelkosinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-238">Returns the hyperbolic cosine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-239">Der Hyperbelkosinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-239">The hyperbolic cosine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-240">Die <xref:System.Numerics.Complex.Cosh%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Cosh%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-240">The <xref:System.Numerics.Complex.Cosh%2A> method for complex numbers corresponds to the <xref:System.Math.Cosh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-241">Die <xref:System.Numerics.Complex.Cosh%2A> Methode anhand der folgende Formel berechnet den hyperbolischen Kosinus der komplexen Zahl a + Bi:</span><span class="sxs-lookup"><span data-stu-id="b9077-241">The <xref:System.Numerics.Complex.Cosh%2A> method uses the following formula to calculate the hyperbolic cosine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b9077-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b9077-242">(<xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Cosh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Divide">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Divide (System.Numerics.Complex dividend, System.Numerics.Complex divisor);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Divide(valuetype System.Numerics.Complex dividend, valuetype System.Numerics.Complex divisor) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Divide (dividend As Complex, divisor As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Divide(System::Numerics::Complex dividend, System::Numerics::Complex divisor);" />
      <MemberSignature Language="F#" Value="static member Divide : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Divide (dividend, divisor)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dividend" Type="System.Numerics.Complex" />
        <Parameter Name="divisor" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="dividend"><span data-ttu-id="b9077-243">Die zu dividierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-243">The complex number to be divided.</span></span></param>
        <param name="divisor"><span data-ttu-id="b9077-244">Die komplexe Zahl, durch die dividiert wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-244">The complex number to divide by.</span></span></param>
        <summary><span data-ttu-id="b9077-245">Dividiert eine komplexe Zahl durch eine andere komplexe Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-245">Divides one complex number by another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="b9077-246">Der Quotient der Division.</span><span class="sxs-lookup"><span data-stu-id="b9077-246">The quotient of the division.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-247">Der Division einer komplexen Zahl, eine + Bi, indem eine zweite komplexe Zahl, die Anzahl, die c und das Dependency Injection, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-247">The division of a complex number, a + bi, by a second complex number, number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-248">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-248">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="b9077-249">Wenn ein Überlauf in der realen oder imaginären Komponente die Berechnung des Quotienten ergibt, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-249">If the calculation of the quotient results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-250">Die <xref:System.Numerics.Complex.Divide%2A> Methode kann verwendet werden, von Sprachen, die benutzerdefinierte Operatoren nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b9077-250">The <xref:System.Numerics.Complex.Divide%2A> method can be used by languages that do not support custom operators.</span></span> <span data-ttu-id="b9077-251">Das Verhalten ist identisch mit der Division mit der Divisionsoperator.</span><span class="sxs-lookup"><span data-stu-id="b9077-251">Its behavior is identical to division using the division operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-252">Im folgende Beispiel dividiert eine komplexe Zahl durch jedes Element in ein Array der komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-252">The following example divides a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide1.cs#1)]
 [!code-vb[System.Numerics.Complex.Divide#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Equals">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-253">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-253">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public bool Equals (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Equals(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Function Equals (value As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Equals(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="override this.Equals : System.Numerics.Complex -&gt; bool" Usage="complex.Equals value" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IEquatable`1.Equals(`0)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-254">Die zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-254">The complex number to compare.</span></span></param>
        <summary><span data-ttu-id="b9077-255">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und eine angegebene komplexe Zahl den gleichen Wert haben.</span><span class="sxs-lookup"><span data-stu-id="b9077-255">Returns a value that indicates whether the current instance and a specified complex number have the same value.</span></span></summary>
        <returns><span data-ttu-id="b9077-256"><see langword="true" />, wenn die komplexe Zahl und <paramref name="value" /> den gleichen Wert haben, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-256"><see langword="true" /> if this complex number and <paramref name="value" /> have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-257">Die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Methode bietet die <xref:System.IEquatable%601> Implementierung für die <xref:System.Numerics.Complex> Struktur.</span><span class="sxs-lookup"><span data-stu-id="b9077-257">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method provides the <xref:System.IEquatable%601> implementation for the <xref:System.Numerics.Complex> structure.</span></span> <span data-ttu-id="b9077-258">Eine etwas bessere Leistung als <xref:System.Numerics.Complex.Equals%28System.Object%29> Methode, da er nicht verfügt, als Parameter in einer komplexen Zahl zu konvertieren.</span><span class="sxs-lookup"><span data-stu-id="b9077-258">It performs slightly better than <xref:System.Numerics.Complex.Equals%28System.Object%29> method because it does not have to convert its parameter to a complex number.</span></span>  
  
 <span data-ttu-id="b9077-259">Wenn ihre reellen Teile gleich sind, und ihre imaginären Teile gleich sind, werden die zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-259">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b9077-260">Die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="b9077-260">The <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#1)]
 [!code-vb[System.Numerics.Complex.Equals#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#1)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="b9077-261">Verwenden der <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Methode mit Vorsicht, da zwei Werte, die scheinbar entsprechen können werden als ungleich betrachtet aufgrund der unterschiedlichen Genauigkeit ihre reellen und imaginären Komponenten.</span><span class="sxs-lookup"><span data-stu-id="b9077-261">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="b9077-262">Im folgenden Beispiel gemeldet, die <c>(3.33333, 0.142857)</c> und <c>(10/3, 1/7)</c> ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-262">The following example reports that <c>(3.33333, 0.142857)</c> and <c>(10/3, 1/7)</c> are not equal.</span></span>  
  
<span data-ttu-id="b9077-263">[! Code-Csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [! Code – Vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span><span class="sxs-lookup"><span data-stu-id="b9077-263">[!code-csharp[System.Numerics.Complex.Equals#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#4)] [!code-vb[System.Numerics.Complex.Equals#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#4)]</span></span> 
<span data-ttu-id="b9077-264">Eine empfohlene Verfahren besteht darin, eine akzeptable Rand Unterschied zwischen den beiden Werten definieren (z. B. 01 % einer der Werte reellen und imaginären Komponenten) statt Vergleichen der Werte hinsichtlich ihrer Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="b9077-264">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="b9077-265">Ist der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich der jeweilige Rand, der Unterschied ist wahrscheinlich auf einen Unterschied bei der Genauigkeit zurückzuführen sein, und daher die Werte gleich wahrscheinlich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-265">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision, and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="b9077-266">Im folgenden Beispiel wird dieses Verfahren, um zwei komplexe Werte zu vergleichen, die im vorherigen Codebeispiel gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-266">The following example uses this technique to compare the two complex values that the previous code example found to be unequal.</span></span> <span data-ttu-id="b9077-267">Er findet den zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-267">It finds the two complex numbers to be equal.</span></span>  
  
<span data-ttu-id="b9077-268">[! Code-Csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [! Code – Vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span><span class="sxs-lookup"><span data-stu-id="b9077-268">[!code-csharp[System.Numerics.Complex.Equals#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision1.cs#5)] [!code-vb[System.Numerics.Complex.Equals#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision1.vb#5)]</span></span></para></block>
        <altmember cref="T:System.Double" />
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object obj);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object obj) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (obj As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ obj);" />
      <MemberSignature Language="F#" Value="override this.Equals : obj -&gt; bool" Usage="complex.Equals obj" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="obj" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="obj"><span data-ttu-id="b9077-269">Das zu vergleichende Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-269">The object to compare.</span></span></param>
        <summary><span data-ttu-id="b9077-270">Gibt einen Wert zurück, der angibt, ob die aktuelle Instanz und ein angegebenes Objekt über den gleichen Wert verfügen.</span><span class="sxs-lookup"><span data-stu-id="b9077-270">Returns a value that indicates whether the current instance and a specified object have the same value.</span></span></summary>
        <returns><span data-ttu-id="b9077-271"><see langword="true" />, wenn der <paramref name="obj" />-Parameter ein <see cref="T:System.Numerics.Complex" />-Objekt oder ein Typ ist, der die implizite Konvertierung in ein <see cref="T:System.Numerics.Complex" />-Objekt unterstützt, und der Wert gleich dem aktuellen <see cref="T:System.Numerics.Complex" />-Objekt ist, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-271"><see langword="true" /> if the <paramref name="obj" /> parameter is a <see cref="T:System.Numerics.Complex" /> object or a type capable of implicit conversion to a <see cref="T:System.Numerics.Complex" /> object, and its value is equal to the current <see cref="T:System.Numerics.Complex" /> object; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-272">Wenn ihre reellen Teile gleich sind, und ihre imaginären Teile gleich sind, werden die zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-272">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b9077-273">Die <xref:System.Numerics.Complex.Equals%28System.Object%29> Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="b9077-273">The <xref:System.Numerics.Complex.Equals%28System.Object%29> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#2)]
 [!code-vb[System.Numerics.Complex.Equals#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#2)]  
  
 <span data-ttu-id="b9077-274">Wenn die `obj` Parameter ist keiner <xref:System.Numerics.Complex> -Objekt, aber es ist ein Datentyp, die für die eine implizite Konvertierung definiert ist, die <xref:System.Numerics.Complex.Equals%28System.Object%29> Methode konvertiert `obj` auf eine <xref:System.Numerics.Complex> -Objekt, deren reeller Teil gleich dem Wert des ist`obj`und deren imaginärer Teil ist gleich 0 (null), bevor der Vergleich durchgeführt.</span><span class="sxs-lookup"><span data-stu-id="b9077-274">If the `obj` parameter is not a <xref:System.Numerics.Complex> object, but it is a data type for which an implicit conversion is defined, the <xref:System.Numerics.Complex.Equals%28System.Object%29> method converts `obj` to a <xref:System.Numerics.Complex> object whose real part is equal to the value of `obj` and whose imaginary part is equal to zero before it performs the comparison.</span></span> <span data-ttu-id="b9077-275">Das folgende Beispiel veranschaulicht dies durch suchen, dass es sich bei einer komplexen Zahl und einen Gleitkommawert mit doppelter Genauigkeit gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-275">The following example illustrates this by finding that a complex number and a double-precision floating-point value are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals3.cs#6)]
 [!code-vb[System.Numerics.Complex.Equals#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals3.vb#6)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="usage"><para><span data-ttu-id="b9077-276">Verwenden der <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> Methode mit Vorsicht, da zwei Werte, die scheinbar entsprechen können werden als ungleich betrachtet aufgrund der unterschiedlichen Genauigkeit ihre reellen und imaginären Komponenten.</span><span class="sxs-lookup"><span data-stu-id="b9077-276">Use the <see cref="M:System.Numerics.Complex.Equals(System.Numerics.Complex)" /> method with caution, because two values that are apparently equivalent can be considered unequal due to the differing precision of their real and imaginary components.</span></span> <span data-ttu-id="b9077-277">Das Problem verstärkt werden kann, wenn <paramref name="obj" /> konvertiert werden muss, um eine <see cref="T:System.Double" /> vor dem Vergleich.</span><span class="sxs-lookup"><span data-stu-id="b9077-277">The problem can be accentuated if <paramref name="obj" /> must be converted to a <see cref="T:System.Double" /> before performing the comparison.</span></span> <span data-ttu-id="b9077-278">Im folgenden Beispiel wird eine komplexe Zahl, deren reelle Komponente gleich zu sein scheint, eine <see cref="T:System.Single" /> Wert mit dem <see cref="T:System.Single" /> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-278">The following example compares a complex number whose real component appears to be equal to a <see cref="T:System.Single" /> value with that <see cref="T:System.Single" /> value.</span></span> <span data-ttu-id="b9077-279">Die Ausgabe zeigt, gibt der Vergleich für Gleichheit <see langword="False" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-279">As the output shows, the comparison for equality returns <see langword="False" />.</span></span>  
  
<span data-ttu-id="b9077-280">[! Code-Csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [! Code – Vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span><span class="sxs-lookup"><span data-stu-id="b9077-280">[!code-csharp[System.Numerics.Complex.Equals#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals4.cs#8)] [!code-vb[System.Numerics.Complex.Equals#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals4.vb#8)]</span></span> 
<span data-ttu-id="b9077-281">Eine empfohlene Verfahren besteht darin, eine akzeptable Rand Unterschied zwischen den beiden Werten definieren (z. B. 01 % einer der Werte reellen und imaginären Komponenten) statt Vergleichen der Werte hinsichtlich ihrer Gleichheit.</span><span class="sxs-lookup"><span data-stu-id="b9077-281">One recommended technique is to define an acceptable margin of difference between the two values (such as .01% of one of the values' real and imaginary components) instead of comparing the values for equality.</span></span> <span data-ttu-id="b9077-282">Ist der Absolute Wert des Unterschieds zwischen den beiden Werten kleiner als oder gleich der jeweilige Rand, der Unterschied ist wahrscheinlich auf einen Unterschied bei der Genauigkeit zurückzuführen sein, und daher die Werte gleich wahrscheinlich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-282">If the absolute value of the difference between the two values is less than or equal to that margin, the difference is likely to be due to a difference in precision and, therefore, the values are likely to be equal.</span></span> <span data-ttu-id="b9077-283">Im folgenden Beispiel wird dieses Verfahren, um die zwei Werte vergleichen, die im vorherigen Codebeispiel gefunden werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-283">The following example uses this technique to compare the two values that the previous code example found to be unequal.</span></span> <span data-ttu-id="b9077-284">Es findet jetzt sie gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-284">It now finds them to be equal.</span></span>  
  
<span data-ttu-id="b9077-285">[! Code-Csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [! Code – Vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span><span class="sxs-lookup"><span data-stu-id="b9077-285">[!code-csharp[System.Numerics.Complex.Equals#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/precision2.cs#7)] [!code-vb[System.Numerics.Complex.Equals#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/precision2.vb#7)]</span></span></para></block>
      </Docs>
    </Member>
    <Member MemberName="Exp">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Exp (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Exp(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Exp (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Exp(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Exp : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Exp value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-286">Eine komplexe Zahl, die einen Exponenten angibt.</span><span class="sxs-lookup"><span data-stu-id="b9077-286">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="b9077-287">Gibt <see langword="e" /> potenziert mit einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-287">Returns <see langword="e" /> raised to the power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-288">Die Zahl <see langword="e" /> hoch <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-288">The number <see langword="e" /> raised to the power <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-289">Verwenden der <xref:System.Numerics.Complex.Pow%2A> Methode, um die Potenzen einer anderen Basis berechnet.</span><span class="sxs-lookup"><span data-stu-id="b9077-289">Use the <xref:System.Numerics.Complex.Pow%2A> method to calculate the powers of other bases.</span></span>  
  
 <span data-ttu-id="b9077-290">Die <xref:System.Numerics.Complex.Exp%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Exp%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-290">The <xref:System.Numerics.Complex.Exp%2A> method for complex numbers corresponds to the <xref:System.Math.Exp%2A?displayProperty=nameWithType> method for real numbers.</span></span> <span data-ttu-id="b9077-291"><xref:System.Numerics.Complex.Exp%2A> ist die Umkehrung der <xref:System.Numerics.Complex.Log%2A>.</span><span class="sxs-lookup"><span data-stu-id="b9077-291"><xref:System.Numerics.Complex.Exp%2A> is the inverse of <xref:System.Numerics.Complex.Log%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-292">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Exp%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-292">The following example illustrates the <xref:System.Numerics.Complex.Exp%2A> method.</span></span> <span data-ttu-id="b9077-293">Es veranschaulicht, wie Kompensation für das Fehlen der Genauigkeit von der <xref:System.Double> Datentyp aufweisen, übergeben den Rückgabewert von der <xref:System.Numerics.Complex.Log%2A> Methode, um die <xref:System.Numerics.Complex.Exp%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-293">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Exp(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="FromPolarCoordinates">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex FromPolarCoordinates (double magnitude, double phase);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex FromPolarCoordinates(float64 magnitude, float64 phase) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.FromPolarCoordinates(System.Double,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function FromPolarCoordinates (magnitude As Double, phase As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex FromPolarCoordinates(double magnitude, double phase);" />
      <MemberSignature Language="F#" Value="static member FromPolarCoordinates : double * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.FromPolarCoordinates (magnitude, phase)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="magnitude" Type="System.Double" />
        <Parameter Name="phase" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="magnitude"><span data-ttu-id="b9077-294">Die Größe, die die Entfernung vom Ursprung (dem Schnittpunkt der x-Achse mit der y-Achse) zur Zahl ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-294">The magnitude, which is the distance from the origin (the intersection of the x-axis and the y-axis) to the number.</span></span></param>
        <param name="phase"><span data-ttu-id="b9077-295">Die Phase, d. h. der Winkel von der Linie zur horizontalen Achse, gemessen im Bogenmaß.</span><span class="sxs-lookup"><span data-stu-id="b9077-295">The phase, which is the angle from the line to the horizontal axis, measured in radians.</span></span></param>
        <summary><span data-ttu-id="b9077-296">Erstellt eine komplexe Zahl aus den Polarkoordinaten eines Punkts.</span><span class="sxs-lookup"><span data-stu-id="b9077-296">Creates a complex number from a point's polar coordinates.</span></span></summary>
        <returns><span data-ttu-id="b9077-297">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-297">A complex number.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-298">Die <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Methode wird eine komplexe Zahl, die basierend auf ihrer Polarkoordinaten instanziiert.</span><span class="sxs-lookup"><span data-stu-id="b9077-298">The <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method instantiates a complex number based on its polar coordinates.</span></span>  
  
 <span data-ttu-id="b9077-299">Da es mehrere Darstellungen eines Punkts auf einer komplexen Ebene, der Rückgabewert von sind der <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Methode normalisiert wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-299">Because there are multiple representations of a point on a complex plane, the return value of the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method is normalized.</span></span> <span data-ttu-id="b9077-300">Die Größe wird normalisiert, um eine positive Zahl ist, und die Phase wird auf einen Wert im Bereich von - normalisiert<xref:System.Math.PI> zu <xref:System.Math.PI>.</span><span class="sxs-lookup"><span data-stu-id="b9077-300">The magnitude is normalized to a positive number, and the phase is normalized to a value in the range of -<xref:System.Math.PI> to <xref:System.Math.PI>.</span></span> <span data-ttu-id="b9077-301">Als Ergebnis die Werte der <xref:System.Numerics.Complex.Phase%2A> und <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaften des resultierenden komplexen Zahl unter Umständen die ursprünglichen Werte nicht gleich der `magnitude` und `phase` Parameter.</span><span class="sxs-lookup"><span data-stu-id="b9077-301">As a result, the values of the <xref:System.Numerics.Complex.Phase%2A> and <xref:System.Numerics.Complex.Magnitude%2A> properties of the resulting complex number may not equal the original values of the `magnitude` and `phase` parameters.</span></span>  
  
 <span data-ttu-id="b9077-302">Zum Konvertieren eines Werts von Grad in Bogenmaß für die `phase` multiplizieren, indem Parameter  <xref:System.Math.PI?displayProperty=nameWithType> /180.</span><span class="sxs-lookup"><span data-stu-id="b9077-302">To convert a value from degrees to radians for the `phase` parameter, multiply it by <xref:System.Math.PI?displayProperty=nameWithType>/180.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-303">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.FromPolarCoordinates%2A> -Methode zum Instanziieren einer komplexen Zahl basierend auf ihrer Polarkoordinaten und zeigt dann den Wert, der die <xref:System.Numerics.Complex.Magnitude%2A> und <xref:System.Numerics.Complex.Phase%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="b9077-303">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberSignature Language="F#" Value="override this.GetHashCode : unit -&gt; int" Usage="complex.GetHashCode " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9077-304">Gibt den Hashcode für das aktuelle <see cref="T:System.Numerics.Complex" />-Objekt zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-304">Returns the hash code for the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <returns><span data-ttu-id="b9077-305">Ein 32-Bit-Hashcode als ganze Zahl mit Vorzeichen.</span><span class="sxs-lookup"><span data-stu-id="b9077-305">A 32-bit signed integer hash code.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Imaginary">
      <MemberSignature Language="C#" Value="public double Imaginary { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Imaginary" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Imaginary" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Imaginary As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Imaginary { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Imaginary : double" Usage="System.Numerics.Complex.Imaginary" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-306">Ruft die imaginäre Komponente des aktuellen <see cref="T:System.Numerics.Complex" />-Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-306">Gets the imaginary component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="b9077-307">Die imaginäre Komponente einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-307">The imaginary component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-308">Erhalten eine komplexen Zahl a + Bi, die <xref:System.Numerics.Complex.Imaginary%2A> Eigenschaft gibt den Wert von b zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-308">Given a complex number a + bi, the <xref:System.Numerics.Complex.Imaginary%2A> property returns the value of b.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-309">Das folgende Beispiel instanziiert ein Array von <xref:System.Numerics.Complex> -Objekte und zeigt die reellen und imaginären Komponenten jedes in der Form a + Bi.</span><span class="sxs-lookup"><span data-stu-id="b9077-309">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Real" />
      </Docs>
    </Member>
    <Member MemberName="ImaginaryOne">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex ImaginaryOne;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex ImaginaryOne" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.ImaginaryOne" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly ImaginaryOne As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex ImaginaryOne;" />
      <MemberSignature Language="F#" Value=" staticval mutable ImaginaryOne : System.Numerics.Complex" Usage="System.Numerics.Complex.ImaginaryOne" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-310">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 0 und einer imaginären Zahl gleich 1 zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-310">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to one.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b9077-311">Das folgende Beispiel instanziiert ein <xref:System.Numerics.Complex> Wert mithilfe der <xref:System.Numerics.Complex.ImaginaryOne> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-311">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.ImaginaryOne> property.</span></span> <span data-ttu-id="b9077-312">Es vergleicht dann diesen Wert auf einen anderen Wert, der durch den Aufruf instanziiert wird die <xref:System.Numerics.Complex> Konstruktor mit einem echten gleich 0 (null) und einem imaginären Teil gleich 1.</span><span class="sxs-lookup"><span data-stu-id="b9077-312">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to one.</span></span> <span data-ttu-id="b9077-313">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="b9077-313">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/cs/imaginaryone1.cs#1)]
 [!code-vb[System.Numerics.Complex.ImaginaryOne#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.imaginaryone/vb/imaginaryone1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.One" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Log">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-314">Gibt den Logarithmus einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-314">Returns the logarithm of a complex number.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-315">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-315">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-316">Gibt den natürlichen Logarithmus (zur Basis <see langword="e" />) einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-316">Returns the natural (base <see langword="e" />) logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-317">Der natürliche Logarithmus (zur Basis <see langword="e" />) von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-317">The natural (base <see langword="e" />) logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-318">Die <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> Methode für komplexe Zahlen entspricht der <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-318">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-319">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Log%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-319">The following example illustrates the <xref:System.Numerics.Complex.Log%2A> method.</span></span> <span data-ttu-id="b9077-320">Es veranschaulicht, wie Kompensation für das Fehlen der Genauigkeit von der <xref:System.Double> Datentyp aufweisen, übergeben den Rückgabewert von der <xref:System.Numerics.Complex.Log%2A> Methode, um die <xref:System.Numerics.Complex.Exp%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-320">It shows that, with some allowance for the lack of precision of the <xref:System.Double> data type, passing the value returned by the <xref:System.Numerics.Complex.Log%2A> method to the <xref:System.Numerics.Complex.Exp%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Log#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.log/cs/log1.cs#1)] 
 [!code-vb[System.Numerics.Complex.Log#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.log/vb/log1.vb#1)]   
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Log(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Exp(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Log">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log (System.Numerics.Complex value, double baseValue);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log(valuetype System.Numerics.Complex value, float64 baseValue) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log (value As Complex, baseValue As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log(System::Numerics::Complex value, double baseValue);" />
      <MemberSignature Language="F#" Value="static member Log : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log (value, baseValue)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="baseValue" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-321">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-321">A complex number.</span></span></param>
        <param name="baseValue"><span data-ttu-id="b9077-322">Die Basis des Logarithmus.</span><span class="sxs-lookup"><span data-stu-id="b9077-322">The base of the logarithm.</span></span></param>
        <summary><span data-ttu-id="b9077-323">Gibt den Logarithmus einer angegebenen komplexen Zahl zu einer angegebenen Basis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-323">Returns the logarithm of a specified complex number in a specified base.</span></span></summary>
        <returns><span data-ttu-id="b9077-324">Der Logarithmus von <paramref name="value" /> zur Basis <paramref name="baseValue" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-324">The logarithm of <paramref name="value" /> in base <paramref name="baseValue" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-325">Die <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> Methode für komplexe Zahlen entspricht der <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-325">The <xref:System.Numerics.Complex.Log%28System.Numerics.Complex%2CSystem.Double%29> method for complex numbers corresponds to the <xref:System.Math.Log%28System.Double%2CSystem.Double%29?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Log10">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Log10 (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Log10(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Log10(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Log10 (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Log10(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Log10 : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Log10 value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-326">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-326">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-327">Gibt den Logarithmus einer angegebenen komplexen Zahl zur Basis 10 zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-327">Returns the base-10 logarithm of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-328">Der Logarithmus zur Basis 10 von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-328">The base-10 logarithm of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-329">Die <xref:System.Numerics.Complex.Log10%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Log10%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-329">The <xref:System.Numerics.Complex.Log10%2A> method for complex numbers corresponds to the <xref:System.Math.Log10%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Magnitude">
      <MemberSignature Language="C#" Value="public double Magnitude { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Magnitude" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Magnitude" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Magnitude As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Magnitude { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Magnitude : double" Usage="System.Numerics.Complex.Magnitude" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-330">Ruft die Größenordnung (oder den absoluten Wert) einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-330">Gets the magnitude (or absolute value) of a complex number.</span></span></summary>
        <value><span data-ttu-id="b9077-331">Die Größe der aktuellen Instanz.</span><span class="sxs-lookup"><span data-stu-id="b9077-331">The magnitude of the current instance.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-332">Die <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaft ist identisch mit den absoluten Wert einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-332">The <xref:System.Numerics.Complex.Magnitude%2A> property is equivalent to the absolute value of a complex number.</span></span> <span data-ttu-id="b9077-333">Es gibt die Entfernung vom Ursprung (dem Schnittpunkt der x-Achse und die y-Achse in der kartesischen Koordinatensystem), der zweidimensionale Punkt durch eine komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-333">It specifies the distance from the origin (the intersection of the x-axis and the y-axis in the Cartesian coordinate system) to the two-dimensional point represented by a complex number.</span></span> <span data-ttu-id="b9077-334">Der Absolute Wert wird wie folgt berechnet:</span><span class="sxs-lookup"><span data-stu-id="b9077-334">The absolute value is calculated as follows:</span></span>  
  
 <span data-ttu-id="b9077-335">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span><span class="sxs-lookup"><span data-stu-id="b9077-335">&#124; a + bi &#124; = <xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(a \* a + b \* b)</span></span>  
  
 <span data-ttu-id="b9077-336">Wenn die Berechnung des absoluten Werts zu einem Überlauf führt, gibt diese Eigenschaft <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-336">If the calculation of the absolute value results in an overflow, this property returns either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-337">Die <xref:System.Numerics.Complex.Magnitude%2A> und <xref:System.Numerics.Complex.Phase%2A> Eigenschaften wird definiert, die Position eines Punkts, der eine komplexe Zahl im System Polarkoordinate darstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-337">The <xref:System.Numerics.Complex.Magnitude%2A> and the <xref:System.Numerics.Complex.Phase%2A> properties define the position of a point that represents a complex number in the polar coordinate system.</span></span>  
  
 <span data-ttu-id="b9077-338">Sie können eine komplexe Zahl, die auf Grundlage ihrer Polarkoordinaten anstelle der kartesischen Koordinaten durch Aufrufen von Instanziieren der <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-338">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-339">Das folgende Beispiel berechnet den absoluten Wert einer komplexen Zahl und zeigt, dass sie den Wert der entspricht der <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-339">The following example calculates the absolute value of a complex number and demonstrates that it is equivalent to the value of the <xref:System.Numerics.Complex.Magnitude%2A> property.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Abs#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.abs/cs/abs1.cs#1)]
 [!code-vb[System.Numerics.Complex.Abs#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.abs/vb/abs1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Abs(System.Numerics.Complex)" />
        <altmember cref="P:System.Numerics.Complex.Phase" />
      </Docs>
    </Member>
    <Member MemberName="Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Multiply (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Multiply (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Multiply(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Multiply : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Multiply (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-340">Die erste zu multiplizierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-340">The first complex number to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-341">Die zweite zu multiplizierende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-341">The second complex number to multiply.</span></span></param>
        <summary><span data-ttu-id="b9077-342">Gibt das Produkt zweier komplexer Zahlen zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-342">Returns the product of two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="b9077-343">Das Produkt des <paramref name="left" />-Parameters und des <paramref name="right" />-Parameters.</span><span class="sxs-lookup"><span data-stu-id="b9077-343">The product of the <paramref name="left" /> and <paramref name="right" /> parameters.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-344">Die Multiplikation von eine komplexe Zahl, a + Bi, und eine zweite komplexe Zahl, die c + di, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-344">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-345">(Ac - bd) + (Ad + bc) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-345">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="b9077-346">Wenn die Multiplikation einen Überlauf in der realen oder imaginären Komponente ergibt, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-346">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-347">Die <xref:System.Numerics.Complex.Multiply%2A> Methode wird implementiert, für die Sprachen, die benutzerdefinierte Operatoren nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b9077-347">The <xref:System.Numerics.Complex.Multiply%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="b9077-348">Das Verhalten ist identisch mit der Multiplikation mit der Multiplikationsoperator.</span><span class="sxs-lookup"><span data-stu-id="b9077-348">Its behavior is identical to multiplication using the multiplication operator.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-349">Im folgenden Beispiel wird ein Vielfaches, eine komplexe Zahl von jedem Element in einem Array komplexer Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-349">The following example multiples a complex number by each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply1.cs#1)]
 [!code-vb[System.Numerics.Complex.Multiply#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Negate">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Negate (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Negate(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Negate (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Negate(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Negate : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Negate value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-350">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-350">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-351">Gibt die additive Inverse einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-351">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-352">Das Ergebnis der <see cref="P:System.Numerics.Complex.Real" />- und <see cref="P:System.Numerics.Complex.Imaginary" />-Komponenten des <paramref name="value" />-Parameters multipliziert mit -1.</span><span class="sxs-lookup"><span data-stu-id="b9077-352">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-353">Die Additive Inverse einer komplexen Zahl ist die komplexe Zahl, die den Wert erzeugt <xref:System.Numerics.Complex> Wenn es um die ursprüngliche komplexe Zahl hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-353">The additive inverse of a complex number is a complex number that produces a value of <xref:System.Numerics.Complex> when it is added to the original complex number.</span></span> <span data-ttu-id="b9077-354">Diese Methode gibt eine komplexe Zahl, die in der die reellen und imaginären Komponenten des ursprünglichen komplexen Zahl mit-1 multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-354">This method returns a complex number in which the real and imaginary components of the original complex number are multiplied by -1.</span></span>  
  
 <span data-ttu-id="b9077-355">Die <xref:System.Numerics.Complex.Negate%2A> Methode wird implementiert, für die Sprachen, die benutzerdefinierte Operatoren nicht unterstützen.</span><span class="sxs-lookup"><span data-stu-id="b9077-355">The <xref:System.Numerics.Complex.Negate%2A> method is implemented for languages that do not support custom operators.</span></span> <span data-ttu-id="b9077-356">Das Verhalten ist identisch, verwenden den unären Negationsoperator Negation <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span><span class="sxs-lookup"><span data-stu-id="b9077-356">Its behavior is identical to negation using the unary negation operator, <xref:System.Numerics.Complex.op_UnaryNegation%2A>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-357">Im folgende Beispiel ruft die Additive Inverse jedes Elements in ein Array der komplexen Zahlen ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-357">The following example obtains the additive inverse of each element in an array of complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate1.cs#1)]
 [!code-vb[System.Numerics.Complex.Negate#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="One">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex One;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex One" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.One" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly One As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex One;" />
      <MemberSignature Language="F#" Value=" staticval mutable One : System.Numerics.Complex" Usage="System.Numerics.Complex.One" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-358">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 1 und einer imaginären Zahl gleich 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-358">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to one and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 <span data-ttu-id="b9077-359">Das folgende Beispiel instanziiert ein <xref:System.Numerics.Complex> Wert mithilfe der <xref:System.Numerics.Complex.One> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-359">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.One> property.</span></span> <span data-ttu-id="b9077-360">Es vergleicht dann diesen Wert auf einen anderen Wert, der durch den Aufruf instanziiert wird die <xref:System.Numerics.Complex> Konstruktor mit einem echten gleich Ausdruck und einem imaginären Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-360">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to one and an imaginary part equal to zero.</span></span> <span data-ttu-id="b9077-361">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="b9077-361">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.One#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.one/cs/one1.cs#1)]
 [!code-vb[System.Numerics.Complex.One#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.one/vb/one1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.Zero" />
      </Docs>
    </Member>
    <Member MemberName="op_Addition">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator + (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Addition(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Addition(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator + (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator +(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( + ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left + right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-362">Der erste zu addierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-362">The first value to add.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-363">Der zweite zu addierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-363">The second value to add.</span></span></param>
        <summary><span data-ttu-id="b9077-364">Addiert zwei komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-364">Adds two complex numbers.</span></span></summary>
        <returns><span data-ttu-id="b9077-365">Die Summe von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-365">The sum of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-366">Die <xref:System.Numerics.Complex.op_Addition%2A> Methode definiert die Additionsoperation für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-366">The <xref:System.Numerics.Complex.op_Addition%2A> method defines the addition operation for complex numbers.</span></span> <span data-ttu-id="b9077-367">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-367">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add3.cs#3)]
 [!code-vb[System.Numerics.Complex.Add#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add3.vb#3)]  
  
 <span data-ttu-id="b9077-368">Das Hinzufügen einer komplexen Zahl ist, a + Bi, und eine zweite komplexe Zahl, die c + di, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-368">The addition of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-369">(a + C) + (b + d) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-369">(a + c) + (b + d)i</span></span>  
  
 <span data-ttu-id="b9077-370">Wenn die Methode Ergebnisse zu einem Überlauf entweder in der realen oder imaginären Komponente aufrufen, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-370">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-371">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.Complex.Add%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-371">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Add%2A> method instead.</span></span>  
  
 <span data-ttu-id="b9077-372">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-372">The equivalent method for this operator is <xref:System.Numerics.Complex.Add%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>  
  
## Examples  
 <span data-ttu-id="b9077-373">Das folgende Beispiel veranschaulicht die Addition mit komplexen Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-373">The following example illustrates addition with complex numbers.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Add#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.add/cs/add2.cs#2)]
 [!code-vb[System.Numerics.Complex.Add#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.add/vb/add2.vb#2)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Add(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Division">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator / (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Division(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Division(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator / (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator /(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( / ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left / right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-374">Der zu dividierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-374">The value to be divided.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-375">Der Wert, durch den dividiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-375">The value to divide by.</span></span></param>
        <summary><span data-ttu-id="b9077-376">Dividiert eine angegebene komplexe Zahl durch eine andere angegebene komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-376">Divides a specified complex number by another specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-377">Das Ergebnis der Division von <paramref name="left" /> durch <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-377">The result of dividing <paramref name="left" /> by <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-378">Die <xref:System.Numerics.Complex.op_Division%2A> Methode definiert die Divisionsoperation für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-378">The <xref:System.Numerics.Complex.op_Division%2A> method defines the division operation for complex numbers.</span></span> <span data-ttu-id="b9077-379">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-379">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Divide#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.divide/cs/divide2.cs#2)]
 [!code-vb[System.Numerics.Complex.Divide#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.divide/vb/divide2.vb#2)]  
  
 <span data-ttu-id="b9077-380">Der Division einer komplexen Zahl ist, a + Bi, und eine zweite komplexe Zahl, die c + di, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-380">The division of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-381">((AC + BD) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc-ad) / (c<sup>2</sup> + d<sup>2</sup>) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-381">((ac + bd) / (c<sup>2</sup> + d<sup>2</sup>)) + ((bc - ad) / (c<sup>2</sup> + d<sup>2</sup>)i</span></span>  
  
 <span data-ttu-id="b9077-382">Wenn ein Überlauf in der realen oder imaginären Komponente die Division ergibt, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-382">If the division results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-383">Sprachen, die benutzerdefinierte Operatoren und überladene Operatoren nicht unterstützen können aufrufen, die <xref:System.Numerics.Complex.Divide%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-383">Languages that do not support custom operators and operator overloading can call the <xref:System.Numerics.Complex.Divide%2A> method instead.</span></span>  
  
 <span data-ttu-id="b9077-384">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-384">The equivalent method for this operator is <xref:System.Numerics.Complex.Divide%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Divide(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Equality">
      <MemberSignature Language="C#" Value="public static bool operator == (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Equality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator == (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator ==(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( = ) : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="left = right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-385">Die erste zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-385">The first complex number to compare.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-386">Die zweite zu vergleichende komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-386">The second complex number to compare.</span></span></param>
        <summary><span data-ttu-id="b9077-387">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-387">Returns a value that indicates whether two complex numbers are equal.</span></span></summary>
        <returns><span data-ttu-id="b9077-388"><see langword="true" />, wenn der <paramref name="left" />-Parameter und der <paramref name="right" />-Parameter denselben Wert aufweisen, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-388"><see langword="true" /> if the <paramref name="left" /> and <paramref name="right" /> parameters have the same value; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-389">Die <xref:System.Numerics.Complex.op_Equality%2A> Methode definiert, den Vorgang des Gleichheitsoperators für <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="b9077-389">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the equality operator for <xref:System.Numerics.Complex> values.</span></span> <span data-ttu-id="b9077-390">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-390">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/eqoperator1.cs#9)]
 [!code-vb[System.Numerics.Complex.Equals#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/eqoperator1.vb#9)]  
  
 <span data-ttu-id="b9077-391">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-391">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method instead.</span></span>  
  
 <span data-ttu-id="b9077-392">Wenn ihre reellen Teile gleich sind, und ihre imaginären Teile gleich sind, werden die zwei komplexe Zahlen gleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-392">Two complex numbers are equal if their real parts are equal and their imaginary parts are equal.</span></span> <span data-ttu-id="b9077-393">Die <xref:System.Numerics.Complex.op_Equality%2A> Methode entspricht dem folgenden Ausdruck:</span><span class="sxs-lookup"><span data-stu-id="b9077-393">The <xref:System.Numerics.Complex.op_Equality%2A> method is equivalent to the following expression:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Equals#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.equals/cs/equals1.cs#3)]
 [!code-vb[System.Numerics.Complex.Equals#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.equals/vb/equals1.vb#3)]  
  
 <span data-ttu-id="b9077-394">Beachten Sie, dass aufgrund der Unterschiede in der Genauigkeit zweier komplexer Zahlen, der scheinbar entsprechen als ungleich betrachtet werden können.</span><span class="sxs-lookup"><span data-stu-id="b9077-394">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="b9077-395">Weitere Informationen und eine mögliche problemumgehung finden Sie in der <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-395">For more information and a possible workaround, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 <span data-ttu-id="b9077-396">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-396">The equivalent method for this operator is <xref:System.Numerics.Complex.Equals%2A?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Explicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-397">Definiert eine explizite Konvertierung zwischen einem <see cref="T:System.Numerics.Complex" />-Objekt und einem anderen Typ.</span><span class="sxs-lookup"><span data-stu-id="b9077-397">Defines an explicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
        <altmember cref="Overload:System.Numerics.Complex.op_Implicit" />
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (decimal value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Decimal value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Decimal)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As Decimal) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Decimal value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : decimal -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Decimal" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-398">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-398">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-399">Definiert eine explizite Konvertierung eines <see cref="T:System.Decimal" />-Werts in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-399">Defines an explicit conversion of a <see cref="T:System.Decimal" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-400">Eine komplexe Zahl mit einer reellen Komponente gleich <paramref name="value" /> und einer imaginären Komponente gleich 0.</span><span class="sxs-lookup"><span data-stu-id="b9077-400">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-401">Explizite Konvertierungsoperatoren definieren die Typen, die konvertiert werden können eine <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-401">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b9077-402">Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann.</span><span class="sxs-lookup"><span data-stu-id="b9077-402">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="b9077-403">Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="b9077-403">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="b9077-404">Andernfalls zeigen sie einen Compilerfehler.</span><span class="sxs-lookup"><span data-stu-id="b9077-404">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="b9077-405">Die Konvertierung von einem <xref:System.Decimal> Wert, der dem Realteil einer komplexen Zahl kann in einem Genauigkeitsverlust führen, da eine <xref:System.Double>, ist der Typ der komplexen Zahl <xref:System.Numerics.Complex.Real%2A> -Eigenschaft verfügt über weniger signifikante Ziffern als eine <xref:System.Decimal>.</span><span class="sxs-lookup"><span data-stu-id="b9077-405">The conversion of a <xref:System.Decimal> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Decimal>.</span></span>



## Examples
 <span data-ttu-id="b9077-406">Das folgende Beispiel veranschaulicht die explizite Konvertierung <xref:System.Decimal> Werte <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="b9077-406">The following example illustrates the explicit conversion of <xref:System.Decimal> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Explicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Explicit">
      <MemberSignature Language="C#" Value="public static explicit operator System.Numerics.Complex (System.Numerics.BigInteger value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Explicit(valuetype System.Numerics.BigInteger value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Explicit(System.Numerics.BigInteger)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Narrowing Operator CType (value As BigInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static explicit operator System::Numerics::Complex(System::Numerics::BigInteger value);" />
      <MemberSignature Language="F#" Value="static member op_Explicit : System.Numerics.BigInteger -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Explicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.BigInteger" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-407">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-407">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-408">Definiert eine explizite Konvertierung eines <see cref="T:System.Numerics.BigInteger" />-Werts in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-408">Defines an explicit conversion of a <see cref="T:System.Numerics.BigInteger" /> value to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-409">Eine komplexe Zahl mit einer reellen Komponente gleich <paramref name="value" /> und einer imaginären Komponente gleich 0.</span><span class="sxs-lookup"><span data-stu-id="b9077-409">A complex number that has a real component equal to <paramref name="value" /> and an imaginary component equal to zero.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-410">Explizite Konvertierungsoperatoren definieren die Typen, die konvertiert werden können eine <xref:System.Numerics.Complex> Objekt.</span><span class="sxs-lookup"><span data-stu-id="b9077-410">Explicit conversion operators define types that can be converted to a <xref:System.Numerics.Complex> object.</span></span> <span data-ttu-id="b9077-411">Sprachcompiler führen diese Konvertierung nicht automatisch aus, da es zu Datenverlust führen kann.</span><span class="sxs-lookup"><span data-stu-id="b9077-411">Language compilers do not perform this conversion automatically because it can involve data loss.</span></span> <span data-ttu-id="b9077-412">Stattdessen führen sie die Konvertierung nur dann, wenn ein Umwandlungsoperator (in c#) oder eine Konvertierungsfunktion (z. B. `CType` in Visual Basic) wird verwendet.</span><span class="sxs-lookup"><span data-stu-id="b9077-412">Instead, they perform the conversion only if a casting operator (in C#) or a conversion function (such as `CType` in Visual Basic) is used.</span></span> <span data-ttu-id="b9077-413">Andernfalls zeigen sie einen Compilerfehler.</span><span class="sxs-lookup"><span data-stu-id="b9077-413">Otherwise, they display a compiler error.</span></span>

 <span data-ttu-id="b9077-414">Die Konvertierung von einem <xref:System.Numerics.BigInteger> Wert, der dem Realteil einer komplexen Zahl kann in einem Genauigkeitsverlust führen, da eine <xref:System.Double>, ist der Typ der komplexen Zahl <xref:System.Numerics.Complex.Real%2A> -Eigenschaft verfügt über weniger signifikante Ziffern als eine <xref:System.Numerics.BigInteger>.</span><span class="sxs-lookup"><span data-stu-id="b9077-414">The conversion of a <xref:System.Numerics.BigInteger> value to the real part of a complex number can result in a loss of precision because a <xref:System.Double>, which is the type of the complex number's <xref:System.Numerics.Complex.Real%2A> property, has fewer significant digits than a <xref:System.Numerics.BigInteger>.</span></span>

 <span data-ttu-id="b9077-415">Wenn die Konvertierung nicht erfolgreich ist da die <xref:System.Numerics.BigInteger> Wert ist außerhalb des Gültigkeitsbereichs der <xref:System.Double> Typ, der Vorgang wird nicht ausgelöst. eine <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-415">If the conversion is unsuccessful because the <xref:System.Numerics.BigInteger> value is out of the range of the <xref:System.Double> type, the operation does not throw an <xref:System.OverflowException>.</span></span> <span data-ttu-id="b9077-416">Stattdessen Wenn `value` ist kleiner als <xref:System.Double.MinValue>, das Ergebnis ist eine komplexe Zahl, die eine <xref:System.Numerics.Complex.Real%2A> Eigenschaftswert gleich <xref:System.Double.NegativeInfinity>.</span><span class="sxs-lookup"><span data-stu-id="b9077-416">Instead, if `value` is less than <xref:System.Double.MinValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.NegativeInfinity>.</span></span> <span data-ttu-id="b9077-417">Wenn `value` ist größer als <xref:System.Double.MaxValue>, das Ergebnis ist eine komplexe Zahl, die eine <xref:System.Numerics.Complex.Real%2A> Eigenschaftswert gleich <xref:System.Double.PositiveInfinity>.</span><span class="sxs-lookup"><span data-stu-id="b9077-417">If `value` is greater than <xref:System.Double.MaxValue>, the result is a complex number that has a <xref:System.Numerics.Complex.Real%2A> property value equal to <xref:System.Double.PositiveInfinity>.</span></span>



## Examples
 <span data-ttu-id="b9077-418">Das folgende Beispiel veranschaulicht die explizite Konvertierung <xref:System.Numerics.BigInteger> Werte <xref:System.Numerics.Complex> Werte.</span><span class="sxs-lookup"><span data-stu-id="b9077-418">The following example illustrates the explicit conversion of <xref:System.Numerics.BigInteger> values to <xref:System.Numerics.Complex> values.</span></span>

 [!code-csharp[System.Numerics.Complex.Explicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.explicit/cs/explicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Explicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.explicit/vb/explicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="op_Implicit">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-419">Definiert eine implizite Konvertierung zwischen einem <see cref="T:System.Numerics.Complex" />-Objekt und einem anderen Typ.</span><span class="sxs-lookup"><span data-stu-id="b9077-419">Defines an implicit conversion between a <see cref="T:System.Numerics.Complex" /> object and another type.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (byte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Byte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Byte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::Byte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : byte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Byte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-420">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-420">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-421">Definiert eine implizite Konvertierung eines Bytewerts ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-421">Defines an implicit conversion of an unsigned byte to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-422">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-422">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-423">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-423">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-424">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-424">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-425">Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen von einem <xref:System.Byte> Wert in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-425">This overload lets the compiler handle conversions from a <xref:System.Byte> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-426">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil gleich ist, der <xref:System.Byte> Wert und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-426">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Byte> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#1)]   
 [!code-vb[System.Numerics.Complex.Implicit#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#1)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (double value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Double)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(double value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-427">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-427">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-428">Definiert eine implizite Konvertierung einer Gleitkommazahl mit doppelter Genauigkeit in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-428">Defines an implicit conversion of a double-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-429">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-429">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-430">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-430">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-431">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-431">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-432">Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen von einem <xref:System.Double> Wert in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-432">This overload lets the compiler handle conversions from a <xref:System.Double> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-433">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil gleich ist, der <xref:System.Double> Wert und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-433">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Double> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#2)]   
 [!code-vb[System.Numerics.Complex.Implicit#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#2)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (short value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Short) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(short value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-434">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-434">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-435">Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-435">Defines an implicit conversion of a 16-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-436">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-436">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-437">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-437">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-438">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-438">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-439">Diese Überladung ermöglicht den Compiler, die Handhabung von Konvertierungen in eine 16-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-439">This overload lets the compiler handle conversions from a signed 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-440">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 16-Bit-Ganzzahl mit Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-440">Note that the result of the conversion is a complex number whose real part is equal to the signed 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#3)]   
 [!code-vb[System.Numerics.Complex.Implicit#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#3)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (int value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Integer) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(int value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-441">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-441">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-442">Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-442">Defines an implicit conversion of a 32-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-443">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-443">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-444">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-444">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-445">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-445">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-446">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen in eine 32-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-446">This overload lets the compiler handle conversions from a signed 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-447">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 32-Bit-Ganzzahl mit Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-447">Note that the result of the conversion is a complex number whose real part is equal to the signed 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#4)]   
 [!code-vb[System.Numerics.Complex.Implicit#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#4)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (long value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Int64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Long) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(long value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : int64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-448">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-448">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-449">Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-449">Defines an implicit conversion of a 64-bit signed integer to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-450">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-450">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-451">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-451">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-452">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-452">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-453">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen in eine 64-Bit-Ganzzahl mit Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-453">This overload lets the compiler handle conversions from a signed 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-454">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 64-Bit-Ganzzahl mit Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-454">Note that the result of the conversion is a complex number whose real part is equal to the signed 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#5](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#5)]   
 [!code-vb[System.Numerics.Complex.Implicit#5](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#5)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (sbyte value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(int8 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.SByte)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As SByte) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::SByte value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : sbyte -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.SByte" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-455">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-455">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-456">Definiert eine implizite Konvertierung eines Bytewerts mit Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-456">Defines an implicit conversion of a signed byte to a complex number.</span></span>   
           
<span data-ttu-id="b9077-457">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="b9077-457">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="b9077-458">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-458">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-459">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-459">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-460">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-460">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-461">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen von einem Byte mit Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-461">This overload lets the compiler handle conversions from a signed byte to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-462">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist das Byte mit Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-462">Note that the result of the conversion is a complex number whose real part is equal to the signed byte and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#6](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#6)]   
 [!code-vb[System.Numerics.Complex.Implicit#6](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#6)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (float value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(float32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.Single)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As Single) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(float value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : single -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Single" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-463">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-463">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-464">Definiert eine implizite Konvertierung einer Gleitkommazahl mit einfacher Genauigkeit in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-464">Defines an implicit conversion of a single-precision floating-point number to a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-465">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-465">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-466">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-466">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-467">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-467">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-468">Diese Überladung ermöglicht dem Compiler, die Handhabung von Konvertierungen von einem <xref:System.Single> Wert in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-468">This overload lets the compiler handle conversions from a <xref:System.Single> value to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-469">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil gleich ist, der <xref:System.Single> Wert und deren imaginärer Teil gleich 0 (null) ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-469">Note that the result of the conversion is a complex number whose real part is equal to the <xref:System.Single> value and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#7](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#7)]   
 [!code-vb[System.Numerics.Complex.Implicit#7](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#7)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ushort value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int16 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt16)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UShort) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt16 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint16 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt16" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-470">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-470">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-471">Definiert eine implizite Konvertierung einer 16-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-471">Defines an implicit conversion of a 16-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="b9077-472">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="b9077-472">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="b9077-473">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-473">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-474">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-474">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-475">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-475">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-476">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen in eine 16-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-476">This overload lets the compiler handle conversions from an unsigned 16-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-477">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 16-Bit-Ganzzahl ohne Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-477">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 16-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#8](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#8)]   
 [!code-vb[System.Numerics.Complex.Implicit#8](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#8)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (uint value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int32 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt32)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As UInteger) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt32 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint32 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt32" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-478">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-478">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-479">Definiert eine implizite Konvertierung einer 32-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-479">Defines an implicit conversion of a 32-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="b9077-480">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="b9077-480">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="b9077-481">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-481">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-482">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-482">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-483">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-483">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-484">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen in eine 32-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-484">This overload lets the compiler handle conversions from an unsigned 32-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-485">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 32-Bit-Ganzzahl ohne Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-485">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 32-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#9](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#9)]   
 [!code-vb[System.Numerics.Complex.Implicit#9](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#9)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Implicit">
      <MemberSignature Language="C#" Value="public static implicit operator System.Numerics.Complex (ulong value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Implicit(unsigned int64 value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Implicit(System.UInt64)~System.Numerics.Complex" />
      <MemberSignature Language="VB.NET" Value="Public Shared Widening Operator CType (value As ULong) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static operator System::Numerics::Complex(System::UInt64 value);" />
      <MemberSignature Language="F#" Value="static member op_Implicit : uint64 -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.op_Implicit value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netcore-1.0;netcore-1.1;netcore-2.0;netcore-2.1;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netstandard-1.1;netstandard-1.2;netstandard-1.3;netstandard-1.4;netstandard-1.6;netstandard-2.0;xamarinandroid-7.1;xamarinios-10.8;xamarinmac-3.0;netframework-4.8;netcore-2.2">
          <AttributeName>System.CLSCompliant(false)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.UInt64" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-486">Der Wert, der in eine komplexe Zahl konvertiert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-486">The value to convert to a complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-487">Definiert eine implizite Konvertierung einer 64-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-487">Defines an implicit conversion of a 64-bit unsigned integer to a complex number.</span></span>   
           
<span data-ttu-id="b9077-488">Diese API ist nicht CLS-kompatibel.</span><span class="sxs-lookup"><span data-stu-id="b9077-488">This API is not CLS-compliant.</span></span></summary>
        <returns><span data-ttu-id="b9077-489">Ein Objekt, das den Wert des <paramref name="value" />-Parameters als reellen Teil und 0 als imaginären Teil enthält.</span><span class="sxs-lookup"><span data-stu-id="b9077-489">An object that contains the value of the <paramref name="value" /> parameter as its real part and zero as its imaginary part.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-490">Die Überladungen von der <xref:System.Numerics.Complex.op_Implicit%2A> Operator definieren die Typen, die von dem ein Compiler kann automatisch konvertieren eine <xref:System.Numerics.Complex> Objekt ohne einen expliziten Umwandlungsoperator (in c#) oder ein Aufruf eine Konvertierungsfunktion (in Visual Basic).</span><span class="sxs-lookup"><span data-stu-id="b9077-490">The overloads of the <xref:System.Numerics.Complex.op_Implicit%2A> operator define the types from which a compiler can automatically convert a <xref:System.Numerics.Complex> object without an explicit casting operator (in C#) or a call to a conversion function (in Visual Basic).</span></span> <span data-ttu-id="b9077-491">Sie sind erweiterungskonvertierungen, die beinhalten keine Daten verloren gehen, und lösen Sie kein <xref:System.OverflowException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-491">They are widening conversions that do not involve data loss and do not throw an <xref:System.OverflowException>.</span></span>

 <span data-ttu-id="b9077-492">Diese Überladung ermöglicht dem Compiler, das Behandeln von Konvertierungen in eine 64-Bit-Ganzzahl ohne Vorzeichen in eine komplexe Zahl, wie im folgenden Beispiel gezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-492">This overload lets the compiler handle conversions from an unsigned 64-bit integer to a complex number, as the following example shows.</span></span> <span data-ttu-id="b9077-493">Beachten Sie, dass das Ergebnis der Konvertierung einer komplexen Zahl, deren reeller Teil ist die 64-Bit-Ganzzahl ohne Vorzeichen gleich und deren imaginärer Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-493">Note that the result of the conversion is a complex number whose real part is equal to the unsigned 64-bit integer and whose imaginary part is equal to zero.</span></span>

 [!code-csharp[System.Numerics.Complex.Implicit#10](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.implicit/cs/implicit1.cs#10)]   
 [!code-vb[System.Numerics.Complex.Implicit#10](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.implicit/vb/implicit1.vb#10)]   

 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="op_Inequality">
      <MemberSignature Language="C#" Value="public static bool operator != (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname bool op_Inequality(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Inequality(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator != (left As Complex, right As Complex) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool operator !=(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member op_Inequality : System.Numerics.Complex * System.Numerics.Complex -&gt; bool" Usage="System.Numerics.Complex.op_Inequality (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-494">Der erste zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-494">The first value to compare.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-495">Der zweite zu vergleichende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-495">The second value to compare.</span></span></param>
        <summary><span data-ttu-id="b9077-496">Gibt einen Wert zurück, der angibt, ob zwei komplexe Zahlen ungleich sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-496">Returns a value that indicates whether two complex numbers are not equal.</span></span></summary>
        <returns><span data-ttu-id="b9077-497"><see langword="true" />, wenn <paramref name="left" /> und <paramref name="right" /> ungleich sind, andernfalls <see langword="false" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-497"><see langword="true" /> if <paramref name="left" /> and <paramref name="right" /> are not equal; otherwise, <see langword="false" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-498">Die <xref:System.Numerics.Complex.op_Equality%2A> Methode definiert, den Vorgang des Ungleichheitsoperators für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-498">The <xref:System.Numerics.Complex.op_Equality%2A> method defines the operation of the inequality operator for complex numbers.</span></span> <span data-ttu-id="b9077-499">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-499">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Inequality#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.inequality/cs/inequality1.cs#1)]
 [!code-vb[System.Numerics.Complex.Inequality#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.inequality/vb/inequality1.vb#1)]  
  
 <span data-ttu-id="b9077-500">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können auf Ungleichheit testen, durch den Aufruf der <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> -Methode und ihren Wert umkehren.</span><span class="sxs-lookup"><span data-stu-id="b9077-500">Languages that do not support custom operators can test for inequality by calling the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method and reversing its value.</span></span>  
  
 <span data-ttu-id="b9077-501">Beachten Sie, dass aufgrund der Unterschiede in der Genauigkeit zweier komplexer Zahlen, der scheinbar entsprechen als ungleich betrachtet werden können.</span><span class="sxs-lookup"><span data-stu-id="b9077-501">Note that, because of differences in precision, two complex numbers that are apparently equivalent can be considered unequal.</span></span> <span data-ttu-id="b9077-502">Eine mögliche Lösung besteht darin, zurückgibt, eine Vergleichsmethode implementiert `true` nur, wenn der Unterschied zwischen den zwei reellen und imaginären Teile der komplexen Zahlen einen bestimmten Schwellenwert überschreitet (z. B. 01 % des Werts der realen oder imaginären Komponente des einer der komplexen Zahlen).</span><span class="sxs-lookup"><span data-stu-id="b9077-502">One possible workaround is to implement a comparison method that returns `true` only if the difference between the two real and imaginary parts of the complex numbers exceeds a certain threshold (such as .01% of the value of the real or imaginary component of one of the complex numbers).</span></span> <span data-ttu-id="b9077-503">Weitere Informationen finden Sie unter der Methode <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29>.</span><span class="sxs-lookup"><span data-stu-id="b9077-503">For more information, see the <xref:System.Numerics.Complex.Equals%28System.Numerics.Complex%29> method.</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Equality(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Multiply">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator * (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Multiply(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator * (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator *(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( * ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left * right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-504">Der erste zu multiplizierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-504">The first value to multiply.</span></span></param>
        <param name="right"><span data-ttu-id="b9077-505">Der zweite zu multiplizierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-505">The second value to multiply.</span></span></param>
        <summary><span data-ttu-id="b9077-506">Multipliziert zwei angegebene komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-506">Multiplies two specified complex numbers.</span></span></summary>
        <returns><span data-ttu-id="b9077-507">Das Produkt von <paramref name="left" /> und <paramref name="right" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-507">The product of <paramref name="left" /> and <paramref name="right" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-508">Die <xref:System.Numerics.Complex.op_Multiply%2A> Methode definiert, den Vorgang der der Multiplikationsoperator für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-508">The <xref:System.Numerics.Complex.op_Multiply%2A> method defines the operation of the multiplication operator for complex numbers.</span></span> <span data-ttu-id="b9077-509">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-509">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Multiply#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.multiply/cs/multiply2.cs#2)]
 [!code-vb[System.Numerics.Complex.Multiply#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.multiply/vb/multiply2.vb#2)]  
  
 <span data-ttu-id="b9077-510">Die Multiplikation von eine komplexe Zahl, a + Bi, und eine zweite komplexe Zahl, die c + di, weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-510">The multiplication of a complex number, a + bi, and a second complex number, c + di, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-511">(Ac - bd) + (Ad + bc) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-511">(ac - bd) + (ad + bc)i</span></span>  
  
 <span data-ttu-id="b9077-512">Wenn die Multiplikation einen Überlauf in der realen oder imaginären Komponente ergibt, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-512">If the multiplication results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-513">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.Complex.Multiply%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-513">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Multiply%2A> method instead.</span></span>  
  
 <span data-ttu-id="b9077-514">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-514">The equivalent method for this operator is <xref:System.Numerics.Complex.Multiply%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Multiply(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_Subtraction">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_Subtraction(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member ( - ) : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="left - right" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-515">Der Wert, von dem subtrahiert werden soll (der Minuend).</span><span class="sxs-lookup"><span data-stu-id="b9077-515">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="b9077-516">Der Wert, der subtrahiert werden soll (der Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="b9077-516">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="b9077-517">Subtrahiert eine komplexe Zahl von einer anderen komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-517">Subtracts a complex number from another complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-518">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-518">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-519">Die <xref:System.Numerics.Complex.op_Subtraction%2A> Methode definiert, den Vorgang des Subtraktionsoperators für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-519">The <xref:System.Numerics.Complex.op_Subtraction%2A> method defines the operation of the subtraction operator for complex numbers.</span></span> <span data-ttu-id="b9077-520">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-520">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract2.cs#2)]
 [!code-vb[System.Numerics.Complex.Subtract#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract2.vb#2)]  
  
 <span data-ttu-id="b9077-521">Wenn die Methode Ergebnisse zu einem Überlauf entweder in der realen oder imaginären Komponente aufrufen, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-521">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-522">Eine komplexe Zahl, c + di, von einer anderen komplexen Zahl, die Subtraktion einen + Bi weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-522">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-523">(a - c) + (b - d) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-523">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="b9077-524">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.Complex.Subtract%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-524">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Subtract%2A> method instead.</span></span>  
  
 <span data-ttu-id="b9077-525">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-525">The equivalent method for this operator is <xref:System.Numerics.Complex.Subtract%28System.Numerics.Complex%2CSystem.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="op_UnaryNegation">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex operator - (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig specialname valuetype System.Numerics.Complex op_UnaryNegation(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.op_UnaryNegation(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Operator - (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex operator -(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member ( ~- ) : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="- value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-526">Der zu negierende Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-526">The value to negate.</span></span></param>
        <summary><span data-ttu-id="b9077-527">Gibt die additive Inverse einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-527">Returns the additive inverse of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-528">Das Ergebnis der <see cref="P:System.Numerics.Complex.Real" />- und <see cref="P:System.Numerics.Complex.Imaginary" />-Komponenten des <paramref name="value" />-Parameters multipliziert mit -1.</span><span class="sxs-lookup"><span data-stu-id="b9077-528">The result of the <see cref="P:System.Numerics.Complex.Real" /> and <see cref="P:System.Numerics.Complex.Imaginary" /> components of the <paramref name="value" /> parameter multiplied by -1.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-529">Die <xref:System.Numerics.Complex.op_UnaryNegation%2A> Methode definiert, den Vorgang der den unären Negationsoperator (gegenzahl) für komplexe Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-529">The <xref:System.Numerics.Complex.op_UnaryNegation%2A> method defines the operation of the unary negation (additive inverse) operator for complex numbers.</span></span> <span data-ttu-id="b9077-530">Sie können Code wie den folgenden:</span><span class="sxs-lookup"><span data-stu-id="b9077-530">It enables code such as the following:</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Negate#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.negate/cs/negate2.cs#2)]
 [!code-vb[System.Numerics.Complex.Negate#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.negate/vb/negate2.vb#2)]  
  
 <span data-ttu-id="b9077-531">Wert erzeugt, die sich ergebende Anzahl von komplexen <xref:System.Numerics.Complex> 0 (null), wenn sie die ursprüngliche komplexe Zahl hinzugefügt wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-531">The resulting complex number produces a value of <xref:System.Numerics.Complex> 0 (zero) when it is added to the original complex number.</span></span> <span data-ttu-id="b9077-532">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können aufrufen, die <xref:System.Numerics.Complex.Negate%2A> Methode stattdessen.</span><span class="sxs-lookup"><span data-stu-id="b9077-532">Languages that do not support custom operators can call the <xref:System.Numerics.Complex.Negate%2A> method instead.</span></span>  
  
 <span data-ttu-id="b9077-533">Die entsprechende Methode für diesen Operator ist <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span><span class="sxs-lookup"><span data-stu-id="b9077-533">The equivalent method for this operator is <xref:System.Numerics.Complex.Negate%28System.Numerics.Complex%29?displayProperty=nameWithType></span></span>]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Negate(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Phase">
      <MemberSignature Language="C#" Value="public double Phase { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Phase" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Phase" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Phase As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Phase { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Phase : double" Usage="System.Numerics.Complex.Phase" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-534">Ruft die Phase einer komplexen Zahl ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-534">Gets the phase of a complex number.</span></span></summary>
        <value><span data-ttu-id="b9077-535">Die Phase einer komplexen Zahl im Bogenmaß.</span><span class="sxs-lookup"><span data-stu-id="b9077-535">The phase of a complex number, in radians.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-536">Für eine komplexe Zahl einer + Bi, die Phase wird berechnet als <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, ein).</span><span class="sxs-lookup"><span data-stu-id="b9077-536">For a complex number a + bi, the phase is computed as <xref:System.Math.Atan2%2A?displayProperty=nameWithType>(b, a).</span></span>  
  
 <span data-ttu-id="b9077-537">Sie können eine komplexe Zahl, durch die kartesischen Koordinaten in der komplexen Ebene oder ihrer Polarkoordinaten identifizieren.</span><span class="sxs-lookup"><span data-stu-id="b9077-537">You can identify a complex number by its Cartesian coordinates on the complex plane or by its polar coordinates.</span></span> <span data-ttu-id="b9077-538">Die Phase (Argumente) einer komplexen Zahl ist der Winkel der reellen Achse ab dem Zeitpunkt der Ursprung (dem Schnittpunkt der x-Achse und y-Achse) gezeichneten Linie zu dem Punkt, der durch die komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-538">The phase (argument) of a complex number is the angle to the real axis of a line drawn from the point of origin (the intersection of the x-axis and the y-axis) to the point represented by the complex number.</span></span> <span data-ttu-id="b9077-539">Die Größe (dargestellt durch die <xref:System.Numerics.Complex.Magnitude%2A> Eigenschaft) ist der Abstand vom Ursprungspunkt zu dem Punkt, die durch die komplexe Zahl dargestellt wird.</span><span class="sxs-lookup"><span data-stu-id="b9077-539">The magnitude (represented by the <xref:System.Numerics.Complex.Magnitude%2A> property) is the distance from the point of origin to the point that is represented by the complex number.</span></span>  
  
 <span data-ttu-id="b9077-540">Sie können eine komplexe Zahl, die auf Grundlage ihrer Polarkoordinaten anstelle der kartesischen Koordinaten durch Aufrufen von Instanziieren der <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-540">You can instantiate a complex number based on its polar coordinates instead of its Cartesian coordinates by calling the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method.</span></span>  
  
 <span data-ttu-id="b9077-541">Um die Phase von Bogenmaß zu Grad zu ändern, Multiplizieren Sie es mit 180 /<xref:System.Math.PI?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-541">To convert the phase from radians to degrees, multiply it by 180/<xref:System.Math.PI?displayProperty=nameWithType>.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-542">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.FromPolarCoordinates%2A> Methode zum Instanziieren einer komplexen Zahl basierend auf ihrer Polarkoordinaten und zeigt dann den Wert, der die <xref:System.Numerics.Complex.Magnitude%2A> und <xref:System.Numerics.Complex.Phase%2A> Eigenschaften.</span><span class="sxs-lookup"><span data-stu-id="b9077-542">The following example uses the <xref:System.Numerics.Complex.FromPolarCoordinates%2A> method to instantiate a complex number based on its polar coordinates, and then displays the value of its <xref:System.Numerics.Complex.Magnitude%2A> and <xref:System.Numerics.Complex.Phase%2A> properties.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Phase#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.phase/cs/phase1.cs#1)]
 [!code-vb[System.Numerics.Complex.Phase#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.phase/vb/phase1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Magnitude" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pow">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-543">Gibt eine komplexe Zahl potenziert mit einem angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-543">Returns a specified complex number raised to a specified power.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, double power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, float64 power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Double) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, double power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * double -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-544">Eine komplexe Zahl, die mit einem Exponenten potenziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-544">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="b9077-545">Eine Gleitkommazahl mit doppelter Genauigkeit, die einen Exponenten darstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-545">A double-precision floating-point number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="b9077-546">Gibt eine angegebene komplexe Zahl potenziert mit einem als Gleitkommazahl mit doppelter Genauigkeit angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-546">Returns a specified complex number raised to a power specified by a double-precision floating-point number.</span></span></summary>
        <returns><span data-ttu-id="b9077-547">Die komplexe Zahl <paramref name="value" /> potenziert mit <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-547">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-548">Wenn `value` gleich <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> ist, gibt die Methode <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType> zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-548">If `value` is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-549">Für andere Werte Wenn `power` ist 0 (null) gibt die Methode zurück <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, und wenn `power` gleich 1 ist, gibt `value`.</span><span class="sxs-lookup"><span data-stu-id="b9077-549">For other values, if `power` is 0, the method returns <xref:System.Numerics.Complex.One?displayProperty=nameWithType>, and if `power` is 1, it returns `value`.</span></span>  
  
 <span data-ttu-id="b9077-550">Diese Methode entspricht der <xref:System.Math.Pow%2A?displayProperty=nameWithType> -Methode für den primitiven numerischen Typen.</span><span class="sxs-lookup"><span data-stu-id="b9077-550">This method corresponds to the <xref:System.Math.Pow%2A?displayProperty=nameWithType> method for primitive numeric types.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-551">Das folgende Beispiel veranschaulicht die Potenzierung mit einer komplexen Zahl und einem Exponenten, deren Wert zwischen-1 und 10 liegt.</span><span class="sxs-lookup"><span data-stu-id="b9077-551">The following example illustrates exponentiation using a complex number and an exponent whose value ranges from -1 to 10.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Pow#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.pow/cs/pow1.cs#1)]
 [!code-vb[System.Numerics.Complex.Pow#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.pow/vb/pow1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pow">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Pow (System.Numerics.Complex value, System.Numerics.Complex power);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Pow(valuetype System.Numerics.Complex value, valuetype System.Numerics.Complex power) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Pow(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Pow (value As Complex, power As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Pow(System::Numerics::Complex value, System::Numerics::Complex power);" />
      <MemberSignature Language="F#" Value="static member Pow : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Pow (value, power)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
        <Parameter Name="power" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-552">Eine komplexe Zahl, die mit einem Exponenten potenziert werden soll.</span><span class="sxs-lookup"><span data-stu-id="b9077-552">A complex number to be raised to a power.</span></span></param>
        <param name="power"><span data-ttu-id="b9077-553">Eine komplexe Zahl, die einen Exponenten angibt.</span><span class="sxs-lookup"><span data-stu-id="b9077-553">A complex number that specifies a power.</span></span></param>
        <summary><span data-ttu-id="b9077-554">Gibt eine komplexe Zahl potenziert mit einem durch eine komplexe Zahl angegebenen Exponenten zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-554">Returns a specified complex number raised to a power specified by a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-555">Die komplexe Zahl <paramref name="value" /> potenziert mit <paramref name="power" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-555">The complex number <paramref name="value" /> raised to the power <paramref name="power" />.</span></span></returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Real">
      <MemberSignature Language="C#" Value="public double Real { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance float64 Real" />
      <MemberSignature Language="DocId" Value="P:System.Numerics.Complex.Real" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property Real As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property double Real { double get(); };" />
      <MemberSignature Language="F#" Value="member this.Real : double" Usage="System.Numerics.Complex.Real" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-556">Ruft die reelle Komponente des aktuellen <see cref="T:System.Numerics.Complex" />-Objekts ab.</span><span class="sxs-lookup"><span data-stu-id="b9077-556">Gets the real component of the current <see cref="T:System.Numerics.Complex" /> object.</span></span></summary>
        <value><span data-ttu-id="b9077-557">Die reelle Komponente einer komplexen Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-557">The real component of a complex number.</span></span></value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-558">Erhalten eine komplexen Zahl a + Bi, <xref:System.Numerics.Complex.Real%2A> Eigenschaft gibt den Wert der ein.</span><span class="sxs-lookup"><span data-stu-id="b9077-558">Given a complex number a + bi, the <xref:System.Numerics.Complex.Real%2A> property returns the value of a.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-559">Das folgende Beispiel instanziiert ein Array von <xref:System.Numerics.Complex> -Objekte und zeigt die reellen und imaginären Komponenten jedes in der Form a + Bi.</span><span class="sxs-lookup"><span data-stu-id="b9077-559">The following example instantiates an array of <xref:System.Numerics.Complex> objects and displays the real and imaginary components of each in the form a + bi.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Real#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.real/cs/real1.cs#1)]
 [!code-vb[System.Numerics.Complex.Real#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.real/vb/real1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Numerics.Complex.Imaginary" />
      </Docs>
    </Member>
    <Member MemberName="Reciprocal">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Reciprocal (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Reciprocal(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Reciprocal(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Reciprocal (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Reciprocal(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Reciprocal : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Reciprocal value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-560">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-560">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-561">Gibt den Kehrwert einer komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-561">Returns the multiplicative inverse of a complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-562">Der Kehrwert von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-562">The reciprocal of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-563">Der Kehrwert oder Kehrwert, einer Zahl *x* ist eine Zahl *y* , in denen *x* multipliziert *y* 1 ergibt.</span><span class="sxs-lookup"><span data-stu-id="b9077-563">The reciprocal, or multiplicative inverse, of a number *x* is a number *y* where *x* multiplied by *y* yields 1.</span></span> <span data-ttu-id="b9077-564">Der Kehrwert einer komplexen Zahl ist die komplexe Zahl, die erzeugt <xref:System.Numerics.Complex.One?displayProperty=nameWithType> Wenn die zwei Zahlen multipliziert werden.</span><span class="sxs-lookup"><span data-stu-id="b9077-564">The reciprocal of a complex number is the complex number that produces <xref:System.Numerics.Complex.One?displayProperty=nameWithType> when the two numbers are multiplied.</span></span> <span data-ttu-id="b9077-565">Wenn es sich bei eine komplexen Zahl a + Bi durch dargestellt wird, wird der Kehrwert durch den Ausdruck dargestellt eine / (eine<sup>2</sup>+ b<sup>2</sup>) + b-/ (eine<sup>2</sup> + b<sup>2</sup>).</span><span class="sxs-lookup"><span data-stu-id="b9077-565">If a complex number is represented by a +bi, its reciprocal is represented by the expression a/(a<sup>2</sup>+b<sup>2</sup>) + -b/(a<sup>2</sup> + b<sup>2</sup>).</span></span>  
  
 <span data-ttu-id="b9077-566">Falls der Wert <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, gibt die Methode zurück <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-566">If value is <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>, the method returns <xref:System.Numerics.Complex.Zero?displayProperty=nameWithType>.</span></span> <span data-ttu-id="b9077-567">Andernfalls wird das Ergebnis des Ausdrucks zurückgegeben <xref:System.Numerics.Complex.One?displayProperty=nameWithType> / `value`.</span><span class="sxs-lookup"><span data-stu-id="b9077-567">Otherwise, it returns the result of the expression <xref:System.Numerics.Complex.One?displayProperty=nameWithType>/`value`.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-568">Im folgenden Beispiel wird die <xref:System.Numerics.Complex.Reciprocal%2A> Methode, um die reziproke Werte mehrerer komplexer Zahlen zu berechnen.</span><span class="sxs-lookup"><span data-stu-id="b9077-568">The following example uses the <xref:System.Numerics.Complex.Reciprocal%2A> method to calculate the reciprocal values of several complex numbers.</span></span> <span data-ttu-id="b9077-569">Es veranschaulicht auch, dass das Ergebnis der Multiplikation von einer komplexen Zahl mit der Kehrwert <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-569">It also demonstrates that the result of multiplying a complex number by its reciprocal is <xref:System.Numerics.Complex.One?displayProperty=nameWithType>.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/cs/reciprocal1.cs#1)]
 [!code-vb[System.Numerics.Complex.Reciprocal#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.reciprocal/vb/reciprocal1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Sin">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sin (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sin(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sin (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sin(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sin : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sin value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-570">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-570">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-571">Gibt den Sinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-571">Returns the sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-572">Der Sinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-572">The sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-573">Die <xref:System.Numerics.Complex.Sin%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Sin%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-573">The <xref:System.Numerics.Complex.Sin%2A> method for complex numbers corresponds to the <xref:System.Math.Sin%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-574">Die <xref:System.Numerics.Complex.Sin%2A> Methode anhand der folgende Formel berechnet den Sinus der komplexen Zahl a + Bi:</span><span class="sxs-lookup"><span data-stu-id="b9077-574">The <xref:System.Numerics.Complex.Sin%2A> method uses the following formula to calculate the sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b9077-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b9077-575">(<xref:System.Math.Sin%2A>(a) \* <xref:System.Math.Cosh%2A>(b), <xref:System.Math.Cos%2A>(a) \* <xref:System.Math.Sinh%2A>(b))</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-576">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Sin%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-576">The following example illustrates the <xref:System.Numerics.Complex.Sin%2A> method.</span></span> <span data-ttu-id="b9077-577">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Asin%2A> Methode, um die <xref:System.Numerics.Complex.Sin%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-577">It shows that passing the value returned by the <xref:System.Numerics.Complex.Asin%2A> method to the <xref:System.Numerics.Complex.Sin%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Asin#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.asin/cs/asin1.cs#1)]
 [!code-vb[System.Numerics.Complex.Asin#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.asin/vb/asin1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Asin(System.Double)" />
        <altmember cref="M:System.Numerics.Complex.Sin(System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Sinh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sinh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sinh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sinh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sinh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sinh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sinh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sinh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-578">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-578">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-579">Gibt den Hyperbelsinus der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-579">Returns the hyperbolic sine of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-580">Der Hyperbelsinus von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-580">The hyperbolic sine of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-581">Die <xref:System.Numerics.Complex.Sinh%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Sinh%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-581">The <xref:System.Numerics.Complex.Sinh%2A> method for complex numbers corresponds to the <xref:System.Math.Sinh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-582">Die <xref:System.Numerics.Complex.Sinh%2A> Methode anhand der folgende Formel berechnet den hyperbolischen Sinus der komplexen Zahl a + Bi:</span><span class="sxs-lookup"><span data-stu-id="b9077-582">The <xref:System.Numerics.Complex.Sinh%2A> method uses the following formula to calculate the hyperbolic sine of the complex number a + bi:</span></span>  
  
 <span data-ttu-id="b9077-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span><span class="sxs-lookup"><span data-stu-id="b9077-583">(<xref:System.Math.Sinh%2A>(a) \* <xref:System.Math.Cos%2A>(b), <xref:System.Math.Cosh%2A>(a) \* <xref:System.Math.Sin%2A>(b))</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Sinh(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Sqrt">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Sqrt (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Sqrt(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Sqrt(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Sqrt (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Sqrt(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Sqrt : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Sqrt value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-584">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-584">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-585">Gibt die Quadratwurzel einer angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-585">Returns the square root of a specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-586">Die Quadratwurzel von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-586">The square root of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-587">Die Quadratwurzel der komplexen Zahl `value` wird mithilfe der folgenden Formel berechnet:</span><span class="sxs-lookup"><span data-stu-id="b9077-587">The square root of the complex number `value` is calculated by using the following formula:</span></span>  
  
 <span data-ttu-id="b9077-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A> / 2.0)</span><span class="sxs-lookup"><span data-stu-id="b9077-588"><xref:System.Numerics.Complex.FromPolarCoordinates%2A?displayProperty=nameWithType>(<xref:System.Math.Sqrt%2A?displayProperty=nameWithType>(`value`.<xref:System.Numerics.Complex.Magnitude%2A>), `value`.<xref:System.Numerics.Complex.Phase%2A>/2.0)</span></span>   
  
 <span data-ttu-id="b9077-589">Die <xref:System.Numerics.Complex.Sqrt%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-589">The <xref:System.Numerics.Complex.Sqrt%2A> method for complex numbers corresponds to the <xref:System.Math.Sqrt%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Subtract">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Subtract (System.Numerics.Complex left, System.Numerics.Complex right);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Subtract(valuetype System.Numerics.Complex left, valuetype System.Numerics.Complex right) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Subtract(System.Numerics.Complex,System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Subtract (left As Complex, right As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Subtract(System::Numerics::Complex left, System::Numerics::Complex right);" />
      <MemberSignature Language="F#" Value="static member Subtract : System.Numerics.Complex * System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Subtract (left, right)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="left" Type="System.Numerics.Complex" />
        <Parameter Name="right" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="left"><span data-ttu-id="b9077-590">Der Wert, von dem subtrahiert werden soll (der Minuend).</span><span class="sxs-lookup"><span data-stu-id="b9077-590">The value to subtract from (the minuend).</span></span></param>
        <param name="right"><span data-ttu-id="b9077-591">Der Wert, der subtrahiert werden soll (der Subtrahend).</span><span class="sxs-lookup"><span data-stu-id="b9077-591">The value to subtract (the subtrahend).</span></span></param>
        <summary><span data-ttu-id="b9077-592">Subtrahiert eine komplexe Zahl von einer anderen komplexen Zahl und gibt das Ergebnis zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-592">Subtracts one complex number from another and returns the result.</span></span></summary>
        <returns><span data-ttu-id="b9077-593">Das Ergebnis der Subtraktion von <paramref name="right" /> von <paramref name="left" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-593">The result of subtracting <paramref name="right" /> from <paramref name="left" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-594">Eine komplexe Zahl, c + di, von einer anderen komplexen Zahl, die Subtraktion einen + Bi weist folgende Form:</span><span class="sxs-lookup"><span data-stu-id="b9077-594">The subtraction of a complex number, c + di, from another complex number, a + bi, takes the following form:</span></span>  
  
 <span data-ttu-id="b9077-595">(a - c) + (b - d) ich</span><span class="sxs-lookup"><span data-stu-id="b9077-595">(a - c) + (b - d)i</span></span>  
  
 <span data-ttu-id="b9077-596">Wenn die Methode Ergebnisse zu einem Überlauf entweder in der realen oder imaginären Komponente aufrufen, ist der Wert dieser Komponente <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> oder <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span><span class="sxs-lookup"><span data-stu-id="b9077-596">If the method call results in an overflow in either the real or imaginary component, the value of that component is either <xref:System.Double.PositiveInfinity?displayProperty=nameWithType> or <xref:System.Double.NegativeInfinity?displayProperty=nameWithType>.</span></span>  
  
 <span data-ttu-id="b9077-597">Sprachen, die keine benutzerdefinierte Operatoren unterstützen können die <xref:System.Numerics.Complex.Subtract%2A> Methode, um Subtraktion mit komplexen Zahlen durchzuführen.</span><span class="sxs-lookup"><span data-stu-id="b9077-597">Languages that do not support custom operators can use the <xref:System.Numerics.Complex.Subtract%2A> method to perform subtraction using complex numbers.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-598">Im folgende Beispiel wird jeder komplexe Zahl in einem Array aus einer komplexen Zahl subtrahiert.</span><span class="sxs-lookup"><span data-stu-id="b9077-598">The following example subtracts each complex number in an array from a complex number.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Subtract#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.subtract/cs/subtract1.cs#1)]
 [!code-vb[System.Numerics.Complex.Subtract#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.subtract/vb/subtract1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.op_Subtraction(System.Numerics.Complex,System.Numerics.Complex)" />
      </Docs>
    </Member>
    <Member MemberName="Tan">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tan (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tan(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tan(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tan (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tan(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tan : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tan value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-599">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-599">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-600">Gibt den Tangens der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-600">Returns the tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-601">Der Tangens von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-601">The tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-602">Die <xref:System.Numerics.Complex.Tan%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Tan%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-602">The <xref:System.Numerics.Complex.Tan%2A> method for complex numbers corresponds to the <xref:System.Math.Tan%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-603">Die <xref:System.Numerics.Complex.Tan%2A> Methode anhand der folgende Formel berechnet den Tangens der komplexen Zahl `value`:</span><span class="sxs-lookup"><span data-stu-id="b9077-603">The <xref:System.Numerics.Complex.Tan%2A> method uses the following formula to calculate the tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="b9077-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="b9077-604"><xref:System.Numerics.Complex.Sin%2A>(`value`) / <xref:System.Numerics.Complex.Cos%2A>(`value`)</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-605">Das folgende Beispiel veranschaulicht die <xref:System.Numerics.Complex.Tan%2A> Methode.</span><span class="sxs-lookup"><span data-stu-id="b9077-605">The following example illustrates the <xref:System.Numerics.Complex.Tan%2A> method.</span></span> <span data-ttu-id="b9077-606">Es wird gezeigt, dass durch Übergeben von zurückgegebenen Wert die <xref:System.Numerics.Complex.Atan%2A> Methode, um die <xref:System.Numerics.Complex.Tan%2A> Methode gibt zurück, die ursprüngliche <xref:System.Numerics.Complex> Wert.</span><span class="sxs-lookup"><span data-stu-id="b9077-606">It shows that passing the value returned by the <xref:System.Numerics.Complex.Atan%2A> method to the <xref:System.Numerics.Complex.Tan%2A> method returns the original <xref:System.Numerics.Complex> value.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Atan#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.atan/cs/atan1.cs#1)]
 [!code-vb[System.Numerics.Complex.Atan#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.atan/vb/atan1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Numerics.Complex.Atan(System.Numerics.Complex)" />
        <altmember cref="M:System.Math.Tan(System.Double)" />
      </Docs>
    </Member>
    <Member MemberName="Tanh">
      <MemberSignature Language="C#" Value="public static System.Numerics.Complex Tanh (System.Numerics.Complex value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig valuetype System.Numerics.Complex Tanh(valuetype System.Numerics.Complex value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.Tanh(System.Numerics.Complex)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function Tanh (value As Complex) As Complex" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Numerics::Complex Tanh(System::Numerics::Complex value);" />
      <MemberSignature Language="F#" Value="static member Tanh : System.Numerics.Complex -&gt; System.Numerics.Complex" Usage="System.Numerics.Complex.Tanh value" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Numerics.Complex" />
      </Parameters>
      <Docs>
        <param name="value"><span data-ttu-id="b9077-607">Eine komplexe Zahl.</span><span class="sxs-lookup"><span data-stu-id="b9077-607">A complex number.</span></span></param>
        <summary><span data-ttu-id="b9077-608">Gibt den Hyperbeltangens der angegebenen komplexen Zahl zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-608">Returns the hyperbolic tangent of the specified complex number.</span></span></summary>
        <returns><span data-ttu-id="b9077-609">Der Hyperbeltangens von <paramref name="value" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-609">The hyperbolic tangent of <paramref name="value" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-610">Die <xref:System.Numerics.Complex.Tanh%2A> Methode für komplexe Zahlen entspricht der <xref:System.Math.Tanh%2A?displayProperty=nameWithType> Methode für reelle Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-610">The <xref:System.Numerics.Complex.Tanh%2A> method for complex numbers corresponds to the <xref:System.Math.Tanh%2A?displayProperty=nameWithType> method for real numbers.</span></span>  
  
 <span data-ttu-id="b9077-611">Die <xref:System.Numerics.Complex.Tanh%2A> Methode anhand der folgende Formel berechnet den hyperbolischen Tangens der komplexen Zahl `value`:</span><span class="sxs-lookup"><span data-stu-id="b9077-611">The <xref:System.Numerics.Complex.Tanh%2A> method uses the following formula to calculate the hyperbolic tangent of the complex number `value`:</span></span>  
  
 <span data-ttu-id="b9077-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span><span class="sxs-lookup"><span data-stu-id="b9077-612"><xref:System.Numerics.Complex.Sinh%2A>(`value`) / <xref:System.Numerics.Complex.Cosh%2A>(`value`)</span></span>  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Math.Tanh(System.Double)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="ToString">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary><span data-ttu-id="b9077-613">Konvertiert den Wert einer komplexen Zahl in die entsprechende Zeichenfolgendarstellung.</span><span class="sxs-lookup"><span data-stu-id="b9077-613">Converts the value of a complex number to its equivalent string representation.</span></span></summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public override string ToString ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance string ToString() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function ToString () As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::String ^ ToString();" />
      <MemberSignature Language="F#" Value="override this.ToString : unit -&gt; string" Usage="complex.ToString " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary><span data-ttu-id="b9077-614">Konvertiert den Wert der aktuellen komplexen Zahl in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-614">Converts the value of the current complex number to its equivalent string representation in Cartesian form.</span></span></summary>
        <returns><span data-ttu-id="b9077-615">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-615">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-616">Die standardmäßige Zeichenfolgendarstellung einer komplexen Zahl zeigt die Anzahl, die unter Verwendung der kartesischen Koordinaten in der Form `(` *eine* `,` *b*`)`, wobei *eine* ist der reellen Teil der komplexen Zahl und *b* der imaginäre Teil.</span><span class="sxs-lookup"><span data-stu-id="b9077-616">The default string representation of a complex number displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b9077-617">Beide *eine* und *b* mithilfe der allgemeine Formatbezeichner ("G") und den Konventionen der aktuellen Systemkultur formatiert.</span><span class="sxs-lookup"><span data-stu-id="b9077-617">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the current system culture.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-618">Das folgende Beispiel zeigt die Zeichenfolgendarstellung mehrerer komplexer Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-618">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="b9077-619">Die Ausgabe verwendet die Formatierungskonventionen der Englisch - USA ("En-US") Kultur, die die aktuelle Systemkultur in diesem Fall ist.</span><span class="sxs-lookup"><span data-stu-id="b9077-619">The output uses the formatting conventions of the English - United States ("en-US") culture, which, in this case, is the current system culture.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring1.cs#1)]
 [!code-vb[System.Numerics.Complex.ToString#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring1.vb#1)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : IFormatProvider -&gt; string" Usage="complex.ToString provider" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="provider"><span data-ttu-id="b9077-620">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-620">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="b9077-621">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung der angegebenen kulturabhängigen Formatierungsinformationen in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-621">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified culture-specific formatting information.</span></span></summary>
        <returns><span data-ttu-id="b9077-622">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form entsprechend dem Wert von <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-622">The string representation of the current instance in Cartesian form, as specified by <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-623">Die Zeichenfolgendarstellung der komplexen Zahl, die von dieser Methode zurückgegebene zeigt die Anzahl, die unter Verwendung der kartesischen Koordinaten in der Form `(` *eine* `,` *b*`)`, in denen *eine* ist der reellen Teil der komplexen Zahl und *b* der imaginäre Teil.</span><span class="sxs-lookup"><span data-stu-id="b9077-623">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b9077-624">Beide *eine* und *b* mithilfe der allgemeine Formatbezeichner ("G") und die Konventionen der Kultur durch definiert formatiert `provider`.</span><span class="sxs-lookup"><span data-stu-id="b9077-624">Both *a* and *b* are formatted using the general format specifier ("G") and the conventions of the culture defined by `provider`.</span></span>  
  
 <span data-ttu-id="b9077-625">Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung.</span><span class="sxs-lookup"><span data-stu-id="b9077-625">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="b9077-626">Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Format der reellen und imaginären Zahlen in der zurückgegebenen Zeichenfolge bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-626">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="b9077-627">Wenn `provider` ist `null`, die zurückgegebene Zeichenfolge wird unter Verwendung formatiert die <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.</span><span class="sxs-lookup"><span data-stu-id="b9077-627">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="b9077-628">Die `provider` Parameter kann einen der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="b9077-628">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="b9077-629">Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-629">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="b9077-630">Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-630">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="b9077-631">Ein benutzerdefiniertes Objekt, das implementiert die <xref:System.IFormatProvider> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="b9077-631">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="b9077-632">Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-632">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-633">Das folgende Beispiel zeigt die Zeichenfolgendarstellung mehrerer komplexer Zahlen.</span><span class="sxs-lookup"><span data-stu-id="b9077-633">The following example displays the string representation of several complex numbers.</span></span> <span data-ttu-id="b9077-634">Das Ergebnis verwendet die Formatierungskonventionen der Englisch - USA ("En-US") und Französisch - Frankreich ("fr-FR") Kulturen.</span><span class="sxs-lookup"><span data-stu-id="b9077-634">The result uses the formatting conventions of the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#2](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring2.cs#2)]
 [!code-vb[System.Numerics.Complex.ToString#2](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring2.vb#2)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance string ToString(string format) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::String ^ ToString(System::String ^ format);" />
      <MemberSignature Language="F#" Value="override this.ToString : string -&gt; string" Usage="complex.ToString format" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="b9077-635">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-635">A standard or custom numeric format string.</span></span></param>
        <summary><span data-ttu-id="b9077-636">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung des angegebenen Formats für die reellen und imaginären Teile in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-636">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="b9077-637">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-637">The string representation of the current instance in Cartesian form.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-638">Die Zeichenfolgendarstellung der komplexen Zahl, die von dieser Methode zurückgegebene zeigt die Anzahl, die unter Verwendung der kartesischen Koordinaten in der Form `(` *eine* `,` *b*`)`, in denen *eine* ist der reellen Teil der komplexen Zahl und *b* der imaginäre Teil.</span><span class="sxs-lookup"><span data-stu-id="b9077-638">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b9077-639">Beide *eine* und *b* mithilfe der angegebenen Formatzeichenfolge formatiert `format`.</span><span class="sxs-lookup"><span data-stu-id="b9077-639">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="b9077-640">Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner oder eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein.</span><span class="sxs-lookup"><span data-stu-id="b9077-640">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="b9077-641">Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, die reellen und imaginären Teile der komplexen Zahl mit dem allgemeinen Formatbezeichner ("G") formatiert sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-641">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="b9077-642">Wenn `format` jeder andere Wert ist, löst die Methode eine <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-642">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="b9077-643">.NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen ausführlicher beschrieben wird:</span><span class="sxs-lookup"><span data-stu-id="b9077-643">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="b9077-644">Weitere Informationen zu numerischen Formatierungszeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="b9077-644">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="b9077-645">Weitere Informationen zur Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="b9077-645">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="b9077-646">Das Format der zurückgegebenen Zeichenfolge richtet sich nach der <xref:System.Globalization.NumberFormatInfo> Objekt für die aktuelle Kultur.</span><span class="sxs-lookup"><span data-stu-id="b9077-646">The format of the returned string is determined by the <xref:System.Globalization.NumberFormatInfo> object for the current culture.</span></span> <span data-ttu-id="b9077-647">Je nachdem auf die `format` -Parameter dieses Objekts steuert, Symbole, z. B. das negativen Vorzeichen, die das Gruppentrennzeichen und das Dezimaltrennzeichen in der Ausgabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-647">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="b9077-648">Aufrufen, um Formatierungsinformationen für Kulturen als der aktuellen Kultur zu ermöglichen, die <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> überladen.</span><span class="sxs-lookup"><span data-stu-id="b9077-648">To provide formatting information for cultures other than the current culture, call the <xref:System.Numerics.Complex.ToString%28System.String%2CSystem.IFormatProvider%29> overload.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-649">Im folgenden Beispiel wird eine komplexe Zahl initialisiert und über mehrere standard-Formatzeichenfolgen angezeigt.</span><span class="sxs-lookup"><span data-stu-id="b9077-649">The following example initializes a complex number and displays it using several standard format strings.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#3](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring3.cs#3)]
 [!code-vb[System.Numerics.Complex.ToString#3](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring3.vb#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b9077-650"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-650"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="b9077-651">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="b9077-651">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="b9077-652">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="b9077-652">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="ToString">
      <MemberSignature Language="C#" Value="public string ToString (string format, IFormatProvider provider);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance string ToString(string format, class System.IFormatProvider provider) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Numerics.Complex.ToString(System.String,System.IFormatProvider)" />
      <MemberSignature Language="VB.NET" Value="Public Function ToString (format As String, provider As IFormatProvider) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::String ^ ToString(System::String ^ format, IFormatProvider ^ provider);" />
      <MemberSignature Language="F#" Value="override this.ToString : string * IFormatProvider -&gt; string" Usage="complex.ToString (format, provider)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IFormattable.ToString(System.String,System.IFormatProvider)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="format" Type="System.String" />
        <Parameter Name="provider" Type="System.IFormatProvider" />
      </Parameters>
      <Docs>
        <param name="format"><span data-ttu-id="b9077-653">Eine standardmäßige oder benutzerdefinierte numerische Formatierungszeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-653">A standard or custom numeric format string.</span></span></param>
        <param name="provider"><span data-ttu-id="b9077-654">Ein Objekt, das kulturspezifische Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-654">An object that supplies culture-specific formatting information.</span></span></param>
        <summary><span data-ttu-id="b9077-655">Konvertiert den Wert der aktuellen komplexen Zahl unter Verwendung des angegebenen Formats und der angegebenen kulturabhängigen Formatierungsinformationen für die reellen und imaginären Teile in die entsprechende Zeichenfolgendarstellung in kartesischer Form.</span><span class="sxs-lookup"><span data-stu-id="b9077-655">Converts the value of the current complex number to its equivalent string representation in Cartesian form by using the specified format and culture-specific format information for its real and imaginary parts.</span></span></summary>
        <returns><span data-ttu-id="b9077-656">Die Zeichenfolgendarstellung der aktuellen Instanz in kartesischer Form entsprechend den Werten von <paramref name="format" /> und <paramref name="provider" />.</span><span class="sxs-lookup"><span data-stu-id="b9077-656">The string representation of the current instance in Cartesian form, as specified by <paramref name="format" /> and <paramref name="provider" />.</span></span></returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-657">Die Zeichenfolgendarstellung der komplexen Zahl, die von dieser Methode zurückgegebene zeigt die Anzahl, die unter Verwendung der kartesischen Koordinaten in der Form `(` *eine* `,` *b*`)`, in denen *eine* ist der reellen Teil der komplexen Zahl und *b* der imaginäre Teil.</span><span class="sxs-lookup"><span data-stu-id="b9077-657">The string representation of the complex number returned by this method displays the number using its Cartesian coordinates in the form `(`*a*`,` *b*`)`, where *a* is the real part of the complex number, and *b* is its imaginary part.</span></span> <span data-ttu-id="b9077-658">Beide *eine* und *b* mithilfe der angegebenen Formatzeichenfolge formatiert `format`.</span><span class="sxs-lookup"><span data-stu-id="b9077-658">Both *a* and *b* are formatted using the format string specified by `format`.</span></span> <span data-ttu-id="b9077-659">Die `format` Parameter kann eine beliebige gültige numerischer Standardformatbezeichner oder eine beliebige Kombination aus benutzerdefinierten Zahlenformatbezeichner sein.</span><span class="sxs-lookup"><span data-stu-id="b9077-659">The `format` parameter can be any valid standard numeric format specifier, or any combination of custom numeric format specifiers.</span></span> <span data-ttu-id="b9077-660">Wenn `format` gleich <xref:System.String.Empty?displayProperty=nameWithType> oder `null`, die reellen und imaginären Teile der komplexen Zahl mit dem allgemeinen Formatbezeichner ("G") formatiert sind.</span><span class="sxs-lookup"><span data-stu-id="b9077-660">If `format` is equal to <xref:System.String.Empty?displayProperty=nameWithType> or is `null`, the real and imaginary parts of the complex number are formatted with the general format specifier ("G").</span></span> <span data-ttu-id="b9077-661">Wenn `format` jeder andere Wert ist, löst die Methode eine <xref:System.FormatException>.</span><span class="sxs-lookup"><span data-stu-id="b9077-661">If `format` is any other value, the method throws a <xref:System.FormatException>.</span></span>  
  
 <span data-ttu-id="b9077-662">.NET Framework bietet umfangreiche formatierungsunterstützung, die in den folgenden Themen ausführlicher beschrieben wird:</span><span class="sxs-lookup"><span data-stu-id="b9077-662">The .NET Framework provides extensive formatting support, which is described in greater detail in the following topics:</span></span>  
  
-   <span data-ttu-id="b9077-663">Weitere Informationen zu numerischen Formatierungszeichenfolgen finden Sie unter [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) und [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span><span class="sxs-lookup"><span data-stu-id="b9077-663">For more information about numeric format strings, see [Standard Numeric Format Strings](~/docs/standard/base-types/standard-numeric-format-strings.md) and [Custom Numeric Format Strings](~/docs/standard/base-types/custom-numeric-format-strings.md).</span></span>  
  
-   <span data-ttu-id="b9077-664">Weitere Informationen zur Formatierung in .NET Framework finden Sie unter [Formatierung von Typen](~/docs/standard/base-types/formatting-types.md).</span><span class="sxs-lookup"><span data-stu-id="b9077-664">For more information about formatting in the .NET Framework, see [Formatting Types](~/docs/standard/base-types/formatting-types.md).</span></span>  
  
 <span data-ttu-id="b9077-665">Die `provider` -Parameter ist ein <xref:System.IFormatProvider> Implementierung.</span><span class="sxs-lookup"><span data-stu-id="b9077-665">The `provider` parameter is an <xref:System.IFormatProvider> implementation.</span></span> <span data-ttu-id="b9077-666">Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt eine <xref:System.Globalization.NumberFormatInfo> Objekt, das kulturspezifische Informationen zum Format der reellen und imaginären Zahlen in der zurückgegebenen Zeichenfolge bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-666">Its <xref:System.IFormatProvider.GetFormat%2A> method returns a <xref:System.Globalization.NumberFormatInfo> object that provides culture-specific information about the format of the real and imaginary numbers in the returned string.</span></span> <span data-ttu-id="b9077-667">Je nachdem auf die `format` -Parameter dieses Objekts steuert, Symbole, z. B. das negativen Vorzeichen, die das Gruppentrennzeichen und das Dezimaltrennzeichen in der Ausgabezeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-667">Depending on the `format` parameter, this object controls symbols such as the negative sign, the group separator, and the decimal point symbol in the output string.</span></span> <span data-ttu-id="b9077-668">Wenn `provider` ist `null`, die zurückgegebene Zeichenfolge wird unter Verwendung formatiert die <xref:System.Globalization.NumberFormatInfo> Objekt der aktuellen Kultur.</span><span class="sxs-lookup"><span data-stu-id="b9077-668">If `provider` is `null`, the returned string is formatted using the <xref:System.Globalization.NumberFormatInfo> object of the current culture.</span></span>  
  
 <span data-ttu-id="b9077-669">Die `provider` Parameter kann einen der folgenden sein:</span><span class="sxs-lookup"><span data-stu-id="b9077-669">The `provider` parameter can be one of the following:</span></span>  
  
-   <span data-ttu-id="b9077-670">Ein <xref:System.Globalization.CultureInfo> Objekt, das die Kultur darstellt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-670">A <xref:System.Globalization.CultureInfo> object that represents the culture that supplies formatting information</span></span>  
  
-   <span data-ttu-id="b9077-671">Die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-671">The <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
-   <span data-ttu-id="b9077-672">Ein benutzerdefiniertes Objekt, das implementiert die <xref:System.IFormatProvider> Schnittstelle.</span><span class="sxs-lookup"><span data-stu-id="b9077-672">A custom object that implements the <xref:System.IFormatProvider> interface.</span></span> <span data-ttu-id="b9077-673">Die <xref:System.IFormatProvider.GetFormat%2A> Methode gibt die <xref:System.Globalization.NumberFormatInfo> -Objekt, das Formatierungsinformationen bereitstellt.</span><span class="sxs-lookup"><span data-stu-id="b9077-673">Its <xref:System.IFormatProvider.GetFormat%2A> method returns the <xref:System.Globalization.NumberFormatInfo> object that supplies formatting information.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-674">Das folgende Beispiel erstellt ein Array der komplexen Zahlen und zeigt jeweils mehrere standard-Formatzeichenfolgen verwenden sowie <xref:System.Globalization.CultureInfo> Objekte, die die Kulturen Englisch - USA ("En-US") und Französisch - Frankreich ("fr-FR") darstellen.</span><span class="sxs-lookup"><span data-stu-id="b9077-674">The following example creates an array of complex numbers, and displays each using several standard format strings as well as <xref:System.Globalization.CultureInfo> objects that represent the English - United States ("en-US") and French - France ("fr-FR") cultures.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.ToString#4](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.tostring/cs/tostring4.cs#4)]
 [!code-vb[System.Numerics.Complex.ToString#4](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.tostring/vb/tostring4.vb#4)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.FormatException"><span data-ttu-id="b9077-675"><paramref name="format" /> ist keine gültige Formatzeichenfolge.</span><span class="sxs-lookup"><span data-stu-id="b9077-675"><paramref name="format" /> is not a valid format string.</span></span></exception>
        <related type="Article" href="~/docs/standard/base-types/standard-numeric-format-strings.md"><span data-ttu-id="b9077-676">Standardmäßige Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="b9077-676">Standard Numeric Format Strings</span></span></related>
        <related type="Article" href="~/docs/standard/base-types/custom-numeric-format-strings.md"><span data-ttu-id="b9077-677">Benutzerdefinierte Zahlenformatzeichenfolgen</span><span class="sxs-lookup"><span data-stu-id="b9077-677">Custom Numeric Format Strings</span></span></related>
      </Docs>
    </Member>
    <Member MemberName="Zero">
      <MemberSignature Language="C#" Value="public static readonly System.Numerics.Complex Zero;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.Numerics.Complex Zero" />
      <MemberSignature Language="DocId" Value="F:System.Numerics.Complex.Zero" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Zero As Complex " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Numerics::Complex Zero;" />
      <MemberSignature Language="F#" Value=" staticval mutable Zero : System.Numerics.Complex" Usage="System.Numerics.Complex.Zero" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Numerics</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.0.0</AssemblyVersion>
        <AssemblyVersion>4.1.1.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Numerics</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>netstandard</AssemblyName>
        <AssemblyVersion>2.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Numerics.Complex</ReturnType>
      </ReturnValue>
      <Docs>
        <summary><span data-ttu-id="b9077-678">Gibt eine neue <see cref="T:System.Numerics.Complex" />-Instanz mit einer reellen Zahl gleich 0 und einer imaginären Zahl gleich 0 zurück.</span><span class="sxs-lookup"><span data-stu-id="b9077-678">Returns a new <see cref="T:System.Numerics.Complex" /> instance with a real number equal to zero and an imaginary number equal to zero.</span></span></summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <span data-ttu-id="b9077-679">Die <xref:System.Numerics.Complex.Zero> Eigenschaft wird am häufigsten zum Vergleich einer <xref:System.Numerics.Complex> Wert 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-679">The <xref:System.Numerics.Complex.Zero> property is most frequently used to compare a <xref:System.Numerics.Complex> value to zero.</span></span>  
  
   
  
## Examples  
 <span data-ttu-id="b9077-680">Das folgende Beispiel instanziiert ein <xref:System.Numerics.Complex> Wert mithilfe der <xref:System.Numerics.Complex.Zero> Eigenschaft.</span><span class="sxs-lookup"><span data-stu-id="b9077-680">The following example instantiates a <xref:System.Numerics.Complex> value by using the <xref:System.Numerics.Complex.Zero> property.</span></span> <span data-ttu-id="b9077-681">Es vergleicht dann diesen Wert auf einen anderen Wert, der durch den Aufruf instanziiert wird die <xref:System.Numerics.Complex> Konstruktor mit einem echten gleich 0 (null) und einem imaginären Teil gleich 0 (null).</span><span class="sxs-lookup"><span data-stu-id="b9077-681">It then compares this value to another value that is instantiated by calling the <xref:System.Numerics.Complex> constructor with a real part equal to zero and an imaginary part equal to zero.</span></span> <span data-ttu-id="b9077-682">Wie die Ausgabe des Beispiels zeigt, sind die beiden Werte gleich.</span><span class="sxs-lookup"><span data-stu-id="b9077-682">As the output from the example shows, the two values are equal.</span></span>  
  
 [!code-csharp[System.Numerics.Complex.Zero#1](~/samples/snippets/csharp/VS_Snippets_CLR_System/system.numerics.complex.zero/cs/zero1.cs#1)]
 [!code-vb[System.Numerics.Complex.Zero#1](~/samples/snippets/visualbasic/VS_Snippets_CLR_System/system.numerics.complex.zero/vb/zero1.vb#1)]  
  
 ]]></format>
        </remarks>
        <altmember cref="F:System.Numerics.Complex.ImaginaryOne" />
        <altmember cref="F:System.Numerics.Complex.One" />
      </Docs>
    </Member>
  </Members>
</Type>