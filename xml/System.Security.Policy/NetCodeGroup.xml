<Type Name="NetCodeGroup" FullName="System.Security.Policy.NetCodeGroup">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="3cb0f97af74421f532dd05e94231b2ab08ceebc3" />
    <Meta Name="ms.sourcegitcommit" Value="d31dc2ede16f6f7bc64e90d9f897ff54c4e3869b" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="04/03/2018" />
    <Meta Name="ms.locfileid" Value="30500584" />
  </Metadata>
  <TypeSignature Language="C#" Value="public sealed class NetCodeGroup : System.Security.Policy.CodeGroup" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi serializable sealed beforefieldinit NetCodeGroup extends System.Security.Policy.CodeGroup" />
  <TypeSignature Language="DocId" Value="T:System.Security.Policy.NetCodeGroup" />
  <TypeSignature Language="VB.NET" Value="Public NotInheritable Class NetCodeGroup&#xA;Inherits CodeGroup" />
  <TypeSignature Language="C++ CLI" Value="public ref class NetCodeGroup sealed : System::Security::Policy::CodeGroup" />
  <AssemblyInfo>
    <AssemblyName>mscorlib</AssemblyName>
    <AssemblyVersion>2.0.5.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <AssemblyInfo>
    <AssemblyName>System.Security.Permissions</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Security.Policy.CodeGroup</BaseTypeName>
  </Base>
  <Interfaces />
  <Attributes>
    <Attribute>
      <AttributeName>System.Runtime.InteropServices.ComVisible(true)</AttributeName>
    </Attribute>
  </Attributes>
  <Docs>
    <summary>Erteilt Webberechtigung für die Site, aus der die Assembly heruntergeladen wurde. Diese Klasse kann nicht vererbt werden.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Codegruppen sind die Bausteine von Codezugriff-Sicherheitsrichtlinie. Jede Richtlinienebene besteht aus einer Stammcodegruppe, die eine oder mehrere untergeordnete Codegruppen aufweisen können. Jede untergeordnete Codegruppe kann eigene untergeordnete Codegruppen verfügen; Dieses Verhalten Erweitert auf eine beliebige Anzahl von Ebenen, die eine Struktur bilden. Jede Codegruppe verfügt über eine mitgliedschaftsbedingung, die bestimmt, ob eine bestimmte Assembly zu der Gruppe, die basierend auf den Beweis für diese Assembly gehört. Nur die, deren mitgliedschaftsbedingungen eine bestimmte Assembly, zusammen mit ihren untergeordnete Codegruppen entsprechen, Codegruppen gelten Codezugriff-Sicherheitsrichtlinie.  
  
 <xref:System.Security.Policy.NetCodeGroup> weist dieselbe Semantik wie der Merge <xref:System.Security.Policy.UnionCodeGroup>; er bildet die Kombination der <xref:System.Security.Policy.PolicyStatement> Objekte alle entsprechenden untergeordneten Codegruppen und <xref:System.Security.Policy.PolicyStatement> generiert aus der Eingabe <xref:System.Security.Policy.Url> Beweis. Allerdings <xref:System.Security.Policy.NetCodeGroup> gibt eine Berechtigung, die mit einer dynamisch berechneten <xref:System.Net.WebPermission> , gewährt Zugriff auf die Website zugreifen, von dem der Code ausgeführt wird. <xref:System.Security.Policy.UnionCodeGroup> gibt einfach einen statischen Berechtigungssatz zurück.  
  
 Wenn eine <xref:System.Security.Policy.NetCodeGroup> wird erstellt, es enthält die standardmäßige Verbindung Zugriffsregeln, die in der folgenden Tabelle gezeigt.  
  
|URI-Schema|Regel|  
|----------------|----------|  
|Datei|Lässt keinen Verbindungszugriff an den Ursprungsserver.|  
|http|HTTP- und HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
|https|HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
  
 Sie können steuern, das Schema und denselben Port, der Code zulässig ist, durch Übergabe an die Ursprungssite Verbindung mit einem <xref:System.Security.Policy.CodeConnectAccess> Objekt mit dem entsprechenden <xref:System.Security.Policy.CodeConnectAccess.Scheme%2A> und <xref:System.Security.Policy.CodeConnectAccess.Port%2A> Eigenschaftswerte die <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> Methode. Erstellen Sie eine Verbindung-Access-Regel, die gilt, wenn der Origin-Schema nicht vorhanden, in den Beweis ist oder nicht, durch Angabe erkannt wird <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> ("") als Formate. Sie können auch eine Verbindungszugriffsregel, die gilt, wenn die Regel keine Verbindung mit einem entsprechenden Schema vorhanden ist, indem erstellen <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> ("*") als Formate.  
  
> [!NOTE]
>  Wenn Code nicht das URI-Schema als Beweis übertragen hat, ist Zugriff mit einem beliebigen Schema wieder auf die Ursprungssite zulässig.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Security.Policy.NetCodeGroup> und Hinzufügen von <xref:System.Security.Policy.CodeConnectAccess> Objekte für Code, mit dem HTTP-Protokollschema heruntergeladen haben.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public NetCodeGroup (System.Security.Policy.IMembershipCondition membershipCondition);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Security.Policy.IMembershipCondition membershipCondition) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.#ctor(System.Security.Policy.IMembershipCondition)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (membershipCondition As IMembershipCondition)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; NetCodeGroup(System::Security::Policy::IMembershipCondition ^ membershipCondition);" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="membershipCondition" Type="System.Security.Policy.IMembershipCondition" />
      </Parameters>
      <Docs>
        <param name="membershipCondition">Eine Mitgliedschaftsbedingung, die Beweise überprüft, um zu ermitteln, ob diese Codegruppe Sicherheitsrichtlinien für den Codezugriff anwendet.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Security.Policy.NetCodeGroup" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine <xref:System.Security.Policy.NetCodeGroup> wird erstellt, es enthält die standardmäßige Verbindung Zugriffsregeln, die in der folgenden Tabelle gezeigt.  
  
|Schema|Regel|  
|------------|----------|  
|Datei|Lässt keinen Verbindungszugriff an den Ursprungsserver.|  
|http|HTTP- und HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
|https|HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen einer <xref:System.Security.Policy.NetCodeGroup> und Hinzufügen von <xref:System.Security.Policy.CodeConnectAccess> Objekte für Code, mit dem HTTP-Protokollschema heruntergeladen haben.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="membershipCondition" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Der Typ des <paramref name="membershipCondition" />-Parameters ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName="AbsentOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AbsentOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AbsentOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AbsentOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AbsentOriginScheme;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält einen Wert zum Angeben des Verbindungszugriffs für Code mit einem unbekannten oder nicht erkannten Ursprungsschema.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> -Methode, Sie geben ein Schema und eine zugeordnete <xref:System.Security.Policy.CodeConnectAccess> Objekt. Alle <xref:System.Security.Policy.CodeConnectAccess> Objekte, die Sie zum Hinzufügen der <xref:System.Security.Policy.NetCodeGroup> mit <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> als Ursprung Schema gelten, wenn der Code Ursprungsschema ist nicht in seinem Beweis vorhanden oder wird nicht für ein Schema vom erkannt die <xref:System.Security.Policy.NetCodeGroup> Objekt.  
  
 Angeben der <xref:System.Security.Policy.CodeConnectAccess> Objekte zu verwenden, wenn das Schema des Codes Ursprung der in der Menge der Ursprungsschemas hinzugefügt, mit dem aktuellen enthaltenen Schemas entspricht keiner <xref:System.Security.Policy.NetCodeGroup> -Objekts die <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> Wert.  
  
 Der Wert, der die <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> Feld ist eine leere Zeichenfolge ("").  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddConnectAccess">
      <MemberSignature Language="C#" Value="public void AddConnectAccess (string originScheme, System.Security.Policy.CodeConnectAccess connectAccess);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void AddConnectAccess(string originScheme, class System.Security.Policy.CodeConnectAccess connectAccess) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.AddConnectAccess(System.String,System.Security.Policy.CodeConnectAccess)" />
      <MemberSignature Language="VB.NET" Value="Public Sub AddConnectAccess (originScheme As String, connectAccess As CodeConnectAccess)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void AddConnectAccess(System::String ^ originScheme, System::Security::Policy::CodeConnectAccess ^ connectAccess);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="originScheme" Type="System.String" />
        <Parameter Name="connectAccess" Type="System.Security.Policy.CodeConnectAccess" />
      </Parameters>
      <Docs>
        <param name="originScheme">Ein <see cref="T:System.String" />, der das Schema enthält, mit dem das Schema des Codes verglichen werden soll.</param>
        <param name="connectAccess">Ein <see cref="T:System.Security.Policy.CodeConnectAccess" /> zum Angeben des Schemas und des Ports, mit denen Code eine Rückverbindung mit dem Ursprungsserver herstellen kann.</param>
        <summary>Fügt der aktuellen Codegruppe den angegebenen Verbindungszugriff hinzu.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können mehrere hinzufügen <xref:System.Security.Policy.CodeConnectAccess> Objekte für die gleichen `origin scheme`. Wenn ein `origin scheme` verfügt bereits über ein oder mehrere zugeordnete <xref:System.Security.Policy.CodeConnectAccess> Objekte angeben `null` für `connectAccess` hat keine Auswirkungen. Wenn das Ursprungsschema nicht über zugeordnete <xref:System.Security.Policy.CodeConnectAccess> Objekten, das angibt `null` für `connectAccess` wird verhindert, dass Code mit dem ein Ursprungsschema, das entspricht `originScheme` auf seinen Ursprungsserver zugreifen.  
  
   
  
## Examples  
 Das folgende Codebeispiel veranschaulicht das Erstellen und Hinzufügen von <xref:System.Security.Policy.CodeConnectAccess> Datenbankobjekte in einem <xref:System.Security.Policy.NetCodeGroup>.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="originScheme" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">
          <paramref name="originScheme" /> enthält Zeichen, die in Schemas nicht zulässig sind.  
  
 - oder -   
  
 <paramref name="originScheme" /> = <see cref="F:System.Security.Policy.NetCodeGroup.AbsentOriginScheme" /> und <paramref name="connectAccess" /> geben <see cref="F:System.Security.Policy.CodeConnectAccess.OriginScheme" /> als Schema an.</exception>
      </Docs>
    </Member>
    <Member MemberName="AnyOtherOriginScheme">
      <MemberSignature Language="C#" Value="public static readonly string AnyOtherOriginScheme;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly string AnyOtherOriginScheme" />
      <MemberSignature Language="DocId" Value="F:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly AnyOtherOriginScheme As String " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::String ^ AnyOtherOriginScheme;" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Enthält einen Wert zum Angeben eines beliebigen undefinierten Ursprungsschemas.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Aufrufen der <xref:System.Security.Policy.NetCodeGroup.AddConnectAccess%2A> -Methode, Sie geben ein Schema und eine zugeordnete <xref:System.Security.Policy.CodeConnectAccess> Objekt. Können Sie den Wert von der <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> Feld an, die <xref:System.Security.Policy.CodeConnectAccess> Objekte, die für ein beliebiges Schema verwendet werden soll, die nicht explizit in der Menge der Ursprungsschemas hinzugefügt, mit dem aktuellen enthalten ist <xref:System.Security.Policy.NetCodeGroup> Objekt.  
  
 Die <xref:System.Security.Policy.CodeConnectAccess> Objekte angegeben, mit der <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> Feld werden nur verwendet, wenn das Schema des Codes Ursprung der in der Menge der Ursprungsschemas hinzugefügt, mit dem aktuellen enthaltenen Schemas entspricht keiner <xref:System.Security.Policy.NetCodeGroup> Objekt.  
  
 Angeben der <xref:System.Security.Policy.CodeConnectAccess> Objekte angewendet, wenn der Code Ursprungsschema nicht verfügbar in seinem Beweis ist oder nicht erkannt wird, verwenden die <xref:System.Security.Policy.NetCodeGroup.AbsentOriginScheme> Wert.  
  
 Der Wert, der die <xref:System.Security.Policy.NetCodeGroup.AnyOtherOriginScheme> Feld ist "*".  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AttributeString">
      <MemberSignature Language="C#" Value="public override string AttributeString { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string AttributeString" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.AttributeString" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property AttributeString As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ AttributeString { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Zeichenfolgendarstellung der Attribute der Richtlinienanweisung für die Codegruppe ab.</summary>
        <value>Immer <see langword="null" />.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Copy">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup Copy ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup Copy() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Copy" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Copy () As CodeGroup" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ Copy();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine tiefe Kopie der aktuellen Codegruppe.</summary>
        <returns>Eine äquivalente Kopie der aktuellen Codegruppe, einschließlich der entsprechenden Mitgliedschaftsbedingungen und untergeordneter Codegruppen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ist eine tiefe Kopie der Codegruppe, was bedeutet, dass Kopien aller Objekte, die die Codegruppe enthält auch vorgenommen werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateXml">
      <MemberSignature Language="C#" Value="protected override void CreateXml (System.Security.SecurityElement element, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void CreateXml(class System.Security.SecurityElement element, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.CreateXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub CreateXml (element As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void CreateXml(System::Security::SecurityElement ^ element, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="element">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Equals">
      <MemberSignature Language="C#" Value="public override bool Equals (object o);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Equals(object o) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Equals(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Equals (o As Object) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Equals(System::Object ^ o);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="o" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="o">Das mit der aktuellen Codegruppe zu vergleichende <see cref="T:System.Security.Policy.NetCodeGroup" />-Objekt.</param>
        <summary>Bestimmt, ob die angegebene Codegruppe mit der aktuellen Codegruppe übereinstimmt.</summary>
        <returns>
          <see langword="true" />, wenn die angegebene Codegruppe mit der aktuellen Codegruppe übereinstimmt, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die folgenden Daten dienen zum Bestimmen der Gleichheit zweier <xref:System.Security.Policy.NetCodeGroup> Objekte:  
  
-   Die <xref:System.Security.Policy.CodeGroup.Name%2A> und <xref:System.Security.Policy.CodeGroup.Description%2A> Eigenschaften.  
  
-   Die <xref:System.Security.Policy.CodeGroup.MembershipCondition%2A>-Eigenschaft  
  
-   Der Satz von Ursprungsschemas und den zugehörigen <xref:System.Security.Policy.CodeConnectAccess> Objekte.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetConnectAccessRules">
      <MemberSignature Language="C#" Value="public System.Collections.DictionaryEntry[] GetConnectAccessRules ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Collections.DictionaryEntry[] GetConnectAccessRules() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetConnectAccessRules" />
      <MemberSignature Language="VB.NET" Value="Public Function GetConnectAccessRules () As DictionaryEntry()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; cli::array &lt;System::Collections::DictionaryEntry&gt; ^ GetConnectAccessRules();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.DictionaryEntry[]</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die Verbindungszugriffsinformationen für die aktuelle Codegruppe ab.</summary>
        <returns>Ein <see cref="T:System.Collections.DictionaryEntry" />-Array, das Verbindungszugriffsinformationen enthält.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In jedem Wörterbucheintrag der <xref:System.Collections.DictionaryEntry.Key%2A> Eigenschaftswert ist das Ursprungsschema und die <xref:System.Collections.DictionaryEntry.Value%2A> Eigenschaftswert ist das Array von zugeordneten <xref:System.Security.Policy.CodeConnectAccess> Objekte. Wenn es keine zugeordnete sind <xref:System.Security.Policy.CodeConnectAccess> Objekte <xref:System.Collections.DictionaryEntry.Value%2A?displayProperty=nameWithType> ein leeres Array zurück.  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, die Verbindung-Zugriffsregeln für Anzeigen einer <xref:System.Security.Policy.NetCodeGroup> Objekt.  
  
 [!code-cpp[NclCodeGroup#8](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#8)]
 [!code-csharp[NclCodeGroup#8](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#8)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetHashCode">
      <MemberSignature Language="C#" Value="public override int GetHashCode ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int32 GetHashCode() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.GetHashCode" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetHashCode () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override int GetHashCode();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft den Hashcode der aktuellen Codegruppe ab.</summary>
        <returns>Der Hashcode der aktuellen Codegruppe.</returns>
        <remarks>To be added.</remarks>
        <altmember cref="M:System.Security.Policy.CodeGroup.GetHashCode" />
      </Docs>
    </Member>
    <Member MemberName="MergeLogic">
      <MemberSignature Language="C#" Value="public override string MergeLogic { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string MergeLogic" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.MergeLogic" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property MergeLogic As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ MergeLogic { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die für das Zusammenführen von Gruppen zu verwendende Logik ab.</summary>
        <value>Die Zeichenfolge "Union".</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ParseXml">
      <MemberSignature Language="C#" Value="protected override void ParseXml (System.Security.SecurityElement e, System.Security.Policy.PolicyLevel level);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance void ParseXml(class System.Security.SecurityElement e, class System.Security.Policy.PolicyLevel level) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ParseXml(System.Security.SecurityElement,System.Security.Policy.PolicyLevel)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Sub ParseXml (e As SecurityElement, level As PolicyLevel)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override void ParseXml(System::Security::SecurityElement ^ e, System::Security::Policy::PolicyLevel ^ level);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="e" Type="System.Security.SecurityElement" />
        <Parameter Name="level" Type="System.Security.Policy.PolicyLevel" />
      </Parameters>
      <Docs>
        <param name="e">To be added.</param>
        <param name="level">To be added.</param>
        <summary>To be added.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="PermissionSetName">
      <MemberSignature Language="C#" Value="public override string PermissionSetName { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string PermissionSetName" />
      <MemberSignature Language="DocId" Value="P:System.Security.Policy.NetCodeGroup.PermissionSetName" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property PermissionSetName As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ PermissionSetName { System::String ^ get(); };" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des <see cref="T:System.Security.NamedPermissionSet" /> für die Codegruppe ab.</summary>
        <value>Immer die Zeichenfolge "Gleicher Web."</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="ResetConnectAccess">
      <MemberSignature Language="C#" Value="public void ResetConnectAccess ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void ResetConnectAccess() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResetConnectAccess" />
      <MemberSignature Language="VB.NET" Value="Public Sub ResetConnectAccess ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void ResetConnectAccess();" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt alle Verbindungszugriffsinformationen der aktuellen Codegruppe.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden Sie diese Methode, um die vom System bereitgestellten Standard-Verbindung Zugriffsregeln entfernt werden sollen.  
  
 In der folgenden Tabelle werden die Standardregeln angezeigt.  
  
|Schema|Regel|  
|------------|----------|  
|Datei|Lässt keinen Verbindungszugriff an den Ursprungsserver.|  
|http|HTTP- und HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
|https|HTTPS-Zugriff ist über den Ursprung Port zulässig.|  
  
   
  
## Examples  
 Im folgenden Codebeispiel wird veranschaulicht, das Aufrufen dieser Methode, um die standardmäßige Code Verbindung Zugriffsregeln entfernt werden sollen.  
  
 [!code-cpp[NclCodeGroup#3](~/samples/snippets/cpp/VS_Snippets_Remoting/NclCodeGroup/cpp/sample.cpp#3)]
 [!code-csharp[NclCodeGroup#3](~/samples/snippets/csharp/VS_Snippets_Remoting/NclCodeGroup/CS/sample.cs#3)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resolve">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.PolicyStatement Resolve (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.PolicyStatement Resolve(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.Resolve(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::PolicyStatement ^ Resolve(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.PolicyStatement</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Die <see cref="T:System.Security.Policy.Evidence" /> für die Assembly.</param>
        <summary>Löst für einen Beweissatz Richtlinien für die Codegruppe und deren untergeordnete Elemente auf.</summary>
        <returns>Ein <see cref="T:System.Security.Policy.PolicyStatement" />, das aus den von der Codegruppe erteilten Berechtigungen mit optionalen Attributen besteht, oder <see langword="null" />, wenn die Codegruppe nicht angewendet werden kann, weil die Mitgliedschaftsbedingung nicht mit den angegebenen Beweisen übereinstimmt.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wertet angegebene Beweis für eine Assembly geladen werden, den Codegruppe durch zunächst geprüft wird, der die mitgliedschaftsbedingung mit den angegebenen Beweisen. Wenn eine Übereinstimmung vorhanden ist, gibt diese Methode eine Policy-Anweisung für die Codegruppe, einschließlich der Evaluierung von untergeordnete Codegruppen an.  
  
 Die Ausführung von dieser Methode lautet wie folgt:  
  
 Wenn die mitgliedschaftsbedingung die angegebene Beweise nicht übereinstimmt, zurück `null`ist, andernfalls Satz der Berechtigungssatz (P) zurückgegeben werden gleich der Codegruppe Policy-Anweisung und den Vorgang fortzusetzen. Für jede untergeordnete Codegruppe die Codegruppe mit denselben Beweisen; aufgelöst Wenn das Ergebnis nicht `null`, diese Policy-Anweisung zurückzugeben. Wenn keine untergeordnete Codegruppe abgeglichen wird, zurückgeben Sie P (des übergeordneten Elements Policy-Anweisung).  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="evidence" />-Parameter ist <see langword="null" />.</exception>
        <exception cref="T:System.Security.Policy.PolicyException">Es sind mehrere Codegruppen mit <see cref="F:System.Security.Policy.PolicyStatementAttribute.Exclusive" /> gekennzeichnet, einschließlich der übergeordneten und sämtlicher untergeordneten Codegruppen.</exception>
      </Docs>
    </Member>
    <Member MemberName="ResolveMatchingCodeGroups">
      <MemberSignature Language="C#" Value="public override System.Security.Policy.CodeGroup ResolveMatchingCodeGroups (System.Security.Policy.Evidence evidence);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Security.Policy.CodeGroup ResolveMatchingCodeGroups(class System.Security.Policy.Evidence evidence) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Security.Policy.NetCodeGroup.ResolveMatchingCodeGroups(System.Security.Policy.Evidence)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Security::Policy::CodeGroup ^ ResolveMatchingCodeGroups(System::Security::Policy::Evidence ^ evidence);" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>mscorlib</AssemblyName>
        <AssemblyVersion>2.0.5.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <AssemblyInfo>
        <AssemblyName>System.Security.Permissions</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Security.Policy.CodeGroup</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="evidence" Type="System.Security.Policy.Evidence" />
      </Parameters>
      <Docs>
        <param name="evidence">Der Beweis für die Assembly.</param>
        <summary>Löst übereinstimmende Codegruppen auf.</summary>
        <returns>Der vollständige Satz von Codegruppen, die dem Beweis entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wertet angegebene Beweis für eine Assembly geladen werden, den Codegruppe durch zunächst geprüft wird, der die mitgliedschaftsbedingung mit den angegebenen Beweisen. Wenn eine Übereinstimmung vorhanden ist, gibt diese Methode eine Stammcodegruppe zurück. Die Codegruppe an, die zurückgegeben werden kann, untergeordnete Codegruppen enthalten, die wiederum auch untergeordnete Codegruppen, möglicherweise so, dass der Rückgabewert gibt den vollständigen Satz von Codegruppen wieder, die von den bereitgestellten Beweisen abgeglichen wurden.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der <paramref name="evidence" />-Parameter ist <see langword="null" />.</exception>
      </Docs>
    </Member>
  </Members>
</Type>