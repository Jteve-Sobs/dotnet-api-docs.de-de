<Type Name="Animatable" FullName="System.Windows.Media.Animation.Animatable">
  <Metadata><Meta Name="ms.openlocfilehash" Value="d76f2c0965e10e5062bdfec4d16886dd46b80a71" /><Meta Name="ms.sourcegitcommit" Value="055a4a82a0b08bfbdc21bd1347fb71f7fe2c099e" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="08/15/2019" /><Meta Name="ms.locfileid" Value="69166244" /></Metadata><TypeSignature Language="C#" Value="public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Animatable extends System.Windows.Freezable implements class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Animatable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Animatable&#xA;Inherits Freezable&#xA;Implements IAnimatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Animatable abstract : System::Windows::Freezable, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type Animatable = class&#xA;    inherit Freezable&#xA;    interface IAnimatable&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Eine abstrakte Klasse, die Unterstützung für Animationen bereitstellt.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Animatable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Animatable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Animatable" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Animiert die angegebene <see cref="T:System.Windows.DependencyProperty" /> mit der angegebenen <see cref="T:System.Windows.Media.Animation.AnimationClock" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="clock">Der Takt, mit dem die angegebene Eigenschaft animiert werden soll. Wenn <paramref name="clock" /> gleich <see langword="null" /> ist, werden alle Animationen aus der angegebenen Eigenschaft entfernt (jedoch nicht angehalten).</param>
        <summary>Wendet einen <see cref="T:System.Windows.Media.Animation.AnimationClock" /> auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Wenn die Eigenschaft bereits animiert wird, wird das <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />-Übergabeverhalten verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass durch die Verwendung dieser Methode zum Entfernen von Uhren aus einer Eigenschaft diese Uhren nicht angehalten werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="clock">Der Takt, mit dem die angegebene Eigenschaft animiert werden soll. Wenn <paramref name="handoffBehavior" /> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und <paramref name="clock" /><see langword="null" /> ist, werden alle Animationen aus der angegebenen Eigenschaft entfernt (jedoch nicht angehalten). Wenn für <paramref name="handoffBehavior" /> der Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> festgelegt ist und clock <see langword="null" /> ist, hat diese Methode keine Auswirkungen.</param>
        <param name="handoffBehavior">Ein Wert, der angibt, wie die neue Animation ggf. mit aktuellen Animationen interagieren soll, die sich bereits auf den Eigenschaftswert auswirken.</param>
        <summary>Wendet einen <see cref="T:System.Windows.Media.Animation.AnimationClock" /> auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Wenn die Eigenschaft bereits animiert wird, wird das angegebene <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass durch die Verwendung dieser Methode zum Entfernen von Uhren aus einer Eigenschaft diese Uhren nicht angehalten werden.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn <xref:System.Windows.Media.Animation.Storyboard>Sie <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline> <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe<xref:System.Windows.Media.Animation.HandoffBehavior>von anwenden, verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem wird nicht Entfernen Sie diese Uhren automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>mithilfe von anwenden, sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Sie <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> die-Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter `null` und als Sekunde an. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Um <xref:System.Windows.Media.Animation.AnimationClock> einen bestimmten aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.AnimationClock> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.ClockController>um eine abzurufen, <xref:System.Windows.Media.Animation.ClockController.Remove%2A> und rufen Sie dann die-Methode von auf. Dies erfolgt in der <xref:System.Windows.Media.Animation.Clock.Completed> Regel im Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem <xref:System.Windows.Media.Animation.ClockController>gesteuert werden können; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> -Eigenschaft einer untergeordneten `null`Uhr gibt zurück. Beachten Sie auch, <xref:System.Windows.Media.Animation.Clock.Completed> dass das Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann er aufgerufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>werden soll.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt an den Garbage Collector übergeben wird, werden auch die Uhren getrennt und an den Garbage Collector übergeben.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter [Übersicht über das Animations-und Zeit Steuerungssystem](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie Animations Uhren mit <xref:System.Windows.Media.Animation.HandoffBehavior> unterschiedlichen Einstellungen anwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="animatable.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="animation">Die Animation, mit der die angegebene Eigenschaft animiert werden soll.  
  
Wenn die <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> der Animation <see langword="null" /> ist, werden alle aktuellen Animationen entfernt und der aktuelle Wert der Eigenschaft bleibt erhalten.  
  
Wenn <paramref name="animation" /> ist <see langword="null" />, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert zurückgesetzt.</param>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Die Animation wird gestartet, wenn der nächste Frame gerendert wird. Wenn die angegebene Eigenschaft bereits animiert wird, wird das <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />-Übergabeverhalten verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Animation <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> größer als 0 (null) ist, beginnt die Animation, nachdem diese Zeitspanne von dem Zeitpunkt, an dem der nächste Frame gerendert wurde, verstrichen ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="animation">Die Animation, mit der die angegebene Eigenschaft animiert werden soll.  
  
Wenn <paramref name="handoffBehavior" /> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und die <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> der Animation <see langword="null" /> ist, werden aktuelle Animationen entfernt, und der aktuelle Werte der Eigenschaft wird beibehalten.  
  
Wenn <paramref name="handoffBehavior" /> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und <paramref name="animation" /> ein <see langword="null" />-Verweis ist, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert der Eigenschaft zurückgesetzt.  
  
Wenn <paramref name="handoffBehavior" /> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> aufweist und die Animation oder ihre <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /><see langword="null" /> ist, hat diese Methode keine Auswirkungen.</param>
        <param name="handoffBehavior">Ein Wert, der angibt, wie die neue Animation ggf. mit aktuellen Animationen interagieren soll, die sich bereits auf den Eigenschaftswert auswirken.</param>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Die Animation wird gestartet, wenn der nächste Frame gerendert wird. Wenn die angegebene Eigenschaft bereits animiert wird, wird das angegebene <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Animation <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> größer als 0 (null) ist, beginnt die Animation, nachdem diese Zeitspanne von dem Zeitpunkt, an dem der nächste Frame gerendert wurde, verstrichen ist.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn <xref:System.Windows.Media.Animation.Storyboard>Sie <xref:System.Windows.Media.Animation.Clock> , <xref:System.Windows.Media.Animation.AnimationTimeline> <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe<xref:System.Windows.Media.Animation.HandoffBehavior>von anwenden, verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem wird nicht Entfernen Sie diese Uhren automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>mithilfe von anwenden, sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> Sie <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> die-Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter `null` und als Sekunde an. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Um <xref:System.Windows.Media.Animation.AnimationClock> einen bestimmten aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> <xref:System.Windows.Media.Animation.ClockController> <xref:System.Windows.Media.Animation.AnimationClock> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.ClockController>um eine abzurufen, <xref:System.Windows.Media.Animation.ClockController.Remove%2A> und rufen Sie dann die-Methode von auf. Dies erfolgt in der <xref:System.Windows.Media.Animation.Clock.Completed> Regel im Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem <xref:System.Windows.Media.Animation.ClockController>gesteuert werden können; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> -Eigenschaft einer untergeordneten `null`Uhr gibt zurück. Beachten Sie auch, <xref:System.Windows.Media.Animation.Clock.Completed> dass das Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann er aufgerufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>werden soll.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt an den Garbage Collector übergeben wird, werden auch die Uhren getrennt und an den Garbage Collector übergeben.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter [Übersicht über das Animations-und Zeit Steuerungssystem](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Animationen mit unter <xref:System.Windows.Media.Animation.HandoffBehavior> schiedlichen Einstellungen angewendet werden.  
  
 [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/cpp/VS_Snippets_Wpf/animateproperty/CPP/InteractiveExample.cpp#interactiveanimationexamplewholepage)]
 [!code-csharp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animateproperty/CSharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]
 [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateproperty/VisualBasic/InteractiveExample.vb#interactiveanimationexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Animatable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Animatable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Animatable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Animatable ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Animatable" Usage="animatable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Animatable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.Animation.Animatable" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften dieses Objekts kopiert diese Methode Ressourcenverweise und Datenbindungen (die jedoch möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon dieser Instanz. Bei dem zurückgegebenen Klon handelt es sich im Grunde um eine tiefe Kopie des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des Klons ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Animation.Animatable.Clone%2A> -Methode kann verwendet werden, um änderbare Kopien <xref:System.Windows.Freezable> von fixierten Objekten zu liefern. Aus Gründen der praktische überschattet diese Methode <xref:System.Windows.Freezable.Clone%2A> die geerbte Methode, um eine stark typisierte Implementierung bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="override this.FreezeCore : bool -&gt; bool" Usage="animatable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking"><see langword="true" />, wenn diese Methode lediglich bestimmen soll, ob diese Instanz fixiert werden kann. <see langword="false" />, wenn diese Instanz beim Aufrufen dieser Methode tatsächlich fixiert werden soll.</param>
        <summary>Legt dieses <see cref="T:System.Windows.Media.Animation.Animatable" />-Objekt als nicht änderbar fest oder bestimmt, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn dieses <see cref="T:System.Windows.Media.Animation.Animatable" />-Objekt als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn es nicht als nicht änderbar festgelegt werden kann.  
  
Wenn <paramref name="isChecking" /><see langword="false" /> ist und dieser <see cref="T:System.Windows.Media.Animation.Animatable" /> jetzt nicht änderbar ist, gibt diese Methode <see langword="true" /> zurück, oder sie gibt <see langword="false" /> zurück, wenn er nicht als nicht änderbar festgelegt werden kann, mit dem Nebeneffekt, dass begonnen wurde, den fixierten Status des Objekts zu ändern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt zurück `false` , <xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A> `true`wenn den Wert hat.  
  
 Rufen Sie diese Methode nicht direkt auf (außer beim Aufrufen von base in einer-Implementierung). Diese <xref:System.Windows.Freezable.CanFreeze%2A> Methode wird intern von (mit `isChecking` gleich `true`) und <xref:System.Windows.Freezable.Freeze%2A> (mit `isChecking` gleich `false`) aufgerufen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Klassen, die von <see cref="T:System.Windows.Media.Animation.Animatable" /> abgeleitet werden, müssen diese Methode überschreiben, wenn die Klasse Daten enthält, die nicht mithilfe von Abhängigkeits Eigenschaften gespeichert werden.  
  
Bei einer typischen-Implementierung wird die Basis Implementierung aufgerufen, anschließend wird <see cref="M:System.Windows.Freezable.Freeze" /> die statische- <see cref="T:System.Windows.Freezable" /> Methode für alle typisierten Eigenschaften aufgerufen, <see langword="true" /> die in der-Klasse enthalten sind, und nur zurückgegeben, wenn alle Eigenschaften fixiert (oder eingefroren) werden. der Fall, dass ein <see langword="false" /> Wert für <paramref name="isChecking" />übergeben wird.</para></block>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="animatable.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Bezeichnet die Eigenschaft, deren Basiswert (nicht animiert) abgerufen werden soll.</param>
        <summary>Gibt den nicht animierten Wert der angegebenen <see cref="T:System.Windows.DependencyProperty" /> zurück.</summary>
        <returns>Der Wert, der zurückgegeben wird, wenn die angegebene Eigenschaft nicht animiert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die angegebene Eigenschaft nicht animiert wird, gibt diese Methode dasselbe Ergebnis wie <xref:System.Windows.DependencyObject.GetValue%2A>zurück.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die nicht animierten Werte der animierten Eigenschaften abgerufen und angezeigt.  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob einer der Abhängigkeitseigenschaften dieses Objekts ein oder mehrere <see cref="T:System.Windows.Media.Animation.AnimationClock" />-Objekte zugeordnet sind.</summary>
        <value><see langword="true" /><see cref="T:System.Windows.Media.Animation.AnimationClock" /> ,<see langword="false" />wenn einem der Abhängigkeits Eigenschaften dieses Objekts ein oder mehrere-Objekte zugeordnet sind, andernfalls.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt nicht an, ob dieses Objekt animierte unter Objekte enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStoredWeakReference">
      <MemberSignature Language="C#" Value="public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ShouldSerializeStoredWeakReference(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ShouldSerializeStoredWeakReference (target As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ShouldSerializeStoredWeakReference(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ShouldSerializeStoredWeakReference : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Stellt ein Objekt dar, das am System der Abhängigkeitseigenschaften teilnimmt.</param>
        <summary>Gibt an, ob ein Abhängigkeitsobjekt serialisiert werden soll.</summary>
        <returns><see langword="true" />, um <paramref name="target" /> zu serialisieren; andernfalls <see langword="false" />. Die Standardeinstellung ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptor> -Klasse verwendet <xref:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference%2A> die-Methode, um zu bestimmen, ob eine Eigenschaft serialisiert werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
