<Type Name="Animatable" FullName="System.Windows.Media.Animation.Animatable">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="7faa98eb3177973c6082c9f012db32e1ad9d0968" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48649654" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class Animatable : System.Windows.Freezable, System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit Animatable extends System.Windows.Freezable implements class System.Windows.Media.Animation.IAnimatable" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Animatable" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class Animatable&#xA;Inherits Freezable&#xA;Implements IAnimatable" />
  <TypeSignature Language="C++ CLI" Value="public ref class Animatable abstract : System::Windows::Freezable, System::Windows::Media::Animation::IAnimatable" />
  <TypeSignature Language="F#" Value="type Animatable = class&#xA;    inherit Freezable&#xA;    interface IAnimatable&#xA;    interface DUCE.IResource" />
  <AssemblyInfo>
    <AssemblyName>PresentationCore</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Freezable</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Windows.Media.Animation.IAnimatable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Eine abstrakte Klasse, die Unterstützung für Animationen bereitstellt.</summary>
    <remarks>To be added.</remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected Animatable ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; Animatable();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Animatable" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ApplyAnimationClock">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Animiert die angegebene <see cref="T:System.Windows.DependencyProperty" /> mit der angegebenen <see cref="T:System.Windows.Media.Animation.AnimationClock" />.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)" />
      <MemberSignature Language="VB.NET" Value="Public Sub ApplyAnimationClock (dp As DependencyProperty, clock As AnimationClock)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="clock">Der Takt, mit dem die angegebene Eigenschaft animiert werden soll. Wenn <c>clock</c> gleich <see langword="null" /> ist, werden alle Animationen aus der angegebenen Eigenschaft entfernt (jedoch nicht angehalten).</param>
        <summary>Wendet einen <see cref="T:System.Windows.Media.Animation.AnimationClock" /> auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Wenn die Eigenschaft bereits animiert wird, wird das <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />-Übergabeverhalten verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass die Uhren mit dieser Methode zum Entfernen von Uhren aus einer Eigenschaft nicht angehalten werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ApplyAnimationClock">
      <MemberSignature Language="C#" Value="public void ApplyAnimationClock (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationClock clock, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void ApplyAnimationClock(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationClock clock, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void ApplyAnimationClock(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationClock ^ clock, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.ApplyAnimationClock : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationClock * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.ApplyAnimationClock (dp, clock, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.ApplyAnimationClock(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationClock,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="clock" Type="System.Windows.Media.Animation.AnimationClock" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="clock">Der Takt, mit dem die angegebene Eigenschaft animiert werden soll. Wenn <c>handoffBehavior</c> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und <c>clock</c><see langword="null" /> ist, werden alle Animationen aus der angegebenen Eigenschaft entfernt (jedoch nicht angehalten). Wenn für <c>handoffBehavior</c> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> aufweist und clock <see langword="null" /> ist, hat diese Methode keine Auswirkungen.</param>
        <param name="handoffBehavior">Ein Wert, der angibt, wie die neue Animation ggf. mit aktuellen Animationen interagieren soll, die sich bereits auf den Eigenschaftswert auswirken.</param>
        <summary>Wendet einen <see cref="T:System.Windows.Media.Animation.AnimationClock" /> auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Wenn die Eigenschaft bereits animiert wird, wird das angegebene <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass es sich bei Verwendung dieser Methode zum Entfernen von Uhren aus einer Eigenschaft die Uhren nicht angehalten werden.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht der Fall ist des Zeitsteuerungssystems Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden, können ein <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück, `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen werden, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall müssen die Benutzer zum Ermitteln des Zeitpunkts aufrufen, <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt an den Garbage Collector übergeben wird, werden auch die Uhren getrennt und an den Garbage Collector übergeben.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter den [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie mithilfe verschiedener Animationsuhren anwenden <xref:System.Windows.Media.Animation.HandoffBehavior> Einstellungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="BeginAnimation">
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)" />
      <MemberSignature Language="VB.NET" Value="Public Sub BeginAnimation (dp As DependencyProperty, animation As AnimationTimeline)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline -&gt; unit" Usage="animatable.BeginAnimation (dp, animation)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="animation">Die Animation, mit der die angegebene Eigenschaft animiert werden soll.  
  
Wenn die <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> der Animation <see langword="null" /> ist, werden aktuelle Animationen entfernt, und der aktuelle Wert der Eigenschaft wird beibehalten.  
  
Wenn <c>animation</c><see langword="null" /> ist, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert zurückgesetzt.</param>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Die Animation wird gestartet, wenn der nächste Frame gerendert wird. Wenn die angegebene Eigenschaft bereits animiert wird, wird das <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" />-Übergabeverhalten verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Animation hat eine <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> größer als 0 (null), die Animation beginnt, nach der angegebenen Zeitraum ab dem Zeitpunkt verstrichen ist der nächste Frame gerendert wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BeginAnimation">
      <MemberSignature Language="C#" Value="public void BeginAnimation (System.Windows.DependencyProperty dp, System.Windows.Media.Animation.AnimationTimeline animation, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void BeginAnimation(class System.Windows.DependencyProperty dp, class System.Windows.Media.Animation.AnimationTimeline animation, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void BeginAnimation(System::Windows::DependencyProperty ^ dp, System::Windows::Media::Animation::AnimationTimeline ^ animation, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="abstract member BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit&#xA;override this.BeginAnimation : System.Windows.DependencyProperty * System.Windows.Media.Animation.AnimationTimeline * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="animatable.BeginAnimation (dp, animation, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.BeginAnimation(System.Windows.DependencyProperty,System.Windows.Media.Animation.AnimationTimeline,System.Windows.Media.Animation.HandoffBehavior)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
        <Parameter Name="animation" Type="System.Windows.Media.Animation.AnimationTimeline" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="dp">Die zu animierende Eigenschaft.</param>
        <param name="animation">Die Animation, mit der die angegebene Eigenschaft animiert werden soll.  
  
Wenn <c>handoffBehavior</c> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und die <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /> der Animation <see langword="null" /> ist, werden aktuelle Animationen entfernt, und der aktuelle Werte der Eigenschaft wird beibehalten.  
  
Wenn <c>handoffBehavior</c> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace" /> aufweist und <c>animation</c> ein <see langword="null" />-Verweis ist, werden alle Animationen aus der Eigenschaft entfernt, und der Eigenschaftswert wird auf den Basiswert der Eigenschaft zurückgesetzt.  
  
Wenn <c>handoffBehavior</c> den Wert <see cref="F:System.Windows.Media.Animation.HandoffBehavior.Compose" /> aufweist und die Animation oder ihre <see cref="P:System.Windows.Media.Animation.Timeline.BeginTime" /><see langword="null" /> ist, hat diese Methode keine Auswirkungen.</param>
        <param name="handoffBehavior">Ein Wert, der angibt, wie die neue Animation ggf. mit aktuellen Animationen interagieren soll, die sich bereits auf den Eigenschaftswert auswirken.</param>
        <summary>Wendet eine Animation auf die angegebene <see cref="T:System.Windows.DependencyProperty" /> an. Die Animation wird gestartet, wenn der nächste Frame gerendert wird. Wenn die angegebene Eigenschaft bereits animiert wird, wird das angegebene <see cref="T:System.Windows.Media.Animation.HandoffBehavior" /> verwendet.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Animation hat eine <xref:System.Windows.Media.Animation.Timeline.BeginTime%2A> größer als 0 (null), die Animation beginnt, nach der angegebenen Zeitraum ab dem Zeitpunkt verstrichen ist der nächste Frame gerendert wird.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht der Fall ist des Zeitsteuerungssystems Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden, können ein <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück, `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen werden, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall müssen die Benutzer zum Ermitteln des Zeitpunkts aufrufen, <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt an den Garbage Collector übergeben wird, werden auch die Uhren getrennt und an den Garbage Collector übergeben.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter den [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie zum Anwenden von Animationen mit verschiedenen <xref:System.Windows.Media.Animation.HandoffBehavior> Einstellungen.  
  
 [!code-cpp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/cpp/VS_Snippets_Wpf/animateproperty/CPP/InteractiveExample.cpp#interactiveanimationexamplewholepage)]
 [!code-csharp[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animateproperty/CSharp/InteractiveExample.cs#interactiveanimationexamplewholepage)]
 [!code-vb[animateproperty#InteractiveAnimationExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animateproperty/VisualBasic/InteractiveExample.vb#interactiveanimationexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Animatable Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Animatable Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Animatable" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Animatable ^ Clone();" />
      <MemberSignature Language="F#" Value="member this.Clone : unit -&gt; System.Windows.Media.Animation.Animatable" Usage="animatable.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Animatable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.Animation.Animatable" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften dieses Objekts kopiert diese Methode Ressourcenverweise und Datenbindungen (die jedoch möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon dieser Instanz. Bei dem zurückgegebenen Klon handelt es sich im Grunde um eine tiefe Kopie des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des Klons ist **FALSE**.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Windows.Media.Animation.Animatable.Clone%2A> Methode kann verwendet werden, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte. Der Einfachheit halber diese Methode führt Shadowing für die geerbte <xref:System.Windows.Freezable.Clone%2A> Methode, um eine stark typisierte Implementierung bereitzustellen.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Freezable.Clone" />
      </Docs>
    </Member>
    <Member MemberName="FreezeCore">
      <MemberSignature Language="C#" Value="protected override bool FreezeCore (bool isChecking);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance bool FreezeCore(bool isChecking) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.FreezeCore(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function FreezeCore (isChecking As Boolean) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override bool FreezeCore(bool isChecking);" />
      <MemberSignature Language="F#" Value="abstract member FreezeCore : bool -&gt; bool&#xA;override this.FreezeCore : bool -&gt; bool" Usage="animatable.FreezeCore isChecking" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="isChecking" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="isChecking">
          <see langword="true" />, wenn die Methode lediglich bestimmen soll, ob diese Instanz eingefroren werden kann. <see langword="false" />, wenn diese Instanz bei einem Aufruf dieser Methode tatsächlich fixiert werden soll.</param>
        <summary>Legt dieses <see cref="T:System.Windows.Media.Animation.Animatable" />-Objekt als nicht änderbar fest oder bestimmt, ob es als nicht änderbar festgelegt werden kann.</summary>
        <returns>Wenn <paramref name="isChecking" /> den Wert <see langword="true" /> aufweist, gibt diese Methode <see langword="true" /> zurück, wenn dieses <see cref="T:System.Windows.Media.Animation.Animatable" />-Objekt als nicht änderbar festgelegt werden kann, oder <see langword="false" />, wenn es nicht als nicht änderbar festgelegt werden kann.  
  
Wenn <paramref name="isChecking" /><see langword="false" /> ist und dieser <see cref="T:System.Windows.Media.Animation.Animatable" /> jetzt nicht änderbar ist, gibt diese Methode <see langword="true" /> zurück, oder sie gibt <see langword="false" /> zurück, wenn er nicht als nicht änderbar festgelegt werden kann, mit dem Nebeneffekt, dass begonnen wurde, den fixierten Status des Objekts zu ändern.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt **"false"** beim <xref:System.Windows.Media.Animation.Animatable.HasAnimatedProperties%2A> ist **"true"**.  
  
 Rufen Sie diese Methode direkt (mit Ausnahme beim Aufrufen der Basis in einer Implementierung) nicht. Diese Methode wird intern von aufgerufen <xref:System.Windows.Freezable.CanFreeze%2A> (mit `isChecking` gleich `true`) und <xref:System.Windows.Freezable.Freeze%2A> (mit `isChecking` gleich `false`).  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Abgeleitete Klassen <see cref="T:System.Windows.Media.Animation.Animatable" /> müssen diese Methode überschreiben, wenn die Klasse Daten enthält, die nicht mit Abhängigkeitseigenschaften gespeichert.  
  
Eine typische Implementierung die basisimplementierung aufrufen würden, dann rufen Sie die statische <see cref="M:System.Windows.Freezable.Freeze" /> für alle <see cref="T:System.Windows.Freezable" /> typisierte Eigenschaften mit die Klasse zurückgeben, <see langword="true" /> nur dann, wenn alle Eigenschaften fixiert waren (oder konnte eingefroren wurde in der Groß-/Kleinschreibung durch Übergeben einer <see langword="false" /> Wert für <paramref name="isChecking" />).</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CloneCore(System.Windows.Freezable)" />
      </Docs>
    </Member>
    <Member MemberName="GetAnimationBaseValue">
      <MemberSignature Language="C#" Value="public object GetAnimationBaseValue (System.Windows.DependencyProperty dp);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object GetAnimationBaseValue(class System.Windows.DependencyProperty dp) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.GetAnimationBaseValue(System.Windows.DependencyProperty)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetAnimationBaseValue (dp As DependencyProperty) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Object ^ GetAnimationBaseValue(System::Windows::DependencyProperty ^ dp);" />
      <MemberSignature Language="F#" Value="abstract member GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj&#xA;override this.GetAnimationBaseValue : System.Windows.DependencyProperty -&gt; obj" Usage="animatable.GetAnimationBaseValue dp" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Windows.Media.Animation.IAnimatable.GetAnimationBaseValue(System.Windows.DependencyProperty)</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="dp" Type="System.Windows.DependencyProperty" />
      </Parameters>
      <Docs>
        <param name="dp">Bezeichnet die Eigenschaft, deren Basiswert (nicht animiert) abgerufen werden soll.</param>
        <summary>Gibt den nicht animierten Wert der angegebenen <see cref="T:System.Windows.DependencyProperty" /> zurück.</summary>
        <returns>Der Wert, der zurückgegeben wird, wenn die angegebene Eigenschaft nicht animiert ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn es sich bei die angegebene Eigenschaft nicht animiert ist, gibt diese Methode das gleiche Ergebnis wie <xref:System.Windows.DependencyObject.GetValue%2A>.  
  
   
  
## Examples  
 Im folgenden Beispiel werden die Werte nicht animiert animierte Eigenschaften abgerufen und angezeigt.  
  
 [!code-csharp[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/GetAnimationBaseValueExample.cs#getanimationbasevalueexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#GetAnimationBaseValueExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/getanimationbasevalueexample.vb#getanimationbasevalueexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="HasAnimatedProperties">
      <MemberSignature Language="C#" Value="public bool HasAnimatedProperties { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasAnimatedProperties" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasAnimatedProperties As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasAnimatedProperties { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasAnimatedProperties : bool" Usage="System.Windows.Media.Animation.Animatable.HasAnimatedProperties" />
      <MemberType>Property</MemberType>
      <Implements>
        <InterfaceMember>P:System.Windows.Media.Animation.IAnimatable.HasAnimatedProperties</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob einer der Abhängigkeitseigenschaften dieses Objekts ein oder mehrere <see cref="T:System.Windows.Media.Animation.AnimationClock" />-Objekte zugeordnet sind.</summary>
        <value>**"true"** eine oder mehrere <see cref="T:System.Windows.Media.Animation.AnimationClock" /> Objekte ist einer der Abhängigkeitseigenschaften dieses Objekts zugeordnet ist, andernfalls **"false"**.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt nicht an, ob dieses Objekt über animierte untergeordnete Objekte enthält.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ShouldSerializeStoredWeakReference">
      <MemberSignature Language="C#" Value="public static bool ShouldSerializeStoredWeakReference (System.Windows.DependencyObject target);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig bool ShouldSerializeStoredWeakReference(class System.Windows.DependencyObject target) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function ShouldSerializeStoredWeakReference (target As DependencyObject) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static bool ShouldSerializeStoredWeakReference(System::Windows::DependencyObject ^ target);" />
      <MemberSignature Language="F#" Value="static member ShouldSerializeStoredWeakReference : System.Windows.DependencyObject -&gt; bool" Usage="System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference target" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationCore</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.EditorBrowsable</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.EditorBrowsable(System.ComponentModel.EditorBrowsableState.Never)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="target" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="target">Stellt ein Objekt dar, das im Abhängigkeitseigenschaftensystem teilnimmt.</param>
        <summary>Gibt an, ob ein Abhängigkeitsobjekt serialisiert werden soll.</summary>
        <returns>
          <see langword="true" />, um <paramref name="target" /> zu serialisieren; andernfalls <see langword="false" />. Der Standardwert ist <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.ComponentModel.TypeDescriptor> -Klasse verwendet die <xref:System.Windows.Media.Animation.Animatable.ShouldSerializeStoredWeakReference%2A> Methode, um zu bestimmen, ob eine Eigenschaft serialisiert werden soll.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>