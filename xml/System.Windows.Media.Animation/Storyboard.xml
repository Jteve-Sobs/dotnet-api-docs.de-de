<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="277dccf156343c8e0c972aed5cd1f2cf6e323c87" />
    <Meta Name="ms.sourcegitcommit" Value="0ec122ee5f3681159b8460ab15b409fd6e3d3ae0" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="10/04/2018" />
    <Meta Name="ms.locfileid" Value="48646417" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ein Containerzeitachse, die Zielinformationen zu Objekten und Eigenschaften für die untergeordneten Animationen bereitstellt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Interaktives Steuern von Storyboards  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Markup steuerbar machen, legen Sie die <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> Eigenschaft der <xref:System.Windows.Media.Animation.BeginStoryboard> Datenobjekt ab, erstellt es; ein Beispiel finden Sie unter [Vorgehensweise: Verwenden von Ereignistriggern zum Steuern einer Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts.md). Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="data-binding-and-animating-timelines"></a>Datenbindung und Animieren von Zeitachsen  
 Die meisten Zeitachsen-Eigenschaften können an Daten gebunden oder animiert sein; jedoch aufgrund der Funktionsweise des Zeitsteuerungssystems datengebundene oder animierte Zeitachsen nicht wie andere Verhalten gebunden oder animierte Objekte. Um ihr Verhalten zu verstehen, ist es hilfreich um zu verstehen, was es bedeutet, die eine Zeitachse zu aktivieren.  
  
 Wenn eine Zeitachse aktiviert ist, werden Kopien der Zeitachse und deren untergeordnete Zeitachsen erstellt. Diese Kopien werden gesperrt (schreibgeschützt) und <xref:System.Windows.Media.Animation.Clock> Objekte daraus erstellt werden. Das eigentliche Animieren der Zieleigenschaften erfolgt durch diese Uhren. Wenn eine Zeitachse ist datengebundene oder animierte, eine Momentaufnahme der aktuellen Werte erfolgt, wenn die Uhr erstellt wird. Obwohl die ursprüngliche Zeitachse ändern weiterhin, nicht die Uhr.  
  
 Für ein Timeline Daten Datenbindung oder Animation widerzuspiegeln muss die Uhr neu erstellt werden. Uhren werden nicht für Sie automatisch neu erstellt. Im Folgenden werden verschiedene Methoden beschrieben, wie Änderungen der Zeitachse übernommen werden können:  
  
-   Wenn die Zeitachse oder gehört zu einer <xref:System.Windows.Media.Animation.Storyboard>, haben, damit es die Änderungen durch das erneute Anwenden der Storyboards mithilfe einer <xref:System.Windows.Media.Animation.BeginStoryboard> oder <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode. Dies hat den Nebeneffekt, dass auch die Animation neu gestartet wird. Im Code können Sie die <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> Methode, um das Storyboard fahren fort, um zur vorherigen Position zurück.  
  
-   Wenn Sie eine Animation direkt an eine Eigenschaft mit dem <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> -Methode, rufen die <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> -Methode erneut auf und übergeben sie die Animation, die geändert wurde.  
  
-   Wenn Sie direkt auf der Uhrebene arbeiten, erstellen und einen neuen Satz von Uhren, und diese verwenden, um den früheren Satz von erstellten Uhren zu ersetzen.  
  
 Ein Beispiel für eine datengebundene Animation finden Sie unter [Key Spline Animation Sample](http://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Storyboard" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert den Satz der Animationen, die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Mit dieser Methode gestartete Storyboards können nicht angehalten, fortgesetzt werden, oder andernfalls interaktiv gesteuert werden, nachdem sie gestartet wurden. Um ein Storyboard steuerbar ist, verwenden Sie die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> oder <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
   
  
## Examples  
 Im folgende Beispiel wird mit einem Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Mit dieser Methode gestartete Storyboards können nicht angehalten, fortgesetzt werden, oder andernfalls interaktiv gesteuert werden, nachdem sie gestartet wurden. Um ein Storyboard steuerbar ist, verwenden Sie die <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> oder <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> Methode.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="isControllable">
          <see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie angeben, die gleiche `containingObject` beim Aufruf der interaktiven Methoden, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht für das Zeitsteuerungssystem Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animieren, wenn der Benutzer klicken, und die <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> Wenn der Benutzer mit der rechten Maustaste.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="isControllable">
          <see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <c>frameworkTemplate</c> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird die <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animieren, wenn der Benutzer klicken, und die <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> Wenn der Benutzer mit der rechten Maustaste.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (kann angehalten werden), nachdem sie gestartet wurde.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie die Verwendung des angegebenen Übergabeverhaltens ersetzt.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie angeben, die gleiche `containingObject` beim Aufruf der interaktiven Methoden, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht für das Zeitsteuerungssystem Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 Im nächsten Beispiel wird die <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animieren, wenn der Benutzer klicken, und die <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> Wenn der Benutzer mit der rechten Maustaste.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <c>frameworkTemplate</c> angewendet wurde.  Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="isControllable">
          <see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert werden, werden sie ersetzt, mit der <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> -Übergabeverhalten.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie angeben, die gleiche `containingObject` beim Aufruf der interaktiven Methoden, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <c>frameworkTemplate</c> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht für das Zeitsteuerungssystem Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (kann angehalten werden), nachdem sie gestartet wurde.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht für das Zeitsteuerungssystem Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie Sie ein steuerbares Storyboard zu erstellen.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 Im nächsten Beispiel wird die <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> animieren, wenn der Benutzer klicken, und die <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> Wenn der Benutzer mit der rechten Maustaste.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <c>frameworkTemplate</c> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <c>containingObject</c> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable">
          <see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie angeben, die gleiche `containingObject` beim Aufruf der interaktiven Methoden, die Sie verwendet, um das Storyboard zu starten.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> Objekte werden erstellt, für das Storyboard und alle Zeitachsen, er enthält. Diese Uhren werden gespeichert mit `containingObject`.  
  
 Eines Storyboards werden ab dem <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse.  
  
## <a name="using-the-compose-handoffbehavior"></a>Mithilfe der Compose HandoffBehavior  
 Beim Anwenden einer <xref:System.Windows.Media.Animation.Storyboard>, <xref:System.Windows.Media.Animation.AnimationTimeline>, oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior>, <xref:System.Windows.Media.Animation.Clock> Objekte, die diese Eigenschaft zuvor zugeordnet waren weiterhin Systemressourcen beanspruchen, nicht für das Zeitsteuerungssystem Diese Uhren automatisch entfernt.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose>, sollten Sie zusammengesetzte Uhren aus der animierten Eigenschaft entfernen, nachdem sie ausgeführt. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden die <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> oder <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> -Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als das zweite. Dies entfernt alle Animationsuhren aus der Eigenschaft.  
  
-   Zum Entfernen einer bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren, mithilfe der <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft der <xref:System.Windows.Media.Animation.AnimationClock> zum Abrufen einer <xref:System.Windows.Media.Animation.ClockController>, rufen Sie dann die <xref:System.Windows.Media.Animation.ClockController.Remove%2A> -Methode der der <xref:System.Windows.Media.Animation.ClockController>. Dies erfolgt in der Regel in der <xref:System.Windows.Media.Animation.Clock.Completed> -Ereignishandler für eine Uhr. Beachten Sie, dass nur Stammuhren von gesteuert werden können eine <xref:System.Windows.Media.Animation.ClockController>; die <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt `null`. Beachten Sie auch, dass die <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis wird nicht aufgerufen, wenn die effektive Dauer der Uhr endlos ist.  In diesem Fall muss der Benutzer bestimmen wann aufzurufen <xref:System.Windows.Media.Animation.ClockController.Remove%2A>.  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn ein Objekt Garbage Collection durchgeführt wird, werden auch die Uhren getrennt. und Garbage collection.  
  
 Weitere Informationen zu uhrobjekten finden Sie unter [Animation und zeitliche Steuerung Systemübersicht](~/docs/framework/wpf/graphics-multimedia/animation-and-timing-system-overview.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.Animation.Storyboard" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die aber möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true." /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien zu erzeugen fixierten <xref:System.Windows.Freezable> Objekte (oder ein beliebiges <xref:System.Windows.Freezable> Objekt). Der Einfachheit halber führt Shadowing für diese Methode die geerbte Version mit einer Implementierung mit starker Typisierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Storyboard" />-Klasse.</summary>
        <returns>Eine neue <see cref="T:System.Windows.Media.Animation.Storyboard" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird intern von aufgerufen <xref:System.Windows.Freezable.CreateInstance%2A> beim Erstellen von neuer Instanzen der <xref:System.Windows.Media.Animation.Storyboard> -Klasse für die verschiedenen Methoden für das Klonen (z. B. <xref:System.Windows.Freezable.Clone%2A> und <xref:System.Windows.Freezable.CloneCurrentValue%2A>).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine typische Implementierung der <xref:System.Windows.Freezable.CreateInstanceCore%2A>.  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Jede <see cref="T:System.Windows.Media.Animation.Storyboard" /> Unterklasse muss diese Methode implementieren. Typische Implementierung besteht darin, einfach den Standardkonstruktor der Klasse aufrufen und das Ergebnis zurück.</para>
        </block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Uhr <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Geschwindigkeit ist die Rate an, der an der Zeit zurzeit fortgesetzt wird, das im Vergleich zur tatsächlichen Zeit.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder 0, wenn die Uhr angehalten wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder <see langword="null" />, wenn die Uhr angehalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Uhr <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Geschwindigkeit ist die Rate an, der an der Zeit zurzeit fortgesetzt wird, das im Vergleich zur tatsächlichen Zeit.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder <see langword="null" />, wenn die Uhr angehalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Uhr <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A> Geschwindigkeit ist die Rate an, der an der Zeit zurzeit fortgesetzt wird, das im Vergleich zur tatsächlichen Zeit.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erste Iteration der Uhr hat den Wert 1.  
  
 Verfügt das Storyboard eine <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> -Einstellung `true`, eine vollständige Iteration besteht aus einem Vorwärts-Rückwärts-Paar, nicht nur eines dieser Segmente.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erste Iteration der Uhr hat den Wert 1.  
  
 Verfügt das Storyboard eine <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> -Einstellung `true`, eine vollständige Iteration besteht aus einem Vorwärts-Rückwärts-Paar, nicht nur eines dieser Segmente.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public Nullable&lt;int&gt; GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Erste Iteration der Uhr hat den Wert 1.  
  
 Wenn diese Uhr Zeitachse verfügt ein <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> Festlegen der `true`, eine vollständige Iteration besteht aus einem Vorwärts-Rückwärts-Paar, nicht nur eines dieser Segmente.  
  
 Unabhängig von ihrer aktuellen Iteration Gibt beim Suchen einer Uhr ihrer aktuelle Iteration 1 zurück. Beim Neustarten einer Uhr gibt auch die aktuelle Iteration 1 zurück.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public Nullable&lt;double&gt; GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht ermittelt werden, ob ein Storyboard angehalten wurde. Um zu bestimmen, ob ein Storyboard angehalten wurde, verwenden Sie die <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> Methode.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht ermittelt werden, ob ein Storyboard angehalten wurde. Um zu bestimmen, ob ein Storyboard angehalten wurde, verwenden Sie die <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> Methode.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode kann nicht ermittelt werden, ob ein Storyboard angehalten wurde. Um zu bestimmen, ob ein Storyboard angehalten wurde, verwenden Sie die <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> Methode.  
  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public Nullable&lt;TimeSpan&gt; GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>
          <see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns>
          <see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns>
          <see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns>
          <see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen zu Uhr des Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-3.0;netframework-3.5">
          <AttributeName>System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die Zeitachse, aus der der <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Das Abhängigkeitsobjekt, das das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Windows.Media.Animation.Storyboard.Target%2A> angefügte Eigenschaft mit Animationszeitachsen, um das Objekt anzugeben, die sie abzielen. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die Zeitachse, aus der der <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Der Name des Abhängigkeitsobjekts, das das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> angefügte Eigenschaft für das angegebene Objekt. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Abhängigkeitsobjekt, aus dem die <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Die Eigenschaft, die das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> angefügte Eigenschaft für das angegebene Objekt. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> angefügte Eigenschaft. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 Beachten Sie, dass bei der <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> wurde festgelegt, im Markup, gibt diese Methode eine leere <xref:System.Windows.PropertyPath> weil der Eigenschaftenverweis aufgelöst und intern gespeichert wird, wenn er aufgelöst wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> an, die für das <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> an, die für das <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard, aber es wurde keine erkennbaren Auswirkungen, wenn sie nicht aktiv ist oder zurzeit angehalten ist. Als Nebeneffekt werden alle zugehörigen untergeordneten Elemente auch angehalten.  
  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> fortgesetzt und neu starten eines Storyboards, die angehalten wurde, wird angezeigt. Ist jedoch nicht was tatsächlich geschieht. Die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode tatsächlich ersetzt den angehaltenen <xref:System.Windows.Media.Animation.Storyboard> mit einer neuen nicht angehaltene Version. Jedes Mal die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> -Methode aufgerufen wird, für das Storyboard Uhr-Objekten erstellt. Zu den Eigenschaften, die sie animieren, werden diese Uhren verteilt. Daher die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode wird aufgerufen, in diesem Fall es die Uhren werden nicht neu gestartet; es durch neue Uhren ersetzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> des angegebenen <see cref="T:System.Windows.FrameworkContentElement" /> an, das diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard, aber es wurde keine erkennbaren Auswirkungen, wenn sie nicht aktiv ist oder zurzeit angehalten ist. Als Nebeneffekt werden alle zugehörigen untergeordneten Elemente auch angehalten.  
  
 Suchen ein angehaltenes Storyboard wird nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltenes Storyboard fortsetzen ist die Verwendung der <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Aufrufen der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode ersetzt die angehaltene Storyboard erneut mit einer neuen, die die Darstellung fortgesetzt wird.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Für ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Durch das Anhalten eines Storyboards Uhr wird der <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> fortgesetzt und neu starten eines Storyboards, die angehalten wurde, wird angezeigt. Ist jedoch nicht was tatsächlich geschieht. Die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode tatsächlich selbst wird durch eine nicht angehaltene Version ersetzt. Jedes Mal die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> -Methode aufgerufen wird, für das Storyboard Uhr-Objekten erstellt. Zu den Eigenschaften, die sie animieren, werden diese Uhren verteilt. Daher die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode wird aufgerufen, in diesem Fall es die Uhren werden nicht neu gestartet; es durch neue Uhren ersetzt.  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> des angegebenen <see cref="T:System.Windows.FrameworkElement" /> an, das diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard, aber es wurde keine erkennbaren Auswirkungen, wenn sie nicht aktiv ist oder zurzeit angehalten ist. Als Nebeneffekt werden alle zugehörigen untergeordneten Elemente auch angehalten.  
  
 Suchen ein angehaltenes Storyboard wird nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltenes Storyboard fortsetzen ist die Verwendung der <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Aufrufen der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode ersetzt die angehaltene Storyboard erneut mit einer neuen, die die Darstellung fortgesetzt wird.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Durch das Anhalten eines Storyboards Uhr wird der <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> fortgesetzt und neu starten eines Storyboards, die angehalten wurde, wird angezeigt. Ist jedoch nicht was tatsächlich geschieht. Die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode tatsächlich selbst wird durch eine nicht angehaltene Version ersetzt. Jedes Mal die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> -Methode aufgerufen wird, für das Storyboard Uhr-Objekten erstellt. Zu den Eigenschaften, die sie animieren, werden diese Uhren verteilt. Daher die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode wird aufgerufen, in diesem Fall es die Uhren werden nicht neu gestartet; es durch neue Uhren ersetzt.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, wirken sich nicht mehr auf die Eigenschaften aus, die zuvor durch sie animiert wurden, unabhängig von ihrer <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, wirken sich nicht mehr auf die Eigenschaften aus, die zuvor durch sie animiert wurden, unabhängig von ihrer <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Alle interaktiven Aktionen auf, eine <xref:System.Windows.Media.Animation.Clock>, und daher auch auf eine <xref:System.Windows.Media.Animation.Storyboard>, treten beim nächsten Teilstrich der zeitsteuerungs-Engine, die kurz vor dem nächsten Rendering erfolgt. Dies bedeutet, dass die <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> Methode noch wirkt sich auf die animierten Eigenschaften bis zu diesem Zeitpunkt. Das heißt, wird das nächste Mal, die, das der Rahmen angezeigt wird, das Storyboard entfernt. Wenn Sie eine Animation aus einer Eigenschaft vor diesem Zeitpunkt aufheben möchten, verwenden Sie die <xref:System.Windows.UIElement.BeginAnimation%2A> -Methode mit einer `animation` Parameterwert `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, wirken sich nicht mehr auf die Eigenschaften aus, die zuvor durch sie animiert wurden, unabhängig von ihrer <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Entfernen eines Storyboards Uhr werden die <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, wirken sich nicht mehr auf die Eigenschaften aus, die zuvor durch sie animiert wurden, unabhängig von ihrer <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Entfernen eines Storyboards Uhr werden die <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fortsetzen eines Storyboards, das nicht angehalten ist, hat keine Auswirkungen.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suchen ein angehaltenes Storyboard wird nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltenes Storyboard fortsetzen ist die Verwendung der <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Aufrufen der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, die nach dem Start des Storyboards ersetzt die alte Storyboard, mit dem dem Aussehen fortgesetzt wird.  
  
 Fortsetzen einer angehaltenen Uhr des Storyboards wird ausgelöst, die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Fortsetzen eines Storyboards, das nicht angehalten ist, hat keine Auswirkungen.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suchen ein angehaltenes Storyboard wird nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltenes Storyboard fortsetzen ist die Verwendung der <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Aufrufen der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, die nach dem Start des Storyboards ersetzt die alte Storyboard, mit dem dem Aussehen fortgesetzt wird.  
  
 Fortsetzen einer angehaltenen Uhr des Storyboards wird ausgelöst, die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zu der Position, an der das nächste Ticken der Uhr erfolgt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse vorwärts oder rückwärts verschoben werden soll.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche beim nächsten Ticken der Uhr aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche beim nächsten Ticken der Uhr aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche beim nächsten Ticken der Uhr aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Diese Methode ändert der Storyboarduhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> zu <xref:System.Windows.Media.Animation.ClockState.Active>. Diese Methode hat keine Auswirkungen auf die Zeitstruktur, bis das nächste Mal, wenn, das ein Tick verarbeitet wird. Als Nebeneffekt werden die entsprechenden Ereignisse auch nicht bis zu diesem Zeitpunkt ausgelöst.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt sowohl den <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> und <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methoden.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche beim nächsten Ticken der Uhr aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Diese Methode ändert der Storyboarduhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> zu <xref:System.Windows.Media.Animation.ClockState.Active>. Diese Methode hat keine Auswirkungen auf die Zeitstruktur, bis das nächste Mal, wenn, das ein Tick verarbeitet wird. Als Nebeneffekt werden die entsprechenden Ereignisse auch nicht bis zu diesem Zeitpunkt ausgelöst.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden, wenn sie nicht steuerbar festgelegt ist. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt, wie die (überspringen) Suche, um eine Sekunde, nachdem ein Storyboard beginnt.  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 Das nächste Beispiel zeigt sowohl den <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> und <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methoden.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse vorwärts oder rückwärts verschoben werden soll.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> wird die gesuchte Zeit von der <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten. Werte werden sofort aktualisiert, damit die Änderungen aufgrund von <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, auch wenn der Bildschirm nicht über diese Änderungen erst die bildschirmaktualisierungen widerspiegelt.  
  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> wird die gesuchte Zeit von der <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten. Werte werden sofort aktualisiert, damit die Änderungen aufgrund von <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, auch wenn der Bildschirm nicht über diese Änderungen erst die bildschirmaktualisierungen widerspiegelt.  
  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> wird die gesuchte Zeit von der <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten. Werte werden sofort aktualisiert, damit die Änderungen aufgrund von <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, auch wenn der Bildschirm nicht über diese Änderungen erst die bildschirmaktualisierungen widerspiegelt.  
  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Diese Methode ändert der Storyboarduhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> auf  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>  
  
 Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt sowohl den <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> und <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methoden.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <c>Ursprung</c> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <c>offset</c> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> wird die gesuchte Zeit von der <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten. Werte werden sofort aktualisiert, damit die Änderungen aufgrund von <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A>, auch wenn der Bildschirm nicht über diese Änderungen erst die bildschirmaktualisierungen widerspiegelt.  
  
 Beachten Sie, dass Vorgänge nehmen sich nicht auf der Storyboards <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> oder <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> Einstellungen berücksichtigt. Das Storyboard wird behandelt, als wären sie verfügt über eine <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> 1 und ohne <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A>.  
  
 Diese Methode ändert der Storyboarduhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> auf  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>  
  
 Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Das folgende Beispiel zeigt sowohl den <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> und <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methoden.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu bestimmen. Der Wert überschreibt nicht die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards. Wenn beispielsweise diese Methode aufgerufen und für ein Storyboard mit der <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 das interaktive Geschwindigkeitsverhältnis 3 angegeben wird, ist die tatsächliche Geschwindigkeit des Storyboards 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu bestimmen. Der Wert überschreibt nicht die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards. Wenn beispielsweise diese Methode aufgerufen und für ein Storyboard mit der <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 das interaktive Geschwindigkeitsverhältnis 3 angegeben wird, ist die tatsächliche Geschwindigkeit des Storyboards 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Löst das Aufrufen dieser Methode die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu bestimmen. Der Wert überschreibt nicht die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards. Wenn beispielsweise diese Methode aufgerufen und für ein Storyboard mit der <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> 0,5 das interaktive Geschwindigkeitsverhältnis 3 angegeben wird, ist die tatsächliche Geschwindigkeit des Storyboards 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 Löst das Aufrufen dieser Methode die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, deren Ziel das angegebene Abhängigkeitsobjekt ist.</param>
        <param name="value">Das Abhängigkeitsobjekt, das als Ziel festgelegt werden soll.</param>
        <summary>Legt das Abhängigkeitsobjekt als Ziel der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.Target%2A> angefügte Eigenschaft für das angegebene Objekt. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
> [!NOTE]
>  Die <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Eigenschaft ist nicht serialisierbar, da es auf einen festgelegt werden kann <xref:System.Windows.DependencyObject>. Es ist nicht garantiert, dass dieses Objekt ordnungsgemäß aus XAML verwiesen werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, deren Ziel das angegebene Abhängigkeitsobjekt ist.</param>
        <param name="name">Der Name des als Ziel zu verwendenden Abhängigkeitsobjekts.</param>
        <summary>Legt das Abhängigkeitsobjekt mit dem angegebenen Namen als Ziel der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> angefügte Eigenschaft für das angegebene Objekt. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A>. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, der die angegebene Abhängigkeitseigenschaft zugeordnet werden soll.</param>
        <param name="path">Ein Pfad, der die zu animierende Abhängigkeitseigenschaft beschreibt.</param>
        <summary>Legt die angegebene Abhängigkeitseigenschaft als Ziel der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A> angefügte Eigenschaft für das angegebene Objekt. Weitere Informationen zur Funktionsweise der Storyboard-Ziel finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetProperty%2A>. Weitere Informationen über die Funktionsweise von angefügten Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](~/docs/framework/wpf/advanced/attached-properties-overview.md).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt der Storyboards aktuelle Zeit bis zum Ende seines Aktivitätszeitraums fest; das Verhalten des Storyboards an diesem Punkt wird anhand der <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> festlegen. Wenn <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> nastaven NA hodnotu <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, das Storyboard aufgefüllt; Wenn die Eigenschaft, um festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.Stop>, das Storyboard gestoppt wird.  
  
 Eine unbegrenzte Anzahl von Wiederholungen ist für ein Storyboard mit der eine unbegrenzte Dauer Aufrufen dieser Methode hat keine Auswirkungen. Das Aufrufen dieser Methode für eine inaktive Storyboard hat keine Auswirkungen.  
  
 Durch das Festlegen einer Uhr zu seiner Füllfarbe Zeitraum Trigger die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt der Storyboards aktuelle Zeit bis zum Ende seines Aktivitätszeitraums fest; das Verhalten des Storyboards an diesem Punkt wird anhand der <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> festlegen. Wenn <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> nastaven NA hodnotu <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd>, das Storyboard aufgefüllt; Wenn die Eigenschaft, um festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.Stop>, das Storyboard gestoppt wird.  
  
 Eine unbegrenzte Anzahl von Wiederholungen ist für ein Storyboard mit der eine unbegrenzte Dauer Aufrufen dieser Methode hat keine Auswirkungen. Das Aufrufen dieser Methode für eine inaktive Storyboard hat keine Auswirkungen.  
  
 Durch das Festlegen einer Uhr zu seiner Füllfarbe Zeitraum Trigger die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, das Beenden eines Storyboards nicht ausgelöst wird, die <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Media.Animation.ClockState.Stopped> Storyboard wirkt sich nicht mehr auf die Zieleigenschaften: Eigenschaften, die animiert, die auf ihren vorherigen Wert zurückgesetzt.  
  
 Beenden einer Uhr werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse, aber nicht die <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
   
  
## Examples  
 Im folgende Beispiel wird mit ein steuerbares Storyboard animiert ein <xref:System.Windows.Media.TextEffect>. Die <xref:System.Windows.Media.TextEffect> in enthalten ist ein <xref:System.Windows.FrameworkContentElement>Bereich benennen.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufruf der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Media.Animation.ClockState.Stopped> Storyboard wirkt sich nicht mehr auf die Zieleigenschaften: Eigenschaften, die animiert, die auf ihren vorherigen Wert zurückgesetzt.  
  
 Beenden einer Uhr werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> und <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignisse, aber nicht die <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis.  
  
 Um das Storyboard interaktiv steuern zu können, müssen Sie verwenden die gleiche `containingObject` Parameter an, wenn es sich bei die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen und zu beenden, und entfernt werden. Um ein Storyboard im Code steuerbar, müssen Sie die geeignete Überladung der Storyboard verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode, und geben Sie `true` damit sie steuerbar wird. Ein Beispiel finden Sie unter [wie: Steuern eine Storyboards nach dessen Start](~/docs/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts.md).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das zu animierende Objekt ab oder legt dieses fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zielobjekt muss ein Abhängigkeitsobjekt sein.  
  
> [!NOTE]
>  Die <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Eigenschaft ist nicht serialisierbar, da es auf einen festgelegt werden kann <xref:System.Windows.DependencyObject>. Es ist nicht garantiert, dass dieses Objekt ordnungsgemäß in XAML verwiesen werden kann.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Namen des zu animierenden Objekts ab oder legt ihn fest. Das Objekt muss ein <see cref="T:System.Windows.FrameworkElement" /> oder <see cref="T:System.Windows.FrameworkContentElement" /> sein, oder es muss <see cref="T:System.Windows.Freezable" /> sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Durch Festlegen dieser Eigenschaft ist optional. Wenn die <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> nicht angegeben ist, wird ein Storyboard Animationen auf eine der folgenden angewendet werden:  
  
-   Wenn das Storyboard, die Animation gehört, gestartet wurde, mit einer <xref:System.Windows.Media.Animation.BeginStoryboard>, dem Element, besitzt die <xref:System.Windows.Media.Animation.BeginStoryboard> richtet sich Aktion, die das Storyboard auslöst.  
  
-   Wenn das Storyboard gestartet wurde, mit der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> -Methode, der <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement> angegeben, wenn das Storyboard gestartet wurde, mit der <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode richtet sich.  
  
 Wenn diese Eigenschaft auf einer Zeitachse mit untergeordneten Elementen festgelegt ist, diese untergeordneten Zeitachsen "erben" des übergeordneten Elements <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> , wenn sie ihre eigenen angeben.  
  
## <a name="making-an-object-targetable"></a>Machen ein Objekt als Ziel gesetzt  
 Bei Verwendung [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)], führen Sie eine der folgenden beiden Aktionen aus, um ein Objekt festzulegen, indem Sie ein Storyboard:  
  
-   Wenn das Objekt ist ein <xref:System.Windows.FrameworkElement> oder <xref:System.Windows.FrameworkContentElement>legen die <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft.  
  
-   Wenn das Objekt ist ein <xref:System.Windows.Freezable> oder für einen benutzerdefinierten <xref:System.Windows.FrameworkContentElement> oder <xref:System.Windows.FrameworkContentElement>, weisen Sie ihm einen Namen mithilfe der [X: Name Directive](~/docs/framework/xaml-services/x-name-directive.md) Markuperweiterung.  
  
 Wenn Sie Code verwenden, legen Sie ein Objekt als Ziel gesetzt mithilfe der <xref:System.Windows.NameScope.RegisterName%2A> Methode, um dem Objekt einen Namen zuzuweisen.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Feld "ID"|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Legen Sie auf der Metadaten-Eigenschaften `true`|Keiner|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>