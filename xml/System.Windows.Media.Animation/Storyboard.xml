<Type Name="Storyboard" FullName="System.Windows.Media.Animation.Storyboard">
  <Metadata><Meta Name="ms.openlocfilehash" Value="67d4284e8db2a1c509f4770c27506fa0b513252e" /><Meta Name="ms.sourcegitcommit" Value="f828282420515ef705e09bbdb6c22116df98b5e3" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86872796" /></Metadata><TypeSignature Language="C#" Value="public class Storyboard : System.Windows.Media.Animation.ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit Storyboard extends System.Windows.Media.Animation.ParallelTimeline" FrameworkAlternate="net-5.0;netcore-3.0;netcore-3.1" />
  <TypeSignature Language="DocId" Value="T:System.Windows.Media.Animation.Storyboard" />
  <TypeSignature Language="VB.NET" Value="Public Class Storyboard&#xA;Inherits ParallelTimeline" />
  <TypeSignature Language="C++ CLI" Value="public ref class Storyboard : System::Windows::Media::Animation::ParallelTimeline" />
  <TypeSignature Language="F#" Value="type Storyboard = class&#xA;    inherit ParallelTimeline" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi Storyboard extends System.Windows.Media.Animation.ParallelTimeline" FrameworkAlternate="netframework-3.0;netframework-3.5;netframework-4.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
  <AssemblyInfo>
    <AssemblyName>PresentationFramework</AssemblyName>
    <AssemblyVersion>3.0.0.0</AssemblyVersion>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
    <AssemblyVersion>5.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Windows.Media.Animation.ParallelTimeline</BaseTypeName>
  </Base>
  <Interfaces />
  <Docs>
    <summary>Ein Containerzeitachse, die Zielinformationen zu Objekten und Eigenschaften für die untergeordneten Animationen bereitstellt.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
## <a name="interactively-controlling-storyboards"></a>Interaktives Steuern von Storyboards  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard in Markup steuerbar zu machen, geben Sie die- <xref:System.Windows.Media.Animation.BeginStoryboard.Name%2A> Eigenschaft des Objekts an, <xref:System.Windows.Media.Animation.BeginStoryboard> das es erstellt. ein Beispiel finden Sie unter Gewusst [wie: Verwenden von Ereignis Triggern zum Steuern eines Storyboards nach dem Start](/dotnet/framework/wpf/graphics-multimedia/how-to-use-event-triggers-to-control-a-storyboard-after-it-starts). Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
## <a name="data-binding-and-animating-timelines"></a>Datenbindung und Animation von Zeitachsen  
 Die meisten Zeitachsen Eigenschaften können Daten gebunden oder animiert sein. aufgrund der Funktionsweise des Zeit Steuerungssystems Verhalten sich Daten gebundene oder animierte Zeitachsen jedoch nicht wie andere Daten gebundene oder animierte Objekte. Um das Verhalten zu verstehen, ist es hilfreich zu verstehen, was es bedeutet, eine Zeitachse zu aktivieren.  
  
 Wenn eine Zeitachse aktiviert ist, werden Kopien aus der Zeitachse und den zugehörigen untergeordneten Zeitachsen erstellt. Diese Kopien sind fixiert (schreibgeschützt), und <xref:System.Windows.Media.Animation.Clock> Objekte werden daraus erstellt. Das eigentliche Animieren der Zieleigenschaften erfolgt durch diese Uhren. Wenn eine Zeitachse Daten gebunden oder animiert ist, wird beim Erstellen der Uhr eine Momentaufnahme der aktuellen Werte erstellt. Obwohl die ursprüngliche Zeitachse weiterhin geändert werden kann, ist dies nicht möglich.  
  
 Damit eine Zeitachse Datenbindung oder Animations Änderungen widerspiegelt, muss die Uhr neu erstellt werden. Uhren werden nicht automatisch neu erstellt. Im Folgenden werden verschiedene Methoden beschrieben, wie Änderungen der Zeitachse übernommen werden können:  
  
-   Wenn die Zeitachse ein ist oder zu einer gehört <xref:System.Windows.Media.Animation.Storyboard> , können Sie Sie mit <xref:System.Windows.Media.Animation.BeginStoryboard> den-Methoden der-Methode oder der- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode widerspiegeln. Dies hat den Nebeneffekt, dass auch die Animation neu gestartet wird. Im Code können Sie die- <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> Methode verwenden, um das Storyboard zurück zur vorherigen Position zu verschieben.  
  
-   Wenn Sie mithilfe der-Methode eine Animation direkt auf eine Eigenschaft angewendet <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> haben, müssen Sie die <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%2A> Methode erneut aufzurufen und die Animation übergeben, die geändert wurde.  
  
-   Wenn Sie direkt auf der Clock-Ebene arbeiten, erstellen Sie eine neue Gruppe von Uhren, und wenden Sie Sie an, und verwenden Sie Sie, um den vorherigen Satz von erstellten Uhren zu ersetzen.  
  
 Ein Beispiel für eine Daten gebundene Animation finden Sie unter Beispiel für eine [KeySpline-Animation](https://go.microsoft.com/fwlink/?LinkID=160011) .  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public Storyboard ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.#ctor" />
      <MemberSignature Language="VB.NET" Value="Public Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Storyboard();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Storyboard" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Begin">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert den Satz der Animationen, die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin();" />
      <MemberSignature Language="F#" Value="member this.Begin : unit -&gt; unit" Usage="storyboard.Begin " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Mit dieser Methode gestartete Storyboards können nicht angehalten, fortgesetzt oder anderweitig interaktiv gesteuert werden, nachdem Sie gestartet wurden. Verwenden Sie die-oder-Methode, um ein Storyboard steuerbar zu machen <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardExample.cs#frameworkcontentelementstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardexample.vb#frameworkcontentelementstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Begin containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Mit dieser Methode gestartete Storyboards können nicht angehalten, fortgesetzt oder anderweitig interaktiv gesteuert werden, nachdem Sie gestartet wurden. Verwenden Sie die-oder-Methode, um ein Storyboard steuerbar zu machen <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Boolean%29> <xref:System.Windows.Media.Animation.Storyboard.Begin%28System.Windows.FrameworkElement%2CSystem.Windows.Media.Animation.HandoffBehavior%2CSystem.Boolean%29> .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="isControllable"><see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, dasselbe angeben.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
   
  
## Examples  
 Im folgenden Beispiel wird verwendet, <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> um zu animieren, wenn der Benutzer mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> rechten Maustaste klickt.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * bool -&gt; unit" Usage="storyboard.Begin (containingObject, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="isControllable"><see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, denselben Parameter verwenden.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, frameworkTemplate As FrameworkTemplate)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <paramref name="frameworkTemplate" /> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Im folgenden Beispiel wird verwendet, <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> um zu animieren, wenn der Benutzer mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> rechten Maustaste klickt.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkContentElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkContentElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkContentElement, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkContentElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkContentElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (kann angehalten werden), nachdem sie gestartet wurde.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf ihre Ziele an und initialisiert sie mithilfe des angegebenen <see cref="T:System.Windows.Media.Animation.HandoffBehavior" />.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das angegebene Übergabe Verhalten ersetzt.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, dasselbe angeben.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 Im nächsten Beispiel wird verwendet, <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> um zu animieren, wenn der Benutzer mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> rechten Maustaste klickt.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementStoryboardWithHandoffBehaviorExample.cs#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementStoryboardWithHandoffBehaviorExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementstoryboardwithhandoffbehaviorexample.vb#frameworkcontentelementstoryboardwithhandoffbehaviorexamplewholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, frameworkTemplate As FrameworkTemplate, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <paramref name="frameworkTemplate" /> angewendet wurde.  Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="isControllable"><see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die Zieleigenschaften bereits animiert sind, werden Sie durch das <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> Übergabe Verhalten ersetzt.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, dasselbe angeben.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, frameworkTemplate As FrameworkTemplate, handoffBehavior As HandoffBehavior)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <paramref name="frameworkTemplate" /> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Ein Objekt, das im selben Namensbereich wie die Ziele der Animationen dieses Storyboards enthalten ist. Animationen ohne einen angegebenen <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable">Bestimmt, ob die Animation steuerbar ist (kann angehalten werden), nachdem sie gestartet wurde.</param>
        <summary>Wendet die Animationen, die diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet sind, auf ihre Ziele an und initiiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, denselben Parameter verwenden.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie ein steuerbares Storyboard erstellt wird.  
  
 [!code-csharp[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/animation_ovws_procedural_snip/CSharp/ControllableStoryboardExample.cs#controllablestoryboardexamplewholepage)]
 [!code-vb[animation_ovws_procedural_snip#ControllableStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/animation_ovws_procedural_snip/visualbasic/controllablestoryboardexample.vb#controllablestoryboardexamplewholepage)]  
  
 Im nächsten Beispiel wird verwendet, <xref:System.Windows.Media.Animation.HandoffBehavior.SnapshotAndReplace> <xref:System.Windows.Media.Animation.HandoffBehavior> um zu animieren, wenn der Benutzer mit der <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> rechten Maustaste klickt.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkElementStoryboardHandoffBehaviorExample.cs#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#GraphicsMMFrameworkElementStoryboardHandoffBehaviorExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkelementstoryboardhandoffbehaviorexample.vb#graphicsmmframeworkelementstoryboardhandoffbehaviorexample)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Begin">
      <MemberSignature Language="C#" Value="public void Begin (System.Windows.FrameworkElement containingObject, System.Windows.FrameworkTemplate frameworkTemplate, System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Begin(class System.Windows.FrameworkElement containingObject, class System.Windows.FrameworkTemplate frameworkTemplate, valuetype System.Windows.Media.Animation.HandoffBehavior handoffBehavior, bool isControllable) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Windows.FrameworkTemplate,System.Windows.Media.Animation.HandoffBehavior,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Begin (containingObject As FrameworkElement, frameworkTemplate As FrameworkTemplate, handoffBehavior As HandoffBehavior, isControllable As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Begin(System::Windows::FrameworkElement ^ containingObject, System::Windows::FrameworkTemplate ^ frameworkTemplate, System::Windows::Media::Animation::HandoffBehavior handoffBehavior, bool isControllable);" />
      <MemberSignature Language="F#" Value="member this.Begin : System.Windows.FrameworkElement * System.Windows.FrameworkTemplate * System.Windows.Media.Animation.HandoffBehavior * bool -&gt; unit" Usage="storyboard.Begin (containingObject, frameworkTemplate, handoffBehavior, isControllable)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="frameworkTemplate" Type="System.Windows.FrameworkTemplate" />
        <Parameter Name="handoffBehavior" Type="System.Windows.Media.Animation.HandoffBehavior" />
        <Parameter Name="isControllable" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das Objekt, auf das die angegebene <paramref name="frameworkTemplate" /> angewendet wurde. Animationen ohne <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> werden auf <paramref name="containingObject" /> angewendet.</param>
        <param name="frameworkTemplate">Die zu animierende Vorlage.</param>
        <param name="handoffBehavior">Das Verhalten, das die neue Animation für die Interaktion mit aktuellen Animationen verwenden soll.</param>
        <param name="isControllable"><see langword="true" />, wenn das Storyboard interaktiv steuerbar sein soll, andernfalls <see langword="false" />.</param>
        <summary>Wendet die dem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordneten Animationen auf die entsprechenden Ziele in der angegebenen Vorlage an und initialisiert sie.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie beim `containingObject` Aufrufen der interaktiven Methoden, die Sie zum Starten des Storyboards verwendet haben, dasselbe angeben.  
  
 Wenn diese Methode aufgerufen wird, <xref:System.Windows.Media.Animation.Clock> werden-Objekte für das Storyboard und alle darin enthaltenen Zeitachsen erstellt. Diese Uhren werden mit gespeichert `containingObject` .  
  
 Beim Starten eines Storyboards werden <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst.  
  
## <a name="using-the-compose-handoffbehavior"></a>Verwenden von Compose HandoffBehavior  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard> , <xref:System.Windows.Media.Animation.AnimationTimeline> oder <xref:System.Windows.Media.Animation.AnimationClock> auf eine Eigenschaft mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> <xref:System.Windows.Media.Animation.HandoffBehavior> , <xref:System.Windows.Media.Animation.Clock> verbrauchen alle Objekte, die dieser Eigenschaft zuvor zugeordnet sind, weiterhin Systemressourcen. das Zeit Steuerungssystem entfernt diese Uhren nicht automatisch.  
  
 Um Leistungsprobleme zu vermeiden, wenn Sie eine große Anzahl von Uhren mithilfe von anwenden <xref:System.Windows.Media.Animation.HandoffBehavior.Compose> , sollten Sie das Verfassen von Uhren aus der animierten Eigenschaft entfernen, nachdem Sie fertiggestellt wurden. Es gibt mehrere Möglichkeiten, eine Uhr zu entfernen.  
  
-   Um alle Uhren aus einer Eigenschaft zu entfernen, verwenden Sie die- <xref:System.Windows.Media.Animation.Animatable.ApplyAnimationClock%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationClock%29> <xref:System.Windows.Media.Animation.Animatable.BeginAnimation%28System.Windows.DependencyProperty%2CSystem.Windows.Media.Animation.AnimationTimeline%29> Methode oder die-Methode des animierten Objekts. Geben Sie die zu animierende Eigenschaft als ersten Parameter und `null` als Sekunde an. Dadurch werden alle Animations Uhren aus der-Eigenschaft entfernt.  
  
-   Um einen bestimmten <xref:System.Windows.Media.Animation.AnimationClock> aus einer Liste von Uhren zu entfernen, verwenden <xref:System.Windows.Media.Animation.Clock.Controller%2A> Sie die-Eigenschaft des, <xref:System.Windows.Media.Animation.AnimationClock> um eine abzurufen <xref:System.Windows.Media.Animation.ClockController> , und rufen Sie dann die- <xref:System.Windows.Media.Animation.ClockController.Remove%2A> Methode von auf <xref:System.Windows.Media.Animation.ClockController> . Dies erfolgt in der Regel im <xref:System.Windows.Media.Animation.Clock.Completed> Ereignishandler für eine Uhr. Beachten Sie, dass nur Stamm Uhren von einem gesteuert werden können <xref:System.Windows.Media.Animation.ClockController> ; die- <xref:System.Windows.Media.Animation.Clock.Controller%2A> Eigenschaft einer untergeordneten Uhr gibt zurück `null` . Beachten Sie auch, dass das- <xref:System.Windows.Media.Animation.Clock.Completed> Ereignis nicht aufgerufen wird, wenn die effektive Dauer der Uhr ewig ist.  In diesem Fall muss der Benutzer bestimmen, wann aufgerufen werden soll <xref:System.Windows.Media.Animation.ClockController.Remove%2A> .  
  
 Dies betrifft hauptsächlich Animationen für Objekte, die eine lange Lebensdauer haben.  Wenn für ein Objekt eine Garbage Collection durchgeführt wird, werden auch die zugehörigen Uhren getrennt und die Garbage Collection erfolgt.  
  
 Weitere Informationen zu Clock-Objekten finden Sie unter Übersicht über das [Animations-und Zeit Steuerungssystem](/dotnet/framework/wpf/graphics-multimedia/animation-and-timing-system-overview).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Clone">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.Storyboard Clone ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Windows.Media.Animation.Storyboard Clone() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Clone" />
      <MemberSignature Language="VB.NET" Value="Public Function Clone () As Storyboard" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::Storyboard ^ Clone();" />
      <MemberSignature Language="F#" Value="override this.Clone : unit -&gt; System.Windows.Media.Animation.Storyboard" Usage="storyboard.Clone " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.Storyboard</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen änderbaren Klon dieser <see cref="T:System.Windows.Media.Animation.Storyboard" />, indem tiefe Kopien der Werte dieses Objekts erzeugt werden. Beim Kopieren von Abhängigkeitseigenschaften kopiert diese Methode Ressourcenverweise und Datenbindungen (die aber möglicherweise nicht mehr aufgelöst werden können), jedoch keine Animationen oder ihre aktuellen Werte.</summary>
        <returns>Ein änderbarer Klon des aktuellen Objekts. Die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft des geklonten Objekts ist <see langword="false" />, auch wenn die <see cref="P:System.Windows.Freezable.IsFrozen" />-Eigenschaft der Quelle <see langword="true" /> war.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird verwendet, um änderbare Kopien von fixierten <xref:System.Windows.Freezable> Objekten (oder einem beliebigen <xref:System.Windows.Freezable> Objekt) zu liefern. Aus Gründen der praktische überschattet diese Methode die geerbte Version durch eine stark typisierte Implementierung.  
  
 Weitere Informationen finden Sie unter <xref:System.Windows.Freezable.Clone%2A?displayProperty=nameWithType>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateInstanceCore">
      <MemberSignature Language="C#" Value="protected override System.Windows.Freezable CreateInstanceCore ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Windows.Freezable CreateInstanceCore() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.CreateInstanceCore" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function CreateInstanceCore () As Freezable" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Windows::Freezable ^ CreateInstanceCore();" />
      <MemberSignature Language="F#" Value="override this.CreateInstanceCore : unit -&gt; System.Windows.Freezable" Usage="storyboard.CreateInstanceCore " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.Freezable</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt eine neue Instanz der <see cref="T:System.Windows.Media.Animation.Storyboard" />-Klasse.</summary>
        <returns>Eine neue <see cref="T:System.Windows.Media.Animation.Storyboard" />-Instanz.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode wird von intern aufgerufen, <xref:System.Windows.Freezable.CreateInstance%2A> Wenn neue Instanzen der <xref:System.Windows.Media.Animation.Storyboard> -Klasse für die verschiedenen Klon Methoden (z. b. <xref:System.Windows.Freezable.Clone%2A> und) erstellt werden <xref:System.Windows.Freezable.CloneCurrentValue%2A> .  
  
   
  
## Examples  
 Das folgende Beispiel zeigt eine typische Implementierung von <xref:System.Windows.Freezable.CreateInstanceCore%2A> .  
  
 [!code-csharp[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/csharp/VS_Snippets_Wpf/freezablesample_procedural/CSharp/freezablesample.cs#createinstancecoreexample)]
 [!code-vb[freezablesample_procedural#CreateInstanceCoreExample](~/samples/snippets/visualbasic/VS_Snippets_Wpf/freezablesample_procedural/visualbasic/freezablesample.vb#createinstancecoreexample)]  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Jede <see cref="T:System.Windows.Media.Animation.Storyboard" /> Unterklasse muss diese Methode implementieren. Die typische Implementierung besteht darin, einfach den Parameter losen Konstruktor der Klasse aufzurufen und das Ergebnis zurückzugeben.</para></block>
        <altmember cref="M:System.Windows.Freezable.CreateInstanceCore" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentGlobalSpeed">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A>Die Geschwindigkeit einer Uhr ist die Rate, mit der die Zeit im Vergleich zur realen Zeit gegenwärtig fortschreitet.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double GetCurrentGlobalSpeed ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentGlobalSpeed() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentGlobalSpeed();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : unit -&gt; double" Usage="storyboard.GetCurrentGlobalSpeed " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder 0, wenn die Uhr angehalten wurde.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double? GetCurrentGlobalSpeed (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder <see langword="null" />, wenn die Uhr angehalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A>Die Geschwindigkeit einer Uhr ist die Rate, mit der die Zeit im Vergleich zur realen Zeit gegenwärtig fortschreitet.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentGlobalSpeed">
      <MemberSignature Language="C#" Value="public double? GetCurrentGlobalSpeed (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentGlobalSpeed(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentGlobalSpeed(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentGlobalSpeed (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentGlobalSpeed(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentGlobalSpeed : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentGlobalSpeed containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle globale Geschwindigkeit oder <see langword="null" />, wenn die Uhr angehalten wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed%2A>Die Geschwindigkeit einer Uhr ist die Rate, mit der die Zeit im Vergleich zur realen Zeit gegenwärtig fortschreitet.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentGlobalSpeed" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentIteration">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int GetCurrentIteration ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int32 GetCurrentIteration() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration () As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; int GetCurrentIteration();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : unit -&gt; int" Usage="storyboard.GetCurrentIteration " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die erste Iterationen einer Uhr haben den Wert 1.  
  
 Wenn dieses Storyboard über <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> die Einstellung verfügt `true` , besteht eine vollständige Iterationen aus einem Forward-Reverse-paar und nicht nur einem dieser Segmente.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int? GetCurrentIteration (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkContentElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkContentElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die erste Iterationen einer Uhr haben den Wert 1.  
  
 Wenn dieses Storyboard über <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> die Einstellung verfügt `true` , besteht eine vollständige Iterationen aus einem Forward-Reverse-paar und nicht nur einem dieser Segmente.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentIteration">
      <MemberSignature Language="C#" Value="public int? GetCurrentIteration (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;int32&gt; GetCurrentIteration(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentIteration(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentIteration (containingObject As FrameworkElement) As Nullable(Of Integer)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;int&gt; GetCurrentIteration(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentIteration : System.Windows.FrameworkElement -&gt; Nullable&lt;int&gt;" Usage="storyboard.GetCurrentIteration containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Int32&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Die aktuelle Iteration der Uhr in ihrem aktuellen Aktivitätszeitraum oder <see langword="null" />, wenn die Uhr beendet wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die erste Iterationen einer Uhr haben den Wert 1.  
  
 Wenn die Zeitachse dieser Uhr über eine <xref:System.Windows.Media.Animation.Timeline.AutoReverse%2A> Einstellung von verfügt `true` , besteht eine vollständige Iterationen aus einem Forward-Reverse-paar und nicht nur einem dieser Segmente.  
  
 Unabhängig von der aktuellen Iterationen gibt die Suche nach einer Uhr die aktuelle Iterations Dauer auf 1 zurück. Beim Neustart einer Uhr wird auch die aktuelle Iterations Zeit auf 1 zurückgesetzt.  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentIteration" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentProgress">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double GetCurrentProgress ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance float64 GetCurrentProgress() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress () As Double" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; double GetCurrentProgress();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : unit -&gt; double" Usage="storyboard.GetCurrentProgress " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Double</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double? GetCurrentProgress (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkContentElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkContentElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentProgress">
      <MemberSignature Language="C#" Value="public double? GetCurrentProgress (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;float64&gt; GetCurrentProgress(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentProgress(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentProgress (containingObject As FrameworkElement) As Nullable(Of Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;double&gt; GetCurrentProgress(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentProgress : System.Windows.FrameworkElement -&gt; Nullable&lt;double&gt;" Usage="storyboard.GetCurrentProgress containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.Double&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentProgress" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr den Zustand <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> besitzt, oder 0,0, wenn die Uhr aktiv ist und die <see cref="P:System.Windows.Media.Animation.Clock.Timeline" /> ihrer <see cref="P:System.Windows.Media.Animation.Timeline.Duration" /> den Wert <see cref="P:System.Windows.Duration.Forever" /> aufweist. Andernfalls ein Wert zwischen 0,0 und 1,0, der den aktuellen Fortschritt der Uhr in ihrer aktuellen Iteration angibt. Der Wert 0,0 gibt keinen Fortschritt an, und der Wert 1,0 gibt an, dass die Uhr das Ende ihrer aktuellen Iteration erreicht hat.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentState">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState () As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : unit -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nicht an, ob ein Storyboard angehalten wurde. Verwenden Sie die-Methode, um zu bestimmen, ob ein Storyboard angehalten wurde <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> .  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkContentElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkContentElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nicht an, ob ein Storyboard angehalten wurde. Verwenden Sie die-Methode, um zu bestimmen, ob ein Storyboard angehalten wurde <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> .  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCurrentState">
      <MemberSignature Language="C#" Value="public System.Windows.Media.Animation.ClockState GetCurrentState (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Windows.Media.Animation.ClockState GetCurrentState(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentState(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentState (containingObject As FrameworkElement) As ClockState" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Windows::Media::Animation::ClockState GetCurrentState(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentState : System.Windows.FrameworkElement -&gt; System.Windows.Media.Animation.ClockState" Usage="storyboard.GetCurrentState containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.Media.Animation.ClockState</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentState" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns>Der aktuelle Zustand der für das Storyboard erstellten Uhr: <see cref="F:System.Windows.Media.Animation.ClockState.Active" />, <see cref="F:System.Windows.Media.Animation.ClockState.Filling" /> oder <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode gibt nicht an, ob ein Storyboard angehalten wurde. Verwenden Sie die-Methode, um zu bestimmen, ob ein Storyboard angehalten wurde <xref:System.Windows.Media.Animation.Storyboard.GetIsPaused%2A> .  
  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetCurrentTime">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan GetCurrentTime ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.TimeSpan GetCurrentTime() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime () As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; TimeSpan GetCurrentTime();" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : unit -&gt; TimeSpan" Usage="storyboard.GetCurrentTime " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan? GetCurrentTime (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkContentElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkContentElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <Member MemberName="GetCurrentTime">
      <MemberSignature Language="C#" Value="public TimeSpan? GetCurrentTime (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance valuetype System.Nullable`1&lt;valuetype System.TimeSpan&gt; GetCurrentTime(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetCurrentTime(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetCurrentTime (containingObject As FrameworkElement) As Nullable(Of TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; Nullable&lt;TimeSpan&gt; GetCurrentTime(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetCurrentTime : System.Windows.FrameworkElement -&gt; Nullable&lt;TimeSpan&gt;" Usage="storyboard.GetCurrentTime containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Nullable&lt;System.TimeSpan&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft die <see cref="P:System.Windows.Media.Animation.Clock.CurrentTime" /> der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> ab.</summary>
        <returns><see langword="null" />, wenn die Uhr des Storyboards <see cref="F:System.Windows.Media.Animation.ClockState.Stopped" /> ist, andernfalls die aktuelle Uhrzeit der Storyboarduhr.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.CurrentTime" />
      </Docs>
    </Member>
    <MemberGroup MemberName="GetIsPaused">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused () As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused();" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : unit -&gt; bool" Usage="storyboard.GetIsPaused " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns><see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkContentElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkContentElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns><see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetIsPaused">
      <MemberSignature Language="C#" Value="public bool GetIsPaused (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance bool GetIsPaused(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetIsPaused(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetIsPaused (containingObject As FrameworkElement) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; bool GetIsPaused(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.GetIsPaused : System.Windows.FrameworkElement -&gt; bool" Usage="storyboard.GetIsPaused containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Ruft einen Wert ab, der angibt, ob die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde.</summary>
        <returns><see langword="true" />, wenn die für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellte <see cref="T:System.Windows.Media.Animation.Storyboard" /> angehalten wurde, andernfalls <see langword="false" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um diese Methode zum Abrufen von Informationen über die Uhr eines Storyboards zu verwenden, muss das Storyboard steuerbar sein. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Clock.IsPaused" />
      </Docs>
    </Member>
    <Member MemberName="GetTarget">
      <MemberSignature Language="C#" Value="public static System.Windows.DependencyObject GetTarget (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.DependencyObject GetTarget(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTarget(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTarget (element As DependencyObject) As DependencyObject" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::DependencyObject ^ GetTarget(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTarget : System.Windows.DependencyObject -&gt; System.Windows.DependencyObject" Usage="System.Windows.Media.Animation.Storyboard.GetTarget element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName Language="C#">[System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)]</AttributeName>
          <AttributeName Language="F#">[&lt;System.ComponentModel.DesignerSerializationVisibility(System.ComponentModel.DesignerSerializationVisibility.Hidden)&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyObject</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die Zeitachse, aus der der <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Das Abhängigkeitsobjekt, das das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Sie die angefügte-Eigenschaft mit Animations Zeitachsen, um das Zielobjekt anzugeben. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> . Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetName">
      <MemberSignature Language="C#" Value="public static string GetTargetName (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig string GetTargetName(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetName(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetName (element As DependencyObject) As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::String ^ GetTargetName(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetName : System.Windows.DependencyObject -&gt; string" Usage="System.Windows.Media.Animation.Storyboard.GetTargetName element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die Zeitachse, aus der der <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Der Name des Abhängigkeitsobjekts, das das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> angefügte-Eigenschaft für das angegebene Objekt ab. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> . Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="GetTargetProperty">
      <MemberSignature Language="C#" Value="public static System.Windows.PropertyPath GetTargetProperty (System.Windows.DependencyObject element);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig class System.Windows.PropertyPath GetTargetProperty(class System.Windows.DependencyObject element) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.GetTargetProperty(System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Function GetTargetProperty (element As DependencyObject) As PropertyPath" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static System::Windows::PropertyPath ^ GetTargetProperty(System::Windows::DependencyObject ^ element);" />
      <MemberSignature Language="F#" Value="static member GetTargetProperty : System.Windows.DependencyObject -&gt; System.Windows.PropertyPath" Usage="System.Windows.Media.Animation.Storyboard.GetTargetProperty element" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.PropertyPath</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Das Abhängigkeitsobjekt, aus dem die <see cref="F:System.Windows.Media.Animation.Storyboard.TargetProperty" /> abgerufen werden soll.</param>
        <summary>Ruft den <see cref="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />-Wert der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> ab.</summary>
        <returns>Die Eigenschaft, die das Ziel von <paramref name="element" /> ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode ruft die <xref:System.Windows.Media.Animation.Storyboard.TargetProperty> angefügte-Eigenschaft für das angegebene Objekt ab. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetProperty> angefügte Eigenschaft. Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 Beachten Sie, dass <xref:System.Windows.Media.Animation.Storyboard.TargetProperty> Diese Methode ein leeres-Element zurückgibt, wenn der im Markup festgelegt wurde, <xref:System.Windows.PropertyPath> da der Eigenschafts Verweis aufgelöst und intern gespeichert wird, wenn er analysiert wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Pause">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> , die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" />zugeordnet ist.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause();" />
      <MemberSignature Language="F#" Value="member this.Pause : unit -&gt; unit" Usage="storyboard.Pause " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> , die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" />zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard an, hat aber keinen erkennbaren Effekt, wenn es nicht aktiv oder aktuell angehalten ist. Als Nebeneffekt werden alle zugeordneten untergeordneten Elemente ebenfalls angehalten.  
  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ein angehaltene Storyboard haben, wird es anscheinend fortgesetzt und neu gestartet. Dies geschieht jedoch nicht. Die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode ersetzt das angehalten tatsächlich <xref:System.Windows.Media.Animation.Storyboard> durch eine neue nicht angehaltene Version. Jedes Mal, wenn die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode aufgerufen wird, werden Clock-Objekte für das Storyboard erstellt. Diese Uhren werden an die Eigenschaften verteilt, die Sie animieren. Wenn die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode erneut aufgerufen wird, wird die Uhr nicht neu gestartet. Sie ersetzt Sie durch neue Uhren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> des angegebenen <see cref="T:System.Windows.FrameworkContentElement" /> an, das diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard an, hat aber keinen erkennbaren Effekt, wenn es nicht aktiv oder aktuell angehalten ist. Als Nebeneffekt werden alle zugeordneten untergeordneten Elemente ebenfalls angehalten.  
  
 Wenn Sie ein angehaltene Storyboard suchen, wird dieses nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltene Storyboard fortzusetzen, ist die Verwendung der- <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Wenn <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Sie die Methode erneut aufrufen, wird das angehaltene Storyboard durch einen neuen ersetzt, der das Aussehen der Fortsetzung aufweist.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch das Anhalten der Uhr eines Storyboards wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ein angehaltene Storyboard haben, wird es anscheinend fortgesetzt und neu gestartet. Dies geschieht jedoch nicht. Die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode ersetzt sich selbst durch eine nicht angehaltene Version. Jedes Mal, wenn die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode aufgerufen wird, werden Clock-Objekte für das Storyboard erstellt. Diese Uhren werden an die Eigenschaften verteilt, die Sie animieren. Wenn die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode erneut aufgerufen wird, wird die Uhr nicht neu gestartet. Sie ersetzt Sie durch neue Uhren.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Pause">
      <MemberSignature Language="C#" Value="public void Pause (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Pause(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Pause (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Pause(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Pause : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Pause containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Hält die <see cref="T:System.Windows.Media.Animation.Clock" /> des angegebenen <see cref="T:System.Windows.FrameworkElement" /> an, das diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> zugeordnet ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode hält das Storyboard an, hat aber keinen erkennbaren Effekt, wenn es nicht aktiv oder aktuell angehalten ist. Als Nebeneffekt werden alle zugeordneten untergeordneten Elemente ebenfalls angehalten.  
  
 Wenn Sie ein angehaltene Storyboard suchen, wird dieses nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltene Storyboard fortzusetzen, ist die Verwendung der- <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. Wenn <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Sie die Methode erneut aufrufen, wird das angehaltene Storyboard durch einen neuen ersetzt, der das Aussehen der Fortsetzung aufweist.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch das Anhalten der Uhr eines Storyboards wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
## <a name="beginning-a-paused-storyboard"></a>Starten eines angehaltenen Storyboards  
 Wenn Sie <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> ein angehaltene Storyboard haben, wird es anscheinend fortgesetzt und neu gestartet. Dies geschieht jedoch nicht. Die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode ersetzt sich selbst durch eine nicht angehaltene Version. Jedes Mal, wenn die- <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode aufgerufen wird, werden Clock-Objekte für das Storyboard erstellt. Diese Uhren werden an die Eigenschaften verteilt, die Sie animieren. Wenn die <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> Methode erneut aufgerufen wird, wird die Uhr nicht neu gestartet. Sie ersetzt Sie durch neue Uhren.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, haben keine Auswirkung mehr auf die Eigenschaften, die sie ehemals animiert haben, unabhängig von deren <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove();" />
      <MemberSignature Language="F#" Value="member this.Remove : unit -&gt; unit" Usage="storyboard.Remove " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, haben keine Auswirkung mehr auf die Eigenschaften, die sie ehemals animiert haben, unabhängig von deren <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Alle interaktiven Aktionen, die auf einem ausgeführt <xref:System.Windows.Media.Animation.Clock> werden, und damit auch auf einem <xref:System.Windows.Media.Animation.Storyboard> , treten beim nächsten Tick der zeitlichen Steuerung auf, was kurz vor dem nächsten Rendervorgang erfolgt. Dies bedeutet, dass die- <xref:System.Windows.Media.Animation.Storyboard.Remove%2A> Methode bis zu diesem Zeitpunkt noch die animierten Eigenschaften beeinträchtigt. Anders ausgedrückt, wenn der Frame das nächste Mal angezeigt wird, wird das Storyboard entfernt. Wenn Sie vor diesem Zeitpunkt eine Animation von einer Eigenschaft trennen müssen, verwenden Sie die- <xref:System.Windows.UIElement.BeginAnimation%2A> Methode mit dem- `animation` Parameterwert `null` .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, haben keine Auswirkung mehr auf die Eigenschaften, die sie ehemals animiert haben, unabhängig von deren <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Wenn Sie eine Storyboarduhr entfernen, wird das- <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> Ereignis ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public void Remove (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Remove(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Remove(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Remove (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Remove(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Remove : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Remove containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Entfernt die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurden. Animationen, die zu diesem <see cref="T:System.Windows.Media.Animation.Storyboard" /> gehören, haben keine Auswirkung mehr auf die Eigenschaften, die sie ehemals animiert haben, unabhängig von deren <see cref="P:System.Windows.Media.Animation.Timeline.FillBehavior" />-Einstellung.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Wenn Sie eine Storyboarduhr entfernen, wird das- <xref:System.Windows.Media.Animation.Timeline.RemoveRequested> Ereignis ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Resume">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume();" />
      <MemberSignature Language="F#" Value="member this.Resume : unit -&gt; unit" Usage="storyboard.Resume " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Fortsetzen eines nicht angehaltenen Storyboards hat keine Auswirkungen.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Wenn Sie ein angehaltene Storyboard suchen, wird dieses nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltene Storyboard fortzusetzen, ist die Verwendung der- <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>Wenn Sie die-Methode aufrufen, nachdem das Storyboard gestartet wurde, ersetzt das alte Storyboard, das die Darstellung des fort Setzens der Methode aufweist.  
  
 Durch das Fortsetzen einer angehaltenen Zeit eines Storyboards wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkContentElement)" />
      </Docs>
    </Member>
    <Member MemberName="Resume">
      <MemberSignature Language="C#" Value="public void Resume (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Resume(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Resume(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Resume (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Resume(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Resume : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Resume containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Setzt die <see cref="T:System.Windows.Media.Animation.Clock" /> fort, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Fortsetzen eines nicht angehaltenen Storyboards hat keine Auswirkungen.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Wenn Sie ein angehaltene Storyboard suchen, wird dieses nicht fortgesetzt. Die einzige Möglichkeit, ein angehaltene Storyboard fortzusetzen, ist die Verwendung der- <xref:System.Windows.Media.Animation.Storyboard.Resume%2A> Methode. <xref:System.Windows.Media.Animation.Storyboard.Begin%2A>Wenn Sie die-Methode aufrufen, nachdem das Storyboard gestartet wurde, ersetzt das alte Storyboard, das die Darstellung des fort Setzens der Methode aufweist.  
  
 Durch das Fortsetzen einer angehaltenen Zeit eines Storyboards wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.Pause(System.Windows.FrameworkElement)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zu der Position, an der das nächste Ticken der Uhr erfolgt.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan -&gt; unit" Usage="storyboard.Seek offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse vorwärts oder rückwärts verschoben werden soll.</param>
        <summary>Durchsucht dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche bei der nächsten Zeiteinheit aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche bei der nächsten Zeiteinheit aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche bei der nächsten Zeiteinheit aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Diese Methode ändert die in die der Storyboard-Uhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> <xref:System.Windows.Media.Animation.ClockState.Active> . Diese Methode hat keine Auswirkung auf die Zeit Steuerungsstruktur, bis das nächste Mal ein Tick verarbeitet wird. Als Nebeneffekt werden die entsprechenden Ereignisse bis dahin ebenfalls nicht ausgelöst.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch das Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> -Methode und die- <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methode.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Seek(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.Seek (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> bis zur angegebenen Position. Das <see cref="T:System.Windows.Media.Animation.Storyboard" /> führt die angeforderte Suche bei der nächsten Zeiteinheit aus.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Diese Methode ändert die in die der Storyboard-Uhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> <xref:System.Windows.Media.Animation.ClockState.Active> . Diese Methode hat keine Auswirkung auf die Zeit Steuerungsstruktur, bis das nächste Mal ein Tick verarbeitet wird. Als Nebeneffekt werden die entsprechenden Ereignisse bis dahin ebenfalls nicht ausgelöst.  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernen, wenn es steuerbar ist. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch das Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
   
  
## Examples  
 Im folgenden Beispiel wird gezeigt, wie Sie nach Beginn eines Storyboards eine Sekunde suchen (überspringen).  
  
 [!code-csharp[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/timingbehaviors_procedural_snip/CSharp/SeekStoryboardExample.cs#seekstoryboardexamplewholepage)]
 [!code-vb[timingbehaviors_procedural_snip#SeekStoryboardExampleWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/timingbehaviors_procedural_snip/visualbasic/seekstoryboardexample.vb#seekstoryboardexamplewholepage)]  
  
 Im nächsten Beispiel werden sowohl die <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> -als auch die- <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methode veranschaulicht.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SeekAlignedToLastTick">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan -&gt; unit" Usage="storyboard.SeekAlignedToLastTick offset" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse vorwärts oder rückwärts verschoben werden soll.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> richtet die Seeding Zeit des <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten Takt Takt aus. Werte werden sofort aktualisiert, um die Änderungen zu widerspiegeln <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> , obwohl der Bildschirm diese Änderungen nicht widerspiegelt, bis der Bildschirm aktualisiert wird.  
  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> richtet die Seeding Zeit des <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten Takt Takt aus. Werte werden sofort aktualisiert, um die Änderungen zu widerspiegeln <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> , obwohl der Bildschirm diese Änderungen nicht widerspiegelt, bis der Bildschirm aktualisiert wird.  
  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkContentElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkContentElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkContentElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkContentElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkContentElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkContentElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> richtet die Seeding Zeit des <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten Takt Takt aus. Werte werden sofort aktualisiert, um die Änderungen zu widerspiegeln <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> , obwohl der Bildschirm diese Änderungen nicht widerspiegelt, bis der Bildschirm aktualisiert wird.  
  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Diese Methode ändert den der Storyboard-Uhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> in.  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Durch das Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> -Methode und die- <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methode.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementSeekExample.cs#frameworkcontentelementseekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementSeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementseekexample.vb#frameworkcontentelementseekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SeekAlignedToLastTick">
      <MemberSignature Language="C#" Value="public void SeekAlignedToLastTick (System.Windows.FrameworkElement containingObject, TimeSpan offset, System.Windows.Media.Animation.TimeSeekOrigin origin);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SeekAlignedToLastTick(class System.Windows.FrameworkElement containingObject, valuetype System.TimeSpan offset, valuetype System.Windows.Media.Animation.TimeSeekOrigin origin) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick(System.Windows.FrameworkElement,System.TimeSpan,System.Windows.Media.Animation.TimeSeekOrigin)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SeekAlignedToLastTick (containingObject As FrameworkElement, offset As TimeSpan, origin As TimeSeekOrigin)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SeekAlignedToLastTick(System::Windows::FrameworkElement ^ containingObject, TimeSpan offset, System::Windows::Media::Animation::TimeSeekOrigin origin);" />
      <MemberSignature Language="F#" Value="member this.SeekAlignedToLastTick : System.Windows.FrameworkElement * TimeSpan * System.Windows.Media.Animation.TimeSeekOrigin -&gt; unit" Usage="storyboard.SeekAlignedToLastTick (containingObject, offset, origin)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="offset" Type="System.TimeSpan" />
        <Parameter Name="origin" Type="System.Windows.Media.Animation.TimeSeekOrigin" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="offset">Ein positiver oder negativer Wert, der den Betrag angibt, um den die Zeitachse ab dem angegebenen <paramref name="origin" /> vorwärts oder rückwärts verschoben werden soll.</param>
        <param name="origin">Die Position, ab der <paramref name="offset" /> angewendet wird.</param>
        <summary>Durchsucht das <see cref="T:System.Windows.Media.Animation.Storyboard" /> sofort (synchron) bis zu einer neuen Position.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> richtet die Seeding Zeit des <xref:System.Windows.Media.Animation.Storyboard> mit dem letzten Takt Takt aus. Werte werden sofort aktualisiert, um die Änderungen zu widerspiegeln <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> , obwohl der Bildschirm diese Änderungen nicht widerspiegelt, bis der Bildschirm aktualisiert wird.  
  
 Beachten Sie, dass bei Such Vorgängen die-oder-Einstellungen des Storyboards nicht berücksichtigt werden <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> . Das Storyboard wird so behandelt, als wäre es ein <xref:System.Windows.Media.Animation.Timeline.SpeedRatio%2A> von 1 und Nein <xref:System.Windows.Media.Animation.ParallelTimeline.SlipBehavior%2A> .  
  
 Diese Methode ändert den der Storyboard-Uhr <xref:System.Windows.Media.Animation.Clock.CurrentState%2A> in.  
  
 <xref:System.Windows.Media.Animation.ClockState.Active>.  
  
 Durch das Suchen eines Storyboards werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
   
  
## Examples  
 Das folgende Beispiel zeigt die <xref:System.Windows.Media.Animation.Storyboard.Seek%2A> -Methode und die- <xref:System.Windows.Media.Animation.Storyboard.SeekAlignedToLastTick%2A> Methode.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/SeekExample.cs#seekexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#SeekExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/seekexample.vb#seekexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="SetSpeedRatio">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : double -&gt; unit" Usage="storyboard.SetSpeedRatio speedRatio" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu ermitteln. Die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards wird von diesem Wert nicht überschrieben. Das Aufrufen dieser Methode und die Angabe eines interaktiven Geschwindigkeitsverhältnisses von 3 für ein Storyboard mit einem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> von 0,5 ergibt für das Storyboard eine tatsächliche Geschwindigkeit von 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der für das <see cref="T:System.Windows.Media.Animation.Clock" /> erstellten <see cref="T:System.Windows.Media.Animation.Storyboard" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkContentElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkContentElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkContentElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkContentElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkContentElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkContentElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu ermitteln. Die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards wird von diesem Wert nicht überschrieben. Das Aufrufen dieser Methode und die Angabe eines interaktiven Geschwindigkeitsverhältnisses von 3 für ein Storyboard mit einem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> von 0,5 ergibt für das Storyboard eine tatsächliche Geschwindigkeit von 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der <see cref="T:System.Windows.Media.Animation.Clock" /> fest, die für diese <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch Aufrufen dieser Methode wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetSpeedRatio">
      <MemberSignature Language="C#" Value="public void SetSpeedRatio (System.Windows.FrameworkElement containingObject, double speedRatio);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SetSpeedRatio(class System.Windows.FrameworkElement containingObject, float64 speedRatio) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetSpeedRatio(System.Windows.FrameworkElement,System.Double)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SetSpeedRatio (containingObject As FrameworkElement, speedRatio As Double)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SetSpeedRatio(System::Windows::FrameworkElement ^ containingObject, double speedRatio);" />
      <MemberSignature Language="F#" Value="member this.SetSpeedRatio : System.Windows.FrameworkElement * double -&gt; unit" Usage="storyboard.SetSpeedRatio (containingObject, speedRatio)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
        <Parameter Name="speedRatio" Type="System.Double" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <param name="speedRatio">Ein endlicher Wert größer 0 (null), der das neue interaktive Geschwindigkeitsverhältnis des Storyboards darstellt. Dieser Wert wird mit dem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Wert des Storyboards multipliziert, um die tatsächliche Geschwindigkeit des Storyboards zu ermitteln. Die <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" />-Eigenschaft des Storyboards wird von diesem Wert nicht überschrieben. Das Aufrufen dieser Methode und die Angabe eines interaktiven Geschwindigkeitsverhältnisses von 3 für ein Storyboard mit einem <see cref="P:System.Windows.Media.Animation.Timeline.SpeedRatio" /> von 0,5 ergibt für das Storyboard eine tatsächliche Geschwindigkeit von 1,5.</param>
        <summary>Legt das interaktive Geschwindigkeitsverhältnis der <see cref="T:System.Windows.Media.Animation.Clock" /> fest, die für diese <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 Durch Aufrufen dieser Methode wird das- <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignis ausgelöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SetTarget">
      <MemberSignature Language="C#" Value="public static void SetTarget (System.Windows.DependencyObject element, System.Windows.DependencyObject value);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTarget(class System.Windows.DependencyObject element, class System.Windows.DependencyObject value) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTarget(System.Windows.DependencyObject,System.Windows.DependencyObject)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTarget (element As DependencyObject, value As DependencyObject)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTarget(System::Windows::DependencyObject ^ element, System::Windows::DependencyObject ^ value);" />
      <MemberSignature Language="F#" Value="static member SetTarget : System.Windows.DependencyObject * System.Windows.DependencyObject -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTarget (element, value)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="value" Type="System.Windows.DependencyObject" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, deren Ziel das angegebene Abhängigkeitsobjekt sein sollte.</param>
        <param name="value">Das Abhängigkeitsobjekt, das als Ziel festgelegt werden soll.</param>
        <summary>Legt das Abhängigkeitsobjekt als Ziel der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.Target%2A> angefügte-Eigenschaft für das angegebene Objekt fest. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> . Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
> [!NOTE]
>  Die- <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Eigenschaft ist nicht serialisierbar, da Sie auf beliebig festgelegt werden kann <xref:System.Windows.DependencyObject> . Es ist nicht sichergestellt, dass auf dieses Objekt in XAML ordnungsgemäß verwiesen werden kann.  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetName">
      <MemberSignature Language="C#" Value="public static void SetTargetName (System.Windows.DependencyObject element, string name);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetName(class System.Windows.DependencyObject element, string name) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetName(System.Windows.DependencyObject,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetName (element As DependencyObject, name As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetName(System::Windows::DependencyObject ^ element, System::String ^ name);" />
      <MemberSignature Language="F#" Value="static member SetTargetName : System.Windows.DependencyObject * string -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetName (element, name)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="name" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, deren Ziel das angegebene Abhängigkeitsobjekt sein sollte.</param>
        <param name="name">Der Name des als Ziel zu verwendenden Abhängigkeitsobjekts.</param>
        <summary>Legt das angegebene <see cref="T:System.Windows.Media.Animation.Timeline" />-Ziel als Abhängigkeitsobjekt mit dem angegebenen Namen fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> angefügte-Eigenschaft für das angegebene Objekt fest. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> . Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="SetTargetProperty">
      <MemberSignature Language="C#" Value="public static void SetTargetProperty (System.Windows.DependencyObject element, System.Windows.PropertyPath path);" />
      <MemberSignature Language="ILAsm" Value=".method public static hidebysig void SetTargetProperty(class System.Windows.DependencyObject element, class System.Windows.PropertyPath path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SetTargetProperty(System.Windows.DependencyObject,System.Windows.PropertyPath)" />
      <MemberSignature Language="VB.NET" Value="Public Shared Sub SetTargetProperty (element As DependencyObject, path As PropertyPath)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static void SetTargetProperty(System::Windows::DependencyObject ^ element, System::Windows::PropertyPath ^ path);" />
      <MemberSignature Language="F#" Value="static member SetTargetProperty : System.Windows.DependencyObject * System.Windows.PropertyPath -&gt; unit" Usage="System.Windows.Media.Animation.Storyboard.SetTargetProperty (element, path)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="element" Type="System.Windows.DependencyObject" />
        <Parameter Name="path" Type="System.Windows.PropertyPath" />
      </Parameters>
      <Docs>
        <param name="element">Die <see cref="T:System.Windows.Media.Animation.Timeline" />, der die angegebene Abhängigkeitseigenschaft zugeordnet werden soll.</param>
        <param name="path">Ein Pfad, der die zu animierende Abhängigkeitseigenschaft beschreibt.</param>
        <summary>Legt die angegebene Abhängigkeitseigenschaft als Ziel der angegebenen <see cref="T:System.Windows.Media.Animation.Timeline" /> fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode legt die <xref:System.Windows.Media.Animation.Storyboard.TargetProperty> angefügte-Eigenschaft für das angegebene Objekt fest. Weitere Informationen zur Funktionsweise der Storyboard-Zielplattform finden Sie unter <xref:System.Windows.Media.Animation.Storyboard.TargetProperty> . Weitere Informationen zur Funktionsweise angefügter Eigenschaften finden Sie unter [Übersicht über angefügte Eigenschaften](/dotnet/framework/wpf/advanced/attached-properties-overview).  
  
 ]]></format>
        </remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
    <MemberGroup MemberName="SkipToFill">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill();" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : unit -&gt; unit" Usage="storyboard.SkipToFill " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt die aktuelle Uhrzeit des Storyboards auf das Ende des aktiven Zeitraums. das Verhalten des Storyboards an dieser Stelle wird durch die- <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> Einstellung angegeben. Wenn <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> auf festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd> , wird das Storyboard gefüllt. wenn die-Eigenschaft auf festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.Stop> , wird das Storyboard angehalten.  
  
 Wenn Sie diese Methode für ein Storyboard mit einer unendlichen Dauer aufrufen, hat eine unendliche Anzahl von Wiederholungen keine Auswirkung. Das Aufrufen dieser Methode in einem inaktiven Storyboard hat keine Auswirkungen.  
  
 Wenn Sie eine Uhr auf den Füllzeitraum setzen, werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="SkipToFill">
      <MemberSignature Language="C#" Value="public void SkipToFill (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void SkipToFill(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.SkipToFill(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub SkipToFill (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void SkipToFill(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.SkipToFill : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.SkipToFill containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Legt die aktuelle Uhrzeit der <see cref="T:System.Windows.Media.Animation.Clock" /> des Storyboards auf das Ende seines Aktivitätszeitraums fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methode verschiebt die aktuelle Uhrzeit des Storyboards auf das Ende des aktiven Zeitraums. das Verhalten des Storyboards an dieser Stelle wird durch die- <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> Einstellung angegeben. Wenn <xref:System.Windows.Media.Animation.Timeline.FillBehavior%2A> auf festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.HoldEnd> , wird das Storyboard gefüllt. wenn die-Eigenschaft auf festgelegt ist <xref:System.Windows.Media.Animation.FillBehavior.Stop> , wird das Storyboard angehalten.  
  
 Wenn Sie diese Methode für ein Storyboard mit einer unendlichen Dauer aufrufen, hat eine unendliche Anzahl von Wiederholungen keine Auswirkung. Das Aufrufen dieser Methode in einem inaktiven Storyboard hat keine Auswirkungen.  
  
 Wenn Sie eine Uhr auf den Füllzeitraum setzen, werden die <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> Ereignisse und ausgelöst <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> .  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Stop">
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop();" />
      <MemberSignature Language="F#" Value="member this.Stop : unit -&gt; unit" Usage="storyboard.Stop " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Beachten Sie, dass das Beenden eines Storyboards nicht das <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis auslöst.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkContentElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkContentElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkContentElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkContentElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkContentElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkContentElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkContentElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkContentElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Media.Animation.ClockState.Stopped> Storyboard wirkt sich nicht mehr auf die Zieleigenschaften aus: Eigenschaften, die animiert wurden, werden auf Ihre vorherigen Werte zurückgesetzt.  
  
 Das Beenden einer Uhr löst das <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> -Ereignis und das- <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignis aus, aber nicht das- <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein steuerbares Storyboard zum Animieren einer verwendet <xref:System.Windows.Media.TextEffect> . Der <xref:System.Windows.Media.TextEffect> ist in einem <xref:System.Windows.FrameworkContentElement> -namens Bereich enthalten.  
  
 [!code-csharp[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/csharp/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/CSharp/FrameworkContentElementControlStoryboardExample.cs#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]
 [!code-vb[StoryboardBeginAnimation_procedural_snip#FrameworkContentElementControlStoryboardExampleUsingWholePage](~/samples/snippets/visualbasic/VS_Snippets_Wpf/StoryboardBeginAnimation_procedural_snip/visualbasic/frameworkcontentelementcontrolstoryboardexample.vb#frameworkcontentelementcontrolstoryboardexampleusingwholepage)]  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Stop">
      <MemberSignature Language="C#" Value="public void Stop (System.Windows.FrameworkElement containingObject);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Stop(class System.Windows.FrameworkElement containingObject) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Windows.Media.Animation.Storyboard.Stop(System.Windows.FrameworkElement)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Stop (containingObject As FrameworkElement)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Stop(System::Windows::FrameworkElement ^ containingObject);" />
      <MemberSignature Language="F#" Value="member this.Stop : System.Windows.FrameworkElement -&gt; unit" Usage="storyboard.Stop containingObject" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="containingObject" Type="System.Windows.FrameworkElement" />
      </Parameters>
      <Docs>
        <param name="containingObject">Das beim Aufrufen der <see cref="M:System.Windows.Media.Animation.Storyboard.Begin(System.Windows.FrameworkElement,System.Boolean)" />-Methode angegebene Objekt. Dieses Objekt enthält die <see cref="T:System.Windows.Media.Animation.Clock" />-Objekte, die für dieses Storyboard und seine untergeordneten Elemente erstellt wurden.</param>
        <summary>Beendet die <see cref="T:System.Windows.Media.Animation.Clock" />, die für dieses <see cref="T:System.Windows.Media.Animation.Storyboard" /> erstellt wurde.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein <xref:System.Windows.Media.Animation.ClockState.Stopped> Storyboard wirkt sich nicht mehr auf die Zieleigenschaften aus: Eigenschaften, die animiert wurden, werden auf Ihre vorherigen Werte zurückgesetzt.  
  
 Das Beenden einer Uhr löst das <xref:System.Windows.Media.Animation.Timeline.CurrentGlobalSpeedInvalidated> -Ereignis und das- <xref:System.Windows.Media.Animation.Timeline.CurrentStateInvalidated> Ereignis aus, aber nicht das- <xref:System.Windows.Media.Animation.Timeline.Completed> Ereignis  
  
 Um dieses Storyboard interaktiv zu steuern, müssen Sie den gleichen `containingObject` Parameter verwenden, wenn Sie die interaktiven Methoden aufrufen, die Sie zum Starten des Storyboards verwendet haben. Ein steuerbares Storyboard kann anhalten, fortsetzen, suchen, anhalten und entfernt werden. Um ein Storyboard im Code steuerbar zu machen, müssen Sie die entsprechende Überladung der-Methode des Storyboards verwenden <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> und angeben `true` , um es steuerbar zu machen. Ein Beispiel finden Sie unter Gewusst [wie: Steuern eines Storyboards, nachdem es gestartet](/dotnet/framework/wpf/graphics-multimedia/how-to-control-a-storyboard-after-it-starts)wurde.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Target">
      <MemberSignature Language="C#" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="ILAsm" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.Target" />
      <MemberSignature Language="VB.NET" Value="see GetTarget, and SetTarget" />
      <MemberSignature Language="F#" Value="see GetTarget, and SetTarget" Usage="see GetTarget, and SetTarget" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft das zu animierende Objekt ab oder legt dieses fest.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Zielobjekt muss ein Abhängigkeits Objekt sein.  
  
> [!NOTE]
>  Die- <xref:System.Windows.Media.Animation.Storyboard.Target%2A> Eigenschaft ist nicht serialisierbar, da Sie auf beliebig festgelegt werden kann <xref:System.Windows.DependencyObject> . Es ist nicht sichergestellt, dass in XAML auf dieses Objekt ordnungsgemäß verwiesen werden kann.  
  
<a name="dependencyPropertyInfo_Target"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.Animation.Storyboard.TargetProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetName">
      <MemberSignature Language="C#" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="ILAsm" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="DocId" Value="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      <MemberSignature Language="VB.NET" Value="see GetTargetName, and SetTargetName" />
      <MemberSignature Language="F#" Value="see GetTargetName, and SetTargetName" Usage="see GetTargetName, and SetTargetName" />
      <MemberType>AttachedProperty</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft den Namen des zu animierenden Objekts ab oder legt ihn fest. Das Objekt muss ein <see cref="T:System.Windows.FrameworkElement" />, <see cref="T:System.Windows.FrameworkContentElement" /> oder <see cref="T:System.Windows.Freezable" /> sein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Festlegen dieser Eigenschaft ist optional. Wenn <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> nicht angegeben ist, werden die Animationen eines Storyboards auf eine der folgenden Aktionen angewendet:  
  
-   Wenn das Storyboard, zu dem die Animation gehört, mit einem gestartet wurde <xref:System.Windows.Media.Animation.BeginStoryboard> , wird das Element, das die Aktion besitzt, die <xref:System.Windows.Media.Animation.BeginStoryboard> das Storyboard auslöst, als Ziel verwendet.  
  
-   Wenn das Storyboard mithilfe der-Methode gestartet wurde <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> , <xref:System.Windows.FrameworkElement> wird das oder das <xref:System.Windows.FrameworkContentElement> angegeben, wenn das Storyboard mit der-Methode gestartet wurde <xref:System.Windows.Media.Animation.Storyboard.Begin%2A> .  
  
 Wenn diese Eigenschaft für eine Zeitachse mit untergeordneten Elementen festgelegt wird, erben diese untergeordneten Zeitachsen die übergeordneten Elemente, <xref:System.Windows.Media.Animation.Storyboard.TargetName%2A> sofern Sie keine eigenen angeben.  
  
## <a name="making-an-object-targetable"></a>Erstellen eines Objekts mit targetable  
 Wenn [!INCLUDE[TLA2#tla_xaml](~/includes/tla2sharptla-xaml-md.md)] Sie verwenden, führen Sie eine der beiden folgenden Aktionen aus, um ein Objekt zu erstellen, das von einem Storyboard als Ziel Tabelle verwendet wird:  
  
-   Wenn das Objekt ein <xref:System.Windows.FrameworkElement> oder ein ist <xref:System.Windows.FrameworkContentElement> , legen Sie dessen- <xref:System.Windows.FrameworkElement.Name%2A> Eigenschaft fest.  
  
-   Wenn das Objekt ein <xref:System.Windows.Freezable> oder ein benutzerdefiniertes <xref:System.Windows.FrameworkContentElement> oder ist <xref:System.Windows.FrameworkContentElement> , weisen Sie ihm mithilfe der [x:Name](/dotnet/framework/xaml-services/x-name-directive) -direktivenmarkererweiterung einen Namen zu.  
  
 Wenn Sie Code verwenden, erstellen Sie ein Objekt mit der- <xref:System.Windows.NameScope.RegisterName%2A> Methode, um dem Objekt einen Namen zuzuweisen.  
  
<a name="dependencyPropertyInfo_TargetName"></a>   
## <a name="dependency-property-information"></a>Informationen zur Abhängigkeitseigenschaft  
  
|||  
|-|-|  
|Bezeichnerfeld|<xref:System.Windows.Media.Animation.Storyboard.TargetNameProperty>|  
|Metadateneigenschaften auf `true` festgelegt|Keine|  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="TargetNameProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetNameProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetNameProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetNameProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetNameProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetNameProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetNameProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.Target" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetName" />
      </Docs>
    </Member>
    <Member MemberName="TargetPropertyProperty">
      <MemberSignature Language="C#" Value="public static readonly System.Windows.DependencyProperty TargetPropertyProperty;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly class System.Windows.DependencyProperty TargetPropertyProperty" />
      <MemberSignature Language="DocId" Value="F:System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly TargetPropertyProperty As DependencyProperty " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly System::Windows::DependencyProperty ^ TargetPropertyProperty;" />
      <MemberSignature Language="F#" Value=" staticval mutable TargetPropertyProperty : System.Windows.DependencyProperty" Usage="System.Windows.Media.Animation.Storyboard.TargetPropertyProperty" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>PresentationFramework</AssemblyName>
        <AssemblyVersion>3.0.0.0</AssemblyVersion>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
        <AssemblyVersion>5.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Windows.DependencyProperty</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Bezeichnet die angefügte <see cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />-Eigenschaft.</summary>
        <remarks>To be added.</remarks>
        <altmember cref="P:System.Windows.Media.Animation.Storyboard.TargetProperty" />
      </Docs>
    </Member>
  </Members>
</Type>
