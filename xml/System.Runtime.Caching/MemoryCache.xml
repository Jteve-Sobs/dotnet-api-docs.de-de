<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="8a5e7c8ab9dab691bba880d9398bb5da07f52844" /><Meta Name="ms.sourcegitcommit" Value="b53d35b4a410c949742abd4c6a989d1af5357bca" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/21/2020" /><Meta Name="ms.locfileid" Value="86771492" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den Typ dar, der einen Cache im Arbeitsspeicher implementiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache> -Klasse ist eine konkrete Implementierung der abstrakten <xref:System.Runtime.Caching.ObjectCache> -Klasse.  
  
> [!NOTE]
>  Die- <xref:System.Runtime.Caching.MemoryCache> Klasse ähnelt der ASP.net- <xref:System.Web.Caching.Cache> Klasse. Die <xref:System.Runtime.Caching.MemoryCache> -Klasse verfügt über viele Eigenschaften und Methoden für den Zugriff auf den Cache, der Ihnen vertraut ist, wenn Sie die ASP.NET-Klasse verwendet haben <xref:System.Web.Caching.Cache> . Die Hauptunterschiede zwischen der <xref:System.Web.Caching.Cache> -Klasse und der-Klasse <xref:System.Runtime.Caching.MemoryCache> sind, dass die- <xref:System.Runtime.Caching.MemoryCache> Klasse geändert wurde, damit Sie von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Anwendungen verwendet werden kann, die keine ASP.NET-Anwendungen sind. Die- <xref:System.Runtime.Caching.MemoryCache> Klasse hat z. b. keine Abhängigkeiten von der- `System.Web` Assembly. Ein weiterer Unterschied besteht darin, dass Sie mehrere Instanzen der <xref:System.Runtime.Caching.MemoryCache> -Klasse für die Verwendung in derselben Anwendung und in derselben-Instanz erstellen können <xref:System.AppDomain> .  
  
 Die- <xref:System.Runtime.Caching.MemoryCache> Klasse lässt nicht `null` als Wert im Cache zu. Jeder Versuch, einen Cache Eintrag mit dem Wert hinzuzufügen oder zu ändern, `null` schlägt fehl.  
  
 Der- <xref:System.Runtime.Caching.MemoryCache> Typ implementiert keine *Cache Regionen*. Wenn Sie also Methoden aufrufen, <xref:System.Runtime.Caching.MemoryCache> die Basis Methoden implementieren, die einen Parameter für Regionen enthalten, übergeben Sie keinen Wert für den-Parameter. Die Methoden, die den Regions Parameter verwenden, stellen einen Standard `null` Wert bereit. Beispielsweise verfügt die- <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> Methoden Überladung über einen `regionName` Parameter, dessen Standardwert ist `null` .  
  
   
  
## Examples  
 Im folgenden Beispiel wird ein Verweis auf die Standard-Speicher Cache Instanz deklariert. Der Cache Eintrag verwendet ein <xref:System.Runtime.Caching.CacheItemPolicy> -Objekt, um Entfernungs-und Ablauf Details für den Cache Eintrag bereitzustellen. Außerdem wird ein- <xref:System.Runtime.Caching.ChangeMonitor> Objekt verwendet, um den Status der Quelldaten (eine Datei) im Dateisystem zu überwachen.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/ff477235(v=vs.140)">Exemplarische Vorgehensweise: Zwischenspeichern von Anwendungsdaten in ASP.NET</related>
    <related type="Article" href="/dotnet/framework/performance/caching-in-net-framework-applications">Caching in .NET Framework-Anwendungen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = Nothing)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der beim Nachschlagen von Konfigurationsinformationen verwendet werden soll.  
  
 <c>Hinweis</c> Es ist nicht erforderlich, dass für jeden Namen Konfigurationsinformationen vorhanden sind.  
  
Wenn ein passender Konfigurationseintrag vorhanden ist, werden die Konfigurationsinformationen verwendet, um die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz zu konfigurieren. Wenn kein entsprechender Konfigurationseintrag vorhanden ist, kann auf den Namen über die <see cref="P:System.Runtime.Caching.MemoryCache.Name" />-Eigenschaft zugegriffen werden, da der angegebene Name der <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz zugeordnet ist. Weitere Informationen über die Speichercachekonfiguration finden Sie unter <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Eine Auflistung von Name-Wert-Paaren mit Konfigurationsinformationen zum Konfigurieren des Caches.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, überprüft Sie, ob Konfigurationseinträge vorhanden sind, die möglicherweise überschrieben wurden, indem der optionale- `config` Parameter im-Konstruktor verwendet wurde. Sie können die folgenden Parameter im- `config` Parameter übergeben. Alle Werte können als ganze Zahlen übermittelt werden.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Wenn dieser Konstruktor aufgerufen wird, werden die Konfigurationseinstellungen zuerst aus den Anwendungs Konfigurationsdateien abgerufen. Wenn in der Anwendungs Konfigurationsdatei keine Konfigurationseinträge vorhanden sind, werden nur die in bereitgestellten Einstellungen `config` angewendet. Wenn die Konfigurationseinträge in der Anwendungskonfiguration vorhanden sind und Informationen ebenfalls weitergegeben `config` werden, überschreibt die Informationen in die Informationen, die `config` aus der Konfigurationsdatei gelesen werden.  
  
 Der Name, der einer Cache Instanz zugewiesen ist, wird auf zweierlei Weise verwendet:  
  
-   , Um die Nachverfolgung mehrerer Cache Instanzen zu unterstützen, wenn mehr als eine Instanz vorhanden ist.  
  
-   , Um auf Einstellungen in der Konfigurationsdatei zu verweisen, wenn die <xref:System.Runtime.Caching.MemoryCache> Instanz initialisiert wird.  
  
    > [!NOTE]
    >  Es gibt keinen Mechanismus zum Erzwingen eindeutiger Namen für Cache Instanzen. Daher ist es möglich, mehrere Cache Instanzen mit demselben Namen zu haben.  
  
    > [!CAUTION]
    >  Erstellen Sie keine <xref:System.Runtime.Caching.MemoryCache> Instanzen, es sei denn, dies ist erforderlich. Wenn Sie Cache Instanzen in Client-und Webanwendungen erstellen, <xref:System.Runtime.Caching.MemoryCache> sollten die Instanzen früh im Lebenszyklus der Anwendung erstellt werden. Sie müssen nur die Anzahl der Cache Instanzen erstellen, die in der Anwendung verwendet werden, und Verweise auf die Cache Instanzen in Variablen speichern, auf die Global zugegriffen werden kann. In ASP.NET-Anwendungen können Sie z. b. die Verweise im Anwendungs Zustand speichern. Wenn Sie nur eine einzelne Cache Instanz in Ihrer Anwendung erstellen, verwenden Sie den Standard Cache, und rufen Sie aus der-Eigenschaft einen Verweis darauf ab, <xref:System.Runtime.Caching.MemoryCache.Default%2A> Wenn Sie auf den Cache zugreifen müssen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Name bzw. Wert im <paramref name="config" />-Parameter konnte nicht analysiert werden.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Ein Wert in der <paramref name="config" />-Auflistung ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der beim Nachschlagen von Konfigurationsinformationen verwendet werden soll.</param>
        <param name="config">Eine Auflistung von Name-Wert-Paaren mit Konfigurationsinformationen zum Konfigurieren des Caches.</param>
        <param name="ignoreConfigSection">Gibt an, ob der Konfigurationsabschnitt ignoriert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag als eine <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz ein und fügt Details wie der Eintrag zu entfernen ist im Cache hinzu.</summary>
        <returns><see langword="true" />, wenn der Einfügevorgang erfolgreich war, oder FALSE, wenn bereits ein Eintrag mit demselben Schlüssel wie das Element im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> Methoden Überladungen werden verwendet, um einen Cache Eintrag in den Cache einzufügen. Wenn kein Cache Eintrag mit einem übereinstimmenden Schlüssel vorhanden ist, fügen diese Methoden einen neuen Eintrag ein. Wenn bereits ein Cache Eintrag mit einem übereinstimmenden Schlüssel vorhanden ist, wird der vorhandene Eintrag zurückgegeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung der angegebenen <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz und Details zur Entfernung des Eintrags im Cache hinzu.</summary>
        <returns>Der vorhandene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der `item` -Parameter liefert den Schlüssel und den Wert, der von der-Methode verwendet wird. Wenn der Cache über einen Cache Eintrag mit demselben Schlüssel wie der Schlüssel des `item` Parameters verfügt, gibt die Methode den vorhandenen Eintrag als- <xref:System.Runtime.Caching.CacheItem> Instanz zurück. Wenn kein vorhandener Cache Eintrag vorhanden ist, erstellt die Methode eine neue, indem Sie den vom-Parameter bereitgestellten Schlüssel und Wert `item` sowie die Entfernungs Details verwendet, die von angegeben werden `policy` .  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Runtime.Caching.CacheItem.Value" />-Eigenschaft ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl der absolute und gleitende Ablaufzeitwert für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt werden auf andere Werte als die Standardwerte der <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Felder und der <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Felder festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten Ablaufzeit und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz verwenden. Die andere Ablaufeinstellung muss auf das <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Feld oder das <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Feld festgelegt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den hinzuzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung des angegebenen Schlüssels, eines Werts und eines absoluten Ablaufwerts im Cache hinzu.</summary>
        <returns>Der vorhandene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Cache keinen Cache Eintrag hat, dessen Schlüssel mit dem- `key` Parameter übereinstimmt, wird ein neuer Cache Eintrag erstellt, und die <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> Methoden Überladung gibt zurück `null` . Wenn ein übereinstimmender Cache Eintrag vorhanden ist, wird der vorhandene Eintrag zurückgegeben.  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl der absolute und gleitende Ablaufzeitwert für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt werden auf andere Werte als die Standardwerte der <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Felder und der <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Felder festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten Ablaufzeit und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz verwenden. Die andere Ablaufeinstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der hinzugefügt oder abgerufen werden soll.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung des angegebenen Schlüssels und Werts und der angegebenen Details zur Entfernung in den Cache ein.</summary>
        <returns>Ein Cacheeintrag, wenn bereits ein entsprechender Cacheeintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl die absoluten als auch die gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts werden auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
Oder 
Sowohl der Löschrückruf als auch der Updaterückruf wurden für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben. Der <see cref="T:System.Runtime.Caching.MemoryCache" /> unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> wurde auf einen Wert größer als ein Jahr festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Speicherplatz auf dem Computer, der vom Cache verwendet werden kann, in Bytes ab.</summary>
        <value>Der Speicherplatz in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die aktuelle Instanz des Caches den von der-Eigenschaft festgelegten Grenzwert für den Arbeitsspeicher überschreitet <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> , entfernt die Cache Implementierung Cache Einträge. Jede Cache Instanz in der Anwendung kann die Menge an Arbeitsspeicher verwenden, die von der-Eigenschaft angegeben wird <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> .  
  
 Die Einstellungen für die- <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> Eigenschaft können in der Anwendungs Konfigurationsdatei angegeben werden. Alternativ können Sie im Konstruktor übergeben werden, wenn die- <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird. Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt; NamedCaches- &gt; Element (Cache Einstellungen)](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings). Weitere Informationen zum Festlegen dieses Werts, wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter der- <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> Methode.  
  
 <xref:System.Runtime.Caching.MemoryCache>erzwingt nicht sofort <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> , wenn einer-Instanz ein neues Element hinzugefügt wird <xref:System.Runtime.Caching.MemoryCache> . Die interne Heuristik, die zusätzliche Elemente aus der entfernt, <xref:System.Runtime.Caching.MemoryCache> führt Sie schrittweise aus und berücksichtigt Informationen aus dem Garbage Collector (siehe [Garbage Collection](/dotnet/standard/garbage-collection/)) und anderen Faktoren wie der aktuellen Cache Größe und der Gesamtauslastung des System Arbeitsspeichers. Obwohl der <xref:System.Runtime.Caching.MemoryCache> versucht, die Cache Größe innerhalb der konfigurierten beizubehalten, <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> ist es möglich, den Grenzwert vorübergehend zu überschreiten, indem Cache Elemente mit sehr hoher Geschwindigkeit hinzugefügt werden.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;NamedCaches- &gt; Element (Cache Einstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = Nothing) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den zu suchenden Cacheeintrag.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Bestimmt, ob ein Cacheeintrag im Cache vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der Cache einen Cacheeintrag enthält, dessen Schlüssel <paramref name="key" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = Nothing) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Enumeration eindeutiger Cacheeintragsschlüssel für das <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Erstellt ein <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt, das Ereignisse auslösen kann, wenn Änderungen an angegebenen Cacheeinträgen vorgenommen werden.</summary>
        <returns>Eine Änderungsüberwachung, die Einträge im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> Methode erstellt eine- <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanz. Dieser spezialisierte Änderungs Monitor wird verwendet, um die in der Auflistung angegebenen Cache Einträge zu überwachen `keys` und Ereignisse bei einer Änderung der Einträge zu Triggern.  
  
 Ein überwachter Eintrag wird aus einem der folgenden Gründe als geändert betrachtet:  
  
-   Der Schlüssel ist zum Zeitpunkt des Aufrufes der-Methode nicht vorhanden <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> . In diesem Fall wird die resultierende <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanz sofort auf einen geänderten Zustand festgelegt. Dies bedeutet, dass der Rückruf sofort ausgelöst wird, wenn der Code anschließend einen Änderungs Benachrichtigungs Rückruf bindet.  
  
-   Der zugehörige Cache Eintrag wurde aus dem Cache entfernt. Dies kann vorkommen, wenn der Eintrag explizit entfernt wird, wenn er abläuft, oder wenn er entfernt wird, um Arbeitsspeicher wiederherzustellen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Element in der <paramref name="keys" />-Auflistung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die <see cref="T:System.Runtime.Caching.MemoryCache" />-Standardinstanz ab.</summary>
        <value>Die Standardinstanz des Caches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer einen Verweis auf die Standard Cache Instanz zurück. Für typische Anwendungsszenarien ist nur eine Instanz von <xref:System.Runtime.Caching.MemoryCache> erforderlich.  
  
 Da die Standard Cache Instanz nicht vom Konstruktor erstellt wird, müssen Sie die Konfiguration verwenden, um die Speicher-und Abruf Werte für die Standard Cache Instanz explizit festzulegen. Weitere Informationen finden Sie unter [ &lt; MemoryCache- &gt; Element (Cache Einstellungen)](/dotnet/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings">&lt;MemoryCache- &gt; Element (Cache Einstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Beschreibung der Funktionen ab, die der Cache bereitstellt.</summary>
        <value>Eine bitweise Kombination von Flags, die die Standardfunktionen der Cacheimplementierung angeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen einer Cache Implementierung sind eine Kombination der folgenden Werte:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede <xref:System.Runtime.Caching.MemoryCache> Instanz ist an das <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> Ereignis gebunden. Wenn jedoch beim Herunterfahren der Anwendungsdomäne ein Speicher basierter Cache nicht explizit verworfen wurde, ruft die Cache Instanz automatisch die- <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> Methode auf.  
  
 Die verworfene Cache Instanz wird mit den folgenden Schritten heruntergefahren:  
  
1.  Der Status des Caches wird festgelegt, um anzugeben, dass der Cache verworfen wird. Jeder Versuch, öffentliche zwischen Speicherungs Methoden aufzurufen, die den Status des Caches ändern, wie z. b. Methoden zum Hinzufügen, entfernen oder Abrufen von Cache Einträgen, kann zu unerwartetem Verhalten führen. Wenn Sie z. b. die-Methode aufrufen, <xref:System.Runtime.Caching.MemoryCache.Set%2A> nachdem der Cache verworfen wurde, tritt ein No-op-Fehler auf. Wenn Sie versuchen, Elemente aus dem Cache abzurufen, <xref:System.Runtime.Caching.MemoryCache.Get%2A> gibt die Methode immer zurück `null` .  
  
2.  Die Leistungsdaten des Leistungs Zählers werden nicht mehr von der aktuellen Cache Instanz ausgelöst.  
  
3.  Alle Verweise auf zwischengespeicherte Objekte, die von der aktuellen Cache Instanz gehalten werden, werden freigegeben.  
  
4.  Alle <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanzen, die derzeit Einträge im Cache überwachen, werden benachrichtigt.  
  
5.  Rückruf Objekte, die Benachrichtigungen über Änderungen für diese Monitore bereitstellen, werden aufgerufen.  
  
6.  Alle- <xref:System.Web.Caching.CacheItemRemovedCallback> Instanzen, die mit Einträgen im Cache registriert sind, werden aufgerufen. Der Entfernungs Grund, der an die Rückrufe übermittelt wird, ist <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt einen Eintrag aus dem Cache zurück.</summary>
        <returns>Ein Verweis auf den Cacheeintrag, der von <paramref name="key" /> identifiziert wird, wenn der Eintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = Nothing) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt den angegebenen Eintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz aus dem Cache zurück.</summary>
        <returns>Ein Verweis auf den Cacheeintrag, der von <paramref name="key" /> identifiziert wird, wenn der Eintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der durch angegebene Cache Eintrag `key` im Cache vorhanden ist, <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> gibt die Methode ihn als- <xref:System.Runtime.Caching.CacheItem> Instanz zurück. Die <xref:System.Runtime.Caching.CacheItem.Key%2A> -Eigenschaft und die-Eigenschaft <xref:System.Runtime.Caching.CacheItem.Value%2A> der- <xref:System.Runtime.Caching.CacheItem> Instanz werden festgelegt. Die-Eigenschaft ist jedoch <xref:System.Runtime.Caching.CacheItem.RegionName%2A> `null` , da Regionen nicht in der-Klasse implementiert werden <xref:System.Runtime.Caching.MemoryCache> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = Nothing) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt die Gesamtanzahl von Cacheeinträgen im Cache zurück.</summary>
        <returns>Die Anzahl von Einträgen im Cache.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen Enumerator, der zum Durchlaufen einer Auflistung von Cacheeinträgen verwendet werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Enumerator, der von der-Methode zurückgegeben wird, kann zum Durchlaufen von <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> Einträgen im Cache verwendet werden.  
  
> [!IMPORTANT]
>  Das Abrufen eines Enumerators für eine <xref:System.Runtime.Caching.MemoryCache> -Instanz ist ein ressourcenintensiver und blockierender Vorgang. Daher sollte der Enumerator nicht in Produktionsanwendungen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = Nothing) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">Der Name der Region.</param>
        <summary>Ruft die Größe des benannten Bereichs ab.</summary>
        <returns>Die Größe des benannten Bereichs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = Nothing) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Ein Satz von eindeutigen Bezeichnern für die zurückzugebenden Cacheeinträge.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt einen Satz von Cacheeinträgen zurück, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Satz von Cacheeinträgen, die den angegebenen Schlüsseln entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Cache Eintrag, der von dargestellt wird `keys` , nicht vorhanden ist, wird der entsprechende Wert für das zurückgegebene Objekt im Wörterbuch auf festgelegt `null` . Daher verfügt das zurückgegebene Wörterbuch immer über die gleiche Anzahl von Elementen wie die Anzahl der Elemente in `keys` .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein individueller Schlüssel in der Auslistung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cachewert, der abgerufen bzw. festgelegt werden soll.</param>
        <summary>Ruft einen Wert im Cache mithilfe der Standardindexereigenschaft für eine Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ab, oder legt ihn fest.</summary>
        <value>Der Wert in der Cacheinstanz für den angegebenen Schlüssel, falls der Eintrag vorhanden ist, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft festlegen, wird der Wert in den Cache eingefügt. Die Ablauf Richtlinie für den Cache Eintrag ist auf festgelegt <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> . Wenn bereits ein Cache Eintrag mit einem übereinstimmenden Schlüssel vorhanden ist, wird sein Wert aktualisiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder - 
Der eingefügte Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName Language="C#">[get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")]</AttributeName>
          <AttributeName Language="F#">[&lt;get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")&gt;]</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Caches ab.</summary>
        <value>Der Name des Caches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.MemoryCache.Name%2A> Eigenschaft gibt den Namen der aktuellen Instanz der- <xref:System.Runtime.Caching.MemoryCache> Klasse zurück. In einer Anwendung, die mehrere Cache Instanzen verwendet, können Sie die-Eigenschaft verwenden, <xref:System.Runtime.Caching.MemoryCache.Name%2A> um-Instanzen zu unterscheiden. Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. Der standardmäßige speicherbasierte Cache gibt den Standardnamen zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Prozentsatz des physischen Arbeitsspeichers ab, der vom Cache verwendet werden kann.</summary>
        <value>Der Prozentsatz des physischen Arbeitsspeichers, der vom Cache verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Eigenschaft gibt den Prozentsatz des gesamten Arbeitsspeichers des physischen Computers zurück, der von einer einzelnen Instanz der-Klasse verwendet werden kann <xref:System.Runtime.Caching.MemoryCache> . Wenn die Cache Instanz den angegebenen Grenzwert überschreitet, werden Cache Einträge entfernt.  
  
 Die Einstellungen für die- <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Eigenschaft können in der Anwendungs Konfigurationsdatei angegeben werden. Sie können auch von einem Aufrufer übergeben werden, wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird. Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt; NamedCaches- &gt; Element (Cache Einstellungen)](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings). Weitere Informationen zum Konfigurieren der-Eigenschaft, wenn die- <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter der- <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;NamedCaches- &gt; Element (Cache Einstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Zeit ab, nach der der Cache die Arbeitsspeicherstatistik aktualisiert.</summary>
        <value>Die maximale Zeit, bevor die Arbeitsspeicherstatistik aktualisiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einstellungen für die- <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> Eigenschaft können in der Anwendungs Konfigurationsdatei angegeben werden. Sie können auch bei der Initialisierung der Klasse erfolgreich durchgeführt werden <xref:System.Runtime.Caching.MemoryCache> . Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt; NamedCaches- &gt; Element (Cache Einstellungen)](/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings). Weitere Informationen zum Konfigurieren der-Eigenschaft, wenn die- <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter der- <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="/dotnet/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings">&lt;NamedCaches- &gt; Element (Cache Einstellungen)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt das angegebene Element aus dem Cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der entfernt werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Entfernt einen Cacheeintrag aus dem Cache.</summary>
        <returns>Der entfernte Cacheeintrag, wenn der Eintrag im Cache gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der durch angegebene Eintrag `key` im Cache vorhanden ist, löst das Entfernen des Elements alle zugeordneten Änderungs Monitore aus. Wenn das entfernte Element einem- <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder einem-Objekt zugeordnet wurde <xref:System.Web.Caching.CacheItemRemovedCallback> , ist der Grund, der an den Rückruf übermittelt wurde, <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> .  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = Nothing) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;dotnet-plat-ext-3.1;dotnet-plat-ext-5.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der entfernt werden soll.</param>
        <param name="reason">Der Grund, aus dem das Element entfernt wurde.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Entfernt mithilfe des Grunds einen Cacheeintrag aus dem Cache.</summary>
        <returns>Der entfernte Cacheeintrag, wenn der Eintrag im Cache gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Eintrag nicht vorhanden ist, wird er erstellt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Ein Objekt, das einen einzufügenden Cacheeintrag darstellt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag in den Cache ein und gibt dabei mit einer <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz den Schlüssel und den Wert für den Cacheeintrag an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie <xref:System.Runtime.Caching.MemoryCache.Set%2A> bei anderen Methoden Überladungen legt die- <xref:System.Runtime.Caching.MemoryCache.Set%2A> Methode immer einen Cache Wert im Cache ab, unabhängig davon, ob bereits ein Eintrag mit demselben Schlüssel vorhanden ist. Wenn der angegebene Eintrag nicht im Cache vorhanden ist, wird ein neuer Cache Eintrag eingefügt. Wenn der angegebene Eintrag bereits vorhanden ist, wird der zugehörige Wert aktualisiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItem.Key" />-Eigenschaft ist <see langword="null" />.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItem.Value" />-Eigenschaft ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine ungültige Kombination der Argumente für den Cacheeintrag wurde übergeben. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer absoluten und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />- oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Eigenschaft festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = Nothing)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den einzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung eines Schlüssels und eines Werts in den Cache ein und gibt zeitbasierte Ablaufdetails an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie <xref:System.Runtime.Caching.MemoryCache.Set%2A> bei anderen Methoden Überladungen legt die- <xref:System.Runtime.Caching.MemoryCache.Set%2A> Methode immer einen Cache Wert im Cache ab, unabhängig davon, ob bereits ein Eintrag mit demselben Schlüssel vorhanden ist. Wenn der angegebene Eintrag nicht vorhanden ist, wird ein neuer Cache Eintrag eingefügt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 Der- `absoluteExpiration` Parameter gibt an, wann der Eintrag aus dem Cache entfernt werden soll.  
  
 Durch das Entfernen eines Eintrags werden alle zugeordneten Änderungs Monitore ausgelöst. Wenn das entfernte Element einem- <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder-Objekt zugeordnet wurde <xref:System.Web.Caching.CacheItemRemovedCallback> , ist der Grund für das Entfernen, das an die Rückrufe geleitet wird, in der- <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> Eigenschaft enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="Value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">–   Eine ungültige Kombination der Argumente für den Cacheeintrag wurde übergeben. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Das tritt auf, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ablaufende Einträge auf Grundlage eines absoluten und gleitenden Ablaufs nicht unterstützt. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
Oder 
-   Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = default);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = Nothing)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den einzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung eines Schlüssels, eines Werts und von Entfernungsdetails in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie <xref:System.Runtime.Caching.MemoryCache.Set%2A> bei anderen Methoden Überladungen legt die- <xref:System.Runtime.Caching.MemoryCache.Set%2A> Methode immer einen Cache Wert im Cache ab, unabhängig davon, ob bereits ein entsprechender Eintrag vorhanden ist. Wenn der angegebene Eintrag nicht im Cache vorhanden ist, wird ein neuer Cache Eintrag eingefügt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 Durch das Entfernen eines Eintrags werden alle zugeordneten Änderungs Monitore ausgelöst. Wenn das entfernte Element einem- <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder-Objekt zugeordnet wurde <xref:System.Web.Caching.CacheItemRemovedCallback> , ist der Grund für das Entfernen, das an die Rückrufe geleitet wird, in der- <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> Eigenschaft enthalten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="value" /> ist gleich <see langword="null" />.  
  
- oder - 
Der Rückrufverweis, der in der <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" />-Eigenschaft an die Hilfsmethode übergeben wurde, lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">–   Eine ungültige Kombination der Argumente für den Cacheeintrag ist vorhanden. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Das liegt daran, dass die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ablaufende Einträge auf Grundlage eines absoluten und gleitenden Ablaufs nicht unterstützt. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für die <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Klasse angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
Oder 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberSignature Language="F#" Value="override this.System.Collections.IEnumerable.GetEnumerator : unit -&gt; System.Collections.IEnumerator" Usage="memoryCache.System.Collections.IEnumerable.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt Unterstützung für eine Iteration durch eine generische Auflistung bereit.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Sie kann nur verwendet werden, wenn eine- <xref:System.Runtime.Caching.MemoryCache> Instanz in eine- <xref:System.Collections.IEnumerable> Schnittstelle umgewandelt wird.  
  
 Sie können diese Methode zum Durchlaufen einer generischen Auflistung von Cache Einträgen verwenden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Der Prozentsatz der gesamten Cacheeinträge, der entfernt werden soll.</param>
        <summary>Entfernt einen angegebenen Prozentsatz von Cacheeinträgen aus dem Cacheobjekt.</summary>
        <returns>Die Anzahl von Einträgen, die aus dem Cache entfernt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.MemoryCache.Trim%2A> Eigenschaft entfernt zuerst Einträge, die entweder einen absoluten oder gleitenden Ablauf überschritten haben. Für alle Rückrufe, die für Elemente, die entfernt werden, wird ein entfernter Grund von übermittelt <xref:System.Web.Caching.CacheItemRemovedReason.Expired> .  
  
 Wenn das Entfernen abgelaufener Einträge unzureichend ist, um den angegebenen Prozentsatz zu erreichen, werden weitere Einträge aus dem Cache basierend auf einem zuletzt verwendeten LRU-Algorithmus entfernt, bis der angeforderte Prozentsatz erreicht ist. Alle Rückrufe, die für Elemente registriert werden, die auf diese Weise entfernt werden, werden als Entfernungs Grund von übermittelt <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted> .  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
