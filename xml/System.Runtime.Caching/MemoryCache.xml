<Type Name="MemoryCache" FullName="System.Runtime.Caching.MemoryCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5a9a7564632e1ddf32afdc927a309aba7d36e6a9" /><Meta Name="ms.sourcegitcommit" Value="220917117f9d774aaa482439aa7324e39dc1f5b6" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/25/2019" /><Meta Name="ms.locfileid" Value="56766628" /></Metadata><TypeSignature Language="C#" Value="public class MemoryCache : System.Runtime.Caching.ObjectCache, IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit MemoryCache extends System.Runtime.Caching.ObjectCache implements class System.Collections.IEnumerable, class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.MemoryCache" />
  <TypeSignature Language="VB.NET" Value="Public Class MemoryCache&#xA;Inherits ObjectCache&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class MemoryCache : System::Runtime::Caching::ObjectCache, IDisposable" />
  <TypeSignature Language="F#" Value="type MemoryCache = class&#xA;    inherit ObjectCache&#xA;    interface IEnumerable&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Runtime.Caching.ObjectCache</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt den Typ dar, der einen Cache im Arbeitsspeicher implementiert.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache> -Klasse ist eine konkrete Implementierung der abstrakten <xref:System.Runtime.Caching.ObjectCache> -Klasse.  
  
> [!NOTE]
>  Die <xref:System.Runtime.Caching.MemoryCache> Klasse ist vergleichbar mit der ASP.NET <xref:System.Web.Caching.Cache> Klasse. Die <xref:System.Runtime.Caching.MemoryCache> -Klasse verfügt über viele Eigenschaften und Methoden für den Zugriff auf den Cache, der Sie vertraut sein werden, wenn Sie die ASP.NET verwendet haben <xref:System.Web.Caching.Cache> Klasse. Die wichtigsten Unterschiede zwischen der <xref:System.Web.Caching.Cache> und <xref:System.Runtime.Caching.MemoryCache> Klassen sind, die die <xref:System.Runtime.Caching.MemoryCache> Klasse wurde geändert, um es von verwendet werden kann [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Anwendungen, die nicht von ASP.NET-Anwendungen sind. Z. B. die <xref:System.Runtime.Caching.MemoryCache> -Klasse verfügt über keine Abhängigkeiten auf der `System.Web` Assembly. Ein weiterer Unterschied ist, dass Sie mehrere Instanzen erstellen, können die <xref:System.Runtime.Caching.MemoryCache> Klasse für die Verwendung in der gleichen Anwendung und im selben <xref:System.AppDomain> Instanz.  
  
 Die <xref:System.Runtime.Caching.MemoryCache> -Klasse lässt nicht zu `null` als Wert im Cache. Jeder Versuch, hinzufügen oder Ändern von einem Cacheeintrag mit einem Wert von `null` schlägt fehl.  
  
 Die <xref:System.Runtime.Caching.MemoryCache> Typ implementiert nicht *cache-Bereiche*. Wenn Sie daher Aufrufen <xref:System.Runtime.Caching.MemoryCache> übergeben Methoden, die Basismethoden implementieren, die einen Parameter für Bereiche, enthalten einen Wert für den Parameter nicht. Die Methoden, die alle den Region-Parameter verwenden, geben Sie den Standardwert `null` Wert. Z. B. die <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> methodenüberladung verfügt über eine `regionName` Parameter, dessen Standardwert `null`.  
  
   
  
## Examples  
 Das folgende Beispiel deklariert einen Verweis auf die Standard-Memory-Cache-Instanz. Der Cacheeintrag verwendet eine <xref:System.Runtime.Caching.CacheItemPolicy> Lösch-und Ablaufdetails für den Cacheeintrag zu verwendendes Objekt. Darüber hinaus verwendet er eine <xref:System.Runtime.Caching.ChangeMonitor> Objekt, das den Zustand der Quelldaten (Dies ist eine Datei) im Dateisystem überwachen.  
  
```vb  
Private Sub btnGet_Click(ByVal sender As Object, ByVal e As EventArgs)   
    Dim cache As ObjectCache = MemoryCache.[Default]   
    Dim fileContents As String = TryCast(cache("filecontents"), String)   
  
    If fileContents Is Nothing Then   
        Dim policy As New CacheItemPolicy()   
        Dim filePaths As New List(Of String)()   
        filePaths.Add("c:\cache\example.txt")   
  
        policy.ChangeMonitors.Add(New HostFileChangeMonitor(filePaths))   
  
        ' Fetch the file contents.  
        fileContents = File.ReadAllText("c:\cache\example.txt")   
  
        cache.[Set]("filecontents", fileContents, policy)   
    End If   
  
    Label1.Text = fileContents  
End Sub  
```  
  
```csharp  
private void btnGet_Click(object sender, EventArgs e)  
{  
    ObjectCache cache = MemoryCache.Default;  
    string fileContents = cache["filecontents"] as string;  
  
    if (fileContents == null)  
    {  
        CacheItemPolicy policy = new CacheItemPolicy();  
  
        List<string> filePaths = new List<string>();  
        filePaths.Add("c:\\cache\\example.txt");  
  
        policy.ChangeMonitors.Add(new   
        HostFileChangeMonitor(filePaths));  
  
        // Fetch the file contents.  
        fileContents =   
            File.ReadAllText("c:\\cache\\example.txt");  
  
        cache.Set("filecontents", fileContents, policy);  
    }  
  
    Label1.Text = fileContents;  
}  
```  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/942236f6-0138-4aaf-af71-a5ea451a1e23">Exemplarische Vorgehensweise: Zwischenspeichern von Anwendungsdaten in ASP.NET</related>
    <related type="Article" href="https://msdn.microsoft.com/library/c4b47ee0-4b82-4124-9bce-818088385e34">Caching in .NET Framework-Anwendungen</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, Optional config As NameValueCollection = null)" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der beim Nachschlagen von Konfigurationsinformationen verwendet werden soll.  
  
 <c>Hinweis</c> Es ist nicht erforderlich, dass für jeden Namen Konfigurationsinformationen vorhanden sind.  
  
Wenn ein passender Konfigurationseintrag vorhanden ist, werden die Konfigurationsinformationen verwendet, um die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz zu konfigurieren. Wenn kein entsprechender Konfigurationseintrag vorhanden ist, kann auf den Namen über die <see cref="P:System.Runtime.Caching.MemoryCache.Name" />-Eigenschaft zugegriffen werden, da der angegebene Name der <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz zugeordnet ist. Weitere Informationen über die Speichercachekonfiguration finden Sie unter <see cref="T:System.Runtime.Caching.Configuration.MemoryCacheElement" />.</param>
        <param name="config">Eine Auflistung von Name-Wert-Paaren mit Konfigurationsinformationen zum Konfigurieren des Caches.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, überprüft, ob Konfigurationseinträge, die mithilfe des optionalen überschrieben wurden möglicherweise `config` Parameter im Konstruktor. Sie können die folgenden Parameter in übergeben die `config` Parameter. Alle Werte können als ganze Zahlen übergeben werden.  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.CacheMemoryLimitMegabytes%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PhysicalMemoryLimitPercentage%2A>  
  
-   <xref:System.Runtime.Caching.Configuration.MemoryCacheElement.PollingInterval%2A>  
  
 Wenn dieser Konstruktor aufgerufen wird, werden die Konfigurationseinstellungen aus Anwendungskonfigurationsdateien zuerst abgerufen. Wenn keine Konfigurationseinträge in der Anwendungskonfigurationsdatei vorhanden ist, wird nur die Einstellungen in bereitgestellten `config` angewendet werden. Wenn Sie die Konfigurationseinträge in der Anwendungskonfiguration vorhanden sind und auch Informationen übergeben wird `config`, die Informationen in den `config` überschreibt die Informationen, die aus der Konfigurationsdatei gelesen wird.  
  
 Die Name-Wert, der eine Cache-Instanz zugewiesen ist, wird auf zwei Arten verwendet:  
  
-   Helfen Sie Ihnen das Nachverfolgen mehrerer Cache-Instanzen, wenn mehr als eine Instanz vorhanden ist.  
  
-   Einstellungen in der Konfiguration auf Datei bei der <xref:System.Runtime.Caching.MemoryCache> -Instanz initialisiert wird.  
  
    > [!NOTE]
    >  Es gibt keinen Mechanismus, um eindeutige Namen für den Cache-Instanzen zu erzwingen. Aus diesem Grund ist es möglich, mehrere Cacheinstanzen mit dem gleichen Namen haben.  
  
    > [!CAUTION]
    >  Erstellen Sie nicht <xref:System.Runtime.Caching.MemoryCache> Instanzen, es sei denn, dies erforderlich ist. Bei der Erstellung von Cache-Instanzen in Client- und Webanwendungen, die <xref:System.Runtime.Caching.MemoryCache> Instanzen erstellt werden soll, früh im Lebenszyklus Anwendung. Sie müssen nur die Anzahl von Cache-Instanzen erstellen, die in Ihrer Anwendung verwendet werden, und speichern Verweise auf die Cache-Instanz in der Variablen, die Global zugegriffen werden können. In ASP.NET-Anwendungen können Sie z. B. die Verweise im Anwendungszustand speichern. Wenn Sie nur eine einzelner Cache-Instanz in Ihrer Anwendung erstellen, der Standardcache verwendet, und rufen Sie einen Verweis aus der <xref:System.Runtime.Caching.MemoryCache.Default%2A> Eigenschaft, wenn Sie den Cache zugreifen möchten.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="name" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Name bzw. Wert im <paramref name="config" />-Parameter konnte nicht analysiert werden.</exception>
        <exception cref="T:System.Configuration.ConfigurationException">Ein Wert in der <paramref name="config" />-Auflistung ist ungültig.</exception>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public MemoryCache (string name, System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string name, class System.Collections.Specialized.NameValueCollection config, bool ignoreConfigSection) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.#ctor(System.String,System.Collections.Specialized.NameValueCollection,System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (name As String, config As NameValueCollection, ignoreConfigSection As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; MemoryCache(System::String ^ name, System::Collections::Specialized::NameValueCollection ^ config, bool ignoreConfigSection);" />
      <MemberSignature Language="F#" Value="new System.Runtime.Caching.MemoryCache : string * System.Collections.Specialized.NameValueCollection * bool -&gt; System.Runtime.Caching.MemoryCache" Usage="new System.Runtime.Caching.MemoryCache (name, config, ignoreConfigSection)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="name" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="config" Type="System.Collections.Specialized.NameValueCollection" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="ignoreConfigSection" Type="System.Boolean" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="name">Der Name, der beim Nachschlagen von Konfigurationsinformationen verwendet werden soll.</param>
        <param name="config">Eine Auflistung von Name-Wert-Paaren mit Konfigurationsinformationen zum Konfigurieren des Caches.</param>
        <param name="ignoreConfigSection">Gibt an, ob der Konfigurationsabschnitt ignoriert werden soll.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public override bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="memoryCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag als eine <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz ein und fügt Details wie der Eintrag zu entfernen ist im Cache hinzu.</summary>
        <returns>"true", wenn der Eintrag eingefügt wird, oder "false", wenn bereits ein Eintrag mit demselben Schlüssel wie das Element im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A> methodenüberladungen werden verwendet, um einen Cacheeintrag in den Cache einzufügen. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel nicht vorhanden ist, fügen Sie diese Methoden einen neuen Eintrag. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel bereits vorhanden ist, geben sie den vorhandenen Eintrag zurück.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (item As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.AddOrGetExisting (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung der angegebenen <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz und Details zur Entfernung des Eintrags im Cache hinzu.</summary>
        <returns>Der vorhandene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die `item` Parameter liefert die Schlüssel und den Wert, der von der Methode verwendet wird. Wenn im Cache einen Cacheeintrag mit demselben Schlüssel wie der Schlüssel des ist der `item` -Parameter die Methode gibt den vorhandenen Eintrag als eine <xref:System.Runtime.Caching.CacheItem> Instanz. Liegt keine vorhandenen Cacheeintrag vor, wird die Methode erstellt einen neuen Schlüssel mit dem Schlüssel und Wert der `item` Parameter, und mit der angegebenen von Entfernungsdetails `policy`.  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Die <see cref="P:System.Runtime.Caching.CacheItem.Value" />-Eigenschaft ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl der absolute und gleitende Ablaufzeitwert für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt werden auf andere Werte als die Standardwerte der <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Felder und der <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Felder festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten Ablaufzeit und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz verwenden. Die andere Ablaufeinstellung muss auf das <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Feld oder das <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Feld festgelegt werden.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den hinzuzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung des angegebenen Schlüssels, eines Werts und eines absoluten Ablaufwerts im Cache hinzu.</summary>
        <returns>Der vorhandene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Cache einen Cacheeintrag, deren Schlüssel entspricht keinen der `key` , ein neuen Cacheeintrag wird erstellt, und die <xref:System.Runtime.Caching.MemoryCache.AddOrGetExisting%2A?displayProperty=nameWithType> eine Überladung gibt `null`. Wenn ein entsprechender Cacheeintrag vorhanden ist, wird der vorhandene Eintrag zurückgegeben.  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl der absolute und gleitende Ablaufzeitwert für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt werden auf andere Werte als die Standardwerte der <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />-Felder und der <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Felder festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten Ablaufzeit und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Instanz verwenden. Die andere Ablaufeinstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public override object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="memoryCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der hinzugefügt oder abgerufen werden soll.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung des angegebenen Schlüssels und Werts und der angegebenen Details zur Entfernung in den Cache ein.</summary>
        <returns>Ein Cacheeintrag, wenn bereits ein entsprechender Cacheeintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
  
> [!WARNING]
>  Die Methodenüberladungen <xref:System.Runtime.Caching.ObjectCache.Add%2A> und <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> unterstützen die <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft nicht. Daher verwenden Sie zum Festlegen der <xref:System.Runtime.Caching.CacheItemPolicy.UpdateCallback%2A>-Eigenschaft für einen Cacheeintrag stattdessen die <xref:System.Runtime.Caching.MemoryCache.Set%2A>-Methodenüberladungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Sowohl die absoluten als auch die gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts werden auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer Kombination einer absoluten und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
- oder - 
Sowohl der Löschrückruf als auch der Updaterückruf wurden für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben. Der <see cref="T:System.Runtime.Caching.MemoryCache" /> unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" /> wurde auf einen Wert größer als ein Jahr festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="CacheMemoryLimit">
      <MemberSignature Language="C#" Value="public long CacheMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 CacheMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property CacheMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long CacheMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.CacheMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.CacheMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Speicherplatz auf dem Computer, der vom Cache verwendet werden kann, in Bytes ab.</summary>
        <value>Der Speicherplatz in Bytes.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die aktuelle Instanz des Cache überschreitet das Arbeitsspeicherlimit festlegen, indem die <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> -Eigenschaft, die Cacheimplementierung entfernt Einträge im Cache. Jeder Cache-Instanz in der Anwendung können die Größe des Arbeitsspeichers, der angegeben wird die <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> Eigenschaft.  
  
 Die Einstellungen für die <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> Eigenschaft kann in der Anwendungskonfigurationsdatei angegeben werden. Alternativ können sie in den Konstruktor übergeben werden bei der <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird. Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt;NamedCaches&gt; -Element (Cacheeinstellungen)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Weitere Informationen zum Konfigurieren dieses Wert fest, wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter den <xref:System.Runtime.Caching.MemoryCache.%23ctor%2A> Methode.  
  
 <xref:System.Runtime.Caching.MemoryCache> wird nicht sofort erzwungen <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> jedes Mal ein neues Element, um hinzugefügt wird eine <xref:System.Runtime.Caching.MemoryCache> Instanz. Der internen Heuristik das Entfernen von zusätzlichen Elemente aus der <xref:System.Runtime.Caching.MemoryCache> allmählich DataSet.hql und Kontoinformationen berücksichtigt die durch den Garbage Collector (finden Sie unter [Garbage Collection](~/docs/standard/garbage-collection/index.md)) und andere Faktoren wie z. B. aktuelle Cachegröße und gesamten Systemspeichers. Aus diesem Grund, obwohl die <xref:System.Runtime.Caching.MemoryCache> versucht, behalten Sie die Cachegröße innerhalb des konfigurierten <xref:System.Runtime.Caching.MemoryCache.CacheMemoryLimit%2A> es ist möglich, vorübergehend den Grenzwert übersteigen, durch das Hinzufügen von Elementen in einer sehr hohen Rate.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;NamedCaches&gt; -Element (Cacheeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public override bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="override this.Contains : string * string -&gt; bool" Usage="memoryCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den zu suchenden Cacheeintrag.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Bestimmt, ob ein Cacheeintrag im Cache vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der Cache einen Cacheeintrag enthält, dessen Schlüssel <paramref name="key" /> entspricht, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="override this.CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="memoryCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Enumeration eindeutiger Cacheeintragsschlüssel für das <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Erstellt ein <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt, das Ereignisse auslösen kann, wenn Änderungen an angegebenen Cacheeinträgen vorgenommen werden.</summary>
        <returns>Eine Änderungsüberwachung, die Einträge im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> -Methode erstellt eine <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanz. Dieser spezielle änderungsüberwachung wird verwendet, um die Einträge überwachen, die im angegebenen die `keys` Auflistung und um Ereignisse auszulösen, wenn die Einträge ändern.  
  
 Ein überwachter Eintrag gilt für alle der folgenden Gründe geändert haben:  
  
-   Der Schlüssel ist nicht vorhanden, zum Zeitpunkt des Aufrufs an die <xref:System.Runtime.Caching.MemoryCache.CreateCacheEntryChangeMonitor%2A> Methode. In diesem Fall wird das resultierende <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanz wird sofort auf einen geänderten Zustand festgelegt. Dies bedeutet, dass wenn Code anschließend einen Rückruf für änderungsbenachrichtigungen bindet, wird der Rückruf sofort ausgelöst.  
  
-   Der zugeordnete Cacheeintrag wurde aus dem Cache entfernt. Dies kann auftreten, wenn der Eintrag explizit entfernt wird, wenn es abgelaufen ist, oder er entfernt wird, um Arbeitsspeicher freizugeben.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein Element in der <paramref name="keys" />-Auflistung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Default">
      <MemberSignature Language="C#" Value="public static System.Runtime.Caching.MemoryCache Default { get; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.Runtime.Caching.MemoryCache Default" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Default" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly Property Default As MemoryCache" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property System::Runtime::Caching::MemoryCache ^ Default { System::Runtime::Caching::MemoryCache ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Default : System.Runtime.Caching.MemoryCache" Usage="System.Runtime.Caching.MemoryCache.Default" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.MemoryCache</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf die <see cref="T:System.Runtime.Caching.MemoryCache" />-Standardinstanz ab.</summary>
        <value>Die Standardinstanz des Caches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Eigenschaft gibt immer einen Verweis auf die Standard-Cache-Instanz. Für typische Anwendungsszenarien, nur eine Instanz des <xref:System.Runtime.Caching.MemoryCache> ist erforderlich.  
  
 Da die Standard-Cache-Instanz nicht durch den Konstruktor erstellt wird, müssen Sie die Konfiguration verwenden, um den Arbeitsspeicher und Abrufen von Werten für die Standard-Cache-Instanz explizit festzulegen. Weitere Informationen finden Sie unter [ &lt;MemoryCache&gt; -Element (Cacheeinstellungen)](~/docs/framework/configure-apps/file-schema/runtime/memorycache-element-cache-settings.md).  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/182a622f-f7cf-472d-9d0b-451d2fd94525">&lt;MemoryCache&gt; -Element (Cacheeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.MemoryCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft eine Beschreibung der Funktionen ab, die der Cache bereitstellt.</summary>
        <value>Eine bitweise Kombination von Flags, die die Standardfunktionen der Cacheimplementierung angeben.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Funktionen von einer Cacheimplementierung sind eine Kombination der folgenden Werte:  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.InMemoryProvider>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryChangeMonitors>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.AbsoluteExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.SlidingExpirations>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryUpdateCallback>  
  
-   <xref:System.Runtime.Caching.DefaultCacheCapabilities.CacheEntryRemovedCallback>  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="memoryCache.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Jede <xref:System.Runtime.Caching.MemoryCache> -Instanz gebunden ist, die <xref:System.Web.Compilation.ClientBuildManager.AppDomainUnloaded> Ereignis. Allerdings beim Herunterfahren der Anwendungsdomäne, wenn ein Cache speicherbasierte nicht explizit freigegeben wurde, die Cache-Instanz ruft automatisch die <xref:System.Runtime.Caching.MemoryCache.Dispose%2A> Methode.  
  
 Die freigegebenen Cache-Instanz heruntergefahren wird mit den folgenden Schritten:  
  
1.  Der Status des Caches wird festgelegt, um anzugeben, dass der Cache gelöscht wird. Jeder Versuch, rufen Sie öffentliche kann Zwischenspeichern von Methoden, die den Zustand des Cache ändern wie z. B. Methoden, die hinzufügen, entfernen oder Abrufen von Cacheeinträgen, unerwartetes Verhalten verursachen. Wenn Sie aufrufen, z. B. die <xref:System.Runtime.Caching.MemoryCache.Set%2A> -Methode auf, nachdem der Cache gelöscht wird, ein ohne-Op-Fehler auftritt. Wenn Sie versuchen, Elemente aus dem Cache abgerufen werden sollen. die <xref:System.Runtime.Caching.MemoryCache.Get%2A> Methode gibt stets `null`.  
  
2.  Informationen für Leistungsindikatoren wird von der aktuellen Cacheinstanz nicht mehr ausgelöst.  
  
3.  Alle Verweise auf die zwischengespeicherten Objekte, die von der aktuellen Cacheinstanz gespeichert werden veröffentlicht.  
  
4.  Alle <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Instanzen, die derzeit Einträge im Cache überwacht werden, werden benachrichtigt.  
  
5.  ClientCallback-Objekte, die Benachrichtigungen über Änderungen für diese Monitore bereitstellen, werden als bezeichnet.  
  
6.  Alle <xref:System.Web.Caching.CacheItemRemovedCallback> Instanzen, die Einträge im Cache registriert sind, werden aufgerufen. Ist die Ursache für das Entfernen, die an die Rückrufe <xref:System.Runtime.Caching.CacheEntryRemovedReason.CacheSpecificEviction>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public override object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Get : string * string -&gt; obj" Usage="memoryCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt einen Eintrag aus dem Cache zurück.</summary>
        <returns>Ein Verweis auf den Cacheeintrag, der von <paramref name="key" /> identifiziert wird, wenn der Eintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public override System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="override this.GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="memoryCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt den angegebenen Eintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz aus dem Cache zurück.</summary>
        <returns>Ein Verweis auf den Cacheeintrag, der von <paramref name="key" /> identifiziert wird, wenn der Eintrag vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Cacheeintrag angegeben `key` im Cache vorhanden ist die <xref:System.Runtime.Caching.MemoryCache.GetCacheItem%2A> Methodenrückgabe als eine <xref:System.Runtime.Caching.CacheItem> Instanz. Die <xref:System.Runtime.Caching.CacheItem.Key%2A> und <xref:System.Runtime.Caching.CacheItem.Value%2A> Eigenschaften der <xref:System.Runtime.Caching.CacheItem> Instanz festgelegt. Allerdings die <xref:System.Runtime.Caching.CacheItem.RegionName%2A> Eigenschaft `null`, da die Bereiche nicht implementiert werden, in der <xref:System.Runtime.Caching.MemoryCache> Klasse.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public override long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="override this.GetCount : string -&gt; int64" Usage="memoryCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt die Gesamtanzahl von Cacheeinträgen im Cache zurück.</summary>
        <returns>Die Anzahl von Einträgen im Cache.</returns>
        <remarks>To be added.</remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected override System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected Overrides Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; override System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="override this.GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="memoryCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Erstellt einen Enumerator, der zum Durchlaufen einer Auflistung von Cacheeinträgen verwendet werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Enumerator, der von zurückgegeben wird das <xref:System.Runtime.Caching.MemoryCache.GetEnumerator%2A> -Methode kann zum Durchlaufen der Einträge im Cache verwendet werden.  
  
> [!IMPORTANT]
>  Abrufen eines Enumerators für eine <xref:System.Runtime.Caching.MemoryCache> Instanz ist ein ressourcenintensiver und blockierende Vorgang. Aus diesem Grund sollte der Enumerator nicht in Produktionsanwendungen verwendet werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetLastSize">
      <MemberSignature Language="C#" Value="public long GetLastSize (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 GetLastSize(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetLastSize(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function GetLastSize (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="member this.GetLastSize : string -&gt; int64" Usage="memoryCache.GetLastSize regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="regionName">Der Name der Region.</param>
        <summary>Ruft die Größe des benannten Bereichs ab.</summary>
        <returns>Die Größe des benannten Bereichs.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public override System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="override this.GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="memoryCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Ein Satz von eindeutigen Bezeichnern für die zurückzugebenden Cacheeinträge.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Gibt einen Satz von Cacheeinträgen zurück, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Satz von Cacheeinträgen, die den angegebenen Schlüsseln entsprechen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Cacheeintrag, der durch dargestellt wird die `keys` ist nicht vorhanden, den entsprechenden Wert für das zurückgegebene Objekt in das Wörterbuch ist auf `null`. Aus diesem Grund hat das zurückgegebene Wörterbuch immer die gleiche Anzahl von Elementen wie die Anzahl der Elemente in `keys`.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="keys" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Ein individueller Schlüssel in der Auslistung ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public override object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public Overrides Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.MemoryCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cachewert, der abgerufen bzw. festgelegt werden soll.</param>
        <summary>Ruft einen Wert im Cache mithilfe der Standardindexereigenschaft für eine Instanz der <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ab, oder legt ihn fest.</summary>
        <value>Der Wert in der Cacheinstanz für den angegebenen Schlüssel, falls der Eintrag vorhanden ist, andernfalls <see langword="null" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Eigenschaft festlegen, wird der Wert in den Cache eingefügt. Die Ablaufrichtlinie für den Cacheeintrag nastaven NA hodnotu <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration>. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel bereits vorhanden ist, wird dessen Wert aktualisiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder - 
Der eingefügte Wert ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public override string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public Overrides ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.MemoryCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen des Caches ab.</summary>
        <value>Der Name des Caches.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.Name%2A> Eigenschaft gibt den Namen der aktuellen Instanz zurück. die <xref:System.Runtime.Caching.MemoryCache> Klasse. In Anwendungen, die mehrere Cacheinstanzen verwendet, können Sie mithilfe der <xref:System.Runtime.Caching.MemoryCache.Name%2A> Eigenschaft Instanzen voneinander unterscheiden. Weitere Informationen finden Sie unter der Methode <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType>. Der Standardcache auf eine speicherbasierte gibt den Standardnamen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="PhysicalMemoryLimit">
      <MemberSignature Language="C#" Value="public long PhysicalMemoryLimit { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int64 PhysicalMemoryLimit" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PhysicalMemoryLimit As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property long PhysicalMemoryLimit { long get(); };" />
      <MemberSignature Language="F#" Value="member this.PhysicalMemoryLimit : int64" Usage="System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Prozentsatz des physischen Arbeitsspeichers ab, der vom Cache verwendet werden kann.</summary>
        <value>Der Prozentsatz des physischen Arbeitsspeichers, der vom Cache verwendet werden kann.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> -Eigenschaft gibt den Prozentsatz der insgesamt physischen Arbeitsspeichers, der von einer einzelnen Instanz von verwendet werden kann die <xref:System.Runtime.Caching.MemoryCache> Klasse. Wenn die Cache-Instanz den angegebenen Grenzwert überschreitet, werden Einträge im Cache entfernt.  
  
 Die Einstellungen für die <xref:System.Runtime.Caching.MemoryCache.PhysicalMemoryLimit%2A> Eigenschaft kann in der Anwendungskonfigurationsdatei angegeben werden. Alternativ können sie von einem Aufrufer übergeben werden bei der <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird. Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt;NamedCaches&gt; -Element (Cacheeinstellungen)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Weitere Informationen zum Konfigurieren der Eigenschaft bei der <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter den <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;NamedCaches&gt; -Element (Cacheeinstellungen)</related>
      </Docs>
    </Member>
    <Member MemberName="PollingInterval">
      <MemberSignature Language="C#" Value="public TimeSpan PollingInterval { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.TimeSpan PollingInterval" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property PollingInterval As TimeSpan" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property TimeSpan PollingInterval { TimeSpan get(); };" />
      <MemberSignature Language="F#" Value="member this.PollingInterval : TimeSpan" Usage="System.Runtime.Caching.MemoryCache.PollingInterval" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die maximale Zeit ab, nach der der Cache die Arbeitsspeicherstatistik aktualisiert.</summary>
        <value>Die maximale Zeit, bevor die Arbeitsspeicherstatistik aktualisiert wird.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Einstellungen für die <xref:System.Runtime.Caching.MemoryCache.PollingInterval%2A> Eigenschaft kann in der Anwendungskonfigurationsdatei angegeben werden. Alternativ sie können übergeben werden, wenn die <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird. Weitere Informationen zum Konfigurieren dieser Eigenschaft finden Sie unter [ &lt;NamedCaches&gt; -Element (Cacheeinstellungen)](~/docs/framework/configure-apps/file-schema/runtime/namedcaches-element-cache-settings.md). Weitere Informationen zum Konfigurieren der Eigenschaft bei der <xref:System.Runtime.Caching.MemoryCache> Klasse initialisiert wird, finden Sie unter den <xref:System.Runtime.Caching.MemoryCache.%23ctor%28System.String%2CSystem.Collections.Specialized.NameValueCollection%29?displayProperty=nameWithType> Methode.  
  
 ]]></format>
        </remarks>
        <related type="Article" href="https://msdn.microsoft.com/library/6bd4fbc5-55a6-4dc4-998b-cdcc7e023330">&lt;NamedCaches&gt; -Element (Cacheeinstellungen)</related>
      </Docs>
    </Member>
    <MemberGroup MemberName="Remove">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Entfernt das angegebene Element aus dem Cache.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public override object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * string -&gt; obj" Usage="memoryCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der entfernt werden soll.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Entfernt einen Cacheeintrag aus dem Cache.</summary>
        <returns>Der entfernte Cacheeintrag, wenn der Eintrag im Cache gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Eintrag angegeben `key` vorhanden ist im Cache, und entfernen Sie die Element-Trigger zugeordneten änderungsüberwachungen. Wenn das entfernte Element zugeordnet wurde eine <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder ein <xref:System.Web.Caching.CacheItemRemovedCallback> Objekt ist, ist der Grund dafür an den Rückruf übergeben <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed>.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public object Remove (string key, System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance object Remove(string key, valuetype System.Runtime.Caching.CacheEntryRemovedReason reason, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Remove(System.String,System.Runtime.Caching.CacheEntryRemovedReason,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Function Remove (key As String, reason As CacheEntryRemovedReason, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="override this.Remove : string * System.Runtime.Caching.CacheEntryRemovedReason * string -&gt; obj" Usage="memoryCache.Remove (key, reason, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" Index="0" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="reason" Type="System.Runtime.Caching.CacheEntryRemovedReason" Index="1" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
        <Parameter Name="regionName" Type="System.String" Index="2" FrameworkAlternate="dotnet-plat-ext-2.1;dotnet-plat-ext-2.2;dotnet-plat-ext-3.0;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der entfernt werden soll.</param>
        <param name="reason">Der Grund, aus dem das Element entfernt wurde.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt wurde. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Entfernt mithilfe des Grunds einen Cacheeintrag aus dem Cache.</summary>
        <returns>Der entfernte Cacheeintrag, wenn der Eintrag im Cache gefunden wird, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Fügt einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der angegebene Eintrag nicht vorhanden ist, wird es erstellt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; override void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="override this.Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="memoryCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Ein Objekt, das einen einzufügenden Cacheeintrag darstellt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt einen Cacheeintrag in den Cache ein und gibt dabei mit einer <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz den Schlüssel und den Wert für den Cacheeintrag an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei anderen <xref:System.Runtime.Caching.MemoryCache.Set%2A> -methodenüberladungen, die <xref:System.Runtime.Caching.MemoryCache.Set%2A> -Methode setzt einen Cachewert immer im Cache, unabhängig davon, ob ein Eintrag bereits vorhanden ist, die den gleichen Schlüssel verfügt. Wenn der angegebene Eintrag nicht im Cache vorhanden ist, wird ein neuer Cacheeintrag eingefügt. Wenn der angegebene Eintrag bereits vorhanden ist, wird dessen Wert aktualisiert.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="item" /> ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItem.Key" />-Eigenschaft ist <see langword="null" />.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItem.Value" />-Eigenschaft ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">Eine ungültige Kombination der Argumente für den Cacheeintrag wurde übergeben. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse kann keine Ablaufrichtlinie auf Grundlage einer absoluten und einer gleitenden Ablaufzeit festlegen. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />- oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />-Eigenschaft festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" /> ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="memoryCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den einzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung eines Schlüssels und eines Werts in den Cache ein und gibt zeitbasierte Ablaufdetails an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei anderen <xref:System.Runtime.Caching.MemoryCache.Set%2A> -methodenüberladungen, die <xref:System.Runtime.Caching.MemoryCache.Set%2A> -Methode immer versetzt einen Cachewert im Cache, unabhängig davon, ob ein Eintrag mit dem gleichen Schlüssel bereits vorhanden ist. Wenn der angegebene Eintrag nicht vorhanden ist, wird ein neuer Cacheeintrag eingefügt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 Die `absoluteExpiration` Parameter gibt an, wann der Eintrag aus dem Cache entfernt werden soll.  
  
 Alle zugeordneten änderungsüberwachungen wird ausgelöst, wenn Sie einen Eintrag zu entfernen. Wenn das entfernte Element zugeordnet war eine <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder <xref:System.Web.Caching.CacheItemRemovedCallback> Objekt ist, ist der Grund für die Entfernung, die den Rückrufen übergeben werden, Bestandteil der <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder -  
 <paramref name="Value" /> ist <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">–   Eine ungültige Kombination der Argumente für den Cacheeintrag wurde übergeben. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Das tritt auf, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ablaufende Einträge auf Grundlage eines absoluten und gleitenden Ablaufs nicht unterstützt. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für das <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekt angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
- oder - 
-   Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public override void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overrides Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="override this.Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="memoryCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den einzufügenden Cacheeintrag.</param>
        <param name="value">Die Daten für den Cacheeintrag.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Ein benannter Bereich im Cache, dem ein Cacheeintrag hinzugefügt werden kann. Übergeben Sie keinen Wert für diesen Parameter. Dieser Parameter ist standardmäßig <see langword="null" />, da die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse keine Bereiche implementiert.</param>
        <summary>Fügt einen Cacheeintrag unter Verwendung eines Schlüssels, eines Werts und von Entfernungsdetails in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wie bei anderen <xref:System.Runtime.Caching.MemoryCache.Set%2A> -methodenüberladungen, die <xref:System.Runtime.Caching.MemoryCache.Set%2A> -Methode setzt einen Cachewert immer im Cache, unabhängig davon, ob ein überrein stimmender Eintrag ist bereits vorhanden. Wenn der angegebene Eintrag nicht im Cache vorhanden ist, wird ein neuer Cacheeintrag eingefügt. Wenn der angegebene Eintrag vorhanden ist, wird er aktualisiert.  
  
 Alle zugeordneten änderungsüberwachungen wird ausgelöst, wenn Sie einen Eintrag zu entfernen. Wenn das entfernte Element zugeordnet war eine <xref:System.Web.Caching.CacheItemUpdateCallback> Objekt oder <xref:System.Web.Caching.CacheItemRemovedCallback> Objekt ist, ist der Grund für die Entfernung, die den Rückrufen übergeben werden, Bestandteil der <xref:System.Runtime.Caching.CacheEntryRemovedReason.Removed> Eigenschaft.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException"><paramref name="key" /> ist <see langword="null" />.  
  
- oder - 
 <paramref name="value" /> ist gleich <see langword="null" />.  
  
- oder - 
Der Rückrufverweis, der in der <see cref="P:System.Runtime.Caching.CacheItemPolicy.UpdateCallback" />-Eigenschaft an die Hilfsmethode übergeben wurde, lautet <see langword="null" />.</exception>
        <exception cref="T:System.ArgumentException">–   Eine ungültige Kombination der Argumente für den Cacheeintrag ist vorhanden. Dies tritt auf, wenn die folgenden Ablaufdetails für das Richtlinienobjekt für den Cacheeintrag festgelegt werden: 
-   Wenn die absoluten und gleitenden Ablaufzeitwerte des <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Objekts auf andere Werte als die Standards von <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> und <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden. Das liegt daran, dass die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse ablaufende Einträge auf Grundlage eines absoluten und gleitenden Ablaufs nicht unterstützt. Nur eine Ablaufeinstellung kann explizit festgelegt werden, wenn Sie die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse verwenden. Die andere Einstellung muss auf <see cref="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" /> oder <see cref="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" /> festgelegt werden.  
  
–   Wenn sowohl der Löschrückruf als auch der Updaterückruf für die <see cref="T:System.Runtime.Caching.CacheItemPolicy" />-Klasse angegeben werden. Die <see cref="T:System.Runtime.Caching.MemoryCache" />-Klasse unterstützt nur das Verwenden von einem Typ von Rückruf pro Cacheeintrag.</exception>
        <exception cref="T:System.ArgumentOutOfRangeException">Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft wird auf einen Wert kleiner als <see cref="F:System.TimeSpan.Zero" /> festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.SlidingExpiration" />-Eigenschaft ist auf einen größeren Wert als ein Jahr festgelegt.  
  
- oder - 
Die <see cref="P:System.Runtime.Caching.CacheItemPolicy.Priority" />-Eigenschaft ist kein Wert der <see cref="T:System.Runtime.Caching.CacheItemPriority" />-Enumeration.</exception>
        <exception cref="T:System.NotSupportedException"><paramref name="regionName" /> ist nicht <see langword="null" />.</exception>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Stellt Unterstützung für eine Iteration durch eine generische Auflistung bereit.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Kann verwendet werden nur dann, wenn eine <xref:System.Runtime.Caching.MemoryCache> Instanz der Umwandlung in eine <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Sie können diese Methode verwenden, eine generische Auflistung von Cacheeinträgen durchlaufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Trim">
      <MemberSignature Language="C#" Value="public long Trim (int percent);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance int64 Trim(int32 percent) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.MemoryCache.Trim(System.Int32)" />
      <MemberSignature Language="VB.NET" Value="Public Function Trim (percent As Integer) As Long" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; long Trim(int percent);" />
      <MemberSignature Language="F#" Value="member this.Trim : int -&gt; int64" Usage="memoryCache.Trim percent" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="percent" Type="System.Int32" />
      </Parameters>
      <Docs>
        <param name="percent">Der Prozentsatz der gesamten Cacheeinträge, der entfernt werden soll.</param>
        <summary>Entfernt einen angegebenen Prozentsatz von Cacheeinträgen aus dem Cacheobjekt.</summary>
        <returns>Die Anzahl von Einträgen, die aus dem Cache entfernt wurden.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.MemoryCache.Trim%2A> -Eigenschaft entfernt zuerst Einträge, die eine Absolute oder gleitende Ablaufzeit überschritten haben. Alle Rückrufe, die für Elemente, die entfernt werden Grund für die übergeben werden registriert werden <xref:System.Web.Caching.CacheItemRemovedReason.Expired>.  
  
 Wenn die Entfernung abgelaufener Einträge nicht ausreichend, um den angegebenen trim Prozentsatz zu erreichen ist, werden zusätzliche Einträge aus dem Cache basierend auf einer Least-recently verwendet (LRU)-Algorithmus, bis die angeforderte trim Prozentsatz erreicht ist entfernt. Alle Rückrufe, die für Elemente, die auf diese Weise entfernt registriert werden, übergeben einen Grund für die Entfernung <xref:System.Runtime.Caching.CacheEntryRemovedReason.Evicted>.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>