<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="5857681ac8d5732c6af8a6885bbec57f01693a37" /><Meta Name="ms.sourcegitcommit" Value="88014e1c5440e3df4f66ef04393854d15b1fd534" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="09/05/2019" /><Meta Name="ms.locfileid" Value="70490446" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Objektcache dar und stellt die Basismethoden und Eigenschaften für den Zugriff auf den Objektcache bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Runtime.Caching.ObjectCache> Typ ist der primäre Typ für den in-Memory-Objekt Cache. Zum Entwickeln einer benutzerdefinierten Cache Implementierung leiten Sie von der <xref:System.Runtime.Caching.ObjectCache> -Klasse ab.  
  
> [!NOTE]
>  Die <xref:System.Runtime.Caching.ObjectCache> -Klasse ist neu ab [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Die integrierte <xref:System.Runtime.Caching.MemoryCache> Klasse wird von der <xref:System.Runtime.Caching.ObjectCache> -Klasse abgeleitet. Die <xref:System.Runtime.Caching.MemoryCache> -Klasse ist die einzige konkrete Objekt Cache Implementierung in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] der, die von <xref:System.Runtime.Caching.ObjectCache> der-Klasse abgeleitet wird.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Da der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Typ nur allgemeine Cache Funktionen darstellt, ist es nicht erforderlich, wie <see cref="T:System.Runtime.Caching.ObjectCache" /> eine Instanz instanziiert und abgerufen werden muss. Außerdem ist es nicht erforderlich, dass konkrete Implementierungen der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Klasse Singletons sein müssen.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" />ist kein Singleton, Sie sollten jedoch nur ein paar oder möglicherweise nur <see cref="T:System.Runtime.Caching.MemoryCache" /> eine Instanz erstellen, und Code, der Elemente zwischenspeichert, sollte diese Instanzen verwenden.  
  
</para></block>  
  
 Wenn Sie von der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Klasse erben, müssen Sie die zugehörigen Methoden überschreiben.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse zu initialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne dass ein vorhandener Cacheeintrag mit einem übereinstimmenden Schlüssel zurückgegeben werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methoden Überladungen versuchen, einen Cache Eintrag in den Cache einzufügen, ohne einen vorhandenen Cache Eintrag mit demselben Schlüssel zu überschreiben oder zu entfernen. Der Cache Eintrag kann ein typisiertes <xref:System.Runtime.Caching.CacheItem> -Objekt oder ein generisches-Objekt sein.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> -Methoden Überladungen und <xref:System.Runtime.Caching.ObjectCache.Add%2A> die-Methoden Überladungen haben einen signifikanten Unterschied. Wenn diese Methoden einen Cache Eintrag einfügen, wenn ein übereinstimmender Eintrag im Cache gefunden wird, <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> gibt die Methoden Überladungen den vorhandenen Cache Eintrag zurück, <xref:System.Runtime.Caching.ObjectCache.Add%2A> die Methoden Überladungen jedoch nicht. Durch diese unterschiedlichen Methoden Überladungen können Aufrufer Ihren Code basierend darauf optimieren, ob Sie den vorhandenen Cache Eintrag benötigen. In verteilten Caches kann das Zurückgeben eines vorhandenen Werts mithilfe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> der-Methode kostengünstiger sein als die Rückgabe eines booleschen Werts <xref:System.Runtime.Caching.ObjectCache.Add%2A> mithilfe der-Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz in den Cache einzufügen, und fügt Details zur Entfernung des Eintrags hinzu.</summary>
        <returns><see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="item" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methoden Überladungen sind in der <xref:System.Runtime.Caching.ObjectCache> -Klasse virtuell (nicht abstrakt), da <xref:System.Runtime.Caching.ObjectCache.Add%2A> die-Methode <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>intern aufruft. Dadurch wird die Anzahl von Methoden Überladungen reduziert, die von einem cacheimplementierer bereitgestellt werden müssen. Wenn eine Cache Implementierung kein spezielles Verhalten für die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode erfordert, kann Sie einfach die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> -Methoden Überladungen implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft. Dieser Parameter ist erforderlich, wenn die <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />-Methode aufgerufen wird.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne einen vorhandenen Cacheeintrag zu überschreiben.</summary>
        <returns><see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methoden Überladungen sind in der <xref:System.Runtime.Caching.ObjectCache> -Klasse virtuell (nicht abstrakt), da <xref:System.Runtime.Caching.ObjectCache.Add%2A> die-Methode <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>intern aufruft. Dadurch wird die Anzahl von Methoden Überladungen reduziert, die von einem cacheimplementierer bereitgestellt werden müssen. Wenn eine Cache Implementierung kein spezielles Verhalten für die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode erfordert, kann Sie einfach die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> -Methoden Überladungen implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse einen Cacheeintrag im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns><see langword="true" />, wenn der Eintrag erfolgreich eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methoden Überladungen sind in der <xref:System.Runtime.Caching.ObjectCache> -Klasse virtuell (nicht abstrakt), da <xref:System.Runtime.Caching.ObjectCache.Add%2A> die-Methode <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>intern aufruft. Dadurch wird die Anzahl von Methoden Überladungen reduziert, die von einem cacheimplementierer bereitgestellt werden müssen. Wenn eine Cache Implementierung kein spezielles Verhalten für die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode erfordert, kann Sie einfach die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> -Methoden Überladungen implementieren.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag in den Cache einzufügen, und gibt einen vorhandenen Cacheeintrag mit einem übereinstimmenden Schlüssel zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> -Methoden Überladungen fügen einen Eintrag in den Cache ein. Wenn bereits ein Cache Eintrag mit einem übereinstimmenden Schlüssel vorhanden ist, wird der vorhandene Eintrag zurückgegeben. Der Cache Eintrag kann ein <xref:System.Runtime.Caching.CacheItem> -Objekt oder ein generisches-Objekt sein.  
  
 Es gibt einen Unterschied zwischen <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> den über Ladungen und <xref:System.Runtime.Caching.ObjectCache.Add%2A> den über Ladungen. Wenn diese überladenen Methoden versuchen, einen Cache Eintrag einzufügen, geben die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> über Ladungen den vorhandenen Cache Eintrag zurück, wenn ein vorhandener Eintrag gefunden wird, der über einen Schlüssel verfügt, der mit einem vorhandenen eingefügten Cache Eintrag übereinstimmt. Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> über Ladungen sind nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse das angegebene <see cref="T:System.Runtime.Caching.CacheItem" />-Objekt in den Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns>Der angegebene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag unter Verwendung eines Schlüssels, eines Objekts für den Cacheeintrag, eines absoluten Ablaufwerts und eines optionalen Bereichs zum Hinzufügen des Caches in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> Methoden Überladung gibt einen Objektwert zurück, <xref:System.Runtime.Caching.CacheItem> kein-Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt einen Cacheeintrag mit einem angegebenen Schlüssel und Wert für den Cacheeintrag sowie Informationen zur Entfernung in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> -Methode gibt einen Objektwert zurück, <xref:System.Runtime.Caching.CacheItem> kein-Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem sich der Cacheeintrag möglicherweise befindet, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, überprüft sie, ob der Cacheeintrag bereits im Cache vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der Cache einen Cacheeintrag mit demselben Schlüsselwert wie <paramref name="key" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Die eindeutigen Bezeichner für die zu überwachenden Cacheeinträge.</param>
        <param name="regionName">Optional. Ein benannter Bereich im Cache, in dem sich die Cacheschlüssel im <paramref name="keys" />-Parameter befinden, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie ein <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt, das Ereignisse auslösen kann, wenn Änderungen an angegebenen Cacheeinträgen vorgenommen werden.</summary>
        <returns>Eine Änderungsüberwachung, die Cacheeinträge im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine abgeleitete <xref:System.Runtime.Caching.ObjectCache> Klasse die Basis <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> Methode überschreibt, muss die Cache Implementierung ein <xref:System.Runtime.Caching.CacheEntryChangeMonitor> -Objekt erstellen. Dieser spezialisierte Änderungs Monitor benachrichtigt Aufrufer, wenn Änderungen an den Cache Einträgen vorgenommen werden, die im `keys` -Parameter angegeben sind. Wenn z. b. ein überwachtes Element `keys` im-Parameter aktualisiert oder aus dem Cache entfernt wird, löst der von dieser Methode erstellte Änderungs Monitor ein Ereignis aus.  
  
 Wenn eine Cache Implementierung benannte Cache Regionen unterstützt, kann ein Zeichen folgen Wert als `regionName` Parameter angegeben werden. Andernfalls wird für `null`den-Parameter der Standardwert verwendet.  
  
> [!NOTE]
>  Nicht alle Cache Implementierungen unterstützen Änderungs Monitore für Cache Einträge. Informationen dazu, ob die Cache Implementierung <xref:System.Runtime.Caching.CacheEntryChangeMonitor> -Objekte unterstützt, finden Sie in der Dokumentation für die jeweilige Cache Implementierung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie eine Beschreibung der Funktionen ab, die von einer Cacheimplementierung bereitgestellt werden.</summary>
        <value>Eine bitweise Kombination von Flags, die die Standardfunktionen einer Cacheimplementierung angeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als Objekt aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung ist vorhanden, da einige Cache Implementierungen <xref:System.Runtime.Caching.CacheItem> möglicherweise die-Klasse erweitern. In diesem Fall gibt die <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -Methoden Überladung nicht notwendigerweise alle Informationen zu zwischengespeicherten Daten zurück. Allerdings ermöglicht <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> die-Methoden Überladung, dass benutzerdefinierte Caches mehr als nur den Cache Wert zurückgeben.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> -Methode ähnelt der <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -Methode, mit der <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Ausnahme, dass die- <xref:System.Runtime.Caching.CacheItem> Methode den Cache Eintrag als-Instanz zurückgibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, für den die Cacheeintragsanzahl berechnet werden soll, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie die Gesamtanzahl von Cacheeinträgen im Cache ab.</summary>
        <returns>Die Anzahl von Cacheeinträgen im Cache. Wenn <paramref name="regionName" /> nicht <see langword="null" /> ist, gibt dieser Wert die Anzahl von Einträgen im angegebenen Cachebereich an.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie einen Enumerator, mit dem eine Auflistung von Cacheeinträgen durchlaufen werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cacheimplementierer können diese Methode überschreiben und erweitern, um ein benutzerdefiniertes Mittel zum Durchlaufen einer Auflistung von Cache Einträgen bereitzustellen.  
  
> [!NOTE]
>  Das Zurückgeben eines Enumerators ist in der Regel ein kostspieliger Vorgang als das Zurückgeben des gesamten Cache Eintrags.  
  
 Diese Methode wird von den expliziten Schnittstellen Implementierungen aufgerufen, <xref:System.Runtime.Caching.ObjectCache> die die-Klasse <xref:System.Collections.IEnumerable.GetEnumerator%2A> für <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> die-Methode und die-Methode besitzt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Satz von Cacheeinträgen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> -Methoden Überladung ist eine Leistungsoptimierung für verteilte Caches, die das Abrufen mehrerer Cache Einträge aus dem Cache während eines einzelnen Netzwerk Aufrufes unterstützen.  
  
 Obwohl ein Aufrufer einen oder mehrere Schlüssel an die-Methode übergeben kann, gibt es keine Garantie dafür, dass alle Schlüsseleinträge im Cache darstellen. Daher kann das zurückgegebene Wörterbuch weniger Elemente enthalten, als die Anzahl der Schlüssel, die an die Methode übermittelt wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <summary>Ruft einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> -Methoden Überladung ähnelt <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> der-Methoden Überladung, ermöglicht Ihnen jedoch, den benannten Bereich mithilfe optionaler Parameter Syntax zu übergeben, die von C#verwalteten Sprachen wie z. b. unterstützt wird.  
  
 Diese Methode ist eine virtuelle Methode, da <xref:System.Runtime.Caching.ObjectCache> die-Klasse eine Standard Implementierung bereitstellt `params` , die das <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> Array an die-Methoden Überladung übergibt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine verwaltete Hostumgebung ab, die für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen verfügbar ist und hostspezifische Dienste für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen bereitstellen kann, oder legt diesen fest.</summary>
        <value>Ein Verweis auf eine cachefähige verwaltete Hostumgebung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Host%2A> -Eigenschaft ist für die Verwendung [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] durch Host Umgebungen und durch Cache Implementierungen vorgesehen, die das Verhalten implementieren, das von der .NET Framework Host Umgebung abhängt.  
  
 In der folgenden Tabelle sind die Host Umgebungs Dienste aufgelistet, die möglicherweise in einer verwalteten Host Umgebung verfügbar sind und für <xref:System.Runtime.Caching.ObjectCache> -Implementierungen über die <xref:System.Runtime.Caching.ObjectCache.Host%2A> -Eigenschaft verfügbar sind:  
  
|Dienst|Beschreibung|  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Mit können Host Umgebungen Anwendungs Domänen Bezeichner bereitstellen, die möglicherweise von einer Cache Implementierung für Funktionen wie das Identifizieren von Leistungsindikatoren benötigt werden.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Ermöglicht Host Umgebungen das Bereitstellen eines benutzerdefinierten Datei Änderungs Benachrichtigungs Systems, anstatt das in der [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]bereitgestellte zu verwenden.|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Ermöglicht Cache Implementierungen, den Cache Speicherverbrauch an die Host Umgebung zu melden. Dadurch können Host Umgebungen die Arbeitsspeicher Nutzung über mehrere Cache Implementierungen hinweg zentral verwalten.|  
  
> [!NOTE]
>  Aufrufer dieses Eigenschafts Werts erfordern uneingeschränkte Berechtigungen für die Code Zugriffssicherheit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der der Eigenschaft zugewiesen wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den Eigenschaftenwert mehrmals festzulegen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für vollständige Vertrauenswürdigkeit für alle Accessoren dieser Eigenschaft. Diese Eigenschaft kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass ein Cacheeintrag keinen absoluten Ablauf hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cache Eintrag, der in den Cache eingefügt wird, <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> wobei der als Ablauf Wert festgelegte Feldwert nie auf Grundlage eines absoluten Zeitpunkts abläuft. Allerdings kann ein Cache Eintrag mit dieser Einstellung aus anderen Gründen aus dem Cache entfernt werden, die von einer bestimmten Cache Implementierung bestimmt werden, wie z. b. das Entfernen eines Änderungs Monitor Ereignisses, das durch unzureichenden Arbeitsspeicher verursacht wird.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für einen Cacheeintrag im Cache.</param>
        <summary>Ruft den Standardindexer für die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse ab oder legt diesen fest.</summary>
        <value>Ein Schlüssel, der als Indexer in der Cacheinstanz dient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten der Set-Zugriffsmethode dieser Eigenschaft entspricht der <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> -Methode. Intern könnte eine Cache Implementierung den absoluten Ablauf des angegebenen Werts auf die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> -Methode festlegen. Allerdings liegt dieses Verhalten letztendlich an der Cache Implementierung.  
  
 Das Verhalten der get-Zugriffsmethode ähnelt dem Aufrufen <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> der-Methode `null` und der Verwendung von für den Regions Namen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen einer bestimmten <see cref="T:System.Runtime.Caching.ObjectCache" />-Instanz ab.</summary>
        <value>Der Name einer bestimmten Cacheinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Cache Implementierungen unterstützen möglicherweise mehrere Instanzen des Caches, die in einer einzelnen Anwendung ausgeführt werden. Diese Eigenschaft ermöglicht es cacheimplementierern, einen Namen zurückzugeben, der eine bestimmte Cache Instanz identifiziert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Cacheeintrag keine gleitende Ablaufzeit hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der Ablauf, der auf der Dauer oder einem definierten Zeitfenster basiert, wird auch als gleitender Ablauf bezeichnet. Normalerweise wird ein Element, auf das im angegebenen Zeitfenster nicht zugegriffen wurde, von einer Cache Implementierung entfernt, die auf dem gleitenden Ablauf basierende Elemente entfernt.  
  
 Ein Cache Eintrag, der in den Cache eingefügt wird, <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> wobei der als Ablauf Wert festgelegte Feldwert nicht aufgrund einer nicht--Aktivität in einem gleitenden Zeitfenster entfernt werden sollte. Allerdings kann ein Cache Element entfernt werden, wenn es einen absoluten Ablauf hat, oder wenn ein anderes Entfernungs Ereignis auftritt, z. b. ein Änderungs Monitor oder eine hohe Arbeitsspeicher Auslastung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, entfernt sie den Cacheeintrag aus dem Cache.</summary>
        <returns>Ein Objekt, das den Wert des entfernten, vom Schlüssel angegebenen Cacheeintrags darstellt, oder <see langword="null" />, wenn der angegebene Eintrag nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode in einer benutzerdefinierten Cache Implementierung über `key`schreiben und ein Cache Eintrag im Cache vorhanden ist, der entspricht, sollte der Wert des entfernten Elements zurückgegeben werden. Wenn nichts aus dem Cache entfernt wurde, sollte die-Methode `null`zurückgeben.  
  
> [!NOTE]
>  Einige Implementierungen verteilter Caches unterstützen möglicherweise nicht die Möglichkeit, den Wert zurückzugeben, der aus dem Cache entfernt wurde. Dies kann daran liegen, dass die Cache Implementierung das Zurückgeben des Werts eines entfernten Cache Elements nicht unterstützt. Dies kann auch daran liegen, dass das Marshalling des Objekts als Rückgabewert zu teuer ist. In solchen Fällen können Cache Implementierungen zurückgeben `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das typische Verhalten <xref:System.Runtime.Caching.ObjectCache.Set%2A> der Überladungs Methoden ist ein Einfüge-oder Aktualisierungs Vorgang. Ein Cache Eintrag wird entweder als neuer Eintrag eingefügt, wenn der angegebene Eintrag nicht vorhanden ist, oder der Cache Eintrag wird mit einem neuen Wert aktualisiert, wenn er bereits vorhanden ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Cacheelement.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse den Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel für `item` nicht vorhanden ist, `item` wird als neuer Cache Eintrag eingefügt. Wenn ein Element mit einem Schlüssel vorhanden ist `item` , der mit übereinstimmt `item` , wird der Wert von verwendet, um den Wert des vorhandenen Cache Eintrags zu aktualisieren oder zu überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein und gibt zeitbasierte Ablaufdetails an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element, das `key` mit übereinstimmt, nicht im Cache `value` vorhanden `key` ist, werden und zum Einfügen als neuer Cache Eintrag verwendet. Wenn ein Element mit einem Schlüssel vorhanden ist `item` , der mit übereinstimmt, wird der Cache Eintrag mithilfe `value`von aktualisiert oder überschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese Methoden Überladung ermöglicht es Ihnen, mehr Entfernungs-oder Ablauf Details bereitzustellen, als diejenigen, die in einem zeitbasierten absoluten Ablauf verfügbar sind.  
  
 Wenn ein Element, das `key` mit übereinstimmt, nicht im Cache `value` vorhanden `key` ist, werden und zum Einfügen als neuer Cache Eintrag verwendet. Wenn ein Element mit einem Schlüssel vorhanden ist `item` , der mit übereinstimmt, wird der Cache Eintrag mithilfe `value`von aktualisiert oder überschrieben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine stark typisierte Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine generische Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Sie kann nur verwendet werden, wenn eine <xref:System.Runtime.Caching.ObjectCache> abgeleitete Instanz in eine <xref:System.Collections.IEnumerable> -Schnittstelle umgewandelt wird.  
  
 Entwickler können diese Methode zum Durchlaufen einer generischen Auflistung von Cache Einträgen verwenden.  
  
 Dies ist die Standard <xref:System.Collections.IEnumerable.GetEnumerator%2A> Implementierung, die intern die <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> -Methode aufruft.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>
