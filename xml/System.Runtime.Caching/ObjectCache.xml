<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="490163b95a1c739f285d903ae3e13cfd6489a285" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36637583" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Objektcache dar und stellt die Basismethoden und Eigenschaften für den Zugriff auf den Objektcache bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache> ist der primäre Typ für den Objektcache in-Memory-. Um eine benutzerdefinierte Cacheimplementierung zu entwickeln, ableiten von der <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
> [!NOTE]
>  Die <xref:System.Runtime.Caching.ObjectCache> Klasse ist neu ab dem [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Die integrierte <xref:System.Runtime.Caching.MemoryCache> Klasse leitet sich von der <xref:System.Runtime.Caching.ObjectCache> Klasse. Die <xref:System.Runtime.Caching.MemoryCache> Klasse ist der Cacheimplementierung nur konkretes Objekt in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] abgeleitet, die die <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides">
      <para>Da die <see cref="T:System.Runtime.Caching.ObjectCache" /> nur allgemeine Cachefunktionen darstellt, besteht keine Notwendigkeit, wie ein <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz instanziiert und abgerufen werden muss. Darüber hinaus besteht keine Notwendigkeit, die konkreten Implementierungen der <see cref="T:System.Runtime.Caching.ObjectCache" /> Klasse Singletons sein muss.  <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> ist kein Singleton, aber Sie sollten nur wenige oder möglicherweise nur eine erstellen <see cref="T:System.Runtime.Caching.MemoryCache" /> Instanz und Code, der Elemente zwischengespeichert, sollten diese Instanzen verwenden.  </para></block>  Beim Erben von der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Klasse, müssen Sie seine Methoden überschreiben.</para>
    </block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse zu initialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne dass ein vorhandener Cacheeintrag mit einem übereinstimmenden Schlüssel zurückgegeben werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen versuchen Sie es, um einen Cacheeintrag in den Cache ohne überschreiben oder Entfernen von einem vorhandenen Cacheeintrag mit dem gleichen Schlüssel einzufügen. Der Cacheeintrag kann ein typisiertes <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode und die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind ein wesentlicher Unterschied. Wenn diese Methoden einen Cacheeintrag einfügen, wenn ein entsprechender Eintrag im Cache gefunden wird die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode zurück, den vorhandene Cacheeintrag, aber die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode nicht. Mit diesen anderen methodenüberladungen kann Aufrufer ihren Code basierend auf den vorhandene Cacheeintrag benötigte optimieren. In verteilten Caches Zurückgeben eines vorhandenen Werts mithilfe der <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Methode ist möglicherweise teurer als einen booleschen Wert zurückgibt, mit <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz in den Cache einzufügen, und fügt Details zur Entfernung des Eintrags hinzu.</summary>
        <returns>
          <see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="item" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft. Dieser Parameter ist erforderlich, wenn die <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />-Methode aufgerufen wird.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Da Bereiche nicht in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementiert sind, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne einen vorhandenen Cacheeintrag zu überschreiben.</summary>
        <returns>
          <see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse einen Cacheeintrag im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns>
          <see langword="true" />, wenn der Eintrag erfolgreich eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> methodenüberladungen sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> intern Methodenaufrufe <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die eine Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung keine spezielle Verhaltensweisen für erfordert die <xref:System.Runtime.Caching.ObjectCache.Add%2A> -Methode, es kann nur implementieren die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag in den Cache einzufügen, und gibt einen vorhandenen Cacheeintrag mit einem übereinstimmenden Schlüssel zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode fügen Sie einen Eintrag im Cache. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel bereits vorhanden ist, geben sie den vorhandenen Eintrag zurück. Der Cacheeintrag kann ein <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Es gibt einen Unterschied zwischen der <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen und der <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen. Wenn diese überladenen Methoden zum Einfügen eines Cache-Eintrags, versuchen Sie, wenn ein vorhandener Eintrag gefunden wird, dass ein Schlüssel, der einem vorhandenen entspricht Cacheeintrag, eingefügt hat die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen zurückgeben den vorhandene Cacheeintrag. Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen jedoch nicht.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse das angegebene <see cref="T:System.Runtime.Caching.CacheItem" />-Objekt in den Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns>Der angegebene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag unter Verwendung eines Schlüssels, eines Objekts für den Cacheeintrag, eines absoluten Ablaufwerts und eines optionalen Bereichs zum Hinzufügen des Caches in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> eine Überladung gibt einen Objektwert zurück, keinen <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt einen Cacheeintrag mit einem angegebenen Schlüssel und Wert für den Cacheeintrag sowie Informationen zur Entfernung in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Methode gibt einen Objektwert zurück, keinen <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem sich der Cacheeintrag möglicherweise befindet, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, überprüft sie, ob der Cacheeintrag bereits im Cache vorhanden ist.</summary>
        <returns>
          <see langword="true" />, wenn der Cache einen Cacheeintrag mit demselben Schlüsselwert wie <paramref name="key" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Die eindeutigen Bezeichner für die zu überwachenden Cacheeinträge.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, wo sich die Cacheschlüssel im <c>keys</c>-Parameter befinden, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie ein <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt, das Ereignisse auslösen kann, wenn Änderungen an angegebenen Cacheeinträgen vorgenommen werden.</summary>
        <returns>Eine Änderungsüberwachung, die Cacheeinträge im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein abgeleiteter <xref:System.Runtime.Caching.ObjectCache> -Klasse überschreibt die <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> -Methode der Cacheimplementierung muss erstellen eine <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekt. Dieser spezielle geändert Monitor benachrichtigt Aufrufer aus, wenn auf die Einträge, die im angegebenen Änderungen der `keys` Parameter. Angenommen, ein Überwachungskapazität für Elemente in der `keys` Parameter aktualisiert oder aus dem Cache entfernt wird, löst ein Ereignis aus der änderungsüberwachung, die von dieser Methode erstellt.  
  
 Wenn eine Cacheimplementierung benannten Cachebereiche unterstützt, kann ein String-Wert angegeben werden, als die `regionName` Parameter. Andernfalls verwendet der Parameter standardmäßig `null`.  
  
> [!NOTE]
>  Nicht alle Cache-Implementierungen unterstützt Cacheeintrag Änderung überwacht. Um zu bestimmen, ob die Cacheimplementierung unterstützt <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekten finden Sie in der Dokumentation für die bestimmte Cacheimplementierung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie eine Beschreibung der Funktionen ab, die von einer Cacheimplementierung bereitgestellt werden.</summary>
        <value>Eine bitweise Kombination von Flags, die die Standardfunktionen einer Cacheimplementierung angeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als Objekt aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Da Bereiche nicht in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementiert sind, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung vorhanden ist, da einige Implementierungen Cache verlängern könnte die <xref:System.Runtime.Caching.CacheItem> Klasse. In diesem Fall die <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> methodenüberladung nicht unbedingt alle Informationen über zwischengespeicherte Daten zurück. Allerdings die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> -methodenüberladung können benutzerdefinierte Caches um mehr als nur den Cachewert zurückzugeben.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methode entspricht der <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -Methode, außer dass die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methodenrückgabe return den Cacheeintrag als eine <xref:System.Runtime.Caching.CacheItem> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, für den die Cacheeintragsanzahl berechnet werden soll, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie die Gesamtanzahl von Cacheeinträgen im Cache ab.</summary>
        <returns>Die Anzahl von Cacheeinträgen im Cache. Wenn <paramref name="regionName" /> nicht <see langword="null" /> ist, gibt dieser Wert die Anzahl von Einträgen im angegebenen Cachebereich an.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie einen Enumerator, mit dem eine Auflistung von Cacheeinträgen durchlaufen werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cache-Implementierungen können außer Kraft setzen, und erweitern diese Methode, um eine benutzerdefinierte Iteration durch eine Auflistung von Cacheeinträgen systemverarbeitungsaufwand.  
  
> [!NOTE]
>  Ein Enumerator zurückgegeben wird in der Regel ein teurer Vorgang als den gesamte Cacheeintrag zurückzugeben.  
  
 Diese Methode wird aufgerufen, indem Sie die expliziten schnittstellenimplementierungen, die die <xref:System.Runtime.Caching.ObjectCache> Klasse wurde für die <xref:System.Collections.IEnumerable.GetEnumerator%2A> und <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Satz von Cacheeinträgen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung trägt zur leistungsoptimierung für verteilte Caches, die mehrere Cacheeinträge aus dem Cache abrufen, während eines einzelnen Netzwerkaufrufs unterstützen.  
  
 Obwohl ein Aufrufer einen oder mehrere Schlüssel an die Methode übergeben werden kann, besteht keine Garantie, dass alle Schlüssel Einträge im Cache darstellen. Aus diesem Grund kann das zurückgegebene Wörterbuch weniger Elemente als die Anzahl der Schlüssel enthalten, die an die Methode übergeben wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute>
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Da Bereiche nicht in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] implementiert sind, ist der Standardwert <see langword="null" />.</param>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <summary>Ruft einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> methodenüberladung ist wie die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung, jedoch können Sie übergeben benannten Bereich mit der optionalen Parameter-Syntax, die von verwalteten Sprachen wie c# unterstützt wird.  
  
 Diese Methode ist eine virtuelle Methode, da die <xref:System.Runtime.Caching.ObjectCache> Klasse stellt eine Standardimplementierung, die übergibt die `params` array an die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute>
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine verwaltete Hostumgebung ab, die für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen verfügbar ist und hostspezifische Dienste für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen bereitstellen kann, oder legt diesen fest.</summary>
        <value>Ein Verweis auf eine cachefähige verwaltete Hostumgebung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft dient zur Verwendung von [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Umgebungen und durch die Cache-Implementierungen, die die Implementierung des Verhaltens, das von .NET Framework abhängt gehostet Umgebung.  
  
 Die folgende Tabelle enthält den Satz von Hostdiensten Umgebung, die möglicherweise von einer verwalteten hostumgebung verfügbar und verfügbaren auf <xref:System.Runtime.Caching.ObjectCache> Implementierungen über die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft:  
  
|Dienst|Beschreibung |  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Ermöglicht umfassende Hostumgebungen Anwendung denselben Domänenbezeichner bereitzustellen, die möglicherweise von einem Cacheimplementierung für Funktionen, z. B. das Identifizieren von Leistungsindikatoren benötigt wird.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Geben Sie ein Benachrichtigungssystem benutzerdefinierte dateiänderung anstelle eines bereitgestellt, die Hostumgebungen ermöglicht die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Ermöglicht das Cache-Implementierungen Cachespeicher Verbrauch der hostumgebung. Dies ermöglicht umfassende Hostumgebungen, Speicherverbrauch über mehrere Cache Implementierungen zentral zu verwalten.|  
  
> [!NOTE]
>  Der Aufrufer dieses Eigenschaftswerts erfordern uneingeschränkten Codezugriffsberechtigungen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der der Eigenschaft zugewiesen wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den Eigenschaftenwert mehrmals festzulegen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für alle Accessoren dieser Eigenschaft. Diese Eigenschaft kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass ein Cacheeintrag keinen absoluten Ablauf hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cacheeintrag, der in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> festgelegt werden, da der Ablaufwert nie ablaufen sollen Feldwert basierend auf einem absoluten Zeitpunkt zeitlich. Allerdings kann ein Cacheeintrag mit dieser Einstellung aus dem Cache aus anderen Gründen entfernt werden, die von einer bestimmten Cacheimplementierung, z. B. eine änderungsüberwachung Ereignis Entfernung verursacht durch ungenügenden Arbeitsspeicher bedingt bestimmt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für einen Cacheeintrag im Cache.</param>
        <summary>Ruft den Standardindexer für die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse ab oder legt diesen fest.</summary>
        <value>Ein Schlüssel, der als Indexer in der Cacheinstanz dient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten von der Set-Accessor für diese Eigenschaft entspricht der <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> Methode. Eine Cacheimplementierung konnte absoluten Ablauf des angegebenen Werts, der intern festgelegt die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> Methode. Dieses Verhalten jedoch letztendlich ist der Cache-Implementierung.  
  
 Das Verhalten von "Get"-Zugriffsmethode ist wie das Aufrufen der <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> -Methode und der Verwendung `null` für Name der Region.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen einer bestimmten <see cref="T:System.Runtime.Caching.ObjectCache" />-Instanz ab.</summary>
        <value>Der Name einer bestimmten Cacheinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige Implementierungen Cache unterstützen möglicherweise mehrere Instanzen des Caches, die in einer einzigen Anwendung ausgeführt wird. Diese Eigenschaft ermöglicht Cache-Implementierer, die einen Namen zurück, der eine bestimmte Cache-Instanz identifiziert.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Cacheeintrag keine gleitende Ablaufzeit hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ablauf, der auf von Dauer oder einem definierten Zeitfenster Grundlage wird auch als gleitende Ablaufzeit bezeichnet. Eine Cacheimplementierung, die Elemente, die entfernt auf die Ablaufzeit basieren werden in der Regel wird ein Element entfernt, die nicht im angegebenen Fenster Zeit zugegriffen wurde.  
  
 Ein Cacheeintrag, der in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> Feldwert festgelegt werden, da der Ablaufwert nie aufgrund von nicht-Aktivität in einem gleitenden Zeitfenster entfernt werden soll. Allerdings kann ein Cacheelement, das entfernt werden, wenn es sich um einen absoluten Ablauf hat oder wenn einige andere Entfernung-Ereignis auftritt, eine solche Änderung Monitor oder Arbeitsspeicher Druck.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, entfernt sie den Cacheeintrag aus dem Cache.</summary>
        <returns>Ein Objekt, das den Wert des entfernten, vom Schlüssel angegebenen Cacheeintrags darstellt, oder <see langword="null" />, wenn der angegebene Eintrag nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode in einer benutzerdefinierten Cacheimplementierung außer Kraft setzen, ist es ein Cacheeintrag im Cache, der entspricht `key`, der Wert des entfernten Elements zurückgegeben werden soll. Wenn nichts aus dem Cache entfernt wurde, sollte die Methode zurückgeben `null`.  
  
> [!NOTE]
>  Einige verteilte Cache-Implementierungen unterstützen möglicherweise nicht die Möglichkeit, den Wert zurück, der aus dem Cache entfernt wurde. Möglicherweise der Cacheimplementierung Zurückgeben des Werts eines Cacheelements entfernt nicht unterstützt. Es könnte auch sein, da das Objekt zu marshallen, ein Rückgabewert zu teuer ist. In solchen Fällen können die Cache-Implementierungen zurückgeben `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das normale Verhalten der <xref:System.Runtime.Caching.ObjectCache.Set%2A> Überladung Methoden ist ein INSERT- oder Update-Vorgang. Ein Cacheeintrag ist, dass entweder als neuer Eintrag eingefügt, wenn der angegebene Eintrag nicht vorhanden oder der Cacheeintrag mit einem neuen Wert aktualisiert wird, wenn sie bereits vorhanden ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Cacheelement.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse den Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel für `item` ist nicht vorhanden, `item` als ein neuer Cacheeintrag eingefügt wird. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, wird den Wert von `item` dient zum Aktualisieren oder überschreibt den Wert der vorhandene Cacheeintrag.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein und gibt zeitbasierte Ablaufdetails an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element, das übereinstimmt `key` ist nicht im Cache vorhanden `value` und `key` werden verwendet, um als neuer Cacheeintrag einzufügen. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, der Cacheeintrag aktualisiert oder überschrieben werden, mithilfe von `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung können Sie ausführlichere Entfernung oder den Ablauf von Informationen bereitstellen, die in absolute Ablaufzeit zeitbasierte verfügbar sind.  
  
 Wenn ein Element, das übereinstimmt `key` ist nicht im Cache vorhanden `value` und `key` werden verwendet, um als neuer Cacheeintrag einzufügen. Wenn ein Element mit einem Schlüssel, der entspricht `item` vorhanden ist, der Cacheeintrag aktualisiert oder überschrieben werden, mithilfe von `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>To be added.</summary>
        <returns>To be added.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine generische Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Kann verwendet werden, wenn ein abgeleiteter <xref:System.Runtime.Caching.ObjectCache> Instanz umgewandelt wird eine <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Entwickler können diese Methode eine generische Auflistung von Cacheeinträgen durchlaufen.  
  
 Dies ist die Standardeinstellung <xref:System.Collections.IEnumerable.GetEnumerator%2A> Implementierung, die intern Ruft die <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>