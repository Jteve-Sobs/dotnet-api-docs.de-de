<Type Name="ObjectCache" FullName="System.Runtime.Caching.ObjectCache">
  <Metadata><Meta Name="ms.openlocfilehash" Value="59fa32fc7e57fc1209e20ba0f2ff6e59a2225a77" /><Meta Name="ms.sourcegitcommit" Value="756d085f27705e86604f1bba5f2086ee23761acf" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="01/30/2019" /><Meta Name="ms.locfileid" Value="55349865" /></Metadata><TypeSignature Language="C#" Value="public abstract class ObjectCache : System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt;" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ObjectCache extends System.Object implements class System.Collections.Generic.IEnumerable`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt;, class System.Collections.IEnumerable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ObjectCache" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ObjectCache&#xA;Implements IEnumerable(Of KeyValuePair(Of String, Object))" />
  <TypeSignature Language="C++ CLI" Value="public ref class ObjectCache abstract : System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;" />
  <TypeSignature Language="F#" Value="type ObjectCache = class&#xA;    interface seq&lt;KeyValuePair&lt;string, obj&gt;&gt;&#xA;    interface IEnumerable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</InterfaceName>
    </Interface>
    <Interface>
      <InterfaceName>System.Collections.IEnumerable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt einen Objektcache dar und stellt die Basismethoden und Eigenschaften für den Zugriff auf den Objektcache bereit.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache> ist der primäre Typ für den Cache im Speicher enthaltenes Objekt. Um eine benutzerdefinierte Cacheimplementierung zu entwickeln, leiten Sie von der <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
> [!NOTE]
>  Die <xref:System.Runtime.Caching.ObjectCache> Klasse ist als der neue der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)].  
  
 Die integrierte <xref:System.Runtime.Caching.MemoryCache> Klasse leitet sich von der <xref:System.Runtime.Caching.ObjectCache> Klasse. Die <xref:System.Runtime.Caching.MemoryCache> Klasse ist das einzige konkrete Cacheimplementierung in der [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] abgeleitet, die die <xref:System.Runtime.Caching.ObjectCache> Klasse.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Da die <see cref="T:System.Runtime.Caching.ObjectCache" /> nur allgemeine Cachefunktionen darstellt, besteht keine Notwendigkeit, wie ein <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz instanziiert und abgerufen werden muss. Darüber hinaus besteht keine Notwendigkeit, die konkrete Implementierungen der <see cref="T:System.Runtime.Caching.ObjectCache" /> Klasse muss Singletons sein.  
  
 <block subset="none" type="note"><para><see cref="T:System.Runtime.Caching.MemoryCache" /> ist kein Singleton, aber Sie sollten nur wenige oder möglicherweise nur einen erstellen <see cref="T:System.Runtime.Caching.MemoryCache" /> -Instanz und den Code, der Elemente zwischengespeichert, sollten diese Instanzen verwenden.  
  
</para></block>  
  
 Beim Erben von der <see cref="T:System.Runtime.Caching.ObjectCache" /> -Klasse, müssen Sie die Methoden überschreiben.</para></block>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ObjectCache ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ObjectCache();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters />
      <Docs>
        <summary>Wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse zu initialisieren.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Add">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne dass ein vorhandener Cacheeintrag mit einem übereinstimmenden Schlüssel zurückgegeben werden muss.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode zu testen, um einen Cacheeintrag in den Cache ohne überschreiben, oder entfernen einen vorhandenen Cacheeintrag mit dem gleichen Schlüssel einzufügen. Der Cacheeintrag kann ein typisiertes sein <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode und die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode haben einen wesentlichen Unterschied. Wenn diese Methoden einen Cacheeintrag einfügen, wenn ein überrein stimmender Eintrag im Cache gefunden wird die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode zurück, den vorhandene Cacheeintrag, aber die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode nicht. Mit diesen anderen Überladungen kann Aufrufer ihren Code basierend auf den benötigten gibt an, ob des vorhandene Cacheeintrags zu optimieren. In verteilten Caches Zurückgeben von einem vorhandenen Wert mit dem <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Methode möglicherweise teurer als die Rückgabe eines booleschen Werts mithilfe von <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (item As CacheItem, policy As CacheItemPolicy) As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual bool Add(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool&#xA;override this.Add : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; bool" Usage="objectCache.Add (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz in den Cache einzufügen, und fügt Details zur Entfernung des Eintrags hinzu.</summary>
        <returns><see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="item" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode ruft intern <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die einen Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung spezielles Verhalten für nicht erforderlich ist der <xref:System.Runtime.Caching.ObjectCache.Add%2A> implementieren-Methode es kann nur, die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * DateTimeOffset * string -&gt; bool&#xA;override this.Add : string * obj * DateTimeOffset * string -&gt; bool" Usage="objectCache.Add (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft. Dieser Parameter ist erforderlich, wenn die <see cref="Overload:System.Runtime.Caching.ObjectCache.Add" />-Methode aufgerufen wird.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein, ohne einen vorhandenen Cacheeintrag zu überschreiben.</summary>
        <returns><see langword="true" />, wenn der Eintrag eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode ruft intern <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die einen Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung spezielles Verhalten für nicht erforderlich ist der <xref:System.Runtime.Caching.ObjectCache.Add%2A> implementieren-Methode es kann nur, die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Add">
      <MemberSignature Language="C#" Value="public virtual bool Add (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Add(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Add(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function Add (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool&#xA;override this.Add : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; bool" Usage="objectCache.Add (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse einen Cacheeintrag im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns><see langword="true" />, wenn der Eintrag erfolgreich eingefügt wird, oder <see langword="false" />, wenn bereits ein Eintrag mit demselben Schlüssel wie <paramref name="key" /> im Cache vorhanden ist.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen der Methode sind virtuell (nicht abstrakte) auf die <xref:System.Runtime.Caching.ObjectCache> Klasse, da die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Methode ruft intern <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A>. Dies reduziert die Anzahl der Überladungen der Methode, die einen Cache-Implementierung bereitstellen. Wenn eine Cacheimplementierung spezielles Verhalten für nicht erforderlich ist der <xref:System.Runtime.Caching.ObjectCache.Add%2A> implementieren-Methode es kann nur, die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="AddOrGetExisting">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, versucht sie, einen Cacheeintrag in den Cache einzufügen, und gibt einen vorhandenen Cacheeintrag mit einem übereinstimmenden Schlüssel zurück.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen der Methode fügen Sie einen Eintrag im Cache. Wenn ein Cacheeintrag mit einem übereinstimmenden Schlüssel bereits vorhanden ist, geben sie den vorhandenen Eintrag zurück. Der Cacheeintrag möglich einen <xref:System.Runtime.Caching.CacheItem> Objekt oder ein generisches Objekt.  
  
 Es gibt einen Unterschied zwischen der <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen und die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen. Wenn diese überladenen Methoden versuchen, einen Cacheeintrag zu einzufügen, wenn ein vorhandener Eintrag gefunden wird, dass ein Schlüssel, der entspricht einem vorhandenen Cacheeintrag eingefügt hat die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%2A> Überladungen geben Folgendes den vorhandene Cacheeintrag zurück. Die <xref:System.Runtime.Caching.ObjectCache.Add%2A> Überladungen nicht der Fall.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem AddOrGetExisting (System.Runtime.Caching.CacheItem value, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem AddOrGetExisting(class System.Runtime.Caching.CacheItem value, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (value As CacheItem, policy As CacheItemPolicy) As CacheItem" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract System::Runtime::Caching::CacheItem ^ AddOrGetExisting(System::Runtime::Caching::CacheItem ^ value, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.AddOrGetExisting (value, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="value" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse das angegebene <see cref="T:System.Runtime.Caching.CacheItem" />-Objekt in den Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <returns>Der angegebene Cacheeintrag, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * DateTimeOffset * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag unter Verwendung eines Schlüssels, eines Objekts für den Cacheeintrag, eines absoluten Ablaufwerts und eines optionalen Bereichs zum Hinzufügen des Caches in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Dies <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> eine Überladung gibt einen Objektwert ab, keine <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="AddOrGetExisting">
      <MemberSignature Language="C#" Value="public abstract object AddOrGetExisting (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object AddOrGetExisting(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.AddOrGetExisting(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function AddOrGetExisting (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member AddOrGetExisting : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; obj" Usage="objectCache.AddOrGetExisting (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt einen Cacheeintrag mit einem angegebenen Schlüssel und Wert für den Cacheeintrag sowie Informationen zur Entfernung in den Cache ein.</summary>
        <returns>Der Wert des angegebenen Cacheeintrags, wenn ein Cacheeintrag mit demselben Schlüssel vorhanden ist, andernfalls <see langword="null" />.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.AddOrGetExisting%28System.String%2CSystem.Object%2CSystem.Runtime.Caching.CacheItemPolicy%2CSystem.String%29> Methode gibt einen Objektwert zurück, keine <xref:System.Runtime.Caching.CacheItem> Objekt.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Contains">
      <MemberSignature Language="C#" Value="public abstract bool Contains (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance bool Contains(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Contains(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Contains (key As String, Optional regionName As String = null) As Boolean" />
      <MemberSignature Language="F#" Value="abstract member Contains : string * string -&gt; bool" Usage="objectCache.Contains (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem sich der Cacheeintrag möglicherweise befindet, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, überprüft sie, ob der Cacheeintrag bereits im Cache vorhanden ist.</summary>
        <returns><see langword="true" />, wenn der Cache einen Cacheeintrag mit demselben Schlüsselwert wie <paramref name="key" /> enthält, andernfalls <see langword="false" />.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CreateCacheEntryChangeMonitor">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheEntryChangeMonitor CreateCacheEntryChangeMonitor(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function CreateCacheEntryChangeMonitor (keys As IEnumerable(Of String), Optional regionName As String = null) As CacheEntryChangeMonitor" />
      <MemberSignature Language="F#" Value="abstract member CreateCacheEntryChangeMonitor : seq&lt;string&gt; * string -&gt; System.Runtime.Caching.CacheEntryChangeMonitor" Usage="objectCache.CreateCacheEntryChangeMonitor (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheEntryChangeMonitor</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Die eindeutigen Bezeichner für die zu überwachenden Cacheeinträge.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, in dem sich die Cacheschlüssel im <paramref name="keys" />-Parameter befinden, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie ein <see cref="T:System.Runtime.Caching.CacheEntryChangeMonitor" />-Objekt, das Ereignisse auslösen kann, wenn Änderungen an angegebenen Cacheeinträgen vorgenommen werden.</summary>
        <returns>Eine Änderungsüberwachung, die Cacheeinträge im Cache überwacht.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine abgeleitete <xref:System.Runtime.Caching.ObjectCache> -Klasse überschreibt die <xref:System.Runtime.Caching.ObjectCache.CreateCacheEntryChangeMonitor%2A> -Methode, die die Cacheimplementierung erstellen muss eine <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekt. Dieser spezielle änderungsüberwachung Aufrufer benachrichtigt, wenn es sich bei Änderungen auf die Einträge, die im angegebenen die `keys` Parameter. Angenommen, ein Überwachungskapazität für Elemente in der `keys` -Parameter aktualisiert oder aus dem Cache entfernt, die von dieser Methode erstellte änderungsüberwachung löst ein Ereignis.  
  
 Wenn eine Cacheimplementierung benannten Cache Regionen unterstützt, kann ein String-Wert angegeben werden, als die `regionName` Parameter. Andernfalls die Standardeinstellung eine `null`.  
  
> [!NOTE]
>  Nicht alle Cache-Implementierungen unterstützen Cacheeintrag änderungsüberwachungen. Um zu bestimmen, ob die Cacheimplementierung unterstützt <xref:System.Runtime.Caching.CacheEntryChangeMonitor> Objekten finden Sie in der Dokumentation für die bestimmte Cacheimplementierung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="DefaultCacheCapabilities">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance valuetype System.Runtime.Caching.DefaultCacheCapabilities DefaultCacheCapabilities" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property DefaultCacheCapabilities As DefaultCacheCapabilities" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Runtime::Caching::DefaultCacheCapabilities DefaultCacheCapabilities { System::Runtime::Caching::DefaultCacheCapabilities get(); };" />
      <MemberSignature Language="F#" Value="member this.DefaultCacheCapabilities : System.Runtime.Caching.DefaultCacheCapabilities" Usage="System.Runtime.Caching.ObjectCache.DefaultCacheCapabilities" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.DefaultCacheCapabilities</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie eine Beschreibung der Funktionen ab, die von einer Cacheimplementierung bereitgestellt werden.</summary>
        <value>Eine bitweise Kombination von Flags, die die Standardfunktionen einer Cacheimplementierung angeben.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Get">
      <MemberSignature Language="C#" Value="public abstract object Get (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Get(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Get(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Get (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Get : string * string -&gt; obj" Usage="objectCache.Get (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als Objekt aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCacheItem">
      <MemberSignature Language="C#" Value="public abstract System.Runtime.Caching.CacheItem GetCacheItem (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Runtime.Caching.CacheItem GetCacheItem(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCacheItem(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCacheItem (key As String, Optional regionName As String = null) As CacheItem" />
      <MemberSignature Language="F#" Value="abstract member GetCacheItem : string * string -&gt; System.Runtime.Caching.CacheItem" Usage="objectCache.GetCacheItem (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Runtime.Caching.CacheItem</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag, der abgerufen werden soll.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie den angegebenen Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz aus dem Cache ab.</summary>
        <returns>Der Cacheeintrag, der von <paramref name="key" /> identifiziert wird.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Diese methodenüberladung ist vorhanden, da einige cacheimplementierungen verlängern könnte die <xref:System.Runtime.Caching.CacheItem> Klasse. In diesem Fall die <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -methodenüberladung, nicht unbedingt alle Informationen über zwischengespeicherte Daten zurück. Allerdings die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> -methodenüberladung können benutzerdefinierte Caches um mehr als nur den Cachewert zurückzugeben.  
  
 Die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methode entspricht der <xref:System.Runtime.Caching.ObjectCache.Get%28System.String%2CSystem.String%29> -Methode, außer dass die <xref:System.Runtime.Caching.ObjectCache.GetCacheItem%28System.String%2CSystem.String%29> Methodenrückgabe return den Cacheeintrag als eine <xref:System.Runtime.Caching.CacheItem> Instanz.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetCount">
      <MemberSignature Language="C#" Value="public abstract long GetCount (string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance int64 GetCount(string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetCount(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetCount (Optional regionName As String = null) As Long" />
      <MemberSignature Language="F#" Value="abstract member GetCount : string -&gt; int64" Usage="objectCache.GetCount regionName" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int64</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, für den die Cacheeintragsanzahl berechnet werden soll, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie die Gesamtanzahl von Cacheeinträgen im Cache ab.</summary>
        <returns>Die Anzahl von Cacheeinträgen im Cache. Wenn <paramref name="regionName" /> nicht <see langword="null" /> ist, gibt dieser Wert die Anzahl von Einträgen im angegebenen Cachebereich an.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="GetEnumerator">
      <MemberSignature Language="C#" Value="protected abstract System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object))" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ GetEnumerator();" />
      <MemberSignature Language="F#" Value="abstract member GetEnumerator : unit -&gt; System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string, obj&gt;&gt;" Usage="objectCache.GetEnumerator " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, erstellt sie einen Enumerator, mit dem eine Auflistung von Cacheeinträgen durchlaufen werden kann.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cacheimplementierungen können außer Kraft setzen, und erweitern diese Methode, um eine benutzerdefinierte Iteration durch eine Auflistung von Cacheeinträgen bereitzustellen.  
  
> [!NOTE]
>  Ein Enumerator zurückgegeben normalerweise ist teurer als die Rückgabe des gesamten Cacheeintrags.  
  
 Diese Methode wird aufgerufen, indem Sie die expliziten schnittstellenimplementierungen, die die <xref:System.Runtime.Caching.ObjectCache> Klasse enthält, für die <xref:System.Collections.IEnumerable.GetEnumerator%2A> und <xref:System.Collections.Generic.IEnumerable%601.GetEnumerator%2A> Methoden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="GetValues">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ruft einen Satz von Cacheeinträgen ab.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public abstract System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (System.Collections.Generic.IEnumerable&lt;string&gt; keys, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(class System.Collections.Generic.IEnumerable`1&lt;string&gt; keys, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.Collections.Generic.IEnumerable{System.String},System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function GetValues (keys As IEnumerable(Of String), Optional regionName As String = null) As IDictionary(Of String, Object)" />
      <MemberSignature Language="F#" Value="abstract member GetValues : seq&lt;string&gt; * string -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (keys, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="keys" Type="System.Collections.Generic.IEnumerable&lt;System.String&gt;" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, ruft sie einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> methodenüberladung ist eine leistungsoptimierung für verteilte Caches, die mehrere Cacheeinträge aus dem Cache abrufen, während der einen einzelnen Netzwerkaufruf zu unterstützen.  
  
 Auch wenn ein Aufrufer eine oder mehrere Schlüssel an die Methode übergeben werden kann, besteht keine Garantie, dass alle Schlüssel der Einträge im Cache darstellt. Aus diesem Grund kann das zurückgegebene Wörterbuch weniger Elemente als die Anzahl der Schlüssel enthalten, die an die Methode übergeben wurden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="GetValues">
      <MemberSignature Language="C#" Value="public virtual System.Collections.Generic.IDictionary&lt;string,object&gt; GetValues (string regionName, params string[] keys);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance class System.Collections.Generic.IDictionary`2&lt;string, object&gt; GetValues(string regionName, string[] keys) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.GetValues(System.String,System.String[])" />
      <MemberSignature Language="VB.NET" Value="Public Overridable Function GetValues (regionName As String, ParamArray keys As String()) As IDictionary(Of String, Object)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual System::Collections::Generic::IDictionary&lt;System::String ^, System::Object ^&gt; ^ GetValues(System::String ^ regionName, ... cli::array &lt;System::String ^&gt; ^ keys);" />
      <MemberSignature Language="F#" Value="abstract member GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;&#xA;override this.GetValues : string * string[] -&gt; System.Collections.Generic.IDictionary&lt;string, obj&gt;" Usage="objectCache.GetValues (regionName, keys)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IDictionary&lt;System.String,System.Object&gt;</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="regionName" Type="System.String" />
        <Parameter Name="keys" Type="System.String[]">
          <Attributes>
            <Attribute FrameworkAlternate="dotnet-plat-ext-2.1">
              <AttributeName>System.ParamArray</AttributeName>
            </Attribute>
          </Attributes>
        </Parameter>
      </Parameters>
      <Docs>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag oder die Einträge hinzugefügt werden können, falls Bereiche implementiert werden. Da Bereiche in [!INCLUDE[net_v40_short](~/includes/net-v40-short-md.md)] nicht implementiert werden, ist der Standardwert <see langword="null" />.</param>
        <param name="keys">Eine Auflistung von eindeutigen Bezeichnern für die abzurufenden Cacheeinträge.</param>
        <summary>Ruft einen Satz von Cacheeinträgen ab, die den angegebenen Schlüsseln entsprechen.</summary>
        <returns>Ein Wörterbuch von Schlüssel-Wert-Paaren, die Cacheeinträge darstellen.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.GetValues%2A?displayProperty=nameWithType> methodenüberladung ist wie die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> -methodenüberladung, jedoch ermöglicht die Übergabe benannten Bereichs mithilfe optionaler Parameter-Syntax, die von verwalteten Sprachen wie C# unterstützt wird.  
  
 Diese Methode ist eine virtuelle Methode, da die <xref:System.Runtime.Caching.ObjectCache> Klasse stellt eine Standardimplementierung, die übergibt die `params` array an die <xref:System.Runtime.Caching.ObjectCache.GetValues%28System.Collections.Generic.IEnumerable%7BSystem.String%7D%2CSystem.String%29> -methodenüberladung.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Host">
      <MemberSignature Language="C#" Value="public static IServiceProvider Host { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property class System.IServiceProvider Host" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Host" />
      <MemberSignature Language="VB.NET" Value="Public Shared Property Host As IServiceProvider" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; static property IServiceProvider ^ Host { IServiceProvider ^ get(); void set(IServiceProvider ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Host : IServiceProvider with get, set" Usage="System.Runtime.Caching.ObjectCache.Host" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.5;netframework-4.5.1;netframework-4.5.2;netframework-4.6;netframework-4.6.1;netframework-4.6.2;netframework-4.7;netframework-4.7.1;netframework-4.7.2;netframework-4.8">
          <AttributeName>set: System.Security.SecurityCritical</AttributeName>
        </Attribute>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>get: System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.IServiceProvider</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Verweis auf eine verwaltete Hostumgebung ab, die für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen verfügbar ist und hostspezifische Dienste für <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierungen bereitstellen kann, oder legt diesen fest.</summary>
        <value>Ein Verweis auf eine cachefähige verwaltete Hostumgebung.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft sollte für die Verwendung durch [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] Umgebungen zu hosten und hostumgebung von cacheimplementierungen, die Verhalten zu implementieren, die von .NET Framework abhängt.  
  
 Die folgende Tabelle enthält den Satz von Hostdienste-Umgebung, die möglicherweise von einer verwalteten hostumgebung zur Verfügung und sind zur <xref:System.Runtime.Caching.ObjectCache> Implementierungen über die <xref:System.Runtime.Caching.ObjectCache.Host%2A> Eigenschaft:  
  
|Dienst|Beschreibung |  
|-------------|-----------------|  
|<xref:System.Runtime.Caching.Hosting.IApplicationIdentifier>|Können Hostumgebungen Anwendung-IDs angeben, die möglicherweise von einer Cacheimplementierung für Funktionen, z. B. das Identifizieren von Leistungsindikatoren benötigt wird.|  
|<xref:System.Runtime.Caching.Hosting.IFileChangeNotificationSystem>|Geben Sie ein benutzerdefiniertes dateiänderung Benachrichtigungssystem, anstatt Sie fürs Hostumgebungen können die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)].|  
|<xref:System.Runtime.Caching.Hosting.IMemoryCacheManager>|Cache-Implementierungen Bericht Cachespeicher Verbrauch an die hostumgebung ermöglicht. Dies ermöglicht die Hostumgebungen für die arbeitsspeichernutzung auf mehrere cacheimplementierungen zentral zu verwalten.|  
  
> [!NOTE]
>  Aufrufer der Wert dieser Eigenschaft benötigen uneingeschränkte Berechtigungen für die Codezugriffssicherheit.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.ArgumentNullException">Der Wert, der der Eigenschaft zugewiesen wird, ist <see langword="null" />.</exception>
        <exception cref="T:System.InvalidOperationException">Es wurde versucht, den Eigenschaftenwert mehrmals festzulegen.</exception>
        <permission cref="F:System.Security.Permissions.SecurityAction.Demand">für volle Vertrauenswürdigkeit für alle Accessoren der diese Eigenschaft. Diese Eigenschaft kann nicht von teilweise vertrauenswürdigem Code verwendet werden.</permission>
      </Docs>
    </Member>
    <Member MemberName="InfiniteAbsoluteExpiration">
      <MemberSignature Language="C#" Value="public static readonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.DateTimeOffset InfiniteAbsoluteExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly InfiniteAbsoluteExpiration As DateTimeOffset " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly DateTimeOffset InfiniteAbsoluteExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable InfiniteAbsoluteExpiration : DateTimeOffset" Usage="System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.DateTimeOffset</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass ein Cacheeintrag keinen absoluten Ablauf hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ein Cacheeintrag, der mit in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> Feldwert festgelegt wird, wie Sie der Ablaufwert nie ablaufen soll basierend auf einem absoluten Zeitpunkt rechtzeitig. Allerdings kann ein Cacheeintrag mit dieser Einstellung aus dem Cache aus anderen Gründen entfernt werden, die von einer bestimmten Cacheimplementierung, z. B. eine änderungsüberwachung Ereignis entfernt, die aufgrund von ungenügendem Arbeitsspeicher bestimmt werden.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Item">
      <MemberSignature Language="C#" Value="public abstract object this[string key] { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance object Item(string)" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Item(System.String)" />
      <MemberSignature Language="VB.NET" Value="Default Public MustOverride Property Item(key As String) As Object" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::Object ^ default[System::String ^] { System::Object ^ get(System::String ^ key); void set(System::String ^ key, System::Object ^ value); };" />
      <MemberSignature Language="F#" Value="member this.Item(string) : obj with get, set" Usage="System.Runtime.Caching.ObjectCache.Item" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für einen Cacheeintrag im Cache.</param>
        <summary>Ruft den Standardindexer für die <see cref="T:System.Runtime.Caching.ObjectCache" />-Klasse ab oder legt diesen fest.</summary>
        <value>Ein Schlüssel, der als Indexer in der Cacheinstanz dient.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das Verhalten von der Set-Accessor dieser Eigenschaft entspricht der <xref:System.Runtime.Caching.MemoryCache.Set%28System.String%2CSystem.Object%2CSystem.DateTimeOffset%2CSystem.String%29> Methode. Eine Cacheimplementierung konnte die absolute Ablaufzeit des angegebenen Werts, der intern festgelegt die <xref:System.Runtime.Caching.ObjectCache.InfiniteAbsoluteExpiration> Methode. Dieses Verhalten jedoch letztendlich ist der Cache-Implementierung.  
  
 Das Verhalten des Get-Accessor ist wie das Aufrufen der <xref:System.Collections.Specialized.NameValueCollection.Get%28System.String%29> -Methode und der Verwendung `null` für den Regionsnamen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Name">
      <MemberSignature Language="C#" Value="public abstract string Name { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string Name" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ObjectCache.Name" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property Name As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ Name { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.Name : string" Usage="System.Runtime.Caching.ObjectCache.Name" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Namen einer bestimmten <see cref="T:System.Runtime.Caching.ObjectCache" />-Instanz ab.</summary>
        <value>Der Name einer bestimmten Cacheinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Einige cacheimplementierungen unterstützen möglicherweise mehrere Instanzen des Caches, die in einer einzigen Anwendung ausgeführt wird. Mit dieser Eigenschaft können einen Namen zurück, der eine bestimmten Cacheinstanz identifiziert cacheimplementierungen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NoSlidingExpiration">
      <MemberSignature Language="C#" Value="public static readonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="ILAsm" Value=".field public static initonly valuetype System.TimeSpan NoSlidingExpiration" />
      <MemberSignature Language="DocId" Value="F:System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberSignature Language="VB.NET" Value="Public Shared ReadOnly NoSlidingExpiration As TimeSpan " />
      <MemberSignature Language="C++ CLI" Value="public: static initonly TimeSpan NoSlidingExpiration;" />
      <MemberSignature Language="F#" Value=" staticval mutable NoSlidingExpiration : TimeSpan" Usage="System.Runtime.Caching.ObjectCache.NoSlidingExpiration" />
      <MemberType>Field</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.TimeSpan</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Gibt an, dass ein Cacheeintrag keine gleitende Ablaufzeit hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Ablauf, der basierend auf Dauer oder einem definierten Zeitfenster wird auch als die gleitende Ablaufzeit bezeichnet. In der Regel wird eine Cacheimplementierung, die Elemente, die entfernt auf die gleitende Ablaufzeit basieren Elemente entfernt werden, die nicht in das angegebene Zeitfenster zugegriffen wurde.  
  
 Ein Cacheeintrag, der mit in den Cache eingefügt wird die <xref:System.Runtime.Caching.ObjectCache.NoSlidingExpiration> Feldwert als Wert für die Gültigkeitsdauer nicht soll, können Sie aufgrund von nicht-Aktivität in einem gleitenden Zeitfenster entfernt werden festlegen. Allerdings kann ein Element im Cache entfernt werden, wenn es sich um einen absoluten Ablauf hat oder ein anderes Entfernung-Ereignis auftritt, eine solche Änderung überwachen oder Arbeitsspeicher unter Druck.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Remove">
      <MemberSignature Language="C#" Value="public abstract object Remove (string key, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance object Remove(string key, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Remove(System.String,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Function Remove (key As String, Optional regionName As String = null) As Object" />
      <MemberSignature Language="F#" Value="abstract member Remove : string * string -&gt; obj" Usage="objectCache.Remove (key, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Object</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt wurde, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, entfernt sie den Cacheeintrag aus dem Cache.</summary>
        <returns>Ein Objekt, das den Wert des entfernten, vom Schlüssel angegebenen Cacheeintrags darstellt, oder <see langword="null" />, wenn der angegebene Eintrag nicht gefunden wurde.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn Sie diese Methode in eine benutzerdefinierte Cacheimplementierung, außer Kraft setzen, ist es ein Cacheeintrag im Cache, der die entspricht `key`, der Wert des entfernten Elements zurückgegeben werden sollen. Wenn nichts aus dem Cache entfernt wurde, sollte die Methode zurückgeben `null`.  
  
> [!NOTE]
>  Einige verteilte cacheimplementierungen unterstützen möglicherweise nicht die Möglichkeit, den Wert zurück, der aus dem Cache entfernt wurde. Dies kann sein, da die Cacheimplementierung Zurückgeben des Werts eines Elements entfernt Cache nicht unterstützt. Es kann auch sein, da das Objekt zu marshallen, wie ein Rückgabewert zu teuer ist. In solchen Fällen können cacheimplementierungen zurückgeben `null`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Set">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Das normale Verhalten von der <xref:System.Runtime.Caching.ObjectCache.Set%2A> Überladung Methoden ist ein INSERT- oder Update-Vorgang. Ein Cacheeintrag ist, dass entweder als neuer Eintrag eingefügt, wenn der angegebene Eintrag nicht vorhanden oder der Cacheeintrag durch einen neuen Wert aktualisiert wird, wenn sie bereits vorhanden ist.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (System.Runtime.Caching.CacheItem item, System.Runtime.Caching.CacheItemPolicy policy);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(class System.Runtime.Caching.CacheItem item, class System.Runtime.Caching.CacheItemPolicy policy) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.Runtime.Caching.CacheItem,System.Runtime.Caching.CacheItemPolicy)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (item As CacheItem, policy As CacheItemPolicy)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract void Set(System::Runtime::Caching::CacheItem ^ item, System::Runtime::Caching::CacheItemPolicy ^ policy);" />
      <MemberSignature Language="F#" Value="abstract member Set : System.Runtime.Caching.CacheItem * System.Runtime.Caching.CacheItemPolicy -&gt; unit" Usage="objectCache.Set (item, policy)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="item" Type="System.Runtime.Caching.CacheItem" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
      </Parameters>
      <Docs>
        <param name="item">Das hinzuzufügende Cacheelement.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <summary>Fügt beim Überschreiben in einer abgeleiteten Klasse den Cacheeintrag als <see cref="T:System.Runtime.Caching.CacheItem" />-Instanz im Cache ein und gibt Informationen darüber an, wie der Eintrag entfernt wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Schlüssel für `item` ist nicht vorhanden, `item` wird als ein neuer Cacheeintrag eingefügt. Wenn ein Element mit einem Schlüssel, entspricht `item` vorhanden ist, handelt es sich bei den Wert von `item` dient zum Aktualisieren oder den Wert des der vorhandene Cacheeintrag zu überschreiben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, DateTimeOffset absoluteExpiration, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, valuetype System.DateTimeOffset absoluteExpiration, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.DateTimeOffset,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, absoluteExpiration As DateTimeOffset, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * DateTimeOffset * string -&gt; unit" Usage="objectCache.Set (key, value, absoluteExpiration, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="absoluteExpiration" Type="System.DateTimeOffset" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="absoluteExpiration">Das feste Datum und die Uhrzeit, an dem bzw. zu der der Cacheeintrag abläuft.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein und gibt zeitbasierte Ablaufdetails an.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn ein Element, das entspricht `key` ist nicht im Cache `value` und `key` werden verwendet, um als ein neuer Cacheeintrag eingefügt. Wenn ein Element mit einem Schlüssel, entspricht `item` vorhanden ist, aktualisiert oder überschrieben werden, mithilfe des Cacheeintrags `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Set">
      <MemberSignature Language="C#" Value="public abstract void Set (string key, object value, System.Runtime.Caching.CacheItemPolicy policy, string regionName = null);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Set(string key, object value, class System.Runtime.Caching.CacheItemPolicy policy, string regionName) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.Set(System.String,System.Object,System.Runtime.Caching.CacheItemPolicy,System.String)" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride Sub Set (key As String, value As Object, policy As CacheItemPolicy, Optional regionName As String = null)" />
      <MemberSignature Language="F#" Value="abstract member Set : string * obj * System.Runtime.Caching.CacheItemPolicy * string -&gt; unit" Usage="objectCache.Set (key, value, policy, regionName)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="key" Type="System.String" />
        <Parameter Name="value" Type="System.Object" />
        <Parameter Name="policy" Type="System.Runtime.Caching.CacheItemPolicy" />
        <Parameter Name="regionName" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="key">Ein eindeutiger Bezeichner für den Cacheeintrag.</param>
        <param name="value">Das einzufügende Objekt.</param>
        <param name="policy">Ein Objekt, das Entfernungsdetails für den Cacheeintrag enthält. Dieses Objekt stellt mehr Optionen für das Entfernen bereit als ein einfacher absoluter Ablauf.</param>
        <param name="regionName">Dies ist optional. Ein benannter Bereich im Cache, dem der Cacheeintrag hinzugefügt werden kann, falls Bereiche implementiert werden. Der Standardwert für den optionalen Parameter ist <see langword="null" />.</param>
        <summary>Wenn diese Methode in einer abgeleiteten Klasse überschrieben wird, fügt sie einen Cacheeintrag in den Cache ein.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Überladung dieser Methode können Sie die Cachelöschungs- oder Ablaufrichtlinie mehr als die bereitzustellen, die in absolute Ablaufzeit zeitbasierte verfügbar sind.  
  
 Wenn ein Element, das entspricht `key` ist nicht im Cache `value` und `key` werden verwendet, um als ein neuer Cacheeintrag eingefügt. Wenn ein Element mit einem Schlüssel, entspricht `item` vorhanden ist, aktualisiert oder überschrieben werden, mithilfe des Cacheeintrags `value`.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;string,object&gt;&gt; IEnumerable&lt;KeyValuePair&lt;string,object&gt;&gt;.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.Generic.IEnumerator`1&lt;valuetype System.Collections.Generic.KeyValuePair`2&lt;string, object&gt;&gt; System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#Generic#IEnumerable&lt;System#Collections#Generic#KeyValuePair&lt;System#String,System#Object&gt;&gt;#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator(Of KeyValuePair(Of String, Object)) Implements IEnumerable(Of KeyValuePair(Of String, Object)).GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::Generic::IEnumerator&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt; ^ System.Collections.Generic.IEnumerable&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;.GetEnumerator() = System::Collections::Generic::IEnumerable&lt;System::Collections::Generic::KeyValuePair&lt;System::String ^, System::Object ^&gt;&gt;::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.Generic.IEnumerable`1.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute FrameworkAlternate="netframework-4.0">
          <AttributeName>System.Runtime.TargetedPatchingOptOut("Performance critical to inline this type of method across NGen image boundaries")</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IEnumerator&lt;System.Collections.Generic.KeyValuePair&lt;System.String,System.Object&gt;&gt;</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine stark typisierte Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Einträge im Cache bietet.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="System.Collections.IEnumerable.GetEnumerator">
      <MemberSignature Language="C#" Value="System.Collections.IEnumerator IEnumerable.GetEnumerator ();" />
      <MemberSignature Language="ILAsm" Value=".method hidebysig newslot virtual instance class System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ObjectCache.System#Collections#IEnumerable#GetEnumerator" />
      <MemberSignature Language="VB.NET" Value="Function GetEnumerator () As IEnumerator Implements IEnumerable.GetEnumerator" />
      <MemberSignature Language="C++ CLI" Value=" virtual System::Collections::IEnumerator ^ System.Collections.IEnumerable.GetEnumerator() = System::Collections::IEnumerable::GetEnumerator;" />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.Collections.IEnumerable.GetEnumerator</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Collections.IEnumerator</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Unterstützt die Iteration durch eine generische Auflistung.</summary>
        <returns>Das Enumeratorobjekt, das Zugriff auf die Elemente im Cache bietet.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Bei diesem Member handelt es sich um eine explizite Schnittstellenmemberimplementierung. Es kann verwendet werden, nur, wenn eine abgeleitete <xref:System.Runtime.Caching.ObjectCache> Instanz umgewandelt wird ein <xref:System.Collections.IEnumerable> Schnittstelle.  
  
 Entwickler können diese Methode verwenden, um eine generische Auflistung von Cacheeinträgen durchlaufen.  
  
 Dies ist die Standardeinstellung <xref:System.Collections.IEnumerable.GetEnumerator%2A> -Implementierung, die ruft intern die <xref:System.Runtime.Caching.ObjectCache.GetEnumerator%2A> Methode.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>