<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="dae77b331be178bf2ec565bb32fdb1525ebede13" /><Meta Name="ms.sourcegitcommit" Value="397961a0164281b579f68064c3bb66c071f374d9" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="07/14/2020" /><Meta Name="ms.locfileid" Value="78800198" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Basisklasse für einen abgeleiteten benutzerdefinierten Typ bereit, der Wechsel in den Zustand der Daten überwacht, auf den ein Cacheelement angewiesen ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.ChangeMonitor> Klasse wird als Basisklasse für abgeleitete Monitor Klassen verwendet, die auf bestimmte Cache Implementierungen spezialisiert sind. Eine- <xref:System.Runtime.Caching.ChangeMonitor> Instanz überwacht Änderungen im Zustand der Daten, von denen ein Cache Element abhängt. Beispielsweise kann es sich bei dem Element um eine Datei oder eine Daten Entität handeln, deren Inhalt zwischengespeichert wird. Wenn die Datei oder die Daten Entität aktualisiert wird, muss auch der zugehörige Cache Eintrag geändert werden. Zu den allgemeinen Elementen, die überwacht werden können, gehören Daten Entitäten (z. b. Datenbankfelder, Werte, Zeilen oder Tabellen), ein weiterer Cache Eintrag und Dateien und Dateiattribute.  
  
 Eine Abhängigkeits Änderung ist eine Änderung des Zustands einer Abhängigkeit. Wenn eine-Instanz in einer typischen Cache Implementierung <xref:System.Runtime.Caching.ChangeMonitor> den Cache darüber benachrichtigt, dass sich eine Abhängigkeit geändert hat, führt der Cache die erforderliche Aktion aus, z. b. den eingefügten Cache Eintrag für ungültig zu erklären.  
  
 Abgeleitete <xref:System.Runtime.Caching.ChangeMonitor> Klassen können angepasst werden, um Abhängigkeitsänderungen für bestimmte unterschiedliche Datenspeicher zu überwachen. Beispielsweise gibt es Cache Implementierungen für ein Dateisystem, physischen Arbeitsspeicher oder eine Datenbank. Die <xref:System.Runtime.Caching.ChangeMonitor> -Klasse untersucht Änderungen, die außerhalb des Caches erfolgen, und benachrichtigt dann den Cache, dass Änderungen aufgetreten sind.  
  
 [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)]Enthält die folgenden Klassen, die von der-Klasse abgeleitet sind <xref:System.Runtime.Caching.ChangeMonitor> :  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Jede dieser Klassen funktioniert mit unterschiedlichen Abhängigkeits Typen. Beispielsweise werden von der abgeleiteten <xref:System.Runtime.Caching.FileChangeMonitor> Klasse Änderungen an einem Cache für Dateisystem Daten (Dateien und Ordner) überwacht, von denen das Cache Element abhängig ist.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Wenn Sie eine benutzerdefinierte Cache Implementierung oder einen abgeleiteten Änderungs Monitortyp erstellen, müssen Sie bestimmte Richtlinien befolgen. In der folgenden Liste sind diese Richtlinien zusammengefasst. Weitere Informationen finden Sie in der Dokumentation zu einzelnen Methoden oder Eigenschaften.  
  
-Der Konstruktor einer abgeleiteten Klasse muss die <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> -Eigenschaft, die BEGIN Monitoring-Methode und die-Methode des Aufrufes <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> vor der Rückgabe der Methode festlegen. Wenn ein Konstruktor während der Konstruktion einen Fehler feststellt und Ressourcen verwerfen muss, kann der Konstruktor die-Überladung nur aufrufen, nachdem die-Methode aufgerufen wurde, da die-Überladung <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> eine Ausnahme auslöst, <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Wenn die <see cref="T:System.InvalidOperationException" /> Initialisierung nicht abgeschlossen ist.  
  
-Wenn in den Daten, die überwacht werden, Änderungen auftreten, bevor die Initialisierung beendet ist, muss der Konstruktor die-Methode aufrufen, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> bevor die-Methode aufgerufen wird <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> .  
  
-Nachdem ein abgeleiteter <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Typ instanziiert wurde, müssen Sie den Monitor in eine benutzerdefinierte <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung einfügen. Wenn Sie den Änderungs Monitor nicht mehr benötigen, können Sie die- <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode verwenden.  
  
-Nachdem eine- <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz in eine- <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung eingefügt wurde, muss die- <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz den Änderungs Monitor verwerfen. Auch wenn die Einfügung ungültig ist und eine Ausnahme verursacht, muss die-Implementierung die-Überladung <see cref="T:System.Runtime.Caching.ObjectCache" /> aufrufen <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> .  
  
-Nachdem ein abgeleiteter Änderungs Monitor in einen Cache eingefügt wurde, <see cref="T:System.Runtime.Caching.ObjectCache" /> muss die Implementierung aufrufen <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> , indem ein-Objekt übergeben wird <see cref="T:System.Runtime.Caching.OnChangedCallback" /> . Die- <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode kann nur einmal aufgerufen werden. Wenn bereits eine Abhängigkeits Änderung aufgetreten ist, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wird die Instanz sofort aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz nur einmal aufgerufen. Dieser einmalige Aufruf tritt auf, wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode aufgerufen wird, da die- <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz eine Änderung erkannt hat oder wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode für den aufgerufen wird <see cref="T:System.Runtime.Caching.ChangeMonitor" /> , je nachdem, welcher Wert zuerst auftritt.  
  
-Die- <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz, die von einer-Implementierung bereitgestellt wird, <see cref="T:System.Runtime.Caching.ObjectCache" /> sollte den zugehörigen Cache Eintrag entfernen und einen Grund angeben, indem die- <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> Enumeration verwendet wird.  
  
-Eine- <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz kann die-Methode aufrufen, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> bevor eine Cache Implementierung die-Methode oder die-Methode aufgerufen hat <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> . Wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode aufgerufen wird <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> , bevor aufgerufen wird, <see cref="T:System.Runtime.Caching.ChangeMonitor" /> benachrichtigt die Basis Implementierung den Cache, dass diese aufgetreten ist, und löst den Rückruf aus, <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Alle Zustandsdaten, die an die- <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode übermittelt werden, werden vom Änderungs Monitor gespeichert und anschließend an die-Methode übermittelt, <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode aufgerufen wird.  
  
: Ein Änderungs Monitor muss die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Methode implementieren. Weitere Informationen finden Sie in der Dokumentation zur <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode.  
  
-Die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methoden Überladung muss aufgerufen werden, um die-Instanz zu verwerfen <see cref="T:System.Runtime.Caching.ChangeMonitor" /> . Die Regeln zum Aufrufen von "verwerfen" lauten wie folgt: 
-Bevor ein Element in den Cache eingefügt wird, liegt es in der Verantwortung des Aufrufers, eine-Instanz zu verwerfen <see cref="T:System.Runtime.Caching.ChangeMonitor" /> .  
  
-Sobald das Cache Element und die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> ihm zugeordneten Instanzen an einen Cache übermittelt werden, muss der cacheimplementierer sicherstellen, dass die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode aufgerufen wird, auch wenn die Einfügung fehlschlägt.  
  
-Nachdem ein Element und die zugehörigen <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanzen an einen Cache übergeben wurden, darf der Aufrufer die Abhängigkeit nicht verwerfen, da der <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Aufruf beim Aufrufen der Methode so behandelt wird, als ob sich die Abhängigkeit geändert hat. Folglich <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> wird die Methode automatisch aufgerufen.  
  
Wenn diese Regeln berücksichtigt werden, muss die- <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode auf eine der folgenden Weisen aufgerufen werden: 
-Benutzer müssen die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methoden Überladung aufrufen, wenn Sie festlegen, dass die abgeleitete Change-Monitor-Instanz nicht in einen Cache eingefügt werden soll.  
  
Wenn die Implementierung versucht, die Change-Monitor-Instanz in einen Objekt Cache einzufügen, die Einfügung jedoch fehlschlägt, ist die Cache Implementierung für das Aufrufen der Überladung verantwortlich <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> . Wenn beim Einfügeversuch eine Ausnahme ausgelöst wird, muss die Cache Implementierung alle zugeordneten Abhängigkeiten verwerfen.  
  
-Wenn der Cache Eintrag entfernt wird, muss die Cache Implementierung auch die Abhängigkeit verwerfen.  
  
-Die interne Implementierung der- <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode ruft die- <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode automatisch auf, nachdem Sie einen Rückruf aufgerufen hat, der über registriert wird <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> .  
  
 <block subset="none" type="note"><para>  
 Dieser automatische Rückruf der verwerfen-Methode während des auslösenden Ereignisses tritt nur auf, wenn die Initialisierung der <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz zuvor abgeschlossen wurde.  
  
</para></block>  
  
 Wenn der Konstruktor eines abgeleiteten Änderungs Monitors die- <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode aufruft und sich der Status des Änderungs Monitors bereits geändert hat (d. h., der Status, der überwacht wird, wenn der Konstruktor noch aktiv war), <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wird der Änderungs Monitor von der Methode automatisch verworfen.  
  
-Die- <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> Eigenschaft wird auf festgelegt <see langword="true" /> , nachdem die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> -Methode von der abgeleiteten Change-Monitor-Instanz aufgerufen wurde, unabhängig davon, ob ein- <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Objekt durch einen Aufruf der-Methode festgelegt wurde <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> oder nicht.</para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/xsbfdd8c(v=vs.100)">ASP.NET-Caching</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse. Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die Basisklasse zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.ChangeMonitor> Klasse verfügt über einen Parameter losen Konstruktor. Allerdings müssen Klassen, die von der Basis <xref:System.Runtime.Caching.ChangeMonitor> Klasse erben und das benutzerdefinierte Verhalten der Änderungs Überwachung definieren, im Konstruktor eine Initialisierung ausführen. Weitere Informationen finden Sie im Abschnitt Hinweise für Vererbung.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Der Konstruktor einer abgeleiteten Klasse muss die- <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> Eigenschaft festlegen, die Überwachung starten und die- <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Klasse vor der Rückgabe aufzurufen. Wenn sich eine Abhängigkeit ändert, bevor die Initialisierung beendet ist (z. b. Wenn ein abhängiger Cache Schlüssel nicht im Cache gefunden wurde), muss der Konstruktor die-Methode aufrufen, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> bevor die-Methode aufgerufen wird <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> . In diesem Fall kann der Konstruktor die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode erst aufrufen, nachdem die- <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode aufgerufen wurde, da die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode eine Ausnahme auslöst, wenn die Initialisierung nicht abgeschlossen ist.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode wird verwendet, um die <xref:System.Runtime.Caching.ChangeMonitor> Instanz und zugehörige Ressourcen freizugeben. Die öffentliche- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode wird aufgerufen, um den Entsorgungsprozess mit Schlüssel Lebenszyklus-Ereignissen abgeleiteter Änderungs Monitor Klassen (z. b. der Initialisierung) zu koordinieren und die Instanz freizugeben, <xref:System.Runtime.Caching.ChangeMonitor> damit die Instanz in die Garbage Collection aufgenommen werden kann. Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode wird von abgeleiteten Change-Monitor-Klassen implementiert, um deren verwaltete und nicht verwaltete Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode ruft die- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode der abgeleiteten Klassen nur einmal auf, wenn Sie zum ersten Mal aufgerufen wird. Nachfolgende Aufrufe der- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode haben keine Auswirkung. Nachdem die-Methode aufgerufen wurde, wird die- <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> Eigenschaft auf festgelegt `true` .  
  
 Die-Überladung <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> muss aufgerufen werden, um eine-Instanz zu verwerfen <xref:System.Runtime.Caching.ChangeMonitor> . Im folgenden sind die Regeln zum Aufrufen der verwerfen-Methode aufgeführt:  
  
-   Bevor ein Element in den Cache eingefügt wird, liegt es in der Verantwortung des Aufrufers, eine-Instanz zu verwerfen <xref:System.Runtime.Caching.ChangeMonitor> .  
  
-   Nachdem das Cache Element und die <xref:System.Runtime.Caching.ChangeMonitor> zugeordneten Instanzen an einen Cache weitergegeben wurden, muss der cacheimplementierer sicherstellen, dass <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> aufgerufen wird, auch wenn die Einfügung fehlschlägt.  
  
-   Nachdem ein Element und die zugehörigen <xref:System.Runtime.Caching.ChangeMonitor> Instanzen an einen Cache übergeben wurden, darf der Aufrufer die Abhängigkeit nicht verwerfen, da der Aufruf beim Aufruf der- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode behandelt wird, als ob sich die Abhängigkeit geändert hat. Folglich <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> wird die Methode automatisch aufgerufen.  
  
-   Wenn diese Regeln berücksichtigt werden, muss die- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode auf eine der folgenden Weisen aufgerufen werden:  
  
    -   Benutzer müssen die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methoden Überladung aufrufen, wenn Sie sich entschließen, die abgeleitete Change-Monitor-Instanz nicht in einen Cache einzufügen.  
  
    -   Die Cache Implementierung ist für das Aufrufen der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Überladung zuständig, wenn die Implementierung versucht, die Change-Monitor-Instanz in einen Objekt Cache einzufügen, aber die Einfügung schlägt fehl. Wenn der Einfügeversuch eine Ausnahme verursacht, muss die Cache Implementierung alle zugeordneten Abhängigkeiten verwerfen.  
  
    -   Wenn der Cache Eintrag entfernt wird, muss die Cache Implementierung auch die Abhängigkeit verwerfen.  
  
 Die interne Implementierung der- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode ruft die- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode automatisch auf, nachdem Sie einen Rückruf aufgerufen hat, der über die-Methode registriert wird <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> .  
  
> [!NOTE]
>  Diese automatische Löschung während des auslösenden Ereignisses tritt nur auf, wenn die Initialisierung der- <xref:System.Runtime.Caching.ChangeMonitor> Instanz zuvor abgeschlossen wurde.  
  
 Wenn der Konstruktor eines abgeleiteten Änderungs Monitors die- <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> Methode aufruft und sich der Status des Änderungs Monitors bereits geändert hat (d. h., der Status, der überwacht wird, wenn der Konstruktor noch aktiv war), <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> wird der Änderungs Monitor automatisch von der-Methode verworfen.  
  
> [!NOTE]
>  Benutzer sollten die-Methode nicht aufzurufen <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> . Sie können jedoch nicht verhindern, dass Benutzer die-Methode aufrufen. Wenn dies der Fall ist, wird die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufgerufen. In diesem Fall wird der Cache Eintrag benachrichtigt, als ob sich die Abhängigkeit geändert hat.  
  
 Um zu verhindern, dass abgeleitete Klassen die-Methode überschreiben <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> , ist die-Methode keine explizite Schnittstellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Initialisierung ist in der abgeleiteten Änderungsüberwachungsklasse nicht vollständig, die die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Basismethode aufrief.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um verwaltete und nicht verwaltete Ressourcen sowie Verweise auf eine <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz freizugeben, <see langword="false" />, um nur nicht verwaltete Ressourcen freizugeben. Wenn <see langword="false" /> übergeben wird, wird die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode von einem <see langword="finalizer" />-Thread aufgerufen, und alle externen verwalteten Verweise sind wahrscheinlich nicht mehr gültig, da sie bereits von der Garbage Collection freigegeben wurden.</param>
        <summary>Gibt alle verwalteten und nicht verwalteten Ressourcen und alle Verweise auf die <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz frei. Diese Überladung muss von abgeleiteten Änderungsüberwachungsklassen implementiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert von `disposing` value lautet `true` , werden alle verwalteten und nicht verwalteten Ressourcen verworfen, und alle Verweise auf dieses Objekt werden freigegeben, sodass die abgeleitete Change-Monitor-Instanz in die Garbage Collection aufgenommen werden kann. Es ist sichergestellt, dass die Basis <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode die implementierte <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode nur einmal aufruft.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ein Änderungs Monitor muss die-Überladung implementieren <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> , um alle verwalteten und nicht verwalteten Ressourcen freizugeben, wenn der Wert von <paramref name="disposing" /> ist <see langword="true" /> . Die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Methoden Überladung, die den <paramref name="disposing" /> Wert hat <see langword="true" /> , wird nur einmal aufgerufen, d. h., wenn die Instanz zum ersten Mal verworfen wird. Ein Änderungs Monitor darf die-Überladung nicht <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> direkt aufrufen. Ein abgeleiteter Änderungs Monitor kann die Methode "Public" ohne Parameter <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> für die Basis <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasse aufrufen.  
  
Alternativ kann ein Änderungs Monitor eine Finalizer-Methode implementieren. In diesem Fall kann der Finalizer die Methode aufrufen <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> und ihm den Wert übergeben <paramref name="disposing" /> <see langword="false" /> . Dies ist jedoch in der Regel unnötig. Die Überwachung von Abhängigkeitsänderungen erfolgt in der Regel von einem Dienst, der einen Verweis auf die Change-Monitor-Instanz verwaltet. Durch den Verweis wird verhindert, dass die Instanz in die Garbage Collection aufgenommen wird. Daher ist eine Finalizer-Methode unnötig. Um Speicher Verluste zu vermeiden, <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> gibt die-Methode die Change-Monitor-Instanz frei, wenn eine Abhängigkeit geändert wird (es sei denn, die Initialisierung wurde nicht abgeschlossen).</para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass der von der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse überwachte Zustand geändert wurde.</summary>
        <value><see langword="true" />, wenn der von der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz überwachte Zustand geändert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Wert dieser Eigenschaft in einer abgeleiteten Klasse überprüfen <xref:System.Runtime.Caching.ChangeMonitor> , um festzustellen, ob sich eine Abhängigkeit geändert hat.  
  
 Der Wert wird auf festgelegt, `true` Wenn eine Abhängigkeits Änderung auftritt (d. h., wenn die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufgerufen wird). Nachdem die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode von der abgeleiteten Klasse aufgerufen wurde, ist der Wert der- <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft `true` , unabhängig davon, ob eine- <xref:System.Runtime.Caching.OnChangedCallback> Instanz durch einen Aufruf der- <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode benachrichtigt wurde.  
  
> [!NOTE]
>  Aufrufer können die Eigenschaft überprüfen <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> , um festzustellen, ob sich eine Abhängigkeit geändert hat In einer Multithread-Umgebung ist es jedoch einfacher und besser verwaltbar, Daten in eine Cache Implementierung einzufügen, ohne die-Eigenschaft zu überprüfen <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> . Cache Implementierungen müssen die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> -Eigenschaft für Sie überprüfen und dürfen keinen INSERT-oder Set-Vorgang ausführen, wenn mindestens eine zugeordnete Abhängigkeit bereits geändert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird vom Konstruktor abgeleiteter Klassen aufgerufen, um anzugeben, dass die Initialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Abhängigkeit geändert wird, bevor die Initialisierung in einer abgeleiteten Klasse ausgeführt wird, muss der Konstruktor der abgeleiteten Klasse die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufrufen.  
  
 Wenn die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufgerufen wird, <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> wird die-Eigenschaft automatisch `true` vom Änderungs Monitor auf festgelegt. Wenn der Konstruktor des Änderungs Monitors die- <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> Methode aufruft, wird die-Methode von der-Basisklasse automatisch aufgerufen <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> . Wenn die Initialisierung beendet ist, gibt die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode automatisch die abgeleitete Change-Monitor-Instanz frei.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Der Konstruktor einer abgeleiteten Klasse muss die Basis <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode vor der Rückgabe des Konstruktors aufzurufen. Der Konstruktor einer abgeleiteten Klasse kann die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode erst aufrufen <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> , nachdem aufgerufen wurde, da die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode eine Ausnahme auslöst, wenn die Initialisierung nicht abgeschlossen ist.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass die abgeleitete Instanz einer <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse freigegeben wird.</summary>
        <value><see langword="true" />, wenn die Instanz freigegeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Eigenschaft wird auf festgelegt, `true` nachdem die Basis Methode die- <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode in einer abgeleiteten Klasse aufgerufen hat, um die Instanz zu verwerfen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="VB.NET" Value="Public Sub NotifyOnChanged (onChangedCallback As OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Ein Verweis auf eine Methode, die aufgerufen wird, wenn eine Abhängigkeit geändert wurde.</param>
        <summary>Wird von Cacheimplementierungen aufgerufen, um einen Rückruf zu registrieren und über den <see cref="T:System.Runtime.Caching.ObjectCache" />-Delegaten eine <see cref="T:System.Runtime.Caching.OnChangedCallback" />-Instanz zu benachrichtigen, wenn sich eine Abhängigkeit geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cacheimplementierer verwenden diese Methode, um sich mit einem Änderungs Monitor zu verknüpfen. Wenn Sie dem Cache Element mindestens einen Änderungs Monitor zuordnen, übergeben Sie eine- <xref:System.Runtime.Caching.CacheItemPolicy> Instanz mit einer aufgefüllten Change Monitors-Eigenschaft an das Cache Element. Ein cacheimplementierer, der Änderungs Monitore unterstützt, ist dafür verantwortlich, die <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> Eigenschaft zu durchlaufen und die Delegaten <xref:System.Runtime.Caching.OnChangedCallback> bei jedem gefundenen Änderungs Monitor zu registrieren.  
  
 Da der <xref:System.Runtime.Caching.OnChangedCallback> Delegat einen optionalen State-Parameter enthält, kann eine konkrete Änderungs Monitor Implementierung optionale Zustandsinformationen übergeben. Der cacheimplementierer bestimmt, ob eine explizite Abhängigkeit vom Typ des Zustands, den ein benutzerdefinierter Änderungs Monitor als Teil des Rückrufs übergibt, angenommen werden kann.  
  
> [!NOTE]
>  Die Basis Cache-Erweiterbarkeits-API erfordert keine explizite Abhängigkeit vom Typ des Zustands.  
  
 Die Implementierung der- <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode bestimmt automatisch, ob sich der Status des Monitors bereits geändert hat, wenn die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode aufgerufen wird. Wenn die- <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft ist `true` , ruft die-Methode automatisch den Ereignishandler auf, der <xref:System.Runtime.Caching.OnChangedCallback> über die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode registriert wurde. Dies liegt daran, dass es möglich ist, dass ab dem Zeitpunkt, zu dem eine Cache Implementierung einen Änderungs Monitor erstellt, bis zu dem Zeitpunkt, zu dem eine Cache Implementierung den Monitor abruft und sich damit verbindet, der zugrunde liegende überwachte Zustand geändert wurde. Wenn sich der Zustand bereits geändert hat, ist das Objekt, das an die-Methode weitergegeben wird, <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> `null` .  
  
 Die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> -Methode kann nur einmal aufgerufen werden und löst bei nachfolgenden Aufrufen eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Rückrufmethode wurde bereits aufgerufen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="onChangedCallback" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>1. Sie müssen die- <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode aufzurufen, um über Änderungen an Abhängigkeiten benachrichtigt zu werden. Wenn bereits eine Abhängigkeits Änderung aufgetreten ist, <see cref="T:System.Runtime.Caching.OnChangedCallback" /> wird die-Instanz aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz einmal aufgerufen, entweder wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode aufgerufen wird oder wenn die- <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode aufgerufen wird, je nachdem, welcher Vorgang zuerst ausgeführt wird. Die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> von der Cache Implementierung bereitgestellte Instanz sollte den Cache Eintrag entfernen. Wenn Sie vom Cache Aufrufer angefordert wird, müssen Sie das erforderliche Änderungs-oder Update Ereignis zurück an den ursprünglichen Cache Aufrufer machen.  
  
2.  Die Objekt Cache Implementierung muss den Cache Eintrag entfernen, der einer Abhängigkeits Änderung zugeordnet ist.</para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Die Daten für das Change-Ereignis. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Wird von abgeleiteten Klassen aufgerufen, um das Ereignis auszulösen, wenn sich eine Abhängigkeit ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> wird die-Methode aufgerufen, wenn Abhängigkeitsänderungen auftreten. Die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> -Methode wird auch aufgerufen, wenn eine Change-Monitor-Instanz verworfen wird, die Entsorgung aber nur dann erfolgt, wenn der Rückruf nicht bereits aufgerufen wurde.  
  
 Wenn die- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufgerufen wird, bevor die- <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode aufgerufen wird, werden die Zustandsdaten des Aufrufs der- <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode von der Cache Implementierung gespeichert. Außerdem wird der Rückruf für die- <xref:System.Runtime.Caching.OnChangedCallback> Methode sofort aufgerufen, wenn die- <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasseninstanz darstellt.</summary>
        <value>Der Bezeichner für eine Änderungsüberwachungsinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Eigenschafts Wert besteht in der Regel aus Abhängigkeits Namen kombinierte Zeichen folgen Daten, die die von einer-Instanz überwachten Daten eindeutig Bezeichner <xref:System.Runtime.Caching.ChangeMonitor> . Der Wert der <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Eigenschaft ist eine Zeichenfolge. Der Wert der Zeichenfolge wird verwendet, um die eindeutige ID der <xref:System.Runtime.Caching.ChangeMonitor> Instanz zuzuweisen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die-Eigenschaft überschreiben, können Sie eine benutzerdefinierte-Implementierung für den Zeichen folgen Wert der-Eigenschaft definieren, um ihr eine eindeutige ID zuzuweisen.</para></block>
        <block subset="none" type="overrides"><para>In abgeleiteten Klassen müssen Sie den Wert der-Eigenschaft im Konstruktor festlegen.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
