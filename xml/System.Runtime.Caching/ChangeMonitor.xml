<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata><Meta Name="ms.openlocfilehash" Value="3e6cd0ee8896ef1fe9194a66bf3f83cf2e148edc" /><Meta Name="ms.sourcegitcommit" Value="f9576bf8c61e3d46834aeeff50f858359f2a99ba" /><Meta Name="ms.translationtype" Value="MT" /><Meta Name="ms.contentlocale" Value="de-DE" /><Meta Name="ms.lasthandoff" Value="02/09/2020" /><Meta Name="ms.locfileid" Value="77102053" /></Metadata><TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Basisklasse für einen abgeleiteten benutzerdefinierten Typ bereit, der Wechsel in den Zustand der Daten überwacht, auf den ein Cacheelement angewiesen ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor>-Klasse wird als Basisklasse für abgeleitete Monitor Klassen verwendet, die auf bestimmte Cache Implementierungen spezialisiert sind. Eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz überwacht Änderungen des Zustands von Daten, von denen ein Cache Element abhängt. Beispielsweise kann es sich bei dem Element um eine Datei oder eine Daten Entität handeln, deren Inhalt zwischengespeichert wird. Wenn die Datei oder die Daten Entität aktualisiert wird, muss auch der zugehörige Cache Eintrag geändert werden. Zu den allgemeinen Elementen, die überwacht werden können, gehören Daten Entitäten (z. b. Datenbankfelder, Werte, Zeilen oder Tabellen), ein weiterer Cache Eintrag und Dateien und Dateiattribute.  
  
 Eine Abhängigkeits Änderung ist eine Änderung des Zustands einer Abhängigkeit. In einer typischen Cache Implementierung führt der Cache die erforderliche Aktion aus, wenn eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz den Cache darüber benachrichtigt, dass sich eine Abhängigkeit geändert hat, wie z. b. die ungülgigkeit des eingefügten Cache Eintrags.  
  
 Abgeleitete <xref:System.Runtime.Caching.ChangeMonitor> Klassen können angepasst werden, um Abhängigkeitsänderungen für bestimmte unterschiedliche Datenspeicher zu überwachen. Beispielsweise gibt es Cache Implementierungen für ein Dateisystem, physischen Arbeitsspeicher oder eine Datenbank. Die <xref:System.Runtime.Caching.ChangeMonitor>-Klasse untersucht Änderungen, die außerhalb des Caches erfolgen, und benachrichtigt dann den Cache, dass Änderungen aufgetreten sind.  
  
 Die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] umfasst die folgenden Klassen, die von <xref:System.Runtime.Caching.ChangeMonitor> Klasse abgeleitet werden:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Jede dieser Klassen funktioniert mit unterschiedlichen Abhängigkeits Typen. Beispielsweise überwacht die abgeleitete <xref:System.Runtime.Caching.FileChangeMonitor>-Klasse Änderungen an einem Cache für Dateisystem Daten (Dateien und Ordner), von denen das Cache Element abhängig ist.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides"><para>Wenn Sie eine benutzerdefinierte Cache Implementierung oder einen abgeleiteten Änderungs Monitortyp erstellen, müssen Sie bestimmte Richtlinien befolgen. In der folgenden Liste sind diese Richtlinien zusammengefasst. Weitere Informationen finden Sie in der Dokumentation zu einzelnen Methoden oder Eigenschaften.  
  
-Der Konstruktor einer abgeleiteten Klasse muss die <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />-Eigenschaft festlegen, die Überwachung starten und <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufzurufen, bevor die Methode zurückgibt. Wenn ein Konstruktor während der Konstruktion einen Fehler feststellt und Ressourcen verwerfen muss, kann der Konstruktor nur die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Überladung aufrufen, nachdem die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufgerufen wurde, da die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Überladung eine <see cref="T:System.InvalidOperationException" /> Ausnahme auslöst, wenn die Initialisierung nicht abgeschlossen wird.  
  
-Wenn in den Daten, die überwacht werden, Änderungen auftreten, bevor die Initialisierung beendet ist, muss der Konstruktor die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufrufen, bevor die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufgerufen wird.  
  
-Nachdem ein abgeleiteter <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Typ instanziiert wurde, müssen Sie den Monitor in eine benutzerdefinierte <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung einfügen. Wenn Sie den Änderungs Monitor noch nicht verwendet haben, können Sie die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode abrufen.  
  
-Nachdem eine <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz in eine <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung eingefügt wurde, muss die <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz den Änderungs Monitor verwerfen. Auch wenn die Einfügung ungültig ist und eine Ausnahme verursacht, muss die <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />-Überladung aufrufen.  
  
-Nachdem ein abgeleiteter Änderungs Monitor in einen Cache eingefügt wurde, muss die <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />aufrufen, indem ein <see cref="T:System.Runtime.Caching.OnChangedCallback" />-Objekt übergeben wird. Die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode kann nur einmal aufgerufen werden. Wenn bereits eine Abhängigkeits Änderung aufgetreten ist, wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz sofort aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz nur einmal aufgerufen. Dieser einmalige Aufruf tritt auf, wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufgerufen wird, weil die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz eine Änderung erkannt hat oder wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode auf dem <see cref="T:System.Runtime.Caching.ChangeMonitor" />aufgerufen wird, je nachdem, welcher Wert zuerst auftritt.  
  
-Die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz, die von einer <see cref="T:System.Runtime.Caching.ObjectCache" />-Implementierung bereitgestellt wird, sollte den zugehörigen Cache Eintrag entfernen und einen Grund angeben, indem die <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" />-Enumeration verwendet wird.  
  
-Eine <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz kann die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufrufen, bevor eine Cache Implementierung <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode oder nach aufgerufen hat. Wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufgerufen wird, bevor <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird, benachrichtigt die Basis <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Implementierung den Cache, dass diese aufgetreten ist, und löst den Rückruf aus, der sofort an <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> übermittelt wird, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Alle Zustandsdaten, die an die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode übermittelt werden, werden vom Änderungs Monitor gespeichert und anschließend an die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode übermittelt, wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode aufgerufen wird.  
  
-Ein Änderungs Monitor muss die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode implementieren. Weitere Informationen finden Sie in der Dokumentation zur <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode.  
  
-Die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methoden Überladung muss aufgerufen werden, um die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz zu verwerfen. Die Regeln zum Aufrufen von "verwerfen" lauten wie folgt: 
-Bevor ein Element in den Cache eingefügt wird, liegt es in der Verantwortung des Aufrufers, eine <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz zu verwerfen.  
  
-Sobald die Cache Elemente und die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanzen, die ihr zugeordnet sind, an einen Cache übermittelt werden, muss der cacheimplementierer sicherstellen, dass die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode aufgerufen wird, selbst wenn beim Einfügen ein Fehler auftritt.  
  
-Nachdem ein Element und die zugehörigen <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanzen an einen Cache übergeben wurden, darf der Aufrufer die Abhängigkeit nicht verwerfen, da der Aufruf beim Aufrufen der <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode so behandelt wird, als ob sich die Abhängigkeit geändert hat. Folglich wird die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode automatisch aufgerufen.  
  
Wenn diese Regeln berücksichtigt werden, muss die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode auf eine der folgenden Weisen aufgerufen werden: 
-Benutzer müssen die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methoden Überladung aufrufen, wenn Sie festlegen, dass die abgeleitete Change-Monitor-Instanz nicht in einen Cache eingefügt werden soll.  
  
Wenn die Implementierung versucht, die Change-Monitor-Instanz in einen Objekt Cache einzufügen, die Einfügung jedoch fehlschlägt, ist die Cache Implementierung für das Aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Überladung verantwortlich. Wenn beim Einfügeversuch eine Ausnahme ausgelöst wird, muss die Cache Implementierung alle zugeordneten Abhängigkeiten verwerfen.  
  
-Wenn der Cache Eintrag entfernt wird, muss die Cache Implementierung auch die Abhängigkeit verwerfen.  
  
-Die interne Implementierung der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode ruft automatisch die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode auf, nachdem Sie einen Rückruf aufgerufen hat, der über <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />registriert wird.  
  
 <block subset="none" type="note"><para>  
 Dieser automatische Rückruf der verwerfen-Methode während des auslösenden Ereignisses tritt nur auf, wenn die Initialisierung der <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz zuvor abgeschlossen wurde.  
  
</para></block>  
  
 Wenn der Konstruktor eines abgeleiteten Änderungs Monitors die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufruft und sich der Status des Änderungs Monitors bereits geändert hat (d. h., der Status, der überwacht wird, während der Konstruktor noch aktiv war), wird der Änderungs Monitor von der <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode automatisch verworfen.  
  
-Die <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />-Eigenschaft wird auf <see langword="true" /> festgelegt, nachdem die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode von der abgeleiteten Change-Monitor-Instanz aufgerufen wurde, unabhängig davon, ob ein <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Objekt durch einen Aufruf der <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode festgelegt wurde oder nicht.</para></block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://docs.microsoft.com/previous-versions/aspnet/xsbfdd8c(v=vs.100)">ASP.NET-Caching</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse. Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen aufgerufen, um die Basisklasse zu initialisieren.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor>-Klasse verfügt über einen Parameter losen Konstruktor. Klassen, die von der Basis <xref:System.Runtime.Caching.ChangeMonitor> Klasse erben und das benutzerdefinierte Verhalten der Änderungs Überwachung definieren, müssen jedoch im Konstruktor eine Initialisierung ausführen. Weitere Informationen finden Sie im Abschnitt Hinweise für Vererbung.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Der Konstruktor einer abgeleiteten Klasse muss die <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />-Eigenschaft festlegen, die Überwachung starten und die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Klasse vor der Rückgabe aufzurufen. Wenn sich eine Abhängigkeit ändert, bevor die Initialisierung beendet ist (z. b. Wenn ein abhängiger Cache Schlüssel nicht im Cache gefunden wurde), muss der Konstruktor die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufrufen, bevor die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufgerufen wird. In diesem Fall kann der Konstruktor die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode nur aufrufen, nachdem die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />-Methode aufgerufen wurde, da die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode eine Ausnahme auslöst, wenn die Initialisierung nicht abgeschlossen ist.</para></block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode wird verwendet, um die <xref:System.Runtime.Caching.ChangeMonitor> Instanz und zugehörige Ressourcen freizugeben. Die öffentliche <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode wird aufgerufen, um den Entsorgungsprozess mit Schlüssel Lebenszyklus-Ereignissen abgeleiteter Änderungs Monitor Klassen (z. b. der Initialisierung) zu koordinieren und die <xref:System.Runtime.Caching.ChangeMonitor> Instanz freizugeben, damit die Instanz in die Garbage Collection aufgenommen werden kann. Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode wird von abgeleiteten Change-Monitor-Klassen implementiert, um deren verwaltete und nicht verwaltete Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode ruft die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode der abgeleiteten Klassen nur einmal auf, wenn Sie zum ersten Mal aufgerufen wird. Nachfolgende Aufrufe der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode haben keine Auswirkung. Nachdem die-Methode aufgerufen wurde, wird die <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A>-Eigenschaft auf `true`festgelegt.  
  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Überladung muss aufgerufen werden, um eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz zu verwerfen. Im folgenden sind die Regeln zum Aufrufen der verwerfen-Methode aufgeführt:  
  
-   Bevor ein Element in den Cache eingefügt wird, liegt es in der Verantwortung des Aufrufers, eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz zu verwerfen.  
  
-   Sobald das Cache Element und die <xref:System.Runtime.Caching.ChangeMonitor> Instanzen, die ihm zugeordnet sind, an einen Cache weitergeleitet werden, muss der cacheimplementierer sicherstellen, dass <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> aufgerufen wird, auch wenn die Einfügung fehlschlägt.  
  
-   Nachdem ein Element und die zugehörigen <xref:System.Runtime.Caching.ChangeMonitor> Instanzen an einen Cache übergeben wurden, darf der Aufrufer die Abhängigkeit nicht verwerfen, da der Aufruf beim Aufrufen der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode so behandelt wird, als ob sich die Abhängigkeit geändert hat. Folglich wird die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode automatisch aufgerufen.  
  
-   Wenn diese Regeln berücksichtigt werden, muss die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode auf eine der folgenden Arten aufgerufen werden:  
  
    -   Benutzer müssen die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methoden Überladung aufrufen, wenn Sie festlegen, dass die abgeleitete Change-Monitor-Instanz nicht in einen Cache eingefügt werden soll.  
  
    -   Die Cache Implementierung ist für das Aufrufen der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Überladung zuständig, wenn die Implementierung versucht, die Change-Monitor-Instanz in einen Objekt Cache einzufügen, aber die Einfügung schlägt fehl. Wenn der Einfügeversuch eine Ausnahme verursacht, muss die Cache Implementierung alle zugeordneten Abhängigkeiten verwerfen.  
  
    -   Wenn der Cache Eintrag entfernt wird, muss die Cache Implementierung auch die Abhängigkeit verwerfen.  
  
 Die interne Implementierung der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode ruft automatisch die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode auf, nachdem Sie einen Rückruf aufgerufen hat, der über die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode registriert wird.  
  
> [!NOTE]
>  Diese automatische Löschung während der Ereignis Auslösung tritt nur dann auf, wenn die Initialisierung der <xref:System.Runtime.Caching.ChangeMonitor> Instanz zuvor abgeschlossen wurde.  
  
 Wenn der Konstruktor eines abgeleiteten Änderungs Monitors die <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>-Methode aufruft und sich der Status des Änderungs Monitors bereits geändert hat (d. h., der Status, der überwacht wird, wenn der Konstruktor noch aktiv war), wird der Änderungs Monitor von <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> Methode automatisch verworfen.  
  
> [!NOTE]
>  Benutzer sollten die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode nicht aufzurufen. Sie können jedoch nicht verhindern, dass Benutzer die-Methode aufrufen. Wenn dies der Fall ist, wird die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode aufgerufen. In diesem Fall wird der Cache Eintrag benachrichtigt, als ob sich die Abhängigkeit geändert hat.  
  
 Um zu verhindern, dass abgeleitete Klassen <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode überschreiben, ist die-Methode keine explizite Schnittstellen Implementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Initialisierung ist in der abgeleiteten Änderungsüberwachungsklasse nicht vollständig, die die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Basismethode aufrief.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing"><see langword="true" />, um verwaltete und nicht verwaltete Ressourcen sowie Verweise auf eine <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz freizugeben, <see langword="false" />, um nur nicht verwaltete Ressourcen freizugeben. Wenn <see langword="false" /> übergeben wird, wird die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode von einem <see langword="finalizer" />-Thread aufgerufen, und alle externen verwalteten Verweise sind wahrscheinlich nicht mehr gültig, da sie bereits von der Garbage Collection freigegeben wurden.</param>
        <summary>Gibt alle verwalteten und nicht verwalteten Ressourcen und alle Verweise auf die <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz frei. Diese Überladung muss von abgeleiteten Änderungsüberwachungsklassen implementiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert `disposing` Werts `true`ist, werden alle verwalteten und nicht verwalteten Ressourcen verworfen, und alle Verweise auf dieses Objekt werden freigegeben, sodass die abgeleitete Change-Monitor-Instanz in die Garbage Collection aufgenommen werden kann. Es ist sichergestellt, dass die Basis <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode die implementierte <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode nur einmal aufruft.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Ein Änderungs Monitor muss die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Überladung implementieren, um alle verwalteten und nicht verwalteten Ressourcen freizugeben, wenn der Wert <paramref name="disposing" /> <see langword="true" />ist. Die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methoden Überladung, die den <paramref name="disposing" /> Wert <see langword="true" /> hat, wird nur einmal aufgerufen, d. h., wenn die Instanz zum ersten Mal verworfen wird. Ein Änderungs Monitor darf die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Überladung nicht direkt aufrufen. Ein abgeleiteter Änderungs Monitor kann die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode "Public" ohne Parameter für die Basis <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasse aufrufen.  
  
Alternativ kann ein Änderungs Monitor eine Finalizer-Methode implementieren. In diesem Fall kann der Finalizer die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode aufrufen und ihm einen <paramref name="disposing" /> Wert von <see langword="false" />übergeben. Dies ist jedoch in der Regel unnötig. Die Überwachung von Abhängigkeitsänderungen erfolgt in der Regel von einem Dienst, der einen Verweis auf die Change-Monitor-Instanz verwaltet. Durch den Verweis wird verhindert, dass die Instanz in die Garbage Collection aufgenommen wird. Daher ist eine Finalizer-Methode unnötig. Um Speicher Verluste zu vermeiden, wird bei einer Änderung der Abhängigkeit durch die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode die Change-Monitor-Instanz gelöscht (es sei denn, die Initialisierung wurde nicht abgeschlossen).</para></block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass der von der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse überwachte Zustand geändert wurde.</summary>
        <value><see langword="true" />, wenn der von der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Instanz überwachte Zustand geändert wurde, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können den Wert dieser Eigenschaft in einer abgeleiteten <xref:System.Runtime.Caching.ChangeMonitor> Klasse überprüfen, um festzustellen, ob sich eine Abhängigkeit geändert hat.  
  
 Der Wert wird auf `true` festgelegt, wenn eine Abhängigkeits Änderung auftritt (d. h., wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode aufgerufen wird). Nachdem die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode von der abgeleiteten Klasse aufgerufen wurde, wird der Wert der <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>-Eigenschaft `true`, unabhängig davon, ob eine <xref:System.Runtime.Caching.OnChangedCallback> Instanz durch einen Aufruf der <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode benachrichtigt wurde.  
  
> [!NOTE]
>  Aufrufer können die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft überprüfen, um festzustellen, ob sich eine Abhängigkeit geändert hat In einer Multithread-Umgebung ist es jedoch einfacher und besser verwaltbar, Daten in eine Cache Implementierung einzufügen, ohne die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>-Eigenschaft zu überprüfen. Cache Implementierungen müssen die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>-Eigenschaft für Sie überprüfen und dürfen keinen INSERT-oder Set-Vorgang ausführen, wenn mindestens eine zugehörige Abhängigkeit bereits geändert wurde.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird vom Konstruktor abgeleiteter Klassen aufgerufen, um anzugeben, dass die Initialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Abhängigkeit geändert wird, bevor die Initialisierung in einer abgeleiteten Klasse ausgeführt wird, muss der Konstruktor der abgeleiteten Klasse die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode aufrufen.  
  
 Wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode aufgerufen wird, wird die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>-Eigenschaft automatisch auf `true` durch den Änderungs Monitor festgelegt. Dies hat zur Folge, dass die Basisklasse automatisch die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode aufruft, wenn der Konstruktor des Änderungs Monitors die <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A>-Methode aufruft. Wenn die Initialisierung beendet ist, wird die abgeleitete Change-Monitor-Instanz automatisch von der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode gelöscht.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Der Konstruktor einer abgeleiteten Klasse muss die Basis <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode vor der Rückgabe des Konstruktors aufzurufen. Der Konstruktor einer abgeleiteten Klasse kann die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode erst aufrufen, nachdem <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> aufgerufen wurde, da die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode eine Ausnahme auslöst, wenn die Initialisierung nicht abgeschlossen ist.</para></block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, dass die abgeleitete Instanz einer <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse freigegeben wird.</summary>
        <value><see langword="true" />, wenn die Instanz freigegeben wird, andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die-Eigenschaft wird auf `true` festgelegt, nachdem die Basis <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A>-Methode in einer abgeleiteten Klasse aufgerufen hat, um die Instanz zu verwerfen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Ein Verweis auf eine Methode, die aufgerufen wird, wenn eine Abhängigkeit geändert wurde.</param>
        <summary>Wird von Cacheimplementierungen aufgerufen, um einen Rückruf zu registrieren und über den <see cref="T:System.Runtime.Caching.ObjectCache" />-Delegaten eine <see cref="T:System.Runtime.Caching.OnChangedCallback" />-Instanz zu benachrichtigen, wenn sich eine Abhängigkeit geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cacheimplementierer verwenden diese Methode, um sich mit einem Änderungs Monitor zu verknüpfen. Wenn Sie dem Cache Element mindestens einen Änderungs Monitor zuordnen, übergeben Sie dem Cache Element eine <xref:System.Runtime.Caching.CacheItemPolicy> Instanz mit der Eigenschaft "geänderte Änderungs Monitore". Ein cacheimplementierer, der Änderungs Monitore unterstützt, ist dafür verantwortlich, die <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A>-Eigenschaft zu durchlaufen und die <xref:System.Runtime.Caching.OnChangedCallback> Delegaten bei jedem gefundenen Änderungs Monitor zu registrieren.  
  
 Da der <xref:System.Runtime.Caching.OnChangedCallback> Delegat einen optionalen State-Parameter enthält, kann eine konkrete Änderungs Monitor Implementierung optionale Zustandsinformationen übergeben. Der cacheimplementierer bestimmt, ob eine explizite Abhängigkeit vom Typ des Zustands, den ein benutzerdefinierter Änderungs Monitor als Teil des Rückrufs übergibt, angenommen werden kann.  
  
> [!NOTE]
>  Die Basis Cache-Erweiterbarkeits-API erfordert keine explizite Abhängigkeit vom Typ des Zustands.  
  
 Die Implementierung der <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode bestimmt automatisch, ob sich der Status des Monitors bereits geändert hat, wenn <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode aufgerufen wird. Wenn die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A>-Eigenschaft `true`ist, ruft die Methode automatisch den <xref:System.Runtime.Caching.OnChangedCallback> Ereignishandler auf, der durch die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode registriert wurde. Dies liegt daran, dass es möglich ist, dass ab dem Zeitpunkt, zu dem eine Cache Implementierung einen Änderungs Monitor erstellt, bis zu dem Zeitpunkt, zu dem eine Cache Implementierung den Monitor abruft und sich damit verbindet, der zugrunde liegende überwachte Zustand geändert wurde. Wenn sich der Zustand bereits geändert hat, wird das an die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode weiter gegebene Objekt `null`.  
  
 Die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode kann nur einmal aufgerufen werden und löst bei nachfolgenden Aufrufen eine Ausnahme aus.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Rückrufmethode wurde bereits aufgerufen.</exception>
        <exception cref="T:System.ArgumentNullException"><paramref name="onChangedCallback" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides"><para>1. Sie müssen die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />-Methode aufgerufen werden, um über Änderungen an Abhängigkeiten benachrichtigt zu werden. Wenn bereits eine Abhängigkeits Änderung aufgetreten ist, wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls wird die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz einmal aufgerufen, entweder wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />-Methode aufgerufen wird oder wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" />-Methode aufgerufen wird, je nachdem, welcher Wert zuerst auftritt. Die von der Cache Implementierung bereitgestellte <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz sollte den Cache Eintrag entfernen. Wenn Sie vom Cache Aufrufer angefordert wird, müssen Sie das erforderliche Änderungs-oder Update Ereignis zurück an den ursprünglichen Cache Aufrufer machen.  
  
2.  Die Objekt Cache Implementierung muss den Cache Eintrag entfernen, der einer Abhängigkeits Änderung zugeordnet ist.</para></block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Die Daten für das Change-Ereignis. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Wird von abgeleiteten Klassen aufgerufen, um das Ereignis auszulösen, wenn sich eine Abhängigkeit ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel wird die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode aufgerufen, wenn Abhängigkeitsänderungen auftreten. Die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode wird auch aufgerufen, wenn eine Change-Monitor-Instanz verworfen wird, die Entsorgung jedoch nur dann erfolgt, wenn der Rückruf nicht bereits aufgerufen wurde.  
  
 Wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode aufgerufen wird, bevor die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode aufgerufen wird, werden die Zustandsdaten des Aufrufs der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A>-Methode von der Cache Implementierung gespeichert. Außerdem wird der Rückruf für die <xref:System.Runtime.Caching.OnChangedCallback>-Methode sofort aufgerufen, wenn die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A>-Methode aufgerufen wird.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der die <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasseninstanz darstellt.</summary>
        <value>Der Bezeichner für eine Änderungsüberwachungsinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Der <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A>-Eigenschafts Wert besteht in der Regel aus Abhängigkeits Namen zusammengefasste Zeichen folgen Daten, die die Daten eindeutig Bezeichner, die von einer <xref:System.Runtime.Caching.ChangeMonitor> Instanz überwacht werden. Der Wert der <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A>-Eigenschaft ist eine Zeichenfolge. Der Wert der Zeichenfolge wird verwendet, um die eindeutige ID der <xref:System.Runtime.Caching.ChangeMonitor> Instanz zuzuweisen.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides"><para>Wenn Sie die-Eigenschaft überschreiben, können Sie eine benutzerdefinierte-Implementierung für den Zeichen folgen Wert der-Eigenschaft definieren, um ihr eine eindeutige ID zuzuweisen.</para></block>
        <block subset="none" type="overrides"><para>In abgeleiteten Klassen müssen Sie den Wert der-Eigenschaft im Konstruktor festlegen.</para></block>
      </Docs>
    </Member>
  </Members>
</Type>
