<Type Name="ChangeMonitor" FullName="System.Runtime.Caching.ChangeMonitor">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="73cd7d26a8035ac771856adae7eedfbd2609c7c2" />
    <Meta Name="ms.sourcegitcommit" Value="1654a92bac785a221098172d9cacd405ceaac9b7" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="12/01/2018" />
    <Meta Name="ms.locfileid" Value="52737441" />
  </Metadata>
  <TypeSignature Language="C#" Value="public abstract class ChangeMonitor : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi abstract beforefieldinit ChangeMonitor extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Runtime.Caching.ChangeMonitor" />
  <TypeSignature Language="VB.NET" Value="Public MustInherit Class ChangeMonitor&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class ChangeMonitor abstract : IDisposable" />
  <TypeSignature Language="F#" Value="type ChangeMonitor = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Runtime.Caching</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Stellt eine Basisklasse für einen abgeleiteten benutzerdefinierten Typ, der Änderungen in den Zustand der Daten überwacht, auf den ein Cacheelement angewiesen ist.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor> Klasse dient als Basisklasse für abgeleitete Monitor-Klassen, die für bestimmte Cache-Implementierungen spezialisiert werden. Ein <xref:System.Runtime.Caching.ChangeMonitor> Instanz überwacht Änderungen in den Zustand der Daten, die ein Element im Cache abhängig. Beispielsweise kann für das Element eine Datei oder der Entität sein, deren Inhalt zwischengespeichert werden. Wenn die Datei oder eine Entität aktualisiert wird, muss auch der zugeordnete Cacheeintrag geändert werden. Allgemeine Elemente, die überwacht werden können, enthalten Datenentitäten (z. B. Datenbankfelder, Werte, Zeilen oder Tabellen), ein anderer Cacheeintrag, und Dateien und Attribute der Datei.  
  
 Eine Änderung der Abhängigkeit ist eine Änderung in den Zustand einer Abhängigkeit. In einer typischen Cacheimplementierung nachdem eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz benachrichtigt den Cache, der eine Abhängigkeit geändert hat, die vom Cache durchgeführt, der die erforderlichen Aktion, z. B. den eingefügten Cacheeintrag für ungültig zu erklären.  
  
 Abgeleitete <xref:System.Runtime.Caching.ChangeMonitor> Klassen können zum Überwachen von Änderungen an der Abhängigkeit für spezifische andere Datenspeicher angepasst werden. Es gibt z. B. cacheimplementierungen für ein Dateisystem, physischen Speicher oder einer Datenbank. Die <xref:System.Runtime.Caching.ChangeMonitor> Klasse überprüft die Änderungen, die außerhalb des Caches auf, und klicken Sie dann gewarnt, Cache, der Änderungen vorgenommen wurden.  
  
 Die [!INCLUDE[dnprdnshort](~/includes/dnprdnshort-md.md)] beinhaltet die folgenden Klassen, die von abgeleitet <xref:System.Runtime.Caching.ChangeMonitor> Klasse:  
  
-   <xref:System.Runtime.Caching.CacheEntryChangeMonitor>  
  
-   <xref:System.Runtime.Caching.FileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.HostFileChangeMonitor>  
  
-   <xref:System.Runtime.Caching.SqlChangeMonitor>  
  
 Jede dieser Klassen funktioniert mit verschiedenen Typen von Abhängigkeiten. Z. B. die abgeleiteten <xref:System.Runtime.Caching.FileChangeMonitor> Klasse überwacht die Änderungen an einen Cache für die Dateisystemdaten (Dateien und Ordner), von denen das Element im Cache abhängig.  
  
 ]]></format>
    </remarks>
    <threadsafe>Dieser Typ ist threadsicher.</threadsafe>
    <block subset="none" type="overrides">
      <para>Bei der Erstellung einer benutzerdefiniertes Cacheimplementierung oder abgeleiteten Typs überwachen Änderung müssen Sie bestimmte Richtlinien beachtet. Die folgende Liste enthält die folgenden Richtlinien. Weitere Informationen finden Sie in der Dokumentation für die einzelnen Methoden oder Eigenschaften.  
  
– Der Konstruktor einer abgeleiteten Klasse muss festgelegt die <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> -Eigenschaft, mit der Überwachung beginnen, und rufen <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> -Methode auf, bevor die Methode zurückgibt. Wenn ein Konstruktor ein Fehler, während der Konstruktionen auftritt und aufweisen muss, um Ressourcen zu entfernen, wird der Konstruktor kann nur Aufrufen der <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> überladen werden, nachdem die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode wird aufgerufen, da die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Überladung löst eine <see cref="T:System.InvalidOperationException" /> Ausnahme, wenn die Initialisierung nicht abgeschlossen ist.  
  
– Wenn es sich bei Auftreten von Änderungen in die Daten, die überwacht werden, bevor die Initialisierung abgeschlossen, muss beim Aufruf des Konstruktors der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode vor dem Aufruf der <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode.  
  
– Hinter einem abgeleiteten <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Typ instanziiert wird, müssen Sie den Monitor einfügen, in ein benutzerdefiniertes <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung. Oder wenn Sie mit dem Monitor für die Änderung abgeschlossen haben, rufen Sie die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode.  
  
– Nach dem ein <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz eingelegt ist eine <see cref="T:System.Runtime.Caching.ObjectCache" /> -Implementierung der <see cref="T:System.Runtime.Caching.ObjectCache" /> Instanz erforderlich, dass die änderungsüberwachung freigegeben wird. Auch wenn die Einfügemarke ungültig ist und bewirkt, dass eine Ausnahme aus, die <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung aufrufen, muss die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> überladen.  
  
: Nachdem Sie eine abgeleitete änderungsüberwachung in einem Cache eingefügt wird die <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung aufrufen muss <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />, durch Übergeben einer <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Objekt. Die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode kann nur einmal aufgerufen werden. Wenn eine Änderung der Abhängigkeit bereits aufgetreten ist, die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz wird sofort aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz wird nur einmal aufgerufen werden. Diesmal ein Aufruf wird entweder bei der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode wird aufgerufen, da die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> eine Änderung erkannt oder wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode wird aufgerufen, auf die <see cref="T:System.Runtime.Caching.ChangeMonitor" />, welches Ereignis zuerst eintritt.  
  
– Die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> -Instanz, die vom bereitgestellten ein <see cref="T:System.Runtime.Caching.ObjectCache" /> Implementierung sollten entfernen Sie den zugehörigen Cache-Eintrag, und geben Sie einen Grund, indem die <see cref="F:System.Web.Caching.CacheItemRemovedReason.DependencyChanged" /> Enumeration.  
  
-Ein <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz Aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode entweder bevor eine Cacheimplementierung aufgerufen hat <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode oder nach. Wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode wird aufgerufen, bevor <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird, wird die Basis <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Implementierung benachrichtigt den Cache, der dieses Problem aufgetreten ist, und löst den Rückruf übergeben werden soll <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> direkt beim <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Zustandsdaten, die an die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode durch die änderungsüberwachung gespeichert und später übergeben die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode bei der <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> -Methode wird aufgerufen.  
  
-Eine änderungsüberwachung muss implementieren die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Methode. Weitere Informationen finden Sie in der Dokumentation zur <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />-Methode.  
  
– Die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Überladung aufgerufen werden, um das Löschen der <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz. Die Regeln zum Aufrufen von Dispose sind wie folgt aus: 
– Bevor Sie ein Element in den Cache eingefügt wird, ist es die Verantwortung des Aufrufers, Verwerfen einer <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz.  
  
– Nachdem Element im Cache und die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> auf einen Cache-Instanzen, die ihm zugeordneten übergeben werden, die Cache-Implementierung muss sicherstellen, dass, die die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> -Methode aufgerufen wird, selbst wenn der Vorgang schlägt fehl.  
  
– Nach einem Element und die zugehörigen <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanzen werden mit einem Cache übergeben, die der Aufrufer muss die Abhängigkeit nicht freigeben, da bei der <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> -Methode aufgerufen wird, der Aufruf wird behandelt, als ob die Abhängigkeit geändert hat. Daher die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode wird automatisch aufgerufen.  
  
– Unter Berücksichtigung dieser Regeln, die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> muss in einem der folgenden Methoden aufgerufen werden: 
– Benutzer müssen aufrufen, die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> -methodenüberladung, wenn sie nicht der abgeleiteten Änderungsüberwachungsinstanz in einem Cache einfügen möchten.  
  
– Wenn versucht wird, dass die Implementierung der Änderungsüberwachungsinstanz in den Objektcache ein einzufügen, aber der einfügen ein Fehler auftritt, wird der Cache-Implementierung verantwortlich für das Aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> überladen. Wenn der Versuch der Einfügung eine Ausnahme verursacht hat, muss die Cacheimplementierung alle zugehörigen Abhängigkeiten freigeben.  
  
– Wenn der Cacheeintrag entfernt wird, muss die Cacheimplementierung die Abhängigkeit auch freigeben.  
  
: Die interne Implementierung der der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methodenaufrufe automatisch die <see cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" /> -Methode auf, nachdem sie einen Rückruf aufruft, ist über registriert <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />.  
  
 <block subset="none" type="note"><para>  
 Dieser automatischen Aufruf der Dispose-Methode, bei der das Auslösen von Ereignissen tritt nur auf, wenn die Initialisierung der <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz wurde bereits abgeschlossen.  
  
</para></block>  
  
 Wenn eine abgeleitete änderungsüberwachung-Konstruktor aufruft der <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> -Methode, wenn der Zustand des Monitors Änderung bereits geändert hat (d. h. der Zustand, der bereits Änderungen überwacht wird, wenn der Konstruktor noch aktiv ist) und dann die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> wird Löschen Sie automatisch die änderungsüberwachung.  
  
– Die <see cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" /> -Eigenschaftensatz auf <see langword="true" /> nach der <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode wird aufgerufen, durch die abgeleiteten Änderungsüberwachungsinstanz, unabhängig davon, ob eine <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Objekt festgelegt wurde durch einen Aufruf von der <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode oder nicht.</para>
    </block>
    <altmember cref="N:System.Web.Caching" />
    <altmember cref="T:System.Runtime.Caching.ObjectCache" />
    <related type="Article" href="https://msdn.microsoft.com/library/ac11c8ea-df5d-4de8-b315-9ccf1048b0ce">Zwischenspeicherung in ASP.NET</related>
  </Docs>
  <Members>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="protected ChangeMonitor ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig specialname rtspecialname instance void .ctor() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.#ctor" />
      <MemberSignature Language="VB.NET" Value="Protected Sub New ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; ChangeMonitor();" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters />
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse. Dieser Konstruktor wird von Konstruktoren in abgeleiteten Klassen, die die Basisklasse initialisieren aufgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor> -Klasse verfügt über einen Standardkonstruktor. Jedoch Klassen, die von der Basisklasse erben <xref:System.Runtime.Caching.ChangeMonitor> Klasse und definieren Sie benutzerdefinierte änderungsüberwachung Verhalten durchzuführenden Initialisierung im Konstruktor. Weitere Informationen finden Sie unter dem Abschnitt Hinweise für Vererber.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Muss der Konstruktor einer abgeleiteten Klasse festgelegt. die <see cref="P:System.Runtime.Caching.ChangeMonitor.UniqueId" /> -Eigenschaft, mit der Überwachung beginnen, und rufen die <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> -Klasse vor dem zurückgeben. Wenn eine Abhängigkeit ändert vor der Initialisierung ist abgeschlossen (z. B. wenn ein abhängiger Cacheschlüssel nicht im Cache gefunden wird), den Konstruktor aufrufen muss die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode vor dem Aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> Methode. In diesem Fall kann Konstruktor aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode erst nach der <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> -Methode aufgerufen wird, da die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode löst eine Ausnahme aus, wenn die Initialisierung nicht abgeschlossen ist.</para>
        </block>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode wird verwendet, um die Version der <xref:System.Runtime.Caching.ChangeMonitor> -Instanz und die zugehörigen Ressourcen. Die öffentliche <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode wird aufgerufen, um den Freigabeprozess mit Schlüssel Lebenszyklusereignisse von abgeleiteten Änderungsüberwachungsklassen (z. B. Initialisierung) zu koordinieren und Freigeben der <xref:System.Runtime.Caching.ChangeMonitor> Instanz, sodass die Instanz die Garbage Collection durchgeführt werden kann. Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode wird implementiert von abgeleiteten Änderungsüberwachungsklassen ihre verwalteten und nicht verwalteten Ressourcen freizugeben.  
  
 ]]></format>
        </remarks>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="changeMonitor.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle von der aktuellen Instanz der <see cref="T:System.Runtime.Caching.ChangeMonitor" />-Klasse verwendeten Ressourcen frei.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode ruft die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode der abgeleiteten Klassen nur einmal beim ersten Aufruf ist. Nachfolgende Aufrufe der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode haben keine Auswirkungen. Nachdem die Methode aufgerufen wurde, die <xref:System.Runtime.Caching.ChangeMonitor.IsDisposed%2A> -Eigenschaftensatz auf `true`.  
  
 Die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Überladung aufgerufen werden, um das Löschen einer <xref:System.Runtime.Caching.ChangeMonitor> Instanz. Im folgenden finden die Regeln zum Aufrufen der Dispose-Methode:  
  
-   Bevor ein Element in den Cache eingefügt wird, ist es der Verantwortung des Aufrufers, Verwerfen einer <xref:System.Runtime.Caching.ChangeMonitor> Instanz.  
  
-   Nach Element im Cache und die <xref:System.Runtime.Caching.ChangeMonitor> -Instanzen, die ihm zugeordneten übergeben werden, auf einen Cache, der Cache-Implementierung, die sicherstellen muss, dass <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> aufgerufen wird, selbst wenn der Vorgang schlägt fehl.  
  
-   Nach einem Element und die zugehörigen <xref:System.Runtime.Caching.ChangeMonitor> Instanzen werden mit einem Cache übergeben, die der Aufrufer muss die Abhängigkeit nicht freigeben, da bei der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode aufgerufen wird, der Aufruf wird behandelt, als ob die Abhängigkeit geändert hat. Daher die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird automatisch aufgerufen.  
  
-   Diese Regeln zu berücksichtigen, dass die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> muss in einem der folgenden Methoden aufgerufen werden:  
  
    -   Benutzer müssen aufrufen, die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -methodenüberladung, wenn sie nicht der abgeleiteten Änderungsüberwachungsinstanz in einem Cache einfügen möchten.  
  
    -   Die Cacheimplementierung ist verantwortlich für das Aufrufen der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Überladung, wenn versucht wird, dass die Implementierung der Änderungsüberwachungsinstanz in den Objektcache ein einzufügen, jedoch schlägt der Vorgang fehl. Wenn der Versuch der Einfügung eine Ausnahme verursacht hat, muss die Cacheimplementierung alle zugehörigen Abhängigkeiten freigeben.  
  
    -   Wenn der Cacheeintrag entfernt wird, muss die Abhängigkeit von der Cacheimplementierung auch freigeben.  
  
 Die interne Implementierung der der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methodenaufrufe automatisch die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode auf, nachdem sie einen Rückruf aufruft, ist über registriert der <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode.  
  
> [!NOTE]
>  Diese automatische Dispose bei den Auslösen von Ereignissen tritt nur auf, wenn die Initialisierung der <xref:System.Runtime.Caching.ChangeMonitor> Instanz bereits abgeschlossen.  
  
 Wenn eine abgeleitete änderungsüberwachung Konstruktor ruft die <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> -Methode, wenn der Zustand des Monitors Änderung bereits geändert hat (d. h. der Zustand, der überwacht wird bereits geändert, wenn der Konstruktor noch aktiv ist) klicken Sie dann <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> wird Löschen Sie automatisch die änderungsüberwachung.  
  
> [!NOTE]
>  Benutzer dürfen nicht aufrufen. die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode. Sie können keine jedoch verhindern, dass Benutzer Aufrufen der Methode. Aus diesem Grund, falls dies der Fall, die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> -Methode wird aufgerufen. In diesem Fall wird der Cacheeintrag benachrichtigt, als ob die Abhängigkeit geändert hat.  
  
 Um zu verhindern, dass abgeleitete Klassen überschreiben <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode, die Methode ist es sich nicht um eine explizite schnittstellenimplementierung.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Initialisierung ist nicht vollständig in der abgeleiteten Änderungsüberwachungsklasse, die die Basis bezeichnet <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode.</exception>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected abstract void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected MustOverride Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; abstract void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit" Usage="changeMonitor.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" /> Freigeben von verwalteten und nicht verwalteten Ressourcen und alle Verweise auf eine <see cref="T:System.Runtime.Caching.ChangeMonitor" /> -Instanz <see langword="false" /> um ausschließlich nicht verwaltete Ressourcen freizugeben. Wenn <see langword="false" /> übergeben wird, wird die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Methode wird aufgerufen, indem eine <see langword="finalizer" /> Thread und alle externen verwalteten Verweise sind wahrscheinlich nicht mehr gültig, da sie bereits über die Garbage Collection bereinigt wurden.</param>
        <summary>Gibt alle verwalteten und nicht verwalteten Ressourcen und alle Verweise auf die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz. Diese Überladung muss von abgeleiteten Änderungsüberwachungsklassen implementiert werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn der Wert des `disposing` Wert `true`, alle verwaltete und nicht verwaltete Ressourcen freigegeben, und alle Verweise auf dieses Objekt werden freigegeben, sodass die abgeleiteten Änderungsüberwachungsinstanz Garbage Collection bereinigt werden kann. Es ist sichergestellt, dass die Basis <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode ruft die implementierte <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode nur einmal.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Eine änderungsüberwachung implementieren muss die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> -Überladung verwenden, um alle freigeben verwaltet und nicht verwaltete Ressourcen bei der der Wert des <paramref name="disposing" /> ist <see langword="true" />. Die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> methodenüberladung mit einem <paramref name="disposing" /> Wert <see langword="true" /> wird aufgerufen, nur einmal, d. h., wenn die Instanz zum ersten Mal freigegeben wird. Rufen Sie eine änderungsüberwachung muss nicht die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> direkt überladen werden. Eine abgeleitete änderungsüberwachung kann den öffentlichen parameterlosen Aufrufen <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode auf der Basis <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasse.  
  
Alternativ kann eine änderungsüberwachung eine Finalizer-Methode implementieren. In diesem Fall kann der Finalizer Aufrufen der <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose(System.Boolean)" /> Methode und übergeben sie einen <paramref name="disposing" /> Wert <see langword="false" />. Dies ist jedoch normalerweise nicht erforderlich. Überwachung für Änderungen an der Abhängigkeit erfolgt in der Regel von einem Dienst, der einen Verweis auf die Änderungsüberwachungsinstanz verwaltet. Der Verweis wird verhindert, dass die Instanz von der Garbage Collection und aus diesem Grund stellt eine Finalizer-Methode nicht erforderlich. Um Speicherverluste zu vermeiden, wenn eine Abhängigkeit geändert wird, die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode entfernt die Änderungsüberwachungsinstanz (es sei denn, die Initialisierung nicht abgeschlossen wurde).</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="HasChanged">
      <MemberSignature Language="C#" Value="public bool HasChanged { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool HasChanged" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property HasChanged As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool HasChanged { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.HasChanged : bool" Usage="System.Runtime.Caching.ChangeMonitor.HasChanged" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, das den Zustand, der von überwacht wird, die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasse hat sich geändert.</summary>
        <value>
          <see langword="true" /> Wenn der Zustand, der von überwacht wird, die <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Instanz geändert wurde; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sehen Sie den Wert dieser Eigenschaft in einer abgeleiteten <xref:System.Runtime.Caching.ChangeMonitor> Klasse, um festzustellen, ob eine Abhängigkeit geändert hat.  
  
 Der Wert wird festgelegt, um `true` Wenn eine Abhängigkeit geändert wird (das heißt, wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird aufgerufen). Nach der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird aufgerufen, von der abgeleiteten Klasse den Wert des der <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft `true`, unabhängig davon, ob eine <xref:System.Runtime.Caching.OnChangedCallback> Instanz wurde durch einen Aufruf von benachrichtigt die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode.  
  
> [!NOTE]
>  Aufrufer können überprüfen, die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft, um festzustellen, ob eine Abhängigkeit geändert hat. In einer Umgebung mit mehreren Threads ein einfacherer und mehr verwaltbaren Ansatz ist jedoch zum Einfügen von Daten in einem Cache-Implementierung ohne Überprüfung der <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft. Cache-Implementierungen müssen überprüfen, die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> -Eigenschaft für Sie und dürfen keine führen eine Einfügung oder set-Vorgang, wenn eine oder mehrere zugeordnete Abhängigkeiten bereits geändert haben.  
  
 ]]></format>
        </remarks>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="InitializationComplete">
      <MemberSignature Language="C#" Value="protected void InitializationComplete ();" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void InitializationComplete() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" />
      <MemberSignature Language="VB.NET" Value="Protected Sub InitializationComplete ()" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void InitializationComplete();" />
      <MemberSignature Language="F#" Value="member this.InitializationComplete : unit -&gt; unit" Usage="changeMonitor.InitializationComplete " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Wird aufgerufen, aus dem Konstruktor der abgeleiteten Klassen, um anzugeben, dass die Initialisierung abgeschlossen ist.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Wenn eine Abhängigkeit ändert, bevor die Initialisierung abgeschlossen ist, in einer abgeleiteten Klasse ist, rufen der Konstruktor der abgeleiteten Klasse die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode.  
  
 Wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird aufgerufen, die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> Eigenschaft wird automatisch festgelegt, um `true` durch die änderungsüberwachung. Wenn daher die änderungsüberwachung-Konstruktor ruft die <xref:System.Runtime.Caching.ChangeMonitor.InitializationComplete%2A> -Methode der Basisklasse wird automatisch aufgerufen. die <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methode. Wenn die Initialisierung abgeschlossen ist, wird die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> -Methode verwirft automatisch die abgeleiteten Änderungsüberwachungsinstanz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Rufen Sie der Konstruktor einer abgeleiteten Klasse muss die grundlegende <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> -Methode auf, bevor Sie den Konstruktor zurück. Der Konstruktor einer abgeleiteten Klasse aufrufen, kann die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode erst nach <see cref="M:System.Runtime.Caching.ChangeMonitor.InitializationComplete" /> aufgerufen wurde, da die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> Methode löst eine Ausnahme aus, wenn die Initialisierung nicht abgeschlossen ist.</para>
        </block>
      </Docs>
    </Member>
    <Member MemberName="IsDisposed">
      <MemberSignature Language="C#" Value="public bool IsDisposed { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance bool IsDisposed" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property IsDisposed As Boolean" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property bool IsDisposed { bool get(); };" />
      <MemberSignature Language="F#" Value="member this.IsDisposed : bool" Usage="System.Runtime.Caching.ChangeMonitor.IsDisposed" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Boolean</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert ab, der angibt, das die abgeleitete Instanz einer <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasse verworfen wird.</summary>
        <value>
          <see langword="true" /> Wenn die Instanz freigegeben wird; andernfalls <see langword="false" />.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die Eigenschaft wird festgelegt, um `true` nach der Basis <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> Methodenaufrufe der <xref:System.Runtime.Caching.ChangeMonitor.Dispose%2A> -Methode in einer abgeleiteten Klasse, die Instanz zu verwerfen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="NotifyOnChanged">
      <MemberSignature Language="C#" Value="public void NotifyOnChanged (System.Runtime.Caching.OnChangedCallback onChangedCallback);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void NotifyOnChanged(class System.Runtime.Caching.OnChangedCallback onChangedCallback) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void NotifyOnChanged(System::Runtime::Caching::OnChangedCallback ^ onChangedCallback);" />
      <MemberSignature Language="F#" Value="member this.NotifyOnChanged : System.Runtime.Caching.OnChangedCallback -&gt; unit" Usage="changeMonitor.NotifyOnChanged onChangedCallback" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="onChangedCallback" Type="System.Runtime.Caching.OnChangedCallback" />
      </Parameters>
      <Docs>
        <param name="onChangedCallback">Ein Verweis auf eine Methode, die aufgerufen wird, wenn eine Abhängigkeit geändert hat.</param>
        <summary>Wird von cacheimplementierungen zum Registrieren eines Rückrufs, und benachrichtigen aufgerufen ein <see cref="T:System.Runtime.Caching.ObjectCache" /> -Instanz über die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> delegieren, wenn eine Abhängigkeit geändert hat.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Cacheimplementierungen verwenden Sie diese Methode, bis zu eine änderungsüberwachung zu sich selbst verknüpfen. Wenn Sie ordnen Sie eine oder mehrere Monitore mit das Element im Cache ändern möchten, übergeben Sie einen <xref:System.Runtime.Caching.CacheItemPolicy> Instanz mit einer aufgefüllten Änderung Monitore-Eigenschaft, die das Element im Cache. Ein Cache-Implementierung unterstützt Monitore ändern ist verantwortlich für das Durchlaufen der <xref:System.Runtime.Caching.CacheItemPolicy.ChangeMonitors%2A> -Eigenschaft, und registrieren Sie die <xref:System.Runtime.Caching.OnChangedCallback> Delegaten mit jedem Ändern der überwachen, die es findet.  
  
 Da die <xref:System.Runtime.Caching.OnChangedCallback> -Delegat ist einen optionale State-Parameter, die eine konkrete Implementierung von Monitor kann optionale Zustandsinformationen übergeben. Die Cache-Implementierung wird bestimmt, ob es sich bei explizite Abhängigkeit für den Typ des Zustands, der eine benutzerdefinierte änderungsüberwachung als Teil des Rückrufs übergeben, die ausgeführt werden kann.  
  
> [!NOTE]
>  Die Basis-Cache-Erweiterbarkeits-API sind keine Anforderungen für explizite Abhängigkeit für den Typ des Zustands.  
  
 Die Implementierung der <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode ermittelt automatisch, ob der Zustand des Monitors bereits zum Zeitpunkt geändert hat <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode wird aufgerufen. Wenn die <xref:System.Runtime.Caching.ChangeMonitor.HasChanged%2A> -Eigenschaft ist `true`, und klicken Sie dann die Methode automatisch Ruft die <xref:System.Runtime.Caching.OnChangedCallback> -Ereignishandler, der registriert wurde die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode. Dies tritt auf, da es möglich ist, ab dem Zeitpunkt eine Cacheimplementierung eine änderungsüberwachung, mit der Zeit erstellt, eine Cacheimplementierung Ruft den Monitor, und verbindet sich bis zu, der zugrunde liegenden überwachte Zustand geändert hat. Wenn der Status bereits klicken Sie dann das Objekt geändert hat, die an die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode `null`.  
  
 Die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> Methode kann nur einmal aufgerufen werden, und löst eine Ausnahme bei nachfolgenden Aufrufen.  
  
 ]]></format>
        </remarks>
        <exception cref="T:System.InvalidOperationException">Die Rückrufmethode wurde bereits aufgerufen.</exception>
        <exception cref="T:System.ArgumentNullException">
          <paramref name="onChangedCallback" /> ist <see langword="null" />.</exception>
        <block subset="none" type="overrides">
          <para>1.  Rufen Sie die <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> Methode, um alle Änderungen an der Abhängigkeit benachrichtigt zu werden. Wenn eine Änderung der Abhängigkeit bereits aufgetreten ist, die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz wird aufgerufen, wenn <see cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" /> aufgerufen wird. Andernfalls die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> Instanz wird aufgerufen, wenn Sie einmal, wenn entweder die <see cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" /> Methode wird aufgerufen, oder wenn die <see cref="M:System.Runtime.Caching.ChangeMonitor.Dispose" /> -Methode aufgerufen wird, welches Ereignis zuerst eintritt. Die <see cref="T:System.Runtime.Caching.OnChangedCallback" /> -Instanz, von der Cacheimplementierung bereitgestellt sollten den Cacheeintrag zu entfernen und gegebenenfalls durch den Aufrufer Cache wird ausgelöst, die notwendige Änderung oder Update-Ereignis an den ursprünglichen Aufrufer des Cache.  
  
2.  Die Cacheimplementierung muss den Cacheeintrag zu entfernen, der eine Änderung der Abhängigkeitseigenschaft zugeordnet ist.</para>
        </block>
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      </Docs>
    </Member>
    <Member MemberName="OnChanged">
      <MemberSignature Language="C#" Value="protected void OnChanged (object state);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig instance void OnChanged(object state) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Runtime.Caching.ChangeMonitor.OnChanged(System.Object)" />
      <MemberSignature Language="VB.NET" Value="Protected Sub OnChanged (state As Object)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; void OnChanged(System::Object ^ state);" />
      <MemberSignature Language="F#" Value="member this.OnChanged : obj -&gt; unit" Usage="changeMonitor.OnChanged state" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="state" Type="System.Object" />
      </Parameters>
      <Docs>
        <param name="state">Die Daten für das Change-Ereignis. Dieser Wert kann <see langword="null" /> sein.</param>
        <summary>Aufgerufen von abgeleiteten Klassen zum Auslösen des Ereignisses, wenn eine Abhängigkeit ändert.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 In der Regel die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird aufgerufen, wenn Änderungen an der Abhängigkeit auftreten. Die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird auch aufgerufen werden, wenn eine Änderungsüberwachungsinstanz freigegeben wird, aber die Freigabe tritt nur dann, wenn der Rückruf noch nicht aufgerufen wurde.  
  
 Wenn die <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird aufgerufen, bevor die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> -Methode aufgerufen wird, werden die Daten aus dem Aufruf der <xref:System.Runtime.Caching.ChangeMonitor.OnChanged%2A> Methode wird von der Cacheimplementierung gespeichert. Darüber hinaus wird der Rückruf, der die <xref:System.Runtime.Caching.OnChangedCallback> Methode wird sofort aufgerufen, wenn die <xref:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged%2A> -Methode wird aufgerufen.  
  
 ]]></format>
        </remarks>
        <altmember cref="Overload:System.Runtime.Caching.ChangeMonitor.Dispose" />
        <altmember cref="M:System.Runtime.Caching.ChangeMonitor.NotifyOnChanged(System.Runtime.Caching.OnChangedCallback)" />
        <altmember cref="P:System.Runtime.Caching.ChangeMonitor.HasChanged" />
      </Docs>
    </Member>
    <Member MemberName="UniqueId">
      <MemberSignature Language="C#" Value="public abstract string UniqueId { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance string UniqueId" />
      <MemberSignature Language="DocId" Value="P:System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberSignature Language="VB.NET" Value="Public MustOverride ReadOnly Property UniqueId As String" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; abstract property System::String ^ UniqueId { System::String ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.UniqueId : string" Usage="System.Runtime.Caching.ChangeMonitor.UniqueId" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Runtime.Caching</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.String</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft einen Wert, der darstellt ab der <see cref="T:System.Runtime.Caching.ChangeMonitor" /> Klasseninstanz.</summary>
        <value>Der Bezeichner für eine Änderungsüberwachungsinstanz.</value>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Die <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Eigenschaftswert in der Regel besteht aus Abhängigkeit, kombiniert mit Zeichenfolgendaten eindeutig Bezeichner die Daten, die überwacht wird eine <xref:System.Runtime.Caching.ChangeMonitor> Instanz. Der Wert des der <xref:System.Runtime.Caching.ChangeMonitor.UniqueId%2A> Eigenschaft ist eine Zeichenfolge. Der Wert der Zeichenfolge wird verwendet, die eindeutige ID des Zuweisen der <xref:System.Runtime.Caching.ChangeMonitor> Instanz.  
  
 ]]></format>
        </remarks>
        <block subset="none" type="overrides">
          <para>Durch Überschreiben der Eigenschaft, können Sie eine benutzerdefinierte Implementierung für den Zeichenfolgenwert der Eigenschaft definieren, um eine eindeutige ID zugewiesen</para>
        </block>
        <block subset="none" type="overrides">
          <para>In abgeleiteten Klassen müssen Sie den Wert der Eigenschaft im Konstruktor festlegen.</para>
        </block>
      </Docs>
    </Member>
  </Members>
</Type>