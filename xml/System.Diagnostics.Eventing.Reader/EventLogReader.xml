<Type Name="EventLogReader" FullName="System.Diagnostics.Eventing.Reader.EventLogReader">
  <Metadata>
    <Meta Name="ms.openlocfilehash" Value="5c0e50de1dd9f282c2e38ca286bb4377cb6fa13c" />
    <Meta Name="ms.sourcegitcommit" Value="6a0b904069161bbaec4ffd02aa7d9cf38c61e72e" />
    <Meta Name="ms.translationtype" Value="HT" />
    <Meta Name="ms.contentlocale" Value="de-DE" />
    <Meta Name="ms.lasthandoff" Value="06/24/2018" />
    <Meta Name="ms.locfileid" Value="36676371" />
  </Metadata>
  <TypeSignature Language="C#" Value="public class EventLogReader : IDisposable" />
  <TypeSignature Language="ILAsm" Value=".class public auto ansi beforefieldinit EventLogReader extends System.Object implements class System.IDisposable" />
  <TypeSignature Language="DocId" Value="T:System.Diagnostics.Eventing.Reader.EventLogReader" />
  <TypeSignature Language="VB.NET" Value="Public Class EventLogReader&#xA;Implements IDisposable" />
  <TypeSignature Language="C++ CLI" Value="public ref class EventLogReader : IDisposable" />
  <TypeSignature Language="F#" Value="type EventLogReader = class&#xA;    interface IDisposable" />
  <AssemblyInfo>
    <AssemblyName>System.Core</AssemblyName>
    <AssemblyVersion>4.0.0.0</AssemblyVersion>
  </AssemblyInfo>
  <Base>
    <BaseTypeName>System.Object</BaseTypeName>
  </Base>
  <Interfaces>
    <Interface>
      <InterfaceName>System.IDisposable</InterfaceName>
    </Interface>
  </Interfaces>
  <Docs>
    <summary>Ermöglicht das Lesen von Ereignissen aus einem Ereignisprotokoll anhand von Ereignisabfragen. Die Ereignisse, die von diesem Objekt gelesen werden, werden als <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />-Objekte zurückgegeben.</summary>
    <remarks>
      <format type="text/markdown"><![CDATA[  
  
## Examples  
 Z. B. Code mit dieser Klasse finden Sie unter [How To: Abfrage nach Ereignissen](http://msdn.microsoft.com/library/5231a436-4cf2-4539-90d2-a04813aba069) oder [How To: Zugriff und Informationen zum Lesen von Ereignis](http://msdn.microsoft.com/library/14db3375-d305-49ae-aa24-aedbe906e76c).  
  
 ]]></format>
    </remarks>
  </Docs>
  <Members>
    <MemberGroup MemberName=".ctor">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />-Klasse.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.Diagnostics.Eventing.Reader.EventLogQuery)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventQuery As EventLogQuery)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLogReader(System::Diagnostics::Eventing::Reader::EventLogQuery ^ eventQuery);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.Reader.EventLogReader : System.Diagnostics.Eventing.Reader.EventLogQuery -&gt; System.Diagnostics.Eventing.Reader.EventLogReader" Usage="new System.Diagnostics.Eventing.Reader.EventLogReader eventQuery" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="eventQuery" Type="System.Diagnostics.Eventing.Reader.EventLogQuery" />
      </Parameters>
      <Docs>
        <param name="eventQuery">Die Ereignisabfrage, mit der Ereignisse abgerufen werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />-Klasse durch Angeben einer Ereignisabfrage.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (string path);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.String)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (path As String)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLogReader(System::String ^ path);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.Reader.EventLogReader : string -&gt; System.Diagnostics.Eventing.Reader.EventLogReader" Usage="new System.Diagnostics.Eventing.Reader.EventLogReader path" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des Ereignisprotokolls, aus dem die Ereignisse abgerufen werden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />-Klasse durch Angeben eines aktiven Ereignisprotokolls, aus dem die Ereignisse abgerufen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery, System.Diagnostics.Eventing.Reader.EventBookmark bookmark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(class System.Diagnostics.Eventing.Reader.EventLogQuery eventQuery, class System.Diagnostics.Eventing.Reader.EventBookmark bookmark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.Diagnostics.Eventing.Reader.EventLogQuery,System.Diagnostics.Eventing.Reader.EventBookmark)" />
      <MemberSignature Language="VB.NET" Value="Public Sub New (eventQuery As EventLogQuery, bookmark As EventBookmark)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLogReader(System::Diagnostics::Eventing::Reader::EventLogQuery ^ eventQuery, System::Diagnostics::Eventing::Reader::EventBookmark ^ bookmark);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.Reader.EventLogReader : System.Diagnostics.Eventing.Reader.EventLogQuery * System.Diagnostics.Eventing.Reader.EventBookmark -&gt; System.Diagnostics.Eventing.Reader.EventLogReader" Usage="new System.Diagnostics.Eventing.Reader.EventLogReader (eventQuery, bookmark)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <Parameters>
        <Parameter Name="eventQuery" Type="System.Diagnostics.Eventing.Reader.EventLogQuery" />
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
      </Parameters>
      <Docs>
        <param name="eventQuery">Die Ereignisabfrage, mit der Ereignisse abgerufen werden.</param>
        <param name="bookmark">Das Lesezeichen (Platzhalter), das als Startposition im Ereignisprotokoll oder im Stream von Ereignissen verwendet wird. Die Abfrage gibt nur die Ereignisse zurück, die nach dem Lesezeichenereignis protokolliert wurden.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />-Klasse durch Angeben einer Ereignisabfrage und eines Lesezeichens, das als Startposition für die Abfrage verwendet wird.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName=".ctor">
      <MemberSignature Language="C#" Value="public EventLogReader (string path, System.Diagnostics.Eventing.Reader.PathType pathType);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig specialname rtspecialname instance void .ctor(string path, valuetype System.Diagnostics.Eventing.Reader.PathType pathType) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.#ctor(System.String,System.Diagnostics.Eventing.Reader.PathType)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; EventLogReader(System::String ^ path, System::Diagnostics::Eventing::Reader::PathType pathType);" />
      <MemberSignature Language="F#" Value="new System.Diagnostics.Eventing.Reader.EventLogReader : string * System.Diagnostics.Eventing.Reader.PathType -&gt; System.Diagnostics.Eventing.Reader.EventLogReader" Usage="new System.Diagnostics.Eventing.Reader.EventLogReader (path, pathType)" />
      <MemberType>Constructor</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Parameters>
        <Parameter Name="path" Type="System.String" />
        <Parameter Name="pathType" Type="System.Diagnostics.Eventing.Reader.PathType" />
      </Parameters>
      <Docs>
        <param name="path">Der Name des Ereignisprotokolls, aus dem Ereignisse abgerufen werden sollen, oder der Pfad der Ereignisprotokolldatei, aus der Ereignisse abgerufen werden sollen.</param>
        <param name="pathType">Gibt an, ob die im Pfadparameter verwendete Zeichenfolge den Namen eines Ereignisprotokolls oder den Pfad zu einer Ereignisprotokolldatei angibt.</param>
        <summary>Initialisiert eine neue Instanz der <see cref="T:System.Diagnostics.Eventing.Reader.EventLogReader" />-Klasse durch Angeben des Namens eines Ereignisprotokolls oder des Pfads einer Ereignisprotokolldatei, aus dem bzw. aus der Ereignisse abgerufen werden.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Verwenden der <xref:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent%2A> Methode, um Ereignisse aus diesem Objekt abzurufen.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="BatchSize">
      <MemberSignature Language="C#" Value="public int BatchSize { get; set; }" />
      <MemberSignature Language="ILAsm" Value=".property instance int32 BatchSize" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Eventing.Reader.EventLogReader.BatchSize" />
      <MemberSignature Language="VB.NET" Value="Public Property BatchSize As Integer" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property int BatchSize { int get(); void set(int value); };" />
      <MemberSignature Language="F#" Value="member this.BatchSize : int with get, set" Usage="System.Diagnostics.Eventing.Reader.EventLogReader.BatchSize" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Int32</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft die Anzahl der Ereignisse ab, die bei jedem Lesevorgang aus dem Stream von Ereignissen abgerufen werden, oder legt diese fest.</summary>
        <value>Gibt einen Ganzzahlwert zurück.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="CancelReading">
      <MemberSignature Language="C#" Value="public void CancelReading ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void CancelReading() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.CancelReading" />
      <MemberSignature Language="VB.NET" Value="Public Sub CancelReading ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void CancelReading();" />
      <MemberSignature Language="F#" Value="member this.CancelReading : unit -&gt; unit" Usage="eventLogReader.CancelReading " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Bricht den aktuellen Abfragevorgang ab.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Dispose">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Gibt die vom Objekt verwendeten Ressourcen frei.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="public void Dispose ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig newslot virtual instance void Dispose() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Dispose" />
      <MemberSignature Language="VB.NET" Value="Public Sub Dispose ()" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; virtual void Dispose();" />
      <MemberSignature Language="F#" Value="abstract member Dispose : unit -&gt; unit&#xA;override this.Dispose : unit -&gt; unit" Usage="eventLogReader.Dispose " />
      <MemberType>Method</MemberType>
      <Implements>
        <InterfaceMember>M:System.IDisposable.Dispose</InterfaceMember>
      </Implements>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Gibt alle vom Objekt verwendeten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="Dispose">
      <MemberSignature Language="C#" Value="protected virtual void Dispose (bool disposing);" />
      <MemberSignature Language="ILAsm" Value=".method familyhidebysig newslot virtual instance void Dispose(bool disposing) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Dispose(System.Boolean)" />
      <MemberSignature Language="VB.NET" Value="Protected Overridable Sub Dispose (disposing As Boolean)" />
      <MemberSignature Language="C++ CLI" Value="protected:&#xA; virtual void Dispose(bool disposing);" />
      <MemberSignature Language="F#" Value="abstract member Dispose : bool -&gt; unit&#xA;override this.Dispose : bool -&gt; unit" Usage="eventLogReader.Dispose disposing" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecuritySafeCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="disposing" Type="System.Boolean" />
      </Parameters>
      <Docs>
        <param name="disposing">
          <see langword="true" />, um sowohl verwaltete als auch nicht verwaltete Ressourcen freizugeben, <see langword="false" />, um ausschließlich nicht verwaltete Ressourcen freizugeben.</param>
        <summary>Gibt die vom Objekt verwendeten nicht verwalteten Ressourcen und optional auch die verwalteten Ressourcen frei.</summary>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <Member MemberName="LogStatus">
      <MemberSignature Language="C#" Value="public System.Collections.Generic.IList&lt;System.Diagnostics.Eventing.Reader.EventLogStatus&gt; LogStatus { get; }" />
      <MemberSignature Language="ILAsm" Value=".property instance class System.Collections.Generic.IList`1&lt;class System.Diagnostics.Eventing.Reader.EventLogStatus&gt; LogStatus" />
      <MemberSignature Language="DocId" Value="P:System.Diagnostics.Eventing.Reader.EventLogReader.LogStatus" />
      <MemberSignature Language="VB.NET" Value="Public ReadOnly Property LogStatus As IList(Of EventLogStatus)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; property System::Collections::Generic::IList&lt;System::Diagnostics::Eventing::Reader::EventLogStatus ^&gt; ^ LogStatus { System::Collections::Generic::IList&lt;System::Diagnostics::Eventing::Reader::EventLogStatus ^&gt; ^ get(); };" />
      <MemberSignature Language="F#" Value="member this.LogStatus : System.Collections.Generic.IList&lt;System.Diagnostics.Eventing.Reader.EventLogStatus&gt;" Usage="System.Diagnostics.Eventing.Reader.EventLogReader.LogStatus" />
      <MemberType>Property</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>get: System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Collections.Generic.IList&lt;System.Diagnostics.Eventing.Reader.EventLogStatus&gt;</ReturnType>
      </ReturnValue>
      <Docs>
        <summary>Ruft den Status aller Ereignisprotokolle oder Protokolldateien ab, die mit der Ereignisabfrage im Objekt verknüpft sind.</summary>
        <value>Gibt eine Liste von <see cref="T:System.Diagnostics.Eventing.Reader.EventLogStatus" />-Objekten zurück, die jeweils Statusinformationen über ein Ereignisprotokoll enthalten, das mit der Ereignisabfrage im Objekt verknüpft ist.</value>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="ReadEvent">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Liest das nächste Ereignis, das von der Ereignisabfrage in diesem Objekt zurückgegeben wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="ReadEvent">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Eventing.Reader.EventRecord ReadEvent ();" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Eventing.Reader.EventRecord ReadEvent() cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEvent () As EventRecord" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Eventing::Reader::EventRecord ^ ReadEvent();" />
      <MemberSignature Language="F#" Value="member this.ReadEvent : unit -&gt; System.Diagnostics.Eventing.Reader.EventRecord" Usage="eventLogReader.ReadEvent " />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.Reader.EventRecord</ReturnType>
      </ReturnValue>
      <Parameters />
      <Docs>
        <summary>Liest das nächste Ereignis, das von der Ereignisabfrage in diesem Objekt zurückgegeben wird.</summary>
        <returns>Gibt ein <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />-Objekt zurück.</returns>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Examples  
 Z. B. Code mit dieser Klasse finden Sie unter [How To: Abfrage nach Ereignissen](http://msdn.microsoft.com/library/5231a436-4cf2-4539-90d2-a04813aba069).  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="ReadEvent">
      <MemberSignature Language="C#" Value="public System.Diagnostics.Eventing.Reader.EventRecord ReadEvent (TimeSpan timeout);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance class System.Diagnostics.Eventing.Reader.EventRecord ReadEvent(valuetype System.TimeSpan timeout) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.ReadEvent(System.TimeSpan)" />
      <MemberSignature Language="VB.NET" Value="Public Function ReadEvent (timeout As TimeSpan) As EventRecord" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; System::Diagnostics::Eventing::Reader::EventRecord ^ ReadEvent(TimeSpan timeout);" />
      <MemberSignature Language="F#" Value="member this.ReadEvent : TimeSpan -&gt; System.Diagnostics.Eventing.Reader.EventRecord" Usage="eventLogReader.ReadEvent timeout" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Diagnostics.Eventing.Reader.EventRecord</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="timeout" Type="System.TimeSpan" />
      </Parameters>
      <Docs>
        <param name="timeout">Die maximale Zeit, die ein Lesevorgang ausgeführt werden kann, bevor der Vorgang abgebrochen wird.</param>
        <summary>Liest das nächste Ereignis, das von der Ereignisabfrage in diesem Objekt zurückgegeben wird.</summary>
        <returns>Gibt ein <see cref="T:System.Diagnostics.Eventing.Reader.EventRecord" />-Objekt zurück.</returns>
        <remarks>To be added.</remarks>
      </Docs>
    </Member>
    <MemberGroup MemberName="Seek">
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Docs>
        <summary>Ändert die Position im Stream von Ereignissen, aus dem das nächste Ereignis gelesen wird.</summary>
      </Docs>
    </MemberGroup>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Diagnostics.Eventing.Reader.EventBookmark bookmark);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Diagnostics.Eventing.Reader.EventBookmark bookmark) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.Diagnostics.Eventing.Reader.EventBookmark)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (bookmark As EventBookmark)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Diagnostics::Eventing::Reader::EventBookmark ^ bookmark);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Diagnostics.Eventing.Reader.EventBookmark -&gt; unit" Usage="eventLogReader.Seek bookmark" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das Lesezeichen (Platzhalter), das als Startposition im Ereignisprotokoll oder im Stream von Ereignissen verwendet wird. Nur Ereignisse, die nach dem Lesezeichenereignis protokolliert wurden, werden von der Abfrage zurückgegeben.</param>
        <summary>Ändert die Position im Stream von Ereignissen, aus dem das nächste Ereignis gelesen wird, durch Angeben eines Lesezeichenereignisses. Ereignisse, die vor dem Lesezeichenereignis protokolliert wurden, werden nicht abgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.Diagnostics.Eventing.Reader.EventBookmark bookmark, long offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(class System.Diagnostics.Eventing.Reader.EventBookmark bookmark, int64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.Diagnostics.Eventing.Reader.EventBookmark,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (bookmark As EventBookmark, offset As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::Diagnostics::Eventing::Reader::EventBookmark ^ bookmark, long offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.Diagnostics.Eventing.Reader.EventBookmark * int64 -&gt; unit" Usage="eventLogReader.Seek (bookmark, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="bookmark" Type="System.Diagnostics.Eventing.Reader.EventBookmark" />
        <Parameter Name="offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="bookmark">Das Lesezeichen (Platzhalter), das als Startposition im Ereignisprotokoll oder im Stream von Ereignissen verwendet wird. Nur Ereignisse, die nach dem Lesezeichenereignis protokolliert wurden, werden von der Abfrage zurückgegeben.</param>
        <param name="offset">Der Offset für die Anzahl der Ereignisse zur Änderung der Position des Lesezeichens.</param>
        <summary>Ändert die Position im Stream von Ereignissen, aus dem das nächste Ereignis gelesen wird, durch Angeben eines Lesezeichenereignisses sowie eines Offsets für die Anzahl der Ereignisse aus dem Lesezeichen. Ereignisse, die vor dem Lesezeichenereignis einschließlich Offset protokolliert wurden, werden nicht abgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
    <Member MemberName="Seek">
      <MemberSignature Language="C#" Value="public void Seek (System.IO.SeekOrigin origin, long offset);" />
      <MemberSignature Language="ILAsm" Value=".method public hidebysig instance void Seek(valuetype System.IO.SeekOrigin origin, int64 offset) cil managed" />
      <MemberSignature Language="DocId" Value="M:System.Diagnostics.Eventing.Reader.EventLogReader.Seek(System.IO.SeekOrigin,System.Int64)" />
      <MemberSignature Language="VB.NET" Value="Public Sub Seek (origin As SeekOrigin, offset As Long)" />
      <MemberSignature Language="C++ CLI" Value="public:&#xA; void Seek(System::IO::SeekOrigin origin, long offset);" />
      <MemberSignature Language="F#" Value="member this.Seek : System.IO.SeekOrigin * int64 -&gt; unit" Usage="eventLogReader.Seek (origin, offset)" />
      <MemberType>Method</MemberType>
      <AssemblyInfo>
        <AssemblyName>System.Core</AssemblyName>
        <AssemblyVersion>4.0.0.0</AssemblyVersion>
      </AssemblyInfo>
      <Attributes>
        <Attribute>
          <AttributeName>System.Security.SecurityCritical</AttributeName>
        </Attribute>
      </Attributes>
      <ReturnValue>
        <ReturnType>System.Void</ReturnType>
      </ReturnValue>
      <Parameters>
        <Parameter Name="origin" Type="System.IO.SeekOrigin" />
        <Parameter Name="offset" Type="System.Int64" />
      </Parameters>
      <Docs>
        <param name="origin">Ein Wert in der <see cref="T:System.IO.SeekOrigin" />-Enumeration definiert die Position im Stream von Ereignissen, ab der Ereignisse abgefragt werden.</param>
        <param name="offset">Der Offset für die Anzahl der Ereignisse, die dem Ursprung hinzugefügt werden sollen.</param>
        <summary>Ändert die Position im Stream von Ereignissen, aus dem das nächste Ereignis gelesen wird, durch Angeben einer Startposition sowie eines Offsets für die Startposition. Ereignisse, die vor der Startposition einschließlich Offset protokolliert wurden, werden nicht abgerufen.</summary>
        <remarks>
          <format type="text/markdown"><![CDATA[  
  
## Remarks  
 Sie können diese Funktion nur für Resultsets, die von einem Administrator oder operationskanal oder von EVTX-Protokolldateien verwenden. Diese Funktion wird nicht unterstützt für analytische und Debuggen von Kanälen, oder für ETL-Dateien.  
  
 ]]></format>
        </remarks>
      </Docs>
    </Member>
  </Members>
</Type>